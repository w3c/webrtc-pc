<html xmlns="http://www.w3.org/1999/xhtml">
<head>

  <link href="./webrtc.css" rel="stylesheet" type="text/css" />

  <title>JSEP1 BRANCH - WebRTC 1.0: Real-time Communication Between
  Browsers</title>

  <meta http-equiv='Content-Type' content='text/html; charset=utf-8' /><!--
     === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline.

      To tag a new releas in git hub

          Once the version is checked in and ready to go, you tag it with (need
          to chance the 20110823 to correct date )

               git tag -a v20110823 -m "This is release 20110823"

         Tags are not transferred by default with the push so you have to
         add a - -tags parameter to the push so it looks like. Note you need to
         remoce the space between the - and -tag to make a double dash. 

              git push - -tags 

         or alternatively you can push just the new tag with 

              git push origin v20110823


      To generate the dated version of the specification:

           Open this doc in Mozilla. 

           Do a CTRL-ALT-SHIFT-S

           Select "XHMTL( source)" from dialog box. This will pop a new tab with
           genreated version of the document.

           This will open a new tab with generated html. Copy and paste this to
           a new file. Note if you use Chrome or Safari, this step will not
           work. What will happen is the paste will have the original document,
           not what was displayed in the window that you did the copy on.

           Rename the new file to the correct day such as
           webrtc-broken-20111003.html then search for and edit the links for
           "This version" and "Previos version". Add the new file into CVS and
           check in. 

           Once everyone is happy, the webrtc-broken.html and
           webrtc-broken-20111003.html files can be coppied to
           webrtc.html and webrtc-20111003.html
           respectively in the ../editor/. directory. 
    -->

<script src='ReSpec.js/js/respec.js' class='remove' type="text/javascript"></script>

<script src='webrtc.js' class='remove' type="text/javascript"></script>

 
</head>

<body>
  <section id="abstract">

    <p> This is not a product of the WebRTC WG - it is merely a document being
    used to discuss possible changes to the documents that WG is
    developing. Most the text here was is from the WG document.  </p>

    <p>This document defines a set of APIs to represent streaming media,
    including audio and video, in JavaScript, to allow media to be sent over the
    network to another browser or device implementing the appropriate set of
    real-time protocols, and media received from another browser or device to be
    processed and displayed locally.  This specification is being developed in
    conjunction with a protocol specification developed by the IETF RTCWEB group
    and an API specification to get access to local media devices developed by
    the Media Capture Task Force.  </p>

  </section>

  <section id="conformance"> <p> Implementations that use ECMAScript to
      implement the APIs defined in this specification must implement them in a
      manner consistent with the ECMAScript Bindings defined in the Web IDL
      specification [[!WEBIDL]], as this specification uses that specification
      and terminology.  </p>


  </section>

  <section id="sotd">
   <p>This document is not complete.
   It is subject to major changes and, while early experimentations are
   encouraged, it is therefore not intended for implementation. The API
   is based on preliminary work done in the WHATWG. The Web Real-Time
   Communications Working Group expects this specification to evolve
   significantly based on:</p>
  <ul>
    <li>The outcomes of ongoing exchanges in the companion RTCWEB group
    at IETF to define the set of protocols that, together with this
    document, will enable real-time communications in Web browsers.</li>
    <li>Privacy issues that arise when exposing local capabilities and
    local streams.</li>
    <li>Technical discussions within the group, on the data channel in
    particular.</li>
    <li>Experience gained through early experimentations.</li>
    <li>Feedback received from other groups and individuals.</li>
  </ul>
 
</section> 

  <section id="intro" class="informative">
  <h2>Introduction</h2>

  <p>There are a number of facets to video-conferencing in HTML covered by this specification:</p>

  <ul>
    <li>Representing a multimedia stream (video, audio, or both) from local devices (video
    cameras, microphones, Web cams) or from prerecorded files provided by the user.</li>

    <li>Recording such streams locally.</li>

    <li>Connecting to remote peers using NAT-traversal technologies such as ICE, STUN,
    and TURN.</li>

    <li>Sending the locally-produced streams to remote peers and receiving streams from
    remote peers.</li>

    <li>Displaying such streams (both the locally-produced ones and the remotely-obtained
    ones) locally using the <code>video</code> or <code>audio</code> elements.</li>

    <li>Sending arbitrary data to remote peers.</li>
  </ul>

  <p>This document defines the APIs used for these features.  This specification
  is being developed in conjunction with a protocol specification developed by
  the <a href="http://datatracker.ietf.org/wg/rtcweb/">IETF RTCWEB group</a> and
  an API specification to get access to local media devices developed by the
  <a href="http://www.w3.org/2011/04/webrtc/">Media Capture Task Force</a>.</p>
  </section>

  <section>
  <h2>Stream API</h2>

  <section>
  <h3>Introduction</h3>

  <p>The <code><a>MediaStream</a></code> interface is used to
  represent streams of media data, typically (but not necessarily) of audio and/or video
  content, e.g. from a local camera or a remote site. The data from a <code><a>MediaStream</a></code>
  object does not necessarily have a canonical binary form; for example, it could just be
  "the video currently coming from the user’s video camera". This allows user agents to manipulate
  media streams in whatever fashion is most suitable on the user’s platform.</p>

  <p>Each <code><a>MediaStream</a></code> object can contain zero
  or more tracks, in particular audio and video tracks.
  All tracks in a MediaStream are
  intended to be synchronized when rendered.
  Different MediaStreams do not need to be synchronized.</p>

  <p>Each track in a MediaStream object has a corresponding <code><a>MediaStreamTrack</a></code> object.</p>

  <p>A <code><a>MediaStreamTrack</a></code> represents content comprising one or
  more channels, where the channels have a defined well known relationship to
  each other (such as a stereo or 5.1 audio signal), and are intended to be
  encoded together for transmission as, for instance, an RTP payload type. One
  <code><a>MediaStreamTrack</a></code> sent to another peer MUST appear as one
  and only one <code><a>MediaStreamTrack</a></code> to the recipient. All of the
  channels that a codec needs to encode the media MUST be in the same
  <code><a>MediaStreamTrack</a></code> and the codecs SHOULD be able to encode,
  or discard, all the channels in the track. </p>

  <p>A channel is the smallest atomic unit of media considered in this API specification.</p>

  <p>A <code><a>MediaStream</a></code> object has an input and an output. The
  input depends on how the object was created: a
  <code><a>LocalMediaStream</a></code> object generated by a
  <code>getUserMedia()</code> [[!GETUSERMEDIA]] call, for instance, might take
  its input from the user’s local camera, while a
  <code><a>MediaStream</a></code> created by a
  <code><a>PeerConnection</a></code> object will take as input the data received
  from a remote peer. The output of the object controls how the object is used,
  e.g. what is saved if the object is written to a file, what is displayed if
  the object is used in a <code>video</code> element, or indeed what is
  transmitted to a remote peer if the object is used with a
  <code><a>PeerConnection</a></code> object.</p>

  <p>Each track in a <code><a>MediaStream</a></code> object can be
  disabled, meaning that it is muted in the object’s output. All tracks are initially
  enabled.</p>

  <p>A <code><a>MediaStream</a></code> can be <a>finished</a>, indicating that its inputs have
  forever stopped providing data.</p>

  <p>The output of a <code><a>MediaStream</a></code> object MUST
  correspond to the tracks in its input. Muted audio tracks MUST be replaced with
  silence. Muted video tracks MUST be replaced with blackness.</p>

  <p>A new <code><a>MediaStream</a></code> object can be created from existing
  <code><a>MediaStreamTrack</a></code> objects using the <code>
  <a href="#dom-mediastream">MediaStream()</a></code> constructor. The constructor takes two
  lists of <code><a>MediaStreamTrack</a></code> objects as arguments; one for audio tracks and
  one for video tracks. The lists can either be the track lists of another stream, subsets of
  such lists, or compositions of <code><a>MediaStreamTrack</a></code> objects from different
  <code><a>MediaStream</a></code> objects. </p>

  <p><img alt="" src='images/media-stream-1.png' /></p><!-- no alt since
  it's all described in the previous paragraphs: this is just a
  summary -->
  <!--
c.clearRect(0, 0, 640, 480);
c.save();
try {
  with (c) {
    save();
    strokeStyle = '#AA0000';
    lineWidth = 20;
    beginPath();
    moveTo(50,98);
    lineTo(550, 98);
    stroke();
  }
  mediaStream(c,50,10, true);

} finally {
  c.restore();
}

function cameraIcon(c,x,y) {
  with (c) { save(); try {
    translate(x,y);
    fillRect(-10,-10,20,20);
    beginPath();
    moveTo(7,0);
    lineTo(20,-10);
    lineTo(20,10);
    fill();
    font = '100 8px "Press Start 2P", sans-serif';
    textAlign = 'center';
    textBaseline = 'top';
    fillText('Camera', 4, 15);
  } finally { restore(); } }
}

function mediaStream(c,x,y,vid) {
  with (c) {
    save();
    translate(x-10,y-97);

    // cable
    fillStyle = 'black';
    font = '100 10px "Press Start 2P", sans-serif';
    textAlign = 'right';
    fillText('Input', 95, 170);
    textAlign = 'left';
    fillText('Output', 407, 170);

    // media stream
    fillStyle = '#EE8800';
    strokeStyle = '#FFCC00';
    lineWidth = 6;
    fillRect(100,100,300,170);
    strokeRect(100,100,300,170);
    fillStyle = 'black';
    font = '900 12px "Press Start 2P", sans-serif';
    textAlign = 'left';
    fillText('MediaStream', 110, 123);

    // tracks
    textAlign = 'left';
    strokeStyle = '#CC3300';
    fillStyle = '#FFFF00';
    lineWidth = 4;
    globalAlpha = vid ? 1 : 0.4;
    fillRect(120,140,100,110);
    strokeRect(120,140,100,110);
    globalAlpha = 1;
    fillRect(238,140,100,110);
    strokeRect(238,140,100,110);
    fillStyle = 'black';
    font = '900 10px "Press Start 2P", sans-serif';
    globalAlpha = vid ? 1 : 0.4;
    fillText('Track', 123, 155);
    fillText('(video)', 123, 170);
    globalAlpha = 1;
    fillText('Track', 241, 155);
    fillText('(stereo', 241, 170);
    fillText(' audio)', 241, 185);

    // channels
    strokeStyle = '#999999';
    fillStyle = '#FFFFFF';
    lineWidth = 2;
    fillRect(245,191,86,23);
    strokeRect(245,191,86,23);
    fillRect(245,220,86,23);
    strokeRect(245,220,86,23);
    fillStyle = 'black';
    font = '100 8px "Press Start 2P", sans-serif';
    textAlign = 'left';
    textBaseline = 'alphabetic';
    fillText('left', 249, 202);
    fillText('channel', 249, 211);
    fillText('right', 249, 231);
    fillText('channel', 249, 240);

    // track check marks
    fillStyle = 'black';
    font = '900 35px "Lucida Grande", sans-serif';
    textAlign = 'center';
    textBaseline = 'middle';
    fillText(vid ? '\u2713' : '\u2716', 220, 245);
    fillText('\u2713', 338, 245);

    restore();
  }
}
-->

  <p>The ability to duplicate a <code><a>MediaStream</a></code>, i.e.
  create a new <code><a>MediaStream</a></code> object from the track lists of an existing stream,
  allows for greater control since separate <code><a>MediaStream</a></code> instances can be
  manipulated and <a title="consumer">consumed</a>
  individually. This can be used, for instance, in a video-conferencing scenario to display
  the local video from the user’s camera and microphone in a local monitor, while only
  transmitting the audio to the remote peer (e.g. in response to the user using a "video
  mute" feature). Combining tracks from different <code><a>MediaStream</a>
  </code> objects into a new <code><a>MediaStream</a></code> makes it
  possible to, e.g., record selected tracks from a conversation involving several <code>
  <a href="#mediastream">MediaStream</a></code> objects with a single <code>
  <a href="#mediastreamrecorder">MediaStreamRecorder</a></code>.</p>

  <!--
c.clearRect(0, 0, 640, 480);
c.save();
try {
  with (c) {
    save();
    strokeStyle = '#AA0000';
    lineWidth = 20;
    beginPath();
    moveTo(50,98);
    lineTo(550, 98);
    lineTo(550, 210);
    lineTo(50, 210);
    lineTo(50, 320);
    lineTo(550, 320);
    lineTo(550,420);
    stroke();
    beginPath();
    moveTo(50,320);
    lineTo(50,420);
    stroke();
    restore();
    fillStyle = 'black';
    font = '100 10px "Press Start 2P", sans-serif';
    textAlign = 'center';
    fillText('<video>', 50, 440);
    fillText('PeerConnection', 550, 440);
    font = '100 8px "Press Start 2P", sans-serif';
  }
  cameraIcon(c,25,98)
  mediaStream(c,50,10, true);
  mediaStream(c,50,233, false);

  with (c) {
    font = '100 8px "Press Start 2P", sans-serif';
    textAlign = 'left';
    textBaseline = 'middle';
    fillStyle = 'gray';

    fillText('from', 4, 130);
    fillText('getUserMedia()', 4, 140);

    fillText('via URL.createObjectURL()', 4, 450);

    textAlign = 'center';
    fillText('via addStream()', 550, 450);
  }
} finally {
  c.restore();
}

function cameraIcon(c,x,y) {
  with (c) { save(); try {
    translate(x,y);
    fillRect(-10,-10,20,20);
    beginPath();
    moveTo(7,0);
    lineTo(20,-10);
    lineTo(20,10);
    fill();
    font = '100 8px "Press Start 2P", sans-serif';
    textAlign = 'center';
    textBaseline = 'top';
    fillText('Camera', 4, 15);
  } finally { restore(); } }
}

function mediaStream(c,x,y,vid) {
  with (c) {
    save();
    translate(x-10,y-97);

    // cable
    fillStyle = 'black';
    font = '100 10px "Press Start 2P", sans-serif';
    textAlign = 'right';
    fillText('Input', 95, 170);
    textAlign = 'left';
    fillText('Output', 407, 170);

    // media stream
    fillStyle = '#EE8800';
    strokeStyle = '#FFCC00';
    lineWidth = 6;
    fillRect(100,100,300,170);
    strokeRect(100,100,300,170);
    fillStyle = 'black';
    font = '900 12px "Press Start 2P", sans-serif';
    textAlign = 'left';
    fillText(!vid ? 'MediaStream' : 'LocalMediaStream', 110, 123);

    // tracks
    textAlign = 'left';
    strokeStyle = '#CC3300';
    fillStyle = '#FFFF00';
    lineWidth = 4;
    globalAlpha = vid ? 1 : 0.4;
    fillRect(120,140,100,110);
    strokeRect(120,140,100,110);
    globalAlpha = 1;
    fillRect(238,140,100,110);
    strokeRect(238,140,100,110);
    fillStyle = 'black';
    font = '900 10px "Press Start 2P", sans-serif';
    globalAlpha = vid ? 1 : 0.4;
    fillText('Track', 123, 155);
    fillText('(video)', 123, 170);
    globalAlpha = 1;
    fillText('Track', 241, 155);
    fillText('(stereo', 241, 170);
    fillText(' audio)', 241, 185);

    // channels
    strokeStyle = '#999999';
    fillStyle = '#FFFFFF';
    lineWidth = 2;
    fillRect(245,191,86,23);
    strokeRect(245,191,86,23);
    fillRect(245,220,86,23);
    strokeRect(245,220,86,23);
    fillStyle = 'black';
    font = '100 8px "Press Start 2P", sans-serif';
    textAlign = 'left';
    textBaseline = 'alphabetic';
    fillText('left', 249, 202);
    fillText('channel', 249, 211);
    fillText('right', 249, 231);
    fillText('channel', 249, 240);

    // track check marks
    fillStyle = 'black';
    font = '900 35px "Lucida Grande", sans-serif';
    textAlign = 'center';
    textBaseline = 'middle';
    fillText(vid ? '\u2713' : '\u2716', 220, 245);
    fillText('\u2713', 338, 245);

    restore();
  }
}
-->

  <p>The <code><a>LocalMediaStream</a></code> interface is used
  when the user agent is generating the stream’s data (e.g. from a camera or streaming it
  from a local video file).</p>

  <p>When a <code><a>LocalMediaStream</a></code> object is being
  generated from a local file (as opposed to a live audio/video source), the user agent
  SHOULD stream the data from the file in real time, not all at once. This reduces the
  ease with which pages can distinguish live video from pre-recorded video, which can
  help protect the user’s privacy.</p>

  </section>
  <section>
  <h3>Interface definitions</h3>

  <section>
  <h4>MediaStream</h4>

  <p>The <dfn id='dom-mediastream'><code>MediaStream()</code></dfn>
  constructor takes two arguments. The arguments are two lists with <code><a>MediaStreamTrack</a>
  </code> objects which will be used to construct the audio and video track lists of the new
  <code><a>MediaStream</a></code> object. When the constructor is invoked, the UA must run the
  following steps:</p>

  <ol>
    <li>
        <p>Let <var>audioTracks</var> be the constructor’s first argument.</p>
    </li>
    <li>
        <p>Let <var>videoTracks</var> be the constructor’s second argument.</p>
    </li>
    <li>
        <p>Let <var>stream</var> be a newly constructed <code><a>MediaStream</a></code> object.</p>
    </li>
    <li>
        <p>Set <var>stream’s</var> label attribute to a newly generated value.</p>
    </li>
    <li>
      <p>If <var>audioTracks</var> is not null, then run the following sub steps for each element
      <var>track</var> in <var>audioTracks</var>:</p>

      <ol>
        <li>
          <p>If <var>track</var> is of any other kind than "<code>audio</code>", then throw
          a <code>SyntaxError</code> exception.</p>
        </li>
        <li>
          <p>If <var>track</var> has the same underlying source as another element in
          <var>stream’s</var> audio track list, then abort these steps.</p>
        </li>
        <li>
          <p>Add <var>track</var> to <var>stream’s</var> audio track list.</p>
        </li>
      </ol>
    </li>
    <li>
      <p>If <var>videoTracks</var> is not null, then run the following sub steps for each element
      <var>track</var> in <var>videoTracks</var>:</p>

      <ol>
        <li>
          <p>If <var>track</var> is of any other kind than "<code>video</code>", then throw
          a <code>SyntaxError</code> exception.</p>
        </li>
        <li>
          <p>If <var>track</var> has the same underlying source as another element in
          <var>stream’s</var> video track list, then abort these steps.</p>
        </li>
        <li>
          <p>Add <var>track</var> to <var>stream’s</var> video track list.</p>
        </li>
      </ol>
    </li>
  </ol>

  <p>A <code><a>MediaStream</a></code> can have multiple audio
  and video sources (e.g. because the user has multiple microphones, or because the
  real source of the stream is a media resource with
  many media tracks). The stream represented by a <code><a>MediaStream</a></code>
  thus has zero or more tracks.</p>

  <p>The tracks of a <code><a>MediaStream</a></code> are stored in two track
  lists represented by <code><a>MediaStreamTrackList</a></code> objects; one for
  audio tracks and one for video tracks. The two track lists MUST contain the
  <code><a>MediaStreamTrack</a></code> objects that correspond to the tracks of
  the stream. The relative order of all tracks in a user agent MUST be
  stable. Tracks that come from a media resource whose format defines an order
  MUST be in the order defined by the format; tracks that come from a media
  resource whose format does not define an order MUST be in the relative order
  in which the tracks are declared in that media resource. Within these
  constraints, the order is user-agent defined.</p>

  <p>An object that reads data from the output of a <code><a>MediaStream</a></code> is referred
  to as a <code><a>MediaStream</a></code> <dfn>consumer</dfn>. The list of <code><a>MediaStream</a></code>
  consumers currently include the media elements, <code><a>PeerConnection</a></code> and
  <code><a>MediaStreamRecorder</a></code>.</p>

  <p class='note'><code><a>MediaStream</a></code> consumers be able to handle tracks being
  added and removed. This behavior is specifier per consumer.</p>

  <p>A new media component may be associated with an existing <code><a>MediaStream</a></code>.
  This happens, e.g., on the A-side when the B-side adds a new <code><a>MediaStreamTrack</a></code>
  object to one of the track lists of a <code><a>MediaStream</a></code> that is being sent over a
  <code><a>PeerConnection</a></code>. If this happens for the reason exemplified, or for any other
  reason than the <code>
  <a href="#dom-mediastreamtracklist-add">add()</a></code> method being invoked locally on a
  <code><a>MediaStreamTrackList</a></code> or tracks are being added as the stream is created
  (i.e. the stream is initialized with tracks), the user agent MUST run the following steps:</p>

  <ol>
    <li>
      <p>Create a <code><a>MediaStreamTrack</a></code> object <var>track</var> to represent
      the new media component.</p>
    </li>

    <li>
      <p>If <var>track’s</var> <code>
      <a href="#dom-mediastreamtrack-kind">kind</a></code> attribute equals "<code>audio</code>",
      add it to the <code><a>MediaStream</a></code> object’s
      <code>
      <a href="#dom-mediastream-audiotracks">audioTracks</a></code>
      <code><a>MediaStreamTrackList</a></code> object.</p>
    </li>

    <li>
      <p>If <var>track’s</var> <code>
      <a href="#dom-mediastreamtrack-kind">kind</a></code> attribute equals "<code>video</code>",
      add it to the <code><a>MediaStream</a></code> object’s
      <code>
      <a href="#dom-mediastream-videotracks">videoTracks</a></code>
      <code><a>MediaStreamTrackList</a></code> object.</p>
    </li>

    <li>
      <p><a>Fire a track event</a> named
      <code>
      <a href="#event-mediastreamtracklist-addtrack">addtrack</a></code> with the newly created
      <var>track</var> at the <code><a>MediaStreamTrackList</a></code> object.</p>
    </li>
  </ol>

  <p>An existing media component may also be disassociated from a <code><a>MediaStream</a></code>.
  If this happens for any other reason than the <code>
  <a href="#dom-mediastreamtracklist-remove">remove()</a></code> method being invoked locally on a
  <code><a>MediaStreamTrackList</a></code> or the stream is being destroyed, the user agent MUST
  run the following steps:</p>

  <ol>
    <li>
      <p>Let <var>track</var> be the <code><a>MediaStreamTrack</a></code> object representing
      the media component about to be removed.</p>
    </li>

    <li>
      <p>Remove <var>track</var> from the <code><a>MediaStreamTrackList</a></code> object.</p>
    </li>

    <li>
      <p><a>Fire a track event</a> named
      <code>
      <a href="#event-mediastreamtracklist-removetrack">removetrack</a></code> with
      <var>track</var> at the <code><a>MediaStreamTrackList</a></code> object.</p>
    </li>
  </ol>

  <p>A <code><a>MediaStream</a></code> object is said to be <dfn>finished</dfn> when all tracks belonging to the stream
  have <a>ended</a>. When this
  happens for any reason other than the <code>
  <a href="#dom-mediastream-stop">stop()</a></code> method being invoked, the user agent
  MUST queue a task that runs the following steps:</p>

  <ol>
    <li>
      <p>If the object’s <code><a href="#dom-mediastream-ended">ended</a></code> attribute
      has the value true already, then abort these steps. (The <code>
      <a href="#dom-mediastream-stop">stop()</a></code> method was probably called just
      before the stream stopped for other reasons, e.g. the user clicked an in-page stop
      button and then the user-agent-provided stop button.)</p>
    </li>

    <li>
      <p>Set the object’s <code><a href="#dom-mediastream-ended">ended</a></code> attribute
      to true.</p>
    </li>

    <li>
      <p>Fire a simple event named <code title=
      'event-MediaStream-ended'><a href="#event-mediastream-ended">ended</a></code> at
      the object.</p>
    </li>
  </ol>

  <p>If the end of the stream was reached due to a user request, the task
  source for this <span title='concept-task'>task</span> is the user
  interaction task source. Otherwise the task source for this
  <span title='concept-task'>task</span> is the networking task source.</p>

  <dl title='[Constructor (MediaStreamTrackList? audioTracks, MediaStreamTrackList? videoTracks)]
    interface MediaStream' class='idl'>
    <dt>readonly attribute DOMString label</dt>
    <dd>
      <p>Returns a label that is unique to this stream, so that streams can be recognized
      after they are sent through the <code><a href=
      "#peerconnection">PeerConnection</a></code> API.</p>

      <p>When a <code><a href="#localmediastream">LocalMediaStream</a></code>
      object is created, the user agent MUST generate a globally unique
      identifier string, and MUST initialize the object’s <code><a href=
      "#dom-mediastream-label">label</a></code> attribute to that string. Such
      strings MUST only use characters in the ranges U+0021, U+0023 to U+0027,
      U+002A to U+002B, U+002D to U+002E, U+0030 to U+0039, U+0041 to U+005A,
      U+005E to U+007E, and MUST be 36 characters long.</p><!-- UUIDs have 36
      characters including hyphens; the ranges above comes from RFC4574 (the
      a=label: thing in SDP) -->

      <p class='note'> TODO NOTE - I think we have this slightly wrong. It is the Track on the
      Stream that needs the label. Also, how do you set the label on a Track. </p>
      
      <p>When a <code><a href="#mediastream">MediaStream</a></code> is created to
      represent a stream obtained from a remote peer, the <code title=
      'dom-MediaStream-label'><a href="#dom-mediastream-label">label</a></code> attribute
      is initialized from information provided by the remote source.</p>
      <!-- described below -->

      <p>When a <code><a>MediaStream</a></code> is created from
      another using the <code><a href=
      "#dom-mediastream">MediaStream()</a></code> constructor, the <code title=
      'dom-MediaStream-label'><a href="#dom-mediastream-label">label</a></code> attribute
      is initialized to a newly generated value.</p><!-- described above -->

      <p>The <dfn id='dom-mediastream-label'><code>label</code></dfn> attribute MUST return the value to
      which it was initialized when the object was created.</p>

      <p class='note'>The label of a <code><a>MediaStream</a></code>
      object is unique to the source of the stream, but that does not mean it is not
      possible to end up with duplicates. For example, a locally
      generated stream could be sent from one user to a remote peer using <code><a>PeerConnection</a></code>, and then sent back to the original
      user in the same manner, in which case the original user will have multiple streams
      with the same label (the locally-generated one and the one received from the remote
      peer).</p>
    </dd>

    <dt>readonly attribute MediaStreamTrackList audioTracks</dt>

    <dd>
      <p>Returns a <code><a>MediaStreamTrackList</a></code>
      object representing the audio tracks that can be enabled and disabled.</p>

      <p>The <dfn id='dom-mediastream-audiotracks'><code>audioTracks</code></dfn> attribute MUST return an
      <span title="array host objects">array host object</span> for objects of type
      <code><a>MediaStreamTrack</a></code> that is <em>fixed
      length</em> and <em>read only</em>. The same object MUST be returned each time the
      attribute is accessed.</p>
    </dd>

    <dt>readonly attribute MediaStreamTrackList videoTracks</dt>

    <dd>
      <p>Returns a <code><a>MediaStreamTrackList</a></code>
      object representing the video tracks that can be enabled and disabled.</p>

      <p>The <dfn id='dom-mediastream-videotracks'><code>videoTracks</code></dfn> attribute MUST return an
      <span title="array host objects">array host object</span> for objects of type
      <code><a>MediaStreamTrack</a></code> that is <em>fixed
      length</em> and <em>read only</em>. The same object MUST be returned each time the
      attribute is accessed. </p>
    </dd>

    <dt>MediaStreamRecorder record()</dt>

    <dd>
      <p>Begins recording the stream. The returned <code><a>MediaStreamRecorder</a></code> object provides access to the
      recorded data.</p>

      <p>When the <dfn id='dom-mediastream-record'><code>record()</code></dfn> method is invoked, the user
      agent MUST return a new <code><a>MediaStreamRecorder</a></code> object associated with the
      stream.</p>
    </dd>

    <dt>attribute boolean ended</dt>

    <dd>
      <p>The <dfn id='dom-mediastream-ended'>
      <code>MediaStream.ended</code></dfn> attribute MUST return true if the <code>
      <a>MediaStream</a></code> has <a>finished</a>, and false otherwise.</p>

      <p>When a <code><a>MediaStream</a></code> object is created, its <code>
      <a href="#dom-mediastream-ended">ended</a></code> attribute MUST be set to false,
      unless it is being created using the <code><a href="#dom-mediastream">MediaStream()</a>
      </code> constructor whose arguments are lists of <code><a>MediaStreamTrack</a></code>
      objects that are all <a>ended</a>,
      in which case the <code><a>MediaStream</a></code> object MUST be created with its
      <code><a href="#dom-mediastream-ended">ended</a></code> attribute set to true.</p>
    </dd>

    <dt>attribute Function? onended</dt>

    <dd>This event handler, of type <code><a href=
    "#event-mediastream-ended">ended</a></code>, MUST be supported by all objects
    implementing the <code><a>MediaStream</a></code> interface.</dd>

  </dl>

  <div title='MediaStream implements EventTarget' class='idl'></div>
  </section>

  <section>
 <h4>LocalMediaStream</h4>

 <p>Before the web application can access the users media input devices it must let
 <code>getUserMedia()</code> [[!GETUSERMEDIA]]
 create a <code><a>LocalMediaStream</a></code>. Once the application is done using, e.g.,
 a webcam and a microphone, it may revoke its own access by calling <code>
 <a href="#dom-mediastream-stop">stop()</a></code> on the <code><a>LocalMediaStream</a>
 </code>. <!--If the web application no longer has access to any media input devices, any
 "on air" indicators in the browser UI MUST be turned off.--></p>

 <p>A web application may, once it has access to a <code><a>LocalMediaStream</a></code>,
 use the <code><a href="#dom-mediastream">MediaStream()</a></code> constructor to construct
 additional <code><a>MediaStream</a></code> objects. Since a derived <code><a>MediaStream</a>
 </code> object is created from the tracks of an existing stream, it cannot use any media
 input devices that have not been approved by the user.</p>

 <dl title='interface LocalMediaStream : MediaStream' class='idl'>
   <dt>void stop()</dt>

   <dd>
     <p>When a <code><a>LocalMediaStream</a></code> object’s
     <dfn id='dom-mediastream-stop'><code>stop()</code></dfn> method is invoked, the user agent
     MUST queue a task that runs the following steps on every track:</p>

     <ol>
       <li>
         <p>Let <var>track</var> be the current <code><a>MediaStreamTrack</a></code>
         object.</p>
       </li>
       <li>
         <p><a title="ended">End</a>
         <var>track</var>. The track start outputting only silence and/or blackness,
         as appropriate.</p>
       </li>
       <li>
         <p>Dereference <var>track’s</var> underlying media source.</p>
       </li>
       <li>
         <p>If the reference count of <var>track’s</var> underlying media source is
         greater than zero, then abort these steps.</p>
       </li>
       <li>
         <p>Permanently stop the generation of data for <var>track’s</var> source. If the
         data is being generated from a live source (e.g. a microphone or camera), then the
         user agent SHOULD remove any active "on-air" indicator for that source. If the
         data is being generated from a prerecorded source (e.g. a video file), any
         remaining content in the file is ignored.</p>
       </li>
     </ol>

     <p>The task source for the <span title='concept-task'>tasks</span>
     queued for the <code><a href=
     "#dom-mediastream-stop">stop()</a></code> method is the DOM manipulation task
     source.</p>
   </dd>
 </dl>
 </section>


 <section>
  <h4>MediaStreamTrack</h4>

  <p>A <code><a>MediaStreamTrack</a></code> object represents a media source in the user
  agent. Several <code><a>MediaStreamTrack</a></code> objects can represent the same media
  source, e.g., when the user chooses the same camera in the UI shown by two consecutive calls
  to <code>getUserMedia()</code> [[!GETUSERMEDIA]].</p>

  <p>A <code><a>MediaStreamTrack</a></code> object can reference its media
  source in two ways, either with a strong or a weak reference, depending on how
  the track was created.  For example, a track in a
  <code><a>MediaStream</a></code>, derived from a
  <code><a>LocalMediaStream</a></code> with the <code><a
   href="#dom-mediastream">MediaStream()</a></code> constructor, has a weak
  reference to a local media source, while a track in a
  <code><a>LocalMediaStream</a></code> has a strong reference. This means that a
  track in a <code><a>MediaStream</a></code>, derived from a
  <code><a>LocalMediaStream</a></code>, will end if there is no non-<a>ended</a>
  track in a <code><a>LocalMediaStream</a></code> which references the same
  local media source.  A reference to a non-local media source as, e.g., an RTP
  source, is always strong.</p>

  <p class='note'>The concept with strong and weak references to media sources
  allows the web application to derive new <code><a>MediaStream</a></code>
  objects from <code><a>LocalMediaStream</a></code> objects (created via
  <code>getUserMedia()</code> [[!GETUSERMEDIA]]), and still be able to revoke
  all given permissions with <code><a
   href="#dom-mediastream-stop">LocalMediaStream.stop()</a></code>.</p>

  <p>A <code><a>MediaStreamTrack</a></code> object is said to <em>end</em>
  when the user agent learns that no more data will ever be forthcoming for this
  track.</p>

  <p>When a <code><a>MediaStreamTrack</a></code> object ends for any reason
  (e.g.  because the user rescinds the permission for the page to use the local
  camera, or because the data comes from a finite file and the file’s end has
  been reached and the user has not requested that it be looped, or because the
  track belongs to a <code><a>MediaStream</a></code> that comes from a remote
  peer and the remote peer has permanently stopped sending data, or because the
  UA has instructed the track to end for any reason, or because the reference
  count of the track’s underlying media source has reached zero, it is said to
  be <dfn>ended</dfn>.  When track instance <var>track</var> ends for any reason
  other than <code> <a href="#dom-mediastream-stop">stop()</a></code> method
  being invoked on the <code><a>LocalMediaStream</a></code> object that
  represents <var>track</var>, the user agent MUST queue a task that runs the
  following steps:</p>

  <ol>
    <li>
      <p>If the track’s <code><a href="#dom-mediastreamtrack-readystate">readyState</a>
      </code> attribute has the value <code><a href="#widl-MediaStreamTrack-ENDED">ENDED</a>
      </code> (2) already, then abort these steps.</p>
    </li>
    <li>
      <p>Set <var>track’s</var> <code><a href="#dom-mediastreamtrack-readystate">readyState</a>
      </code> attribute to <code><a href="#widl-MediaStreamTrack-ENDED">ENDED</a></code> (2).</p>
    </li>
    <li>
      <p>Fire a simple event named <code><a href="#event-mediastreamtrack-ended">ended</a>
      </code> at the object.</p>
    </li>
  </ol>



  <dl title='interface MediaStreamTrack' class='idl'>
    <dt>readonly attribute DOMString kind</dt>

    <dd>
      <p>The <dfn id='dom-mediastreamtrack-kind'><code>MediaStreamTrack.kind</code></dfn> attribute MUST
      return the string "<code>audio</code>" if the object’s corresponding
      track is or was an audio track, "<code>video</code>" if the
      corresponding track is or was a video track, and a user-agent defined string
      otherwise.</p>
    </dd>

    <dt>readonly attribute DOMString label</dt>

    <dd>
      <p class='note'> TODO - note - do we need the label from a Stream here. Do these labels
      need to be globally unique. If not what is the name scoping </p>
      
      <p>User agents MAY label audio and video sources (e.g. "Internal
      microphone" or "External USB Webcam"). The <dfn
      id='dom-mediastreamtrack-label'><code>MediaStreamTrack.label</code></dfn>
      attribute MUST return the label of the object’s corresponding track, if
      any. If the corresponding track has or had no label, the attribute MUST
      instead return the empty string.</p>

      <p class='note'>Thus the <code><a href=
      "#dom-mediastreamtrack-kind">kind</a></code> and <code title=
      'dom-MediaStreamTrack-label'><a
       href="#dom-mediastreamtrack-label">label</a></code> attributes do not
      change value, even if the <code><a>MediaStreamTrack</a></code> object is
      disassociated from its corresponding track.</p> </dd>

    <dt>attribute boolean enabled</dt>

    <dd> <p>The <dfn
      id='dom-mediastreamtrack-enabled'><code>MediaStreamTrack.enabled</code></dfn>
      attribute, on getting, MUST return the last value to which it was set. On
      setting, it MUST be set to the new value, and then, if the
      <code><a>MediaStreamTrack</a></code> object is still associated with a
      track, MUST enable the track if the new value is true, and disable it
      otherwise.</p>

      <p class='note'>Thus, after a <code><a>MediaStreamTrack</a></code> is
      disassociated from its track, its <code><a href=
      "#dom-mediastreamtrack-enabled">enabled</a></code> attribute still changes
      value when set, it just doesn’t do anything with that new value.</p> </dd>

    <dt>const unsigned short LIVE = 0</dt>

    <dd>
      <p>The track is active (the track’s underlying media source is making a best-effort
      attempt to provide data in real time).</p>

      <p>The output of a track in the <code><a href="#widl-MediaStreamTrack-LIVE">LIVE</a>
      </code> state can be switched on and off with the <code>
      <a href="#dom-mediastreamtrack-enabled">enabled</a></code> attribute.</p>
    </dd>

    <dt>const unsigned short MUTED = 1</dt>

    <dd>
      <p>The track is muted (the track’s underlying media source is temporarily unable
      to provide data).</p>

      <p>For example, a track is muted on the B-side if the A-side disables the corresponding
      <code><a>MediaStreamTrack</a></code> in the <code><a>MediaStream</a></code> that is
      being sent. A <code><a>MediaStreamTrack</a></code> in a <code><a>LocalMediaStream</a>
      </code> may be muted if the user temporarily revokes the web application’s permission
      to use a media input device.</p>

      <p>When the addstream event triggers on a <code><a>PeerConnection</a></code>, all
      <code><a>MediaStreamTrack</a></code> objects in the resulting <code><a>MediaStream</a>
      </code> are muted until media data can be read from the RTP source.</p>
    </dd>

    <dt>const unsigned short ENDED = 2</dt>

    <dd>
      <p>The track has <a>ended</a>
      (the track’s underlying media source is no longer providing data, and will never
      provide more data for this track).</p>

      <p>For example, a video track in a <code><a>LocalMediaStream</a></code> finishes if
      the user unplugs the USB web camera that acts as the track’s media source.</p>
    </dd>

    <dt>readonly attribute unsigned short readyState</dt>

    <dd> <p>The <dfn
      id='dom-mediastreamtrack-readystate'><code>readyState</code></dfn>
      attribute represents the state of the track. It MUST return the value to
      which the user agent last set it (as defined below). It can have the
      following values: <dfn>LIVE</dfn>, <dfn>MUTED</dfn> or
      <dfn>ENDED</dfn>.</p>

      <p>When a <code><a>MediaStreamTrack</a></code> object is created, its <code>
      <a href="#dom-mediastreamtrack-readystate">readyState</a></code> is either
      <code><a href="#widl-MediaStreamTrack-LIVE">LIVE</a></code> (0) or <code>
      <a href="#widl-MediaStreamTrack-MUTED">MUTED</a></code> (1), depending on the state
      of the track’s underlying media source. For example, a track in a <code>
      <a>LocalMediaStream</a></code>, created with
      <code>getUserMedia()</code> [[!GETUSERMEDIA]]
      , MUST initially have its <code><a href="#dom-mediastreamtrack-readystate">readyState</a>
      </code>attribute set to <code><a href="#widl-MediaStreamTrack-LIVE">LIVE</a></code>
      (1), while a track in a <code><a>MediaStream</a></code>, received with a <code>
      <a>PeerConnection</a></code>, MUST have its <code>
      <a href="#dom-mediastreamtrack-readystate">readyState</a></code> attribute set to
      <code><a href="#widl-MediaStreamTrack-MUTED">MUTED</a></code> (1) until media
      data arrives.</p>
    </dd>

    <dt>attribute Function? onmute</dt>

    <dd>This event handler, of type <code><a href=
    "#event-mediastreamtrack-muted">muted</a></code>, MUST be supported by all objects
    implementing the <code><a>MediaStreamTrack</a></code> interface.</dd>

    <dt>attribute Function? onunmute</dt>

    <dd>This event handler, of type <code><a href=
    "#event-mediastreamtrack-unmuted">unmuted</a></code>, MUST be supported by all objects
    implementing the <code><a>MediaStreamTrack</a></code> interface.</dd>

    <dt>attribute Function? onended</dt>

    <dd>This event handler, of type <code><a href=
    "#event-mediastreamtrack-ended">ended</a></code>, MUST be supported by all objects
    implementing the <code><a>MediaStreamTrack</a></code> interface.</dd>
  </dl>
  </section>


    <section>
 <h4>AudioMediaStreamTrack</h4>

 <p>The <code><a>AudioMediaStreamTrack</a></code> is a specialization of of a
 normal <code><a>MediaStreamTrack</a></code> that only carries audio and is
 extended to have the capability to send and/or receive DTMF codes.</p>

 
 <dl title='interface AudioMediaStreamTrack : MediaStreamTrack' class='idl'>

      <dt>readonly attribute boolean canInsertDTMF</dt>

    <dd> <p>The <dfn
     id='dom-audiomediastreamtrack-caninsertdtmf'><code>canInsertDTMF</code></dfn>
     attribute MUST indicate if the <code><a>AudioMediaStreamTrack</a></code> is
     capable of sending DTMF. </p> </dd>

    
   <dt>void insertDTMF(in DOMString tones, optional long duration)</dt>

   <dd>

     <p> When a <code><a>AudioMediaStreamTrack</a></code> object’s <dfn
     id='dom-AudioMediaStreamTrack-insertDTMF'><code>insertDTMF()</code></dfn>
     method is invoked, the user agent MUST queue a task that that sends the
     DTMF tones. </p>

     <p> The tone parameters is treated as a series of characters. The
     characters 0 to 9, A to D, #, and * generated the associated DTMF
     tones. The characters a to d are equivalent to A to D. The character ,
     indicates a an delay of 2 seconds before processing the next character in
     the tones parameter. Unrecognized characters are ignored.  </p>

     <p> The duration parameters indicates the duration in ms to play the each
     DTMF passed in the tones parameters. The duration can not be more than 6000
     or less than 70. The default duration is 100 ms for each tone.  The gap
     between tones MUST be at least 50 ms but should be as short as possible.
     </p>

     <p> If insertDTMF is called on the same object while an existing task for
     this object is generate DTMF is still running, the previous task is
     canceled. Calling insertDTMF with an empty tones parameter can be used to
     cancel any tones currently being send. </p>

     <p class='note'> Editor Note: We need to add a callback that is set on the
     object that is called after the tones are sent. This is needed to allow the
     application to know when it can send new tones without canceling the tones
     that are currently being sent.  </p>

     <p class='note'> Editor Note: It seems we would want a callback or event
     for incoming tones. The proposal sent to the list had them played as audio to the
     speaker but I don’t see how that is useful. </p>

   </dd>
 </dl>
 </section>


  <section>
  <h4>MediaStreamTrackList</h4>

  <p>A <code><a>MediaStreamTrackList</a></code> object’s <dfn
  id='concept-track-list-corresponding-stream'>corresponding</dfn>
  <code><a>MediaStream</a></code> refers to the <code><a>MediaStream</a></code> object
  which the current <code><a>MediaStreamTrackList</a></code> object is a property of.</p>

  <dl title='interface MediaStreamTrackList' class='idl'>
    <dt>readonly attribute unsigned long length</dt>

    <dd>Returns the number of tracks in the list.</dd>

    <!-- FIXME: getter syntax doesn't seem to be supported by respec -->
    <dt>MediaStreamTrack item(unsigned long index)</dt>

    <dd>Returns the <code><a>MediaStreamTrack</a></code> object at the specified index.</dd>

    <dt>void add(MediaStreamTrack track)</dt>

    <dd>
      <p>Adds the given <code><a>MediaStreamTrack</a></code> to this
      <code><a>MediaStreamTrackList</a></code> according to the ordering rules for tracks.</p>

      <p>When the <dfn id='dom-mediastreamtracklist-add'><code>add()</code></dfn> method is invoked, the
      user agent MUST run the following steps:</p>

      <ol>
        <li>
          <p>Let <var>track</var> be the <code><a>MediaStreamTrack</a></code> argument.</p>
        </li>

        <li>
          <p>Let <var>stream</var> be the <code><a>MediaStreamTrackList</a></code> object’s
          <a href="#concept-track-list-corresponding-stream"
          title="concept-track-list-corresponding-stream">corresponding</a>
          <code><a>MediaStream</a></code> object.</p>
        </li>

        <li>
          <p>If <var>stream</var> is <a>finished</a>, throw an <code>INVALID_STATE_ERR</code>
          exception.</p>
        </li>

        <li>
          <p>If <var>track</var> is already in the <code><a>MediaStreamTrackList</a></code>,
          object’s internal list, then abort these steps.</p>
        </li>

        <li>
          <p>Add <var>track</var> to the end of the <code><a>MediaStreamTrackList</a></code>
          object’s internal list.</p>
        </li>
      </ol>
    </dd>

    <dt>void remove(MediaStreamTrack track)</dt>

    <dd>
      <p>Removes the given <code><a>MediaStreamTrack</a></code> from this
      <code><a>MediaStreamTrackList</a></code>.</p>

      <p>When the <dfn
      id='dom-mediastreamtracklist-remove'><code>remove()</code></dfn> method is
      invoked, the user agent MUST run the following steps:</p>

      <ol>
        <li>
          <p>Let <var>track</var> be the <code><a>MediaStreamTrack</a></code> argument.</p>
        </li>

        <li>
          <p>Let <var>stream</var> be the <code><a>MediaStreamTrackList</a></code> object’s
          <a href="#concept-track-list-corresponding-stream"
          title="concept-track-list-corresponding-stream">corresponding</a>
          <code><a>MediaStream</a></code> object.</p>
        </li>

        <li>
          <p>If <var>stream</var> is <a>finished</a>, throw an <code>INVALID_STATE_ERR</code>
          exception.</p>
        </li>

        <li>
          <p>If <var>track</var> is not in the <code><a>MediaStreamTrackList</a></code>,
          object’s internal list, then abort these steps.</p>
        </li>

        <li>
          <p>Remove <var>track</var> from the <code><a>MediaStreamTrackList</a></code>
          object’s internal list.</p>
        </li>
      </ol>
    </dd>

    <dt>attribute Function? onaddtrack</dt>

    <dd>This event handler, of type <code><a href=
    "#event-mediastreamtracklist-addtrack">addtrack</a></code>, MUST be
    supported by all objects implementing the
    <code><a>MediaStreamTrackList</a></code> interface.</dd>

    <dt>attribute Function? onremovetrack</dt>

    <dd>This event handler, of type <code><a href=
    "#event-mediastreamtracklist-removetrack">removetrack</a></code>, MUST be
    supported by all objects implementing the
    <code><a>MediaStreamTrackList</a></code> interface.</dd> </dl>

  </section>

  <section>
  <h4>MediaStreamRecorder</h4>

  <p class='note'>The <code><a>MediaStreamRecorder</a></code> needs to be able
  to handle the case that arises when changes are made to the
  <code><a>MediaStreamTrackList</a></code> objects of the
  <code><a>MediaStream</a></code> being recorded; e.g., a new track is added as
  a result of the <code> <a
   href="#dom-mediastreamtracklist-add">add()</a></code> method being
  invoked.</p>

  <dl title='interface MediaStreamRecorder' class='idl'>
    <dt>voice getRecordedData (BlobCallback? callBack)</dt>

    <dd>
      <p>Creates a <code>Blob</code> of the recorded data, and invokes the provided
      callback with that <code>Blob</code>.</p>

      <p>When the <dfn id='dom-mediastreamrecorder-getrecordeddata'><code>getRecordedData()</code></dfn>
      method is called, the user agent MUST run the following steps:</p>

      <ol>
        <li>
          <p>Let <var>callBack</var> be the callback indicated by the method’s
          first argument.</p>
        </li>

        <li>
          <p>If <var>callBack</var> is null, abort these steps.</p>
        </li><!-- we could throw an exception instead (that's
   why the method doesn't return until later: so that we can add an
   exception here without changing the algorithm) -->

        <li>
          <p>Let <var>data</var> be the data that was streamed by the
          <code><a>MediaStream</a></code> object from which the
          <code><a>MediaStreamRecorder</a></code> was created
          since the creation of the <code><a>MediaStreamRecorder</a></code> object.</p>
        </li>

        <li>
          <p>Return, and run the remaining steps asynchronously.</p>
        </li>

        <li>
          <p>Generate a file that containing <var>data</var> in a format
          supported by the user agent for use in <code>audio</code> and
          <code>video</code> elements.</p>
        </li>

        <li>
          <p>Let <var>blob</var> be a <code>Blob</code> object representing the
          contents of the file generated in the previous step. [[!FILE-API]]</p>
        </li>

        <li>
          <p>Queue a task to invoke <var>callBack</var> with
          <var>blob</var> as its argument.</p>
        </li>
      </ol>

      <p class='note'>The <code><a href=
      "#dom-mediastreamrecorder-getrecordeddata">getRecordedData()</a></code>
      method can be called multiple times on one
      <code><a>MediaStreamRecorder</a></code> object; each time, it will create
      a new file as if this was the first time the method was being called. In
      particular, the method does not stop or reset the recording when the
      method is called.</p> </dd> </dl> </section>

  <section>
  <h4>BlobCallback</h4>

  <dl title='[Callback, NoInterfaceObject] interface BlobCallback' class=
  'idl'>
    <dt>void handleEvent (Blob blob)</dt>

    <dd>Def TBD</dd>
  </dl>
  </section>

  <section>
  <h4>URL</h4>

  <dl title='partial interface URL' class='idl'>
    <dt>static DOMString createObjectURL (MediaStream stream)</dt>

    <dd> <p>Mints a <a href="#blob-url">Blob URL</a> to refer to the given
      <code><a>MediaStream</a></code>.</p>

      <p>When the <dfn
      id='dom-url-createobjecturl'><code>createObjectURL()</code></dfn> method
      is called with a <code><a>MediaStream</a></code> argument, the user agent
      MUST return a unique <a href="#blob-url">Blob URL</a> for the given
      <code><a>MediaStream</a></code>. [[!FILE-API]]</p>

      <p>For audio and video streams, the data exposed on that stream MUST be in a format
      supported by the user agent for use in <code>audio</code> and <code>video</code>
      elements.</p>

      <p class='bookkeeping'>A <dfn id='blob-url'>Blob URL</dfn> is the same as
      what the File API specification calls a Blob URI, except that anything in
      the definition of that feature that refers to <code>File</code> and
      <code>Blob</code> objects is hereby extended to also apply to
      <code><a>MediaStream</a></code> and <code><a>LocalMediaStream</a></code>
      objects.</p> </dd> </dl> </section> </section>

  <section>
  <h3>Examples</h3>

  <div>
    <p>This sample code exposes a button. When clicked, the button is disabled and the
    user is prompted to offer a stream. The user can cause the button to be re-enabled by
    providing a stream (e.g. giving the page access to the local camera) and then
    disabling the stream (e.g. revoking that access).</p>
    <pre class='example sh_javascript'>
&lt;input type="button" value="Start" onclick="start()" id="startBtn"&gt;
&lt;script&gt;
 var startBtn = document.getElementById('startBtn');
 function start() {
   navigator.getUserMedia({audio:true, video:true}, gotStream);
   startBtn.disabled = true;
 }
 function gotStream(stream) {
   stream.onended = function () {
     startBtn.disabled = false;
   }
 }
&lt;/script&gt;
</pre>
  </div>

  <div>
    <p>This example allows people to record a short audio message and upload it to the
    server. This example even shows rudimentary error handling.</p>
    <pre class='example sh_javascript'>
&lt;input type="button" value="⚫" onclick="msgRecord()" id="recBtn"&gt;
&lt;input type="button" value="◼" onclick="msgStop()" id="stopBtn" disabled&gt;
&lt;p id="status"&gt;To start recording, press the ⚫ button.&lt;/p&gt;
&lt;script&gt;
 var recBtn = document.getElementById('recBtn');
 var stopBtn = document.getElementById('stopBtn');
 function report(s) {
   document.getElementById('status').textContent = s;
 }
 function msgRecord() {
   report('Attempting to access microphone...');
   navigator.getUserMedia({audio:true}, gotStream, noStream);
   recBtn.disabled = true;
 }
 var msgStream, msgStreamRecorder;
 function gotStream(stream) {
   report('Recording... To stop, press to ◼ button.');
   msgStream = stream;
   msgStreamRecorder = stream.record();
   stopBtn.disabled = false;
   stream.onended = function () {
     msgStop();     
   }
 }
 function msgStop() {
   report('Creating file...');
   stopBtn.disabled = true;
   msgStream.onended = null;
   msgStream.stop();
   msgStreamRecorder.getRecordedData(msgSave);
 }
 function msgSave(blob) {
   report('Uploading file...');
   var x = new XMLHttpRequest();
   x.open('POST', 'uploadMessage');
   x.send(blob);
   x.onload = function () {
     report('Done! To record a new message, press the ⚫ button.');
     recBtn.disabled = false;
   };
   x.onerror = function () {
     report('Failed to upload message. To try recording a message again, press the ⚫ button.');
     recBtn.disabled = false;
   };
 }
 function noStream() {
   report('Could not obtain access to your microphone. To try again, press the ⚫ button.');
   recBtn.disabled = false;
 }
&lt;/script&gt;
</pre>
  </div>

  <div>
    <p>This example allows people to take photos of themselves from the local video
    camera.</p>
    <pre class='example sh_javascript'>
&lt;article&gt;
 &lt;style scoped&gt;
  video { transform: scaleX(-1); }
  p { text-align: center; }
 &lt;/style&gt;
 &lt;h1&gt;Snapshot Kiosk&lt;/h1&gt;
 &lt;section id="splash"&gt;
  &lt;p id="errorMessage"&gt;Loading...&lt;/p&gt;
 &lt;/section&gt;
 &lt;section id="app" hidden&gt;
  &lt;p&gt;&lt;video id="monitor" autoplay&gt;&lt;/video&gt; &lt;canvas id="photo"&gt;&lt;/canvas&gt;
  &lt;p&gt;&lt;input type=button value="&amp;#x1F4F7;" onclick="snapshot()"&gt;
 &lt;/section&gt;
 &lt;script&gt;
  navigator.getUserMedia({video:true}, gotStream, noStream);
  var video = document.getElementById('monitor');
  var canvas = document.getElementById('photo');
  function gotStream(stream) {
    video.src = URL.createObjectURL(stream);
    video.onerror = function () {
      stream.stop();
    };
    stream.onended = noStream;
    video.onloadedmetadata = function () {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      document.getElementById('splash').hidden = true;
      document.getElementById('app').hidden = false;
    };
  }
  function noStream() {
    document.getElementById('errorMessage').textContent = 'No camera available.';
  }
  function snapshot() {
    canvas.getContext('2d').drawImage(video, 0, 0);
  }
 &lt;/script&gt;
&lt;/article&gt;
</pre>
  </div>
  </section>
  </section>

  <section>
  <h2>Peer-to-peer connections</h2>

  <!-- ==================================================================== -->

  <p>A <code><a>PeerConnection</a></code> allows two users to
  communicate directly, browser-to-browser. Communications are coordinated via a
  signaling channel provided by script in the page via the server, e.g. using
  <code>XMLHttpRequest</code>.</p>

  <p>Calling <code>new <a>PeerConnection</a>(<var>configuration</var> )</code> creates a <code><a>PeerConnection</a></code> object.</p>

  <p>The <var>configuration</var> is a aray of pairs wher each pair is an array
  where the first element is a stun or turn URIs as defined
  in [[!STUN-URI]] and [[!TURN-URI]]. The if the first element of the pair is
  TURN URI, then the second elment of the pair is the crendential to use with
  that TURN server. This congiruation array give the addreses of STUN and TURN
  server to use to establish the connection. [[!STUN]] [[!TURN]]</p>

  <p>An example configuraiton array is:</p>

  <dl>
    <dt><code>[ ["stun:stun.example.org"] , ["turn:user@turn.example.org","myPassword"] ]</code></dt>
  </dl>

  <p>A <code><a>PeerConnection</a></code> object has an associated a <dfn
  id='peerconnection-ice-agent'><code>PeerConnection</code> ICE Agent</dfn>, and
  a <dfn id='peerconnection-readiness-state'><code>PeerConnection</code>
  readiness state</dfn>. These are initialized when the object is created.</p>

  <p>When the <dfn id='dom-peerconnection'><code>PeerConnection()</code></dfn>
  constructor is invoked, the user agent MUST run the following steps. This
  algorithm has a synchronous section (which is triggered as part of the event
  loop algorithm).  Steps in the synchronous section are marked with ⌛.</p>

  <ol>

    <li>
      <p>Create an ICE Agent and let <var>connection</var>’s <a href=
      "#peerconnection-ice-agent"><code>PeerConnection</code> ICE Agent</a> be that ICE
      Agent and provide it the STUN and TURN servers from the configuration array. [[!ICE]]</p>
    </li>

    <li>
      <p>Set <var>connection</var>’s <a href=
      "#peerconnection-readiness-state"><code>PeerConnection</code> readiness state</a>
      to <code><a href=
      "#widl-PeerConnection-NEW">NEW</a></code> (0).</p>
    </li>

    <li>
     <p>Set <var>connection</var>’s <a href=
      "#peerconnection-readiness-state"><code>PeerConnection</code> ice state </a>
      to <code><a href=
      "#widl-PeerConnection-NEW">NEW</a></code> (0).</p>
    </li>

    
    <li>
      <p>Let <var>connection</var>’s <code title=
      'dom-PeerConnection-localStreams'><a href=
      "#widl-PeerConnection-localStreams">localStreams</a></code> attribute be an empty
      read-only <code><a>MediaStream</a></code> array.
      </p>
    </li>

    <li>
      <p>Let <var>connection</var>’s <code title=
      'dom-PeerConnection-remoteStreams'><a href=
      "#widl-PeerConnection-remoteStreams">remoteStreams</a></code> attribute be an empty
      read-only <code><a>MediaStream</a></code> array.
      </p>
    </li>

    <li>
      <p>Return <var>connection</var>, but continue these steps
      asynchronously.</p>
    </li>

    <li>
      <p>Await a stable state. The synchronous section consists
      of the remaining steps of this algorithm. </p>
    </li>

    <li> <p>If the ice state is set to NEW, it MUST queue a task to start
    gathering ICE address and set the ice state to ICE_GATHERING.</p> </li>
    
 </ol>

  <p> During the lifetime of the peerConnection object, the following
     procedures are followed: </p>

  <ol>
  

     <li> <p> If the ICE Agent finds a candidates that froms a valid
    connection, the ICE state is changed to ICE_CONNECTED </p> </li>

     <li> <p> If the ICE Agent finishes checking all candidates, if a
    connection has been found, the ice state is changed to ICE_COMPLETED and if
    not connection has been found it is changed to ICE_FAILED. </p> </li>

     <li> <p> If the iceState is ICE_CONNECTED or ICE_COMPLETED and the
   SDP stat is SDP_IDLE, the readyState is set to ACTIVE. </p> </li>
   
    <li> <p> If the iceState is ICE_FAILED, a task is queued to calls the close method. </p> </li>
  
    <li> <p> The close method will stop all ICE process and change the
    iceState to ICE_CLOSED. </p> </li>
  
</ol>

<!-- TODO here forward -->

  <p>User agents MAY negotiate any codec and any resolution, bitrate, or other quality
  metric. User agents are encouraged to initially negotiate for the native resolution of
  the stream. For streams that are then rendered (using a <code>video</code> element),
  user agents are encouraged to renegotiate for a resolution that matches the rendered
  display size.</p>

  <p class="note">Starting with the native resolution means that if the Web application
  notifies its peer of the native resolution as it starts sending data, and the peer
  prepares its <code>video</code> element accordingly, there will be no need for a
  renegotiation once the stream is flowing.</p>

  <p>All SDP media descriptions for streams represented by
  <code><a>MediaStream</a></code> objects MUST include a label attribute ("<code
  title="">a=label:</code>") whose value is the value of the
  <code><a>MediaStream</a></code> object’s <code title=
  'dom-MediaStream-label'><a href="#dom-mediastream-label">label</a></code>
  attribute.  [[!SDP]] [[!SDPLABEL]]</p>

  <p><a href="#peerconnection"><code>PeerConnection</code>s</a> MUST not generate any
  candidates for media streams whose media descriptions do not have a label attribute
  ("<code>a=label:</code>"). [[!ICE]] [[!SDP]] [[!SDPLABEL]]</p>

  <p>When a user agent has reached the point in the media negotiation where a
  <code><a>MediaStream</a></code> can be created to represent incoming components, the user
  agent MUST run the following steps:</p>

  <ol>
    <li>
      <p>Let <var>connection</var> be the <code><a>PeerConnection</a></code> expecting this
      media.</p>
    </li>

    <li>
      <p>Create a <code><a>MediaStream</a></code> object to represent
      the media stream. Set its <code><a href=
      "#dom-mediastream-label">label</a></code> attribute to the value of the SDP Label
      attribute for that component’s media stream.</p>
    </li>

    <li>
      <p>Run the following steps for each component in the media stream.</p>

    <ol> <li> <p>Create a <code><a>MediaStreamTrack</a></code> object
      <var>track</var> to represent the component.</p> </li>

      <li> <p>If <var>track’s</var> <code> <a
         href="#dom-mediastreamtrack-kind">kind</a></code> attribute equals
        "<code>audio</code>", add it to the <code><a>MediaStream</a></code>
        object’s <code> <a
         href="#dom-mediastream-audiotracks">audioTracks</a></code>
        <code><a>MediaStreamTrackList</a></code> object.</p> </li>

      <li>
        <p>If <var>track’s</var> <code>
        <a href="#dom-mediastreamtrack-kind">kind</a></code> attribute equals "<code>video</code>",
        add it to the <code><a>MediaStream</a></code> object’s
        <code>
        <a href="#dom-mediastream-videotracks">videoTracks</a></code>
        <code><a>MediaStreamTrackList</a></code> object.</p>
      </li>
    </ol>

    <p class='note'>The internal order in the
    <code><a>MediaStreamTrackList</a></code> objects on the receiving side
    should reflect the order on the sending side. One way to enforce this is to
    specify the order in the SDP.</p> </li> <li> <p>Queue a task to run the
    following substeps:</p>

      <ol>
        <li>
          <p>If the <var>connection</var>’s <a href=
          "#peerconnection-readiness-state"><code>PeerConnection</code> readiness
          state</a> is <code><a href=
          "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), abort these steps.</p>
        </li><!-- close() was probably called just before this
     task ran -->

        <li>
          <p>Add the newly created <code><a>MediaStream</a></code>
          object to the end of <var>connection</var>’s <code title=
          'dom-PeerConnection-remoteStreams'><a href=
          "#widl-PeerConnection-remoteStreams">remoteStreams</a></code> array.</p>
        </li>

        <li>
          <p><a href="#fire-a-stream-event">Fire a stream event</a> named <code title=
          'event-MediaStream-addstream'><a href=
          "#event-mediastream-addstream">addstream</a></code> with the newly created
          <code><a>MediaStream</a></code> object at the <var title=
          "">connection</var> object.</p>
        </li>
      </ol>
    </li>
  </ol>

  <p>When a user agent has negotiated media for a component that belongs to a media stream
  thas is already represented by an existing <code><a>MediaStream</a></code> object, the
  user agent MUST associate the component with that <code><a>MediaStream</a></code> object.</p>

  <p>When a <a href="#peerconnection"><code>PeerConnection</code></a> finds that a stream
  from the remote peer has been removed (its port has been set to zero in a media
  description sent on the signaling channel), the user agent MUST follow these steps:</p>

  <ol> <li> <p>Let <var>connection</var> be the
    <code><a>PeerConnection</a></code> associated with the stream being
    removed.</p> </li>

    <li> <p>Let <var>stream</var> be the <code><a>MediaStream</a></code> object
      that represents the media stream being removed, if any. If there isn’t
      one, then abort these steps.</p> </li>

    <li>
      <p>By definition, <var>stream</var> is now <a>finished</a>.</p>

      <p class='note'>A <span title='concept-task'>task</span> is thus <span title=
      "queue a task">queued</span> to update <var>stream</var> and fire an
      event.</p>
    </li>

    <li>
      <p>Queue a task to run the following substeps:</p>

      <ol>
        <li>
          <p>If the <var>connection</var>’s <a href=
          "#peerconnection-readiness-state"><code>PeerConnection</code> readiness
          state</a> is <code><a href=
          "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), abort these steps.</p>
        </li><!-- close() was probably called just before this
     task ran -->

        <li>
          <p>Remove <var>stream</var> from <var>connection</var>’s
          <code><a href=
          "#widl-PeerConnection-remoteStreams">remoteStreams</a></code> array.</p>
        </li>

        <li>
          <p><a href="#fire-a-stream-event">Fire a stream event</a> named <code title=
          'event-MediaStream-removestream'><a href=
          "#event-mediastream-removestream">removestream</a></code> with <var title=
          "">stream</var> at the <var>connection</var> object.</p>
        </li>
      </ol>
    </li>
  </ol>

  <p>The task source for the <span title='concept-task'>tasks</span> listed
  in this section is the networking task source.</p>

  <p>If a <code><a>PeerConnection</a></code> object is <a
   title="consumer">consuming</a> a <code><a>MediaStream</a></code> and a track
  is added to one of the stream’s <code><a>MediaStreaMtrackList</a></code>
  objects, by, e.g., the <code> <a
   href="#dom-mediastreamtracklist-add">add()</a></code> method being invoked,
  the <code><a>PeerConnection</a></code> object MUST add a media component for
  that track the next time the user agent <span title="provide a stable
  state">provides a stable state</span>.  The user agent MUST also remove a
  media component in same way.</p>

  <p class="warning">To prevent network sniffing from allowing a fourth party to
  establish a connection to a peer using the information sent out-of-band to the other
  peer and thus spoofing the client, the configuration information SHOULD always be
  transmitted using an encrypted connection.</p>

  <section>
  <h3>PeerConnection</h3>

  <p> The general operation of the PeerConnection is described in [[RTCWEB-JSEP]].  </p>
  
  <dt>typedef SdpType DomString; //enum SdpType { "offer", "pranswer", "answer" }</dt>
  <dd>

    <p> The SdpType enums serve as arguments to setLocalDescription and
    setRemoteDescription. They provide information as to how the SDP should be
    handled. </p>
    
    <dl>

       <dt><code title=
        'widl-SdpType-offer'><a href="#widl-SdpType-offer">"offer"</a></code>
        </dt>
        
      <dd><p> An SdpType of "offer" indicates that a description should be
        treated as an [[!SDP]] offer. A description used as a SDP offer may be
        applied anytime the PeerConnection is in a stable state, or as an update
        to a previously sent but unanswered SDP offer. TODO -READ THIS PARA </p>
      </dd>

       <dt><code title=
        'widl-SdpType-pranswer'><a href="#widl-SdpType-pranswer">"pranswer"</a></code>
        </dt>
        
      <dd> <p> An SdpType of "pranswer" indicates that a description should be
        treated as an [[!SDP]] answer, but not a final answer. A description
        used as a SDP "pranswer" may be applied as a response to a SDP offer, or
        an update to a previously sent SDP "answer".  </p>
      </dd>

       <dt><code title=
        'widl-SdpType-answer'><a href="#widl-SdpType-answer">"answer"</a></code>
        </dt>
        
      <dd><p> An SdpType of "answer" indicates that a description should be
        treated as an [[!SDP]] final answer, and the offer-answer exchange
        should be considered complete.  A description used as a SDP answer may
        be applied as a response to a SDP offer, or an update to a previously
        send SDP "pranswer".  </p>
      </dd>
          
    </dl>
      
  </dd>

  <dt>typedef PeerState DomString; //enum PeerState { "new" "opening",
    "active", "closing", "closed"  }</dt>
    <dd> 
  <dl>
    <dt><code title=
      'widl-PeerConnection-NEW'><a href="#widl-PeerConnection-NEW">"new"</a></code>
    </dt>

    <dd>The object was just created, and no networking has yet occurred.</dd>

    <dt><code title= 'dom-PeerConnection-NEGOTIATING'><a href=
      "#widl-PeerConnection-OPENING">"opening"</a></code> </dt>
      
      <dd>The user agent is attempting to establish an connection with the ICE
        Agent and waiting for local and remote SDP to be se </dd>
        
      <dt><code title= 'dom-PeerConnection-ACTIVE'><a href=
        "#widl-PeerConnection-ACTIVE">"active"</a></code> </dt>
        
      <dd>The ICE Agent has found a connection both the local and remote SDP
        have been set. It is possible for media to flow.  </dd>
      
      <dt><code title= 'dom-PeerConnection-CLOSING'><a href=
        "#widl-PeerConnection-CLOSED">"closing"</a></code> </dt>

      <dd> The <code><a>PeerConnection</a></code> object is terminating all
        media and is in the process of closing the connection.  </dd>
        
      <dt> <code title= 'dom-PeerConnection-CLOSED'><a href=
        "#widl-PeerConnection-CLOSED">"closed"</a></code> </dt>

      <dd>The connection is closed.
      </dd>

    </dl>

    </dd>

  <dt>typedef IceState DomString; //enum IceState { "new" "gathering",
  "waiting", "checking", "connected", "completed","failed", "closed"  }</dt>
  <dd> <p>TODO </p>

     <dl>
       
        <dt> <code title= 'widl-PeerConnection-NEW'><a
         href="#widl-PeerConnection-NEW">"new"</a></code> </dt>

        <dd>The PeerConnection object was just created, and no networking has
        yet occurred.</dd>

        <dt> <code title= 'dom-PeerConnection-GATHERING'><a href=
        "#widl-PeerConnection-ICE_GATHERING">"gathering"</a></code> </dt>

        <dd>The ICE Agent is attempting to gather addresses.</dd>

         <dt> <code title= 'dom-PeerConnection-ICE_WAITING'><a href=
        "#widl-PeerConnection-ICE_WAITING">"waiting"</a></code> </dt>

        <dd>The ICE Agent is not gathering any addresses and is waiting for
        candidates from the other side before it can start checking.</dd>

        <dt> <code title= 'dom-PeerConnection-CHECKING'><a href=
        "#widl-PeerConnection-ACTIVE">"checking"</a></code> </dt>

        <dd>The ICE Agent is checking candidates but has not yet found a
        connection.</dd>

        <dt> <code title= 'dom-PeerConnection-CONNECTED'><a href=
        "#widl-PeerConnection-CLOSED">"connected"</a></code> </dt>

        <dd>The ICE
        Agent has found a connection but is still checking other candidates to
        see if there is a better connection.</dd>

        <dt> <code title= 'dom-PeerConnection-COMPLETED'><a href=
        "#widl-PeerConnection-CLOSED">"completed"</a></code> </dt>

        <dd>The ICE Agent has finished checking and found a connection.</dd>

        <dt> <code title= 'dom-PeerConnection-ICE_FAILED'><a href=
        "#widl-PeerConnection-CLOSED">"failed"</a></code> </dt>

        <dd>The ICE Agent is finished checking all candidates and failed to find
        a connection.</dd>

        <dt> <code title= 'dom-PeerConnection-CLOSED'><a href=
        "#widl-PeerConnection-CLOSED">"closed"</a></code> </dt>
        
        <dd>The ICE Agent has shut down and is no longer responding to STUN
        requests.</dd>
        
     </dl>


  </dd>

    <dt>typedef Configuration DomString[][];</dt>
  <dd> <p>TODO </p> </dd>

  
  <dl title=
  '[Constructor (Configuration configuration)] interface PeerConnection'
  class='idl'>

          <dt>DOMString createAnswer (DOMString offer, optional MediaConstraints constraints)</dt>
     <dd>

       <p>The createAnswer method generates a [[!SDP]] answer with the supported
       configuration for the session that is compatible with the parameters
       supplied in offer. Like createOffer, the returned blob contains
       descriptions of the local MediaStreams attached to this PeerConnection,
       the codec/RTP/RTCP options negotiated for this session, and any
       candidates that have been gathered by the ICE Agent. The constraints
       parameter may be supplied to provide additional control over the
       generated answer. </p>
        
       <p> As an answer, the generated SDP will contain a specific configuration
       that specifies how the media plane should be established. For each SDP
       line, the generation of the SDP must follow the appropriate process for
       generating an answer. Session descriptions generated by createAnswer must
       be immediately usable by setLocalDescription without generateing an
       error; like createOffer, the returned description should reflect the
       current state of the system. Calling this method is not required. </p>
        
        <p> A TBD exception is thrown if the constraints parameter is malformed,
       or the offer parameter is malformed. </p>

     </dd>


    <dt>DOMString createOffer (MediaConstraints constraints)</dt>
      <dd>

        <p> The createOffer method generates a blob of SDP that contains a RFC
        offer with the supported configurations for the session, including
        descriptions of the local MediaStreams attached to this PeerConnection,
        the codec/RTP/RTCP options supported by this implementation, and any
        candidates that have been gathered by the ICE Agent. The constraints
        parameter may be supplied to provide additional control over the offer
        generated. </p>
        
        <p> As an offer, the generated SDP will contain the full set of
        capabilities supported by the session (as opposed to an answer, which
        will include only a specific negotiated subset to use); for each SDP
        line, the generation of the SDP must follow the appropriate process for
        generating an offer. In the event createOffer is called after the
        session is established, createOffer will generate an offer that is
        compatible with the current session, incorporating any changes that have
        been made to the session since the last complete offer-answer exchange,
        such as addition or removal of streams. If no changes have been made,
        the offer will be include the capabilites of the current local
        description.  </p>
        
        <p> Session descriptions generated by createOffer MUST be immediately
        usable by setLocalDescription without cuasing an error; if a system has
        limited resources (e.g. a finite number of decoders), createOffer should
        return an offer that reflects the current state of the system, so that
        setLocalDescription will succeed when it attempts to acquire those
        resources. Calling this method is not required. </p> </dd>

        <!-- TOOD move the Domstring with SDP to a type -->
        

        <dt>readonly attribute DOMString localDescription</dt>
     <dd>

       <p> The localDescription method returns a copy of the current local
       configuration, i.e. the answer that was most recently passed to
       setLocalDescription, plus any local candidates that have been generated
       by the ICE Agent since then.  </p>
       
       <p>
       A null object will be returned if the local description has not yet
       been set with an answer.
       </p>

     </dd>

       
      <dt>void setLocalDescription (SdpType action, DOMString sdp)</dt>
     <dd>

       <p> The setLocalDescription method instructs the PeerConnection to apply
       the supplied [[!SDP]] blob as the local offer or anser. The type
       parameter indicates whether the blob should be processed as an offer,
       provisional answer, or final answer. </p>

       <p> This API changes the local media state; among other things, it sets
       up local resources for receiving and decoding media. In order to
       successfully handle scenarios where the application wants to offer to
       change from one media format to a different, incompatible format, the
       PeerConnection must be able to simultaneously support use of both the old
       and new local descriptions (e.g. support codecs that exist in both
       descriptions) until a final answer is received, at which point the
       PeerConnection can fully adopt the new local description, or roll back to
       the old description if the remote side denied the change. </p>

       <p>Changes to the state of media transmission will only occur when a
       final answer is successfully applied.TODO READ </p>

       <p> A TBD exception is thrown if sdp is invalid. A TBD
       exception is thrown if there are insufficient local resources to
       apply the sdp.  </p>

     </dd>

     
      <dt>void setRemoteDescription (SdpType action, DOMString sdp)</dt>
     <dd>

       <p> The setRemoteDescription method instructs the PeerConnection to apply
       the supplied [[!SDP]]. As in setLocalDescription, the action parameter
       indicates how the blob should be processed. This API changes the local
       media state; among other things, it sets up local resources for sending
       and encoding media.  </p>

       <p> Changes to the state of media transmission will only occur when a
       final answer is successfully applied. TODO -READ </p>

       <p> A TBD exception is thrown if the sdp paramater is invalid. A TBD
       exception is thrown if there are insufficient local resources to apply
       the SDP. </p>

     </dd>

     
      <dt>readonly attribute DOMString remoteDescription</dt>
     <dd>

       <p> The remoteDescription method returns a copy of the current remote
       configuration, i.e. the answer that was most recently passed to
       setRemoteDescription, plus any remote candidates that have been supplied
       via processIceMessage since then.  </p>

       <p> A null object will be returned if the remote description has not yet
       been set with an answer. </p>

     </dd>
     
   
    <dt>readonly attribute PeerState readyState</dt>

    <dd>
      
      <p>The <dfn id='dom-peerconnection-readystate'><code
      title="">readyState</code></dfn> attribute MUST return the
      <code><a>PeerConnection</a></code> object’s <a
       href="#peerconnection-readiness-state"><code>PeerConnection</code>
      readiness state</a>. </p>

    </dd>

    <dt>void startIce (optional MediaConstraints constraints)</dt>
    <dd>

      <p> The startIce method starts or updates the ICE Agent process of
      gathering local candidates and pinging remote candidates. If there is a
      manadatory contraint called "media-enum-relay-only" and it is set to true, the ICE
      eingine MUST only use candidates that are thorught a relay servers such as
      a TURN server. This can be used to
      limit the use to TURN candidates by a callee to avoid leaking location
      information prior to the call being accepted. </p>

      <p> This call may result in a change to the state of the ICE Agent, and
      may result in a change to media state if it results in connectivity being
      established. </p>

      <p> A TBD exception will be thrown if constraints is malformed.  </p>

    </dd>

    
     <dt>void addIceCandidate (IceCandidate candidate)</dt>
    <dd>

      <p>The addIceCandidate method provides a remote candidate to the ICE
      Agent, which will be added to the remote description. If startIce has been
      called, connectivity checks will be sent to the new candidates (as long as
      they would not be restircted by the "media-enum-relay-only"
      constraint. This call will result in a change to the state of the ICE
      Agent, and may result in a change to media state if it results in
      connectivity being established.  </p>
      
      <p> The format of the candidate is TODO (same as line with ICE info in
      SDP) </p>

      <p> A TBD exception will be thrown if candidate paramter is
      malformed. </p>

    </dd>
 
    <dt>readonly attribute IceState iceState</dt>
    <dd>
     
      <p>The <dfn id='dom-peerconnection-icestate'><code>iceState</code></dfn>
      attribute MUST return the state of the <a
       href="#peerconnection-ice-agent"><code>PeerConnection</code> ICE
      Agent</a> ICE state. </p>
     
    </dd>

   <dt>readonly attribute MediaStream[] localStreams</dt>

    <dd>
      
      <p>Returns a live array containing the local streams (those that were
      added with <code title= 'dom-PeerConnection-addStream'><a href=
      "#dom-peerconnection-addstream">addStream()</a></code>).</p>
      
    </dd>

    <dt>readonly attribute MediaStream[] remoteStreams</dt>

    <dd>
      
      <p>Returns a live array containing the streams that the remote
      streams. (those that were added by the remote side). </p>

      <p>This array is updated when <code><a href=
      "#event-mediastream-addstream">addstream</a></code> and <code title=
      'event-MediaStream-removestream'><a href=
      "#event-mediastream-removestream">removestream</a></code> events are
      fired.</p> </dd>


    <dt>void addStream (MediaStream stream, optional MediaConstraints constraints)</dt>

    <dd>

      <p>Attempts to starting sending the given stream to the remote peer.  </p>

      <p>When the other peer starts sending a stream in this manner, an <code title=
      'event-MediaStream-addstream'><a href=
      "#event-mediastream-addstream">addstream</a></code> event is fired at the
      <code><a>PeerConnection</a></code> object.</p>

      <p>When the <dfn id='dom-peerconnection-addstream'><code
      title="">addStream()</code></dfn> method is invoked, the user agent MUST
      run the following steps:</p>

      <ol>

        <li>
          <p>If the <code><a>PeerConnection</a></code> object’s
          <a href="#peerconnection-readiness-state"><code>PeerConnection</code> readiness
          state</a> is <code><a href=
          "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), throw an
          <code>INVALID_STATE_ERR</code> exception.</p>
        </li>

        <li>
          <p>If <var>stream</var> is already in the <code><a>PeerConnection</a></code> object’s <code title=
          'dom-PeerConnection-localStreams'><a href=
          "#widl-PeerConnection-localStreams">localStreams</a></code> object, then abort
          these steps.</p>
        </li>

        <li>
          <p>Add <var>stream</var> to the end of the <code><a>PeerConnection</a></code> object’s <code title=
          'dom-PeerConnection-localStreams'><a href=
          "#widl-PeerConnection-localStreams">localStreams</a></code> object.</p>
        </li>

        <li>
          <p>Return from the method.</p>
        </li>

        <li>
          <p>Parse the <var>constraints</var> provided by the application
          and apply them to the MediaStream, if possible. NOTE - need to deal
          with throwing an exption here. 
          </p>
        </li>
        <li>
          <p>Have the <code><a>PeerConnection</a></code> add a
          media stream for <var>stream</var> the next time the user agent
          <span title="provide a stable state">provides a stable state</span>. Any other
          pending stream additions and removals MUST be processed at the same time.</p>
        </li>
      </ol>
    </dd>

    <dt>void removeStream (MediaStream stream)</dt>

    <dd>
      <p>Stops sending the given stream to the remote peer.</p>

      <p>When the other peer stops sending a stream in this manner, a <code title=
      'event-MediaStream-removestream'><a href=
      "#event-mediastream-removestream">removestream</a></code> event is fired at the
      <code><a>PeerConnection</a></code> object.</p>

      <p>When the <dfn id='dom-peerconnection-removestream'><code title="">removeStream()</code></dfn> method
      is invoked, the user agent MUST run the following steps:</p>

      <ol>
     
        <li>
          <p>If the <code><a>PeerConnection</a></code> object’s
          <a href="#peerconnection-readiness-state"><code>PeerConnection</code> readiness
          state</a> is <code><a href=
          "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), throw an
          <code>INVALID_STATE_ERR</code> exception.</p>
        </li>

        <li>
          <p>If <var>stream</var> is not in the <code><a>PeerConnection</a></code> object’s <code title=
          'dom-PeerConnection-localStreams'><a href=
          "#widl-PeerConnection-localStreams">localStreams</a></code> object, then abort
          these steps.</p>
        </li>

        <li>
          <p>Remove <var>stream</var> from the <code><a>PeerConnection</a></code> object’s <code title=
          'dom-PeerConnection-localStreams'><a href=
          "#widl-PeerConnection-localStreams">localStreams</a></code> object.</p>
        </li>

        <li>
          <p>Return from the method.</p>
        </li>

        <li>
          <p>Have the <code><a>PeerConnection</a></code>remove the
          media stream for <var>stream</var> the next time the user agent
          <span title="provide a stable state">provides a stable state</span>. Any other
          pending stream additions and removals MUST be processed at the same time.</p>
        </li><!-- section 9.1.1.2 -->
      </ol>
    </dd>

     <dt>void close ()</dt>

    <dd>

      <p>When the <dfn id='dom-peerconnection-close'><code
      title="">close()</code></dfn> method is invoked, the user agent MUST run
      the following steps:</p>

      <ol>

        <li> <p>If the <code><a>PeerConnection</a></code> object’s <a
          href="#peerconnection-readiness-state"><code>PeerConnection</code>
         readiness state</a> is <code><a href=
         "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), throw an
         <code>INVALID_STATE_ERR</code> exception.</p> </li>

        <li> <p>Destroy the <a
           href="#peerconnection-ice-agent"><code>PeerConnection</code> ICE
          Agent</a>, abruptly ending any active ICE processing and any active
          streaming, and releasing any relevant resources (e.g. TURN
          permissions).</p> </li>

        <li> <p>Set the object’s <a href=
          "#peerconnection-readiness-state"><code>PeerConnection</code>
          readiness state</a> to <code><a href=
          "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3).</p> </li>

      </ol>

      <p class='note'>The <code><a href=
      "#widl-PeerConnection-localStreams">localStreams</a></code> and <code title=
      'dom-PeerConnection-remoteStreams'><a href=
      "#widl-PeerConnection-remoteStreams">remoteStreams</a></code> objects remain in the
      state they were in when the object was closed.</p>
      
    </dd>

    <dt>attribute Function? onconnecting</dt>

    <dd>This event handler, of <span title="event handler event type">event
    handler event type</span> <code><a href=
    "#event-mediastream-connecting">connecting</a></code>, MUST be supported by
    all objects implementing the <code><a>PeerConnection</a></code>
    interface.</dd>

    <dt>attribute Function? onopen</dt>

    <dd>This event handler, of <span title="event handler event type">event
    handler event type</span> <code><a href=
    "#event-mediastream-open">open</a></code>, MUST be supported by all objects
    implementing the <code><a>PeerConnection</a></code> interface.</dd>

    <dt>attribute Function? onstatechange</dt>

    <dd>This event handler, of <span title="event handler event type">event
    handler event type</span> <code><a href=
    "#event-mediastream-open">open</a></code>, MUST be supported by all objects
    implementing the <code><a>PeerConnection</a></code> interface. It is called
    any time the readyState changes. </dd>

    
    <dt>attribute Function? onaddstream</dt>

    <dd>This event handler, of <span title="event handler event type">event
    handler event type</span> <code><a href=
    "#event-mediastream-addstream">addstream</a></code>, MUST be supported by
    all objects implementing the <code><a>PeerConnection</a></code>
    interface.</dd>

    <dt>attribute Function? onremovestream</dt>

    <dd>This event handler, of <span title="event handler event type">event
    handler event type</span> <code><a href=
    "#event-mediastream-removestream">removestream</a></code>, MUST be supported
    by all objects implementing the <code><a>PeerConnection</a></code>
    interface.</dd>

    <dt>attribute Function? onicechange</dt>

    <dd>This event handler, of <span title="event handler event type">event
    handler event type</span> <code><a href=
    "#event-mediastream-icechange">icechange</a></code>, MUST be supported by
    all objects implementing the <code><a>PeerConnection</a></code> interface.
    It is called any time the iceState changes.</dd>

    
  </dl>

  <div title='PeerConnection implements EventTarget' class='idl'></div>
  </section>

  <section>
  <h3>SignalingCallback</h3>

  <dl title='[Callback, NoInterfaceObject] interface SignalingCallback'
  class='idl'>
    <dt>void handleEvent (DOMString message, PeerConnection source)</dt>

    <dd>Def TBD</dd>
  </dl>
  </section>

  <section>
  <h3>Examples</h3>

  <div>
    <p>When two peers decide they are going to set up a connection to each other, they
    both go through these steps. The STUN/TURN server configuration describes a server
    they can use to get things like their public IP address or to set up NAT traversal.
    They also have to send data for the signaling channel to each other using the same
    out-of-band mechanism they used to establish that they were going to communicate in
    the first place.</p>
    <pre  class='example sh_javascript'>
TOOD
</pre>
  </div>
  </section>
  </section>

  <section>
  <h2>The data stream</h2>

  <p class="note">Although progress is being made, there is currently not enough
  agreement on the data channel to write it up. This section will be filled in as rough
  consensus is reached.</p>
  </section>

  <section>
  <h2>Garbage collection</h2>

  <p>A <code>Window</code> object <dfn id='concept-peerconnection-owner'>has a
  strong reference</dfn> to any <code><a>PeerConnection</a></code> objects
  created from the constructor whose global object is that <code>Window</code>
  object.</p><!-- we could be less strict here, e.g. dropping the reference when
  there’s no way for an event to be fired because there’s no event handlers
  registered and there’s no way for the remote peer to notice anything because
  no media is streaming; or e.g. dropping the reference when the object reaches
  the CLOSED state. But as dropping the reference in those cases is black-box
  indistinguishable from keeping the reference, I haven't bothered to work out
  the exact rules. If you do change this, see the /unloading document cleanup
  steps/. --> </section>

  <section>
  <h2>Event definitions</h2>

  <section>
  <h3>MediaStreamTrackEvent</h3>

  <p>The <code><a href=
  "#event-mediastreamtracklist-addtrack">addtrack</a></code> and <code title=
  'event-MediaStreamTracklist-removetrack'><a href=
  "#event-mediastreamtracklist-removetrack">removetrack</a></code> events use the
  <code><a>MediaStreamTrackEvent</a></code> interface.</p>

  <p><dfn title="Fire a track event">Firing a track event
  named <var>e</var></dfn> with a <code><a>MediaStreamTrack</a></code> <var>track</var>
  means that an event with the name <var>e</var>, which does not bubble (except where
  otherwise stated) and is not cancelable (except where otherwise stated), and which
  uses the <code><a>MediaStreamTrackEvent</a></code> interface with the
  <code><a href=
  "#dom-mediastreamtrackevent-track">track</a></code> attribute set to <var>track</var>,
  MUST be created and dispatched at the given target.</p>

  <dl title='[Constructor(DOMString type, optional MediaStreamTrackEventInit eventInitDict)]
    interface MediaStreamTrackEvent : Event' class='idl' data-merge='MediaStreamTrackEventInit'>
    <dt>readonly attribute MediaStreamTrack? track</dt>

    <dd> <p>The <dfn
      id='dom-mediastreamtrackevent-track'><code>track</code></dfn> attribute
      represents the <code><a>MediaStreamTrack</a></code> object associated with
      the event.</p> </dd>

  </dl>
  <dl title='dictionary MediaStreamTrackEventInit : EventInit' class='idl'>
    <dt>MediaStreamTrack? track</dt>

    <dd>
      <p>-</p>
    </dd>

  </dl>
  </section>

  <section>
  <h3>MediaStreamEvent</h3>

  <p>The <code><a href=
  "#event-mediastream-addstream">addstream</a></code> and <code title=
  'event-MediaStream-removestream'><a href=
  "#event-mediastream-removestream">removestream</a></code> events use the
  <code><a>MediaStreamEvent</a></code> interface.</p>

  <p><dfn id='fire-a-stream-event' title="fire a stream event">Firing a stream event
  named <var>e</var></dfn> with a <code><a>MediaStream</a></code> <var>stream</var> means that an event
  with the name <var>e</var>, which does not bubble (except where otherwise
  stated) and is not cancelable (except where otherwise stated), and which uses the
  <code><a>MediaStreamEvent</a></code> interface with the
  <code><a href=
  "#dom-mediastreamevent-stream">stream</a></code> attribute set to <var title=
  "">stream</var>, MUST be created and dispatched at the given target.</p>

  <dl title='[Constructor(DOMString type, optional MediaStreamEventInit eventInitDict)] interface MediaStreamEvent : Event' class='idl' data-merge='MediaStreamEventInit'>
    <dt>readonly attribute MediaStream? stream</dt>

    <dd>
      <p>The <dfn id='dom-mediastreamevent-stream'><code>stream</code></dfn> attribute represents the
      <code><a>MediaStream</a></code> object associated with the
      event.</p>
    </dd>

  </dl>
  <dl title='dictionary MediaStreamEventInit : EventInit' class='idl'>
    <dt>MediaStream? stream</dt>

    <dd>
      <p>-</p>
    </dd>

  </dl>
  </section>
  </section>

  <section class="informative">
  <h2>Event summary</h2>

  <p>The following event fires on <code><a>MediaStream</a></code>
  objects:</p>

  <table>
    <tr>
      <th>Event name</th>

      <th>Interface</th>

      <th>Fired when...</th>
    </tr>

    <tbody>
      <tr>
        <td><dfn id='event-mediastream-ended'><code>ended</code></dfn></td>

        <td><code>Event</code></td>

        <td>The <code><a>MediaStream</a></code> <a>finished</a> as a result of all tracks
        in the <code><a>MediaStream</a></code> <a title="ended">ending</a>.</td>
      </tr>
    </tbody>
  </table>

  <p>The following event fires on <code><a>MediaStreamTrack</a></code>
  objects:</p>

  <table>
    <tr>
      <th>Event name</th>

      <th>Interface</th>

      <th>Fired when...</th>
    </tr>

    <tbody>
      <tr>
        <td><dfn id='event-mediastreamtrack-muted'><code>muted</code></dfn></td>

        <td><code>Event</code></td>

        <td>The <code><a>MediaStreamTrack</a></code> object’s source is temporarily
        unable to provide data.</td>
      </tr>
      <tr>
        <td><dfn id='event-mediastreamtrack-unmuted'><code>unmuted</code></dfn></td>

        <td><code>Event</code></td>

        <td>The <code><a>MediaStreamTrack</a></code> object’s source is live again
        after having been temporarily unable to provide data.</td>
      </tr>
      <tr>
        <td><dfn id='event-mediastreamtrack-ended'><code>ended</code></dfn></td>

        <td><code>Event</code></td>

        <td>The <code><a>MediaStreamTrack</a></code> object’s source will no longer
        provide any data, either because the user revoked the permissions, or because the
        source device has been ejected, or because the remote peer stopped sending data,
        or because the <code><a href=
        "#dom-mediastream-stop">stop()</a></code> method was invoked.</td>
      </tr>
    </tbody>
  </table>

  <p>The following event fires on <code><a>MediaStreamTrackList</a></code>
  objects:</p>

  <table>
    <tr>
      <th>Event name</th>

      <th>Interface</th>

      <th>Fired when...</th>
    </tr>

    <tbody>
      <tr>
        <td><dfn id='event-mediastreamtracklist-addtrack'><code>addtrack</code></dfn></td>

        <td><code><a>MediaStreamTrackEvent</a></code></td>

        <td>A new <code><a>MediaStreamTrack</a></code> has been added to this list.</td>
      </tr>
      <tr>
        <td><dfn id='event-mediastreamtracklist-removetrack'><code>removetrack</code></dfn></td>

        <td><code><a>MediaStreamTrackEvent</a></code></td>

        <td>A <code><a>MediaStreamTrack</a></code> has been removed from this list.</td>
      </tr>
    </tbody>
  </table>

  <p>The following events fire on <code><a>PeerConnection</a></code> objects:</p>

  <table>
    <tr>
      <th>Event name</th>

      <th>Interface</th>

      <th>Fired when...</th>
    </tr>

    <tbody>
      <tr>
        <td><dfn id='event-mediastream-connecting'><code>connecting</code></dfn></td>

        <td><code>Event</code></td>

        <td>The ICE Agent has begun negotiating with the peer. This can happen multiple
        times during the lifetime of the <code><a>PeerConnection</a></code> object.</td>
      </tr>

      <tr>
        <td><dfn id='event-mediastream-open'><code>open</code></dfn></td>

        <td><code>Event</code></td>

        <td>The ICE Agent has finished negotiating with the peer.</td>
      </tr><!--
        <tr>
          <td><dfn title="event-MediaStream-error"><code>error</code></dfn></td>
          <td><code>Event</code></td>
          <td></td>
        </tr>
        <tr>
          <td><dfn title="event-MediaStream-close"><code>close</code></dfn></td>
          <td><code>Event</code></td>
          <td>The <code title="dom-PeerConnection-close">close()</code> method was
            called. </td>
          </tr>
          -->

      <tr>
        <td><dfn id='event-mediastream-message'><code>message</code></dfn></td>

        <td><code>MessageEvent</code></td>

        <td>A <!--<a href="#data-udp-media-stream">-->data UDP media stream<!--</a>--> message was
        received.</td>
      </tr>

      <tr>
        <td><dfn id='event-mediastream-addstream'><code>addstream</code></dfn></td>

        <td><code><a>MediaStreamEvent</a></code></td>

        <td>A new stream has been added to the <code title=
        'dom-PeerConnection-remoteStreams'><a href=
        "#widl-PeerConnection-remoteStreams">remoteStreams</a></code> array.</td>
      </tr>

      <tr>
        <td><dfn id='event-mediastream-removestream'><code>removestream</code></dfn></td>

        <td><code><a>MediaStreamEvent</a></code></td>

        <td>A stream has been removed from the <code title=
        'dom-PeerConnection-remoteStreams'><a href=
        "#widl-PeerConnection-remoteStreams">remoteStreams</a></code> array.</td>
      </tr>
    </tbody>
  </table>
  </section>

  <section>
  <h2 id="sec-iana">IANA Registrations</h2>

  <section>
  <h2
  id="sec-constraints">Constraints Registrations</h2>

  <p> IANA is requeted to register the fofllwling constraints as specified in
  [[!RTCWEB-CONSTRAINTS]]: </p>

  <dl>
    <dt> media-enum-relay-only </dt>
    <dd>
      <p> This constratins indicat4es if the ICE engine is restricted to only
    using media relay cnadiates such as candidates passing thorugh a TURN
    server. This can be used to reduce legkage of IP addresses in certian use
    cases. </p>
      <p> The constraint can be set to true or false. Defaults is false. </p>
    </dd>
    
  </dl>
  
  </section>
  
  <section>
  <h2 id="application_html-peer-connection-data">application/html-peer-connection-data</h2>

  <p>This registration is for community review and will be submitted to the IESG for
  review, approval, and registration with IANA.</p><!--
   To: ietf-types@iana.org
   Subject: Registration of media type application/html-peer-connection-data
  -->

  <dl>
    <dt>Type name:</dt>

    <dd>application</dd>

    <dt>Subtype name:</dt>

    <dd>html-peer-connection-data</dd>

    <dt>Required parameters:</dt>

    <dd>No REQUIRED parameters</dd>

    <dt>Optional parameters:</dt>

    <dd>No OPTIONAL parameters</dd>

    <dt>Encoding considerations:</dt>

    <dd>This MIME type defines a binary protocol format which uses UTF-8 for text
    encoding.</dd>

    <dt>Security considerations:</dt>

    <dd>
      <p>This format is used for encoding UDP packets transmitted by potentially hostile
      Web page content via a trusted user agent to a destination selected by a
      potentially hostile remote server. To prevent this mechanism from being abused for
      cross-protocol attacks, all the data in these packets is masked so as to appear to
      be random noise. The intent of this masking is to reduce the potential attack
      scenarios to those already possible previously.</p>

      <p>However, this feature still allows random data to be sent to destinations that
      might not normally have been able to receive them, such as to hosts within the
      victim’s intranet. If a service within such an intranet cannot handle receiving UDP
      packets containing random noise, it might be vulnerable to attack from this
      feature.</p>
    </dd>

    <dt>Interoperability considerations:</dt>

    <dd>Rules for processing both conforming and non-conforming content are defined in
    this specification.</dd>

    <dt>Published specification:</dt>

    <dd>This document is the relevant specification.</dd>

    <dt>Applications that use this media type:</dt>

    <dd>This type is only intended for use with SDP. [[!SDP]]</dd>

    <dt>Additional information:</dt>

    <dd>
      <dl>
        <dt>Magic number(s):</dt>

        <dd>No sequence of bytes can uniquely identify data in this format, as all data
        in this format is intentionally masked to avoid cross-protocol attacks.</dd>

        <dt>File extension(s):</dt>

        <dd>This format is not for use with files.</dd>

        <dt>Macintosh file type code(s):</dt>

        <dd>This format is not for use with files.</dd>
      </dl>
    </dd>

    <dt>Person &amp; email address to contact for further information:</dt>

    <dd>Daniel C. Burnett &lt;dburnett@voxeo.com&gt;</dd>

    <dt>Intended usage:</dt>

    <dd>Common</dd>

    <dt>Restrictions on usage:</dt>

    <dd>No restrictions apply.</dd>

    <dt>Author:</dt>

    <dd>Daniel C. Burnett &lt;dburnett@voxeo.com&gt;</dd>

    <dt>Change controller:</dt>

    <dd>W3C</dd>
  </dl>

  <p>Fragment identifiers cannot be used with <code><a href=
  "#application_html-peer-connection-data">application/html-peer-connection-data</a></code>
  as URLs cannot be used to identify streams that use this format.</p>
  </section>
  </section>

  <section>
  <h2>Change Log</h2>
  <p> This section will be removed before publication. </p>

  <h3> To Do Items </h3>
  <p> Need a way to indicate the type of the SDP when passing SDP strings. </p>

  <h3> Changes since 12 January 2012</h3>
  <ol>
    <li> Clarified what relation of Stream, Track, and Channel. </li>
  </ol>

  <h3> Changes since 17 October 2011</h3>
  <ol>
    <li>Tweak the introduction text and add a reference to the IETF RTCWEB group.</li>
    <li>Changed the first argument to getUserMedia to be an object.</li>
    <li>Added a MediaStreamHints object as a second argument to PeerConnection.addStream.</li>
    <li>Added AudioMediaStreamTrack class and DTMF interface.</li>
  </ol>

  <h3> Changes since 23 August 2011</h3>
  <ol>
    <li> Separated the SDP and ICE Agent into separate agents and added explicit
 state attributes for each. </li>
    <li> Removed the send method from PeerConenction and associated callback function. </li>
    <li>Modified MediaStream() constructor to take a list of MediaStreamTrack objects instead
    of a MediaStream. Removed text about MediaStream parent and child relationship.</li>
    <li>Added abstract.</li>
    <li>Moved a few paragraphs from the MediaStreamTrack.label section to the
    MediaStream.label section (where they belong).</li>
    <li>Split MediaStream.tracks into MediaStream.audioTracks and MediaStream.videoTracks.</li>
    <li>Removed a sentence that implied that track access is limited to LocalMediaStream.</li>
    <li>Updated a few getUserMedia()-examples to use MediaStreamOptions.</li>
    <li>Replaced calls to URL.getObjectURL() with URL.createObjectURL() in example code.</li>
    <li>Fixed some broken getUserMedia() links.</li>
    <li>Introduced state handling on MediaStreamTrack (removed state handling from MediaStream).</li>
    <li>Reintroduced onended on MediaStream to simplify checking if all tracks are ended.</li>
    <li>Aligned the MediaStreamTrack ended event dispatching behavior with that of MediaStream.</li>
    <li>Updated the LocalMediaStream.stop() algorithm to implicitly use the end track algorithm.</li>
    <li>Replaced an occurrence the term finished track with ended track (to align with
    rest of spec).</li>
    <li>Moved (and extended) the explanation about track references and media sources from
    LocalMediaStream to MediaStreamTrack.</li>
    <li>Removed section "Obtaining local multimedia content".</li>
    <li>Updated getUserMedia() calls in examples (changes in Media Capture TF spec).</li>
    <li>Introduced MediaStreamTrackList interface with support for adding and removing tracks.</li>
    <li>Updated the algorithm that is run when PeerConnection receives a stream (create new
    stream when negotiated instead of when data arrives).</li>
 </ol>
  
  </section>

 
  <section class="appendix">
  <h2>Acknowledgements</h2>

  <p>The editors wish to thank the Working Group chairs, Harald Alvestrand and Stefan
  Håkansson, for their support.</p>
  </section>
</body>
</html>
