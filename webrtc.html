<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>WebRTC 1.0: Real-time Communication Between Browsers</title>
  <script class="remove" src=
  "https://www.w3.org/Tools/respec/respec-w3c-common" type="text/javascript">
  // // keep this comment //
  </script>
  <script class="remove" src="webrtc.js" type="text/javascript">
  // // keep
    this comment //
  </script>
</head>
<body>
  <section id="abstract">
    <p>This document defines a set of ECMAScript APIs in WebIDL to allow media
    to be sent to and received from another browser or device implementing the
    appropriate set of real-time protocols. This specification is being
    developed in conjunction with a protocol specification developed by the
    IETF RTCWEB group and an API specification to get access to local media
    devices developed by the Media Capture Task Force.</p>
  </section>
  <section id="sotd">
    <p>The Editors and active contributors of WebRTC 1.0 intend to publish a
    Candidate Recommendation soon. Consequently, this is a Request for Comments
    by the WebRTC Working Group to seek wide review of this document.</p>
    <p>The API is based on preliminary work done in the WHATWG.</p>
  </section>
  <section class="informative" id="intro">
    <h2>Introduction</h2>
    <p>There are a number of facets to video-conferencing in HTML covered by
    this specification:</p>
    <ul>
      <li>Connecting to remote peers using NAT-traversal technologies such as
      ICE, STUN, and TURN.</li>
      <li>Sending the locally-produced tracks to remote peers and receiving
      tracks from remote peers.</li>
      <li>Sending arbitrary data directly to remote peers.</li>
    </ul>
    <p>This document defines the APIs used for these features. This
    specification is being developed in conjunction with a protocol
    specification developed by the <a href=
    "https://datatracker.ietf.org/wg/rtcweb/">IETF RTCWEB group</a> and an API
    specification to get access to local media devices [[!GETUSERMEDIA]]
    developed by the <a href="https://www.w3.org/wiki/Media_Capture">Media
    Capture Task Force</a>. An overview of the system can be found in
    [[RTCWEB-OVERVIEW]] and [[RTCWEB-SECURITY]].</p>
  </section>
  <section id="conformance">
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant.)</p>
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification MUST implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL-1]], as
    this specification uses that specification and terminology.</p>
  </section>
  <section>
    <h2>Terminology</h2>
    <p>The <code><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
    interface, representing a callback used for event handlers, and the
    <a href="http://dev.w3.org/html5/spec/webappapis.html#errorevent"><code><dfn>
    ErrorEvent</dfn></code></a> interface are defined in [[!HTML5]].</p>
    <p>The concepts <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a
    task</a></dfn>, <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a
    simple event</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#networking-task-source">networking
    task source</a></dfn> are defined in [[!HTML5]].</p>
    <p>The terms <dfn>event</dfn>, <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
    handlers</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
    handler event types</a></dfn> are defined in [[!HTML5]].</p>
    <p>The terms <dfn>MediaStream</dfn>, <dfn>MediaStreamTrack</dfn>, and
    <dfn>MediaStreamConstraints</dfn> are defined in [[!GETUSERMEDIA]].</p>

    <p>The term <dfn>Blob</dfn> is defined in [[!FILEAPI]].</p>
    <p>The term <dfn>media description</dfn> is defined in [[!RFC4566]].</p>
  </section>
  <section>
    <h2>Peer-to-peer connections</h2>
    <section>
      <h3>Introduction</h3>
      <p>An <code><a>RTCPeerConnection</a></code> instance allows to establish
      peer to peer communications. Communications are coordinated via a
      signaling channel which is provided by unspecified means, but generally
      by a script in the page via the server, e.g. using
      <code>XMLHttpRequest</code> [[XMLHttpRequest]] or Web Sockets
      [[WEBSOCKETS-API]].</p>
    </section>
    <section>
      <h3>Configuration</h3>
      <section>
        <h4>RTCConfiguration Dictionary</h4>
        <p>The <code>RTCConfiguration</code> defines a set of parameters to
        configure how the peer to peer communication established via
        <code><a>RTCPeerConnection</a></code> is established or
        re-established.</p>
        <div>
          <pre class="idl">dictionary RTCConfiguration {
             sequence&lt;RTCIceServer&gt;   iceServers;
             RTCIceTransportPolicy    iceTransportPolicy = "all";
             RTCBundlePolicy          bundlePolicy = "balanced";
             RTCRtcpMuxPolicy         rtcpMuxPolicy = "require";
             DOMString                peerIdentity;
             sequence&lt;RTCCertificate&gt; certificates;
             unsigned short           iceCandidatePoolSize = 0;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCConfiguration</a> Members</h2>
            <dl data-link-for="RTCConfiguration" data-dfn-for=
            "RTCConfiguration" class="dictionary-members">
              <dt><dfn><code>iceServers</code></dfn> of type <span class=
              "idlMemberType">sequence&lt;<a>RTCIceServer</a>&gt;</span></dt>
              <dd>
                <p>An array of objects describing servers available to be used
                by ICE, such as STUN and TURN server.</p>
              </dd>
              <dt><dfn><code>iceTransportPolicy</code></dfn> of type
              <span class="idlMemberType"><a>RTCIceTransportPolicy</a></span>,
              defaulting to <code>"all"</code></dt>
              <dd>
                <p>Indicates which candidates the <a>ICE agent</a> is allowed
                to use.</p>
              </dd>
              <dt><dfn><code>bundlePolicy</code></dfn> of type <span class=
              "idlMemberType"><a>RTCBundlePolicy</a></span>, defaulting to
              <code>"balanced"</code></dt>
              <dd>
                <p>Indicates which <a>media-bundling policy</a> to use when
                gathering ICE candidates.</p>
              </dd>
              <dt><dfn><code>rtcpMuxPolicy</code></dfn> of type <span class=
              "idlMemberType"><a>RTCRtcpMuxPolicy</a></span>, defaulting to
              <code>"require"</code></dt>
              <dd>
                <p>Indicates which <a>rtcp-mux policy</a> to use when gathering
                ICE candidates.</p>
              </dd>
              <dt><dfn><code>peerIdentity</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>
                <p>Sets the <a>target peer identity</a> for the
                <a>RTCPeerConnection</a>. The <a>RTCPeerConnection</a> will not
                establish a connection to a remote peer unless it can be
                successfully authenticated with the provided name.</p>
              </dd>
              <dt><dfn><code>certificates</code></dfn> of type <span class=
              "idlMemberType">sequence&lt;<a>RTCCertificate</a>&gt;</span></dt>
              <dd>
                <p>A set of certificates that the
                <a><code>RTCPeerConnection</code></a> uses to authenticate.</p>
                <p>Valid values for this parameter are created through calls to
                the <a data-for=
                "RTCPeerConnection"><code>generateCertificate</code></a>
                function.</p>
                <p>Although any given DTLS connection will use only one
                certificate, this attribute allows the caller to provide
                multiple certificates that support different algorithms. The
                final certificate will be selected based on the DTLS handshake,
                which establishes which certificates are allowed. The
                <code>RTCPeerConnection</code> implementation selects which of
                the certificates is used for a given connection; how
                certificates are selected is outside the scope of this
                specification.</p>
                <p>If this value is absent, then a set of certificates are
                generated for each <a><code>RTCPeerConnection</code></a>
                instance.</p>
                <p>This option allows applications to establish key continuity.
                An <code>RTCCertificate</code> can be persisted in
                [[INDEXEDDB]] and reused. Persistence and reuse also avoids the
                cost of key generation.</p>
                <p>The value for this configuration option cannot change after
                its value is initially selected.</p>
              </dd>
              <dt><dfn><code>iceCandidatePoolSize</code></dfn> of type
              <span class="idlMemberType"><a>unsigned short</a></span>,
              defaulting to <code>0</code></dt>
              <dd>
                <p>Size of the prefetched ICE pool as defined in
                <span data-jsep=
                "ice-candidate-pool constructor">[[!JSEP]]</span></p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
      <section>
        <h4>RTCIceCredentialType Enum</h4>
        <div>
          <pre class="idl">enum RTCIceCredentialType {
    "password",
    "token"
};</pre>
          <table data-link-for="RTCIceCredentialType" data-dfn-for=
          "RTCIceCredentialType" class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code>password</code></dfn></td>
                <td>The credential is a long-term authentication password, as
                described in [[!RFC5389]], Section 10.2.</td>
              </tr>
              <tr>
                <td><dfn><code>token</code></dfn></td>
                <td>The credential is an access token, as described in
                [[!TRAM-TURN-THIRD-PARTY-AUTHZ]], Section 6.2.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section>
        <h4>RTCIceServer Dictionary</h4>
        <p>The <code>RTCIceServer</code> dictionary is used to describe the
        STUN and TURN servers that can be used by the <a>ICE agent</a> to
        establish a connection with a peer.</p>
        <div>
          <pre class="idl">dictionary RTCIceServer {
    required (DOMString or sequence&lt;DOMString&gt;) urls;
             DOMString                          username;
             DOMString                          credential;
             RTCIceCredentialType               credentialType = "password";
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCIceServer</a> Members</h2>
            <dl data-link-for="RTCIceServer" data-dfn-for="RTCIceServer" class=
            "dictionary-members">
              <dt><dfn><code>urls</code></dfn> of type <span class=
              "idlMemberType"><a>(DOMString or
              sequence&lt;DOMString&gt;)</a></span>, required</dt>
              <dd>
                <p>STUN or TURN URI(s) as defined in [[!RFC7064]] and
                [[!RFC7065]] or other URI types.</p>
              </dd>
              <dt><dfn><code>username</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>
                <p>If this <code><a>RTCIceServer</a></code> object represents a
                TURN server, then this attribute specifies the username to use
                with that TURN server.</p>
              </dd>
              <dt><dfn><code>credential</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>
                <p>If this <code><a>RTCIceServer</a></code> object represents a
                TURN server, then this attribute specifies the credential to
                use with that TURN server.</p>
              </dd>
              <dt><dfn><code>credentialType</code></dfn> of type <span class=
              "idlMemberType"><a>RTCIceCredentialType</a></span>, defaulting to
              <code>"password"</code></dt>
              <dd>
                <p>If this <code><a>RTCIceServer</a></code> object represents a
                TURN server, then this attribute specifies how
                <var>credential</var> should be used when that TURN server
                requests authorization.</p>
              </dd>
            </dl>
          </section>
        </div>
        <p>An example array of RTCIceServer objects is:</p>
        <pre class="example highlight"><code>[
     { "urls": "stun:stun1.example.net" },
     { "urls": ["turns:turn.example.org", "turn:turn.example.net"],
       "username": "user",
       "credential": "myPassword",
       "credentialType": "password" }
]</code></pre>
      </section>
      <section>
        <h4>RTCIceTransportPolicy Enum</h4>
        <p>As noted in <span data-jsep="constructor">[[!JSEP]]</span>, if
        the <a data-link-for='RTCConfiguration'>iceTransportPolicy</a> member
        of the <code>RTCConfiguration</code> is specified, it defines the <span
        data-jsep="ice-candidate-policy">ICE candidate policy [[!JSEP]]</span>
        the browser uses to
        surface the permitted candidates to the application; only these
        candidates will be used for connectivity checks.</p>
        <div>
          <pre class="idl">enum RTCIceTransportPolicy {
    "relay",
    "all"
};</pre>
          <table data-link-for="RTCIceTransportPolicy" data-dfn-for=
          "RTCIceTransportPolicy" class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code>relay</code></dfn></td>
                <td>
                  The <a>ICE agent</a> MUST only use media relay candidates
                  such as candidates passing through a TURN server. This can be
                  used to reduce leakage of IP addresses in certain use cases.
                </td>
              </tr>
              <tr>
                <td><dfn><code>all</code></dfn></td>
                <td>
                  The <a>ICE agent</a> may use any type of candidates when this
                  value is specified. This will not include addresses that have
                  been filtered by the browser.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section>
        <h4>RTCBundlePolicy Enum</h4>
        <p>As described in <span data-jsep="constructor">[[!JSEP]]</span>,
        BUNDLE policy affects which media tracks are negotiated if the remote
        endpoint is not BUNDLE-aware, and what ICE candidates are gathered. If
        the remote endpoint is BUNDLE-aware, all media tracks and data channels
        are BUNDLEd onto the same transport.</p>
        <div>
          <pre id="target-bundle-policy" class="idl">enum RTCBundlePolicy {
    "balanced",
    "max-compat",
    "max-bundle"
};</pre>
          <table data-link-for="RTCBundlePolicy" data-dfn-for="RTCBundlePolicy"
          class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code>balanced</code></dfn></td>
                <td>Gather ICE candidates for each media type in use (audio,
                video, and data). If the remote endpoint is not BUNDLE-aware,
                negotiate only one audio and video track on separate
                transports.</td>
              </tr>
              <tr>
                <td><dfn><code>max-compat</code></dfn></td>
                <td>Gather ICE candidates for each track. If the remote
                endpoint is not BUNDLE-aware, negotiate all media tracks on
                separate transports.</td>
              </tr>
              <tr>
                <td><dfn><code>max-bundle</code></dfn></td>
                <td>Gather ICE candidates for only one track. If the remote
                endpoint is not BUNDLE-aware, negotiate only one media
                track.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section>
        <h4>RTCRtcpMuxPolicy Enum</h4>
        <p>Defined in <span data-jsep="constructor">[[!JSEP]]</span>. The
        following is a non-normative summary for convenience.</p>
        <p>The RtcpMuxPolicy affects what ICE candidates are gathered to
        support non-multiplexed RTCP.</p>
        <div>
          <pre id="target-rtcp-mux-policy" class="idl">enum RTCRtcpMuxPolicy {
    "negotiate",
    "require"
};</pre>
          <table data-link-for="RTCRtcpMuxPolicy" data-dfn-for=
          "RTCRtcpMuxPolicy" class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code>negotiate</code></dfn></td>
                <td>Gather ICE candidates for both RTP and RTCP candidates. If
                the remote-endpoint is capable of multiplexing RTCP, multiplex
                RTCP on the RTP candidates. If it is not, use both the RTP and
                RTCP candidates separately.</td>
              </tr>
              <tr>
                <td><dfn><code>require</code></dfn></td>
                <td>Gather ICE candidates only for RTP and multiplex RTCP on
                the RTP candidates. If the remote endpoint is not capable of
                rtcp-mux, session negotiation will fail.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section>
        <h4>Offer/Answer Options</h4>
        <p>These dictionaries describe the options that can be used to control
        the offer/answer creation process.</p>
        <div>
          <pre class="idl">dictionary RTCOfferAnswerOptions {
             boolean voiceActivityDetection = true;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCOfferAnswerOptions</a>
            Members</h2>
            <dl data-link-for="RTCOfferAnswerOptions" data-dfn-for=
            "RTCOfferAnswerOptions" class="dictionary-members">
              <dt><dfn><code>voiceActivityDetection</code></dfn> of type
              <span class="idlMemberType"><a>boolean</a></span>, defaulting to
              <code>true</code></dt>
              <dd>
                <p>Many codecs and systems are capable of detecting "silence"
                and changing their behavior in this case by doing things such
                as not transmitting any media. In many cases, such as when
                dealing with emergency calling or sounds other than spoken
                voice, it is desirable to be able to turn off this behavior.
                This option allows the application to provide information about
                whether it wishes this type of processing enabled or
                disabled.</p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">dictionary RTCOfferOptions : RTCOfferAnswerOptions {
             boolean iceRestart = false;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCOfferOptions</a> Members</h2>
            <dl data-link-for="RTCOfferOptions" data-dfn-for="RTCOfferOptions"
            class="dictionary-members">
              <dt><dfn><code>iceRestart</code></dfn> of type <span class=
              "idlMemberType"><a>boolean</a></span>, defaulting to
              <code>false</code></dt>
              <dd>
                <p>When the value of this dictionary member is true, the
                generated description will have ICE credentials that are
                different from the current credentials (as visible in the
                <code><a data-link-for=
                "RTCPeerConnection">localDescription</a></code> attribute's
                SDP). Applying the generated description will restart ICE.</p>
                <p>When the value of this dictionary member is false, and the
                <code><a data-link-for=
                "RTCPeerConnection">localDescription</a></code> attribute has
                valid ICE credentials, the generated description will have the
                same ICE credentials as the current value from the
                <code><a data-link-for=
                "RTCPeerConnection">localDescription</a></code> attribute.</p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">
          dictionary RTCAnswerOptions : RTCOfferAnswerOptions {
};</pre>
        </div>
      </section>
    </section>
    <section>
      <h3>RTCPeerConnection Interface</h3>
      <p>The [[!JSEP]] specification, as a whole, describes the
      details of how the <code><a>RTCPeerConnection</a></code>
      operates.  References to specific subsections of [[!JSEP]] are
      provided as appropriate.</p>
      <section>
        <h4>Operation</h4>
        <p>Calling <code>new <a>RTCPeerConnection</a>(<var>configuration</var>
        )</code> creates an <code><a>RTCPeerConnection</a></code> object.</p>
        <p>The <var>configuration</var> has the information to find and access
        the servers used by ICE. There may be multiple servers of each type and
        any TURN server also acts as a STUN server.</p>
        <p>An <code><a>RTCPeerConnection</a></code> object has a <dfn>signaling
        state</dfn>, an <dfn>ICE gathering state</dfn>, and an <dfn>ICE
        connection state</dfn>. These are initialized when the object is
        created.</p>
        <p>The ICE protocol implementation of an
        <code><a>RTCPeerConnection</a></code> is represented by an <dfn>ICE
        agent</dfn> [[!ICE]]. The User Agent MUST respond to the following
        events triggered by the <a>ICE Agent</a>:</p>
        <ul>
          <li>
            <p>When the <a>ICE Agent</a>'s <a>ICE candidate pool size</a> is
            set to a nonzero value and the <code>RTCPeerConnection</code>'s
            <a>ICE gathering state</a> is <code>new</code>, the User Agent MUST
            start gathering ICE addresses and <a>update the ICE gathering
            state</a> to <code>gathering</code>.</p>
          </li>
          <li>
            <p>If the <a>ICE Agent</a> has found one or more candidate pairs
            for each <code><a>MediaStreamTrack</a></code> that forms a valid
            connection, <a>update the ICE connection state</a> to
            <code>connected</code>.</p>
          </li>
          <li>
            <p>When the <a>ICE Agent</a> finishes checking all candidate pairs,
            if at least one connection has been found for each <a>media
            description</a>, <a>update the ICE connection state</a> to
            <code>completed</code>, otherwise to <code>failed</code>.</p>
          </li>
        </ul>
        <p>When the <dfn id=
        "dom-peerconnection"><code>RTCPeerConnection()</code></dfn> constructor
        is invoked, the user agent MUST run the following steps:</p>
        <ol>
          <li>
            <p>Let <var>connection</var> be a newly created
            <code><a>RTCPeerConnection</a></code> object.</p>
          </li>
          <li>
            <p>Initialize <var>connection</var>'s <a>ICE Agent</a>.</p>
          </li>
          <li>
            <p><a>Set the configuration</a> specified by the constructor's
            first argument.</p>
          </li>
          <li>
            <p>Let <var>connection</var> have an [[<dfn>isClosed</dfn>]]
            internal slot, initialized to <code>false</code>.</p>
          </li>
          <li>
            <p>Let <var>connection</var> have an [[<dfn>operations</dfn>]]
            internal slot, representing an <a>operations queue</a>, initialized
            to an empty list.</p>
          </li>
          <li>
            <p>Set <var>connection</var>'s <a>signaling state</a> to
            <code>stable</code>.</p>
          </li>
          <li>
            <p>Set <var>connection</var>'s <a>ICE connection state</a> to
            <code>new</code>.</p>
          </li>
          <li>
            <p>Set <var>connection</var>'s <a>ICE gathering state</a> to
            <code>new</code>.</p>
          </li>
          <li>
            <p>Set <var>connection</var>'s <code><a data-for=
            "RTCPeerConnection">pendingLocalDescription</a></code>,
            <code><a data-for=
            "RTCPeerConnection">currentLocalDescription</a></code>,
            <code><a data-for=
            "RTCPeerConnection">pendingRemoteDescription</a></code> and
            <code><a data-for=
            "RTCPeerConnection">currentRemoteDescription</a></code> to
            null.</p>
          </li>
          <li>
            <p>If the <code>certificates</code> value in the
            <code>RTCConfiguration</code> structure is non-empty, check that
            the <code>expires</code> on each value is in the future. If a
            certificate has expired, throw an <code>InvalidAccessError</code>
            exception and abort these steps; otherwise, store the certificates.
            If no <code>certificates</code> value was specified, one or more
            new <code>RTCCertificate</code> instances are generated for use
            with this <code>RTCPeerConnection</code> instance.</p>
          </li>
          <li>
            <p>Return <var>connection</var>.</p>
          </li>
        </ol>
        <p>An <code><a>RTCPeerConnection</a></code> object has an
        <dfn>operations queue</dfn>, [[<a>operations</a>]], which ensures that
        only one asynchronous operation in the queue is executed concurrently. If
        subsequent calls are made while the returned promise of a previous call
        is still not settled, they are added to the queue and executed when all
        the previous calls have finished executing and their promises have
        settled.</p>
        <p>To <dfn id="enqueue-an-operation">enqueue an operation</dfn>, run the
        following steps:</p>
        <ol>
          <li>
            <p>Let <var>connection</var> be the current <code>
            <a>RTCPeerConnection</a></code> object.</p>
          </li>
          <li>
            <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
            <code>true</code>, return a promise rejected with an
            <code>InvalidStateError</code>.</p>
          </li>
          <li>
            <p>Let <var>operation</var> be the operation to be enqueued.</p>
          </li>
          <li>
            <p>Let <var>p</var> be a new promise.</p>
          </li>
          <li>
            <p>Append <var>operation</var> to [[<a>operations</a>]].</p>
          </li>
          <li>
            <p>If the length of [[<a>operations</a>]] is exactly 1,
            execute <var>operation</var>.</p>
          </li>
          <li>
            <p>Upon fulfillment or rejection of the promise returned by the
            <var>operation</var>, run the following steps:</p>
            <ol>
              <li>
                <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
                <code>true</code>, abort these steps.</p>
              </li>
              <li>
                <p>If the promise returned by <var>operation</var> was fulfilled
                with a value, fulfill <var>p</var> with that value.</p>
              </li>
              <li>
                <p>If the promise returned by <var>operation</var> was rejected
                with a value, reject <var>p</var> with that value.</p>
              </li>
              <li>
                <p>Upon fulfillment or rejection of <var>p</var>, execute the
                following steps:</p>
                <ol>
                  <li>
                    <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
                    <code>true</code>, abort these steps.</p>
                  </li>
                  <li>
                    <p>Remove the first element of [[<a>operations</a>]].</p>
                  </li>
                  <li>
                    <p>If [[<a>operations</a>]] is non-empty, execute the
                    operation represented by the first element of
                    [[<a>operations</a>]].</p>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
            <p>Return <var>p</var>.</p>
          </li>
        </ol>
        <p>When a new ICE candidate is available or when the ICE gathering
        process is done , the user agent MUST queue a task to run the following
        steps:</p>
        <ol>
          <li>
            <p>Let <var>connection</var> be the
            <code><a>RTCPeerConnection</a></code> object associated with this
            <a>ICE Agent</a>.</p>
          </li>
          <li>
            <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
            <code>true</code>, abort these steps.</p>
          </li>
          <li>
            <p>If the intent of the <a>ICE Agent</a> is to notify the script
            that:</p>
            <ul>
              <li>
                <p>A new candidate is available.</p>
                <p>Add the candidate to <var>connection</var>'s
                <code><a data-link-for=
                "RTCPeerConnection">localDescription</a></code> and create a
                <code><a>RTCIceCandidate</a></code> instance to represent the
                candidate. Let <var>newCandidate</var> be that object.</p>
              </li>
              <li>
                <p>The gathering process is done.</p>
                <p><a data-lt="update the ICE gathering state">Update
                <var>connection</var>'s ICE gathering state</a> to
                <code>completed</code> and let <var>newCandidate</var> be
                null.</p>
              </li>
            </ul>
          </li>
          <li>
            <p>Fire an event named <code><a>icecandidate</a></code> with
            <var>newCandidate</var> at <var>connection</var>.</p>
          </li>
        </ol>
        <p>To <dfn id="update-ice-gathering-state">update the <a>ICE gathering
        state</a></dfn> of an <code><a>RTCPeerConnection</a></code> instance
        <var>connection</var> to <var>newState</var>, the User Agent MUST queue
        a task that runs the following steps:</p>
        <ol>
          <li>
            <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
            <code>true</code> or <var>connection</var>'s <a>ice gathering
            state</a> has the same value as <var>newState</var>, abort these
            steps.</p>
          </li>
          <li>
            <p>Set <var>connection's</var> <a>ice gathering state</a> to
            <var>newState</var>.</p>
          </li>
          <li>
            <p>Fire a simple event named
            <code><a>icegatheringstatechange</a></code> at
            <var>connection</var>.</p>
          </li>
        </ol>
        <p>To <dfn id="update-ice-connection-state">update the <a>ICE
        connection state</a></dfn> of an <code><a>RTCPeerConnection</a></code>
        instance <var>connection</var> to <var>newState</var>, the User Agent
        MUST queue a task that runs the following steps:</p>
        <ol>
          <li>
            <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
            <code>true</code> or <var>connection</var>'s <a>ice connection
            state</a> has the same value as <var>newState</var>, abort these
            steps.</p>
          </li>
          <li>
            <p>Set <var>connection's</var> <a>ice connection state</a> to
            <var>newState</var>.</p>
          </li>
          <li>
            <p>Fire a simple event named
            <code><a>iceconnectionstatechange</a></code> at
            <var>connection</var>.</p>
          </li>
        </ol>
        <p>To <dfn id="set-description" data-lt="set the RTCSessionDescription">set an RTCSessionDescription</dfn>
        <var>description</var> on an <code><a>RTCPeerConnection</a></code>
        object <var>connection</var>, <a href=
        "#enqueue-an-operation">enqueue</a> the following steps:</p>
        <ol>
          <li>
            <p>Let <var>p</var> be a new promise.</p>
          </li>
          <li>
            <p>In parallel, start the process to apply <var>description</var>
            as described in <span data-jsep=
            "processing-a-local-desc processing-a-remote-desc">[[!JSEP]]</span>.</p>
            <ol>
              <li>
                <p>If the process to apply <var>description</var> fails for any
                reason, then user agent MUST queue a task runs the following
                steps:</p>
                <ol>
                  <li>
                    <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
                    <code>true</code>, then abort these steps.</p>
                  </li>
                  <li>
                    <p>If elements of the SDP were modified in an invalid way
                    as specified in <span data-jsep=
                    "configurable-sdp-paramete">[[!JSEP]]</span>, then reject
                    <var>p</var> with an <code>InvalidModificationError</code>
                    and abort these steps.</p>
                  </li>
                  <li>
                    <p>If the <var>description</var>'s <code><a data-for=
                    "RTCSessionDescription">type</a></code> is wrong for the
                    current <a>signaling state</a> of <var>connection</var>,
                    then reject <var>p</var> with a
                    <code>InvalidStateError</code> and abort these steps.</p>
                  </li>
                  <li>
                    <p>If the content of <var>description</var> is invalid,
                    then reject <var>p</var> with an
                    <code>InvalidAccessError</code> and abort these steps.</p>
                  </li>
                  <li>
                    <p>For all other errors, for example if
                    <var>description</var> cannot be applied at the media
                    layer, reject <var>p</var> with
                    <code>OperationError</code>.</p>
                  </li>
                </ol>
              </li>
              <li>
                <p>If <var>description</var> is applied successfully, the user
                agent MUST queue a task that runs the following steps:</p>
                <ol>
                  <li>
                    <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
                    <code>true</code>, then abort these steps.</p>
                  </li>
                  <li>
                    <p>If <var>description</var> is set as a local description,
                    and its content matches the state of all tracks and data
                    channels, as defined below, <a>clear the negotiation-needed
                    flag</a>.</p>
                    <p class="issue">NOTE: The principles of pending and
                    current SDP were agreed by the WG but the details in the
                    next steps have not yet been fully reviewed. TODO - review
                    this.</p>
                  </li>
                  <li>
                    <p>If <var>description</var> is set as a local description,
                    then run one of the following steps:</p>
                    <ul>
                      <!-- A) transition stable to haveLocalOffer -->
                      <li>
                        <p>If <var>description</var> is of type "offer", set
                        <code><var>connection</var>.<a data-for=
                        "RTCPeerConnection">pendingLocalDescription</a></code>
                        to <var>description</var> and <a>signaling state</a> to
                        <code>have-local-offer</code>.</p>
                      </li>
                      <!-- C) transition haveRemoteOffer or haveLocalProvAnswer to
                      stable -->
                      <li>
                        <p>If <var>description</var> is of type "answer", then
                        this completes an offer answer negotiation. Set
                        <var>connection</var>'s <code><a data-for=
                        "RTCPeerConnection">currentLocalDescription</a></code>
                        to <var>description</var> and <code><a data-for=
                        "RTCPeerConnection">currentRemoteDescription</a></code>
                        to the value of <code><a data-for=
                        "RTCPeerConnection">pendingRemoteDescription</a></code>.
                        Set both <code><a data-for=
                        "RTCPeerConnection">pendingRemoteDescription</a></code>
                        and <code><a data-for=
                        "RTCPeerConnection">pendingLocalDescription</a></code>
                        to null. Finally set <var>connection</var>'s
                        <a>signaling state</a> to <code>stable</code></p>
                      </li>
                      <!-- B) transition rollback to haveLocalOffer to stable -->
                      <li>
                        <p>If <var>description</var> is of type "rollback",
                        then this is a rollback. Set
                        <code><var>connection</var>.<a data-for=
                        "RTCPeerConnection">pendingLocalDescription</a></code>
                        to null and <a>signaling state</a> to
                        <code>stable</code>.</p>
                      </li>
                      <!-- G) transition haveRemoteOffer to haveLocalProvAnswer -->
                      <li>
                        <p>If <var>description</var> is of type "pranswer",
                        then set <code><var>connection</var>. <a data-for=
                        "RTCPeerConnection">pendingLocalDescription</a></code>
                        to <var>description</var> and <a>signaling state</a> to
                        <code>have-local-pranswer</code>.</p>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <p>Otherwise, if <var>description</var> is set as a remote
                    description, then run one of the following steps:</p>
                    <ul>
                      <!-- D) transition stable to haveRemoteOffer -->
                      <li>
                        <p>If <var>description</var> is of type "offer", set
                        <code><var>connection</var>.<a data-for=
                        "RTCPeerConnection">pendingRemoteDescription</a></code>
                        attribute to <var>description</var> and <a>signaling
                        state</a> to <code>have-remote-offer</code>.</p>
                      </li>
                      <!-- F) transition haveRemoteOffer or haveLocalProvAnswer to
                      stable -->
                      <li>
                        <p>If <var>description</var> is of type "answer", then
                        this completes an offer answer negotiation. Set
                        <var>connection</var>'s <code><a data-for=
                        "RTCPeerConnection">currentRemoteDescription</a></code>
                        to <var>description</var> and <code><a data-for=
                        "RTCPeerConnection">currentLocalDescription</a></code>
                        to the value of <code><a data-for=
                        "RTCPeerConnection">pendingLocalDescription</a></code>.
                        Set both <code><a data-for=
                        "RTCPeerConnection">pendingRemoteDescription</a></code>
                        and <code><a data-for=
                        "RTCPeerConnection">pendingLocalDescription</a></code>
                        to null. Finally set <var>connection</var>'s
                        <a>signaling state</a> to <code>stable</code></p>
                      </li>
                      <!-- E) transition rollback to haveRemoteOffer to stable -->
                      <li>
                        <p>If <var>description</var> is of type "rollback",
                        then this is a rollback. Set
                        <code><var>connection</var>.<a data-for=
                        "RTCPeerConnection">pendingRemoteDescription</a></code>
                        to null and <a>signaling state</a> to
                        <code>stable</code>.</p>
                      </li>
                      <!-- H) transition haveRemoteOffer to haveLocalProvAnswer -->
                      <li>
                        <p>If <var>description</var> is of type "pranswer",
                        then set <code><var>connection</var>.<a data-for=
                        "RTCPeerConnection">pendingRemoteDescription</a></code>
                        to <var>description</var> and <a>signaling state</a> to
                        <code>have-remote-pranswer</code>.</p>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <p>If <var>connection</var>'s <a>signaling state</a>
                    changed above, fire a simple event named
                    <code><a>signalingstatechange</a></code> at
                    <var>connection</var>.</p>
                  </li>
                  <li>
                    <p>If <var>description</var> is set as a local description,
                    <var>connection</var>'s <a>ICE gathering state</a> is
                    <code>new</code>, and <var>description</var> contains
                    media, then <a data-lt=
                    "update the ICE gathering state">update
                    <var>connection</var>'s ICE gathering state</a> to
                    <code>gathering</code>.</p>
                  </li>
                  <li>
                    <p>If the process to apply <var>description</var> resulted
                    in an ICE restart <span data-jsep=
                    "applying-a-local-desc applying-a-remote-desc">[[!JSEP]]</span>,
                    then run the following steps:</p>
                    <ol>
                      <li>
                        <p>If <var>connection</var> is not already gathering,
                        <a data-lt="update the ICE gathering state">update
                        <var>connection</var>'s ICE gathering state</a> to
                        <code>gathering</code>.</p>
                      </li>
                      <li>
                        <p>If <var>connection</var>'s <a>ICE connection
                        state</a> is <code>completed</code>, <a data-lt=
                        "update the ICE connection state">update
                        <var>connection</var>'s ICE connection state</a> to
                        <code>connected</code>.</p>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <p>If <var>description</var> is set as a remote description
                    with new media descriptions <span data-jsep=
                    "media-level-parse">[[!JSEP]]</span>, the User Agent MUST
                    <a>dispatch a receiver</a> for all new media
                    descriptions.</p>
                  </li>
                  <li>
                    <p>If <var>connection</var>'s <a>signaling state</a> is now
                    <code>stable</code>, and the negotiation-needed flag is
                    set, the User Agent MUST queue a task to fire a simple
                    event named <code><a>negotiationneeded</a></code> at
                    <var>connection</var> and clear the negotiation-needed
                    flag.</p>
                  </li>
                  <li>
                    <p>Resolve <var>p</var> with <var>undefined</var>.</p>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
            <p>Return <var>p</var>.</p>
          </li>
        </ol>
        <p>The task source for the tasks listed in this section is the
        <a>networking task source</a>.</p>
      </section>
      <section>
        <h3>Interface Definition</h3>
        <p>The <code><a>RTCPeerConnection</a></code> interface presented in
        this section is extended by several partial interfaces throughout this
        specification. Notably, the <a>RTP Media API</a> section, that adds the
        APIs to send and receive <code><a>MediaStreamTrack</a></code>
        objects.</p>
        <div>
          <pre class="idl">
          [ Constructor (optional RTCConfiguration configuration)]
interface RTCPeerConnection : EventTarget  {
    Promise&lt;RTCSessionDescriptionInit&gt; createOffer (optional RTCOfferOptions options);
    Promise&lt;RTCSessionDescriptionInit&gt; createAnswer (optional RTCAnswerOptions options);
    Promise&lt;void&gt;                      setLocalDescription (RTCSessionDescriptionInit description);
    readonly        attribute RTCSessionDescription?    localDescription;
    readonly        attribute RTCSessionDescription?    currentLocalDescription;
    readonly        attribute RTCSessionDescription?    pendingLocalDescription;
    Promise&lt;void&gt;                      setRemoteDescription (RTCSessionDescriptionInit description);
    readonly        attribute RTCSessionDescription?    remoteDescription;
    readonly        attribute RTCSessionDescription?    currentRemoteDescription;
    readonly        attribute RTCSessionDescription?    pendingRemoteDescription;
    Promise&lt;void&gt;                      addIceCandidate ((RTCIceCandidateInit or RTCIceCandidate)? candidate);
    readonly        attribute RTCSignalingState         signalingState;
    readonly        attribute RTCIceGatheringState      iceGatheringState;
    readonly        attribute RTCIceConnectionState     iceConnectionState;
    readonly        attribute RTCPeerConnectionState    connectionState;
    readonly        attribute boolean?                  canTrickleIceCandidates;
    static readonly attribute FrozenArray&lt;RTCIceServer&gt; defaultIceServers;
    RTCConfiguration                   getConfiguration ();
    void                               setConfiguration (RTCConfiguration configuration);
    void                               close ();
                    attribute EventHandler              onnegotiationneeded;
                    attribute EventHandler              onicecandidate;
                    attribute EventHandler              onicecandidateerror;
                    attribute EventHandler              onsignalingstatechange;
                    attribute EventHandler              oniceconnectionstatechange;
                    attribute EventHandler              onicegatheringstatechange;
                    attribute EventHandler              onconnectionstatechange;
};</pre>
          <section>
            <h2>Constructors</h2>
            <dl data-link-for="RTCPeerConnection" data-dfn-for=
            "RTCPeerConnection" class="constructors">
              <dt><dfn><code>RTCPeerConnection</code></dfn></dt>
              <dd>
                See the <a data-lt="RTCPeerConnection()">RTCPeerConnection constructor algorithm</a>.
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">configuration</td>
                      <td class="prmType"><code>RTCConfiguration</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptTrue"><span role="img" aria-label=
                      "True">&#10004;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
              </dd>
            </dl>
          </section>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="RTCPeerConnection" data-dfn-for=
            "RTCPeerConnection" class="attributes">
              <dt><code>localDescription</code> of type <span class=
              "idlAttrType"><a>RTCSessionDescription</a></span>, readonly ,
              nullable</dt>
              <dd>
                <p>The <dfn id=
                "dom-peerconnection-localdescription"><code>localDescription</code></dfn>
                attribute MUST return <code><a data-for=
                "RTCPeerConnection">pendingLocalDescription</a></code> if it is
                not null and otherwise it MUST return <code><a data-for=
                "RTCPeerConnection">currentLocalDescription</a></code>.</p>
              </dd>
              <dt><code>currentLocalDescription</code> of type <span class=
              "idlAttrType"><a>RTCSessionDescription</a></span>, readonly ,
              nullable</dt>
              <dd>
                <p>The <code><a data-for=
                "RTCPeerConnection">currentLocalDescription</a></code>
                attribute represents the local
                <code><a>RTCSessionDescription</a></code> that was successfully
                negotiated the last time the <code>RTCPeerConnection</code>
                transitioned into the stable state plus any local candidates
                that have been generated by the ICE Agent since the offer or
                answer was created.</p>
                <p>The <dfn id=
                "dom-peerconnection-currentlocaldesc"><code>currentLocalDescription</code></dfn>
                attribute MUST return the last value that algorithms in this
                specification set it to, completed with any local candidates
                that have been generated by the <a>ICE Agent</a> since the
                offer or answer was created. Prior to being set, it returns
                null.</p>
              </dd>
              <dt><code>pendingLocalDescription</code> of type <span class=
              "idlAttrType"><a>RTCSessionDescription</a></span>, readonly ,
              nullable</dt>
              <dd>
                <p>The <code><a data-for=
                "RTCPeerConnection">pendingLocalDescription</a></code>
                attribute represents a local
                <code><a>RTCSessionDescription</a></code> that is in the
                process of being negotiated plus any local candidates that have
                been generated by the <a>ICE Agent</a> since the offer or
                answer was created. If the <code>RTCPeerConnection</code> is in
                the stable state, the value is null. This attribute is updated
                by <code><a data-for=
                "RTCPeerConnection">setLocalDescription</a></code>.</p>
                <p>The <dfn id=
                "dom-peerconnection-pendinglocaldesc"><code>pendingLocalDescription</code></dfn>
                attribute MUST return the last value that algorithms in this
                specification set it to, completed with any local candidates
                that have been generated by the <a>ICE Agent</a> since the
                offer or answer was created. Prior to being set, it returns
                null.</p>
              </dd>
              <dt><code>remoteDescription</code> of type <span class=
              "idlAttrType"><a>RTCSessionDescription</a></span>, readonly ,
              nullable</dt>
              <dd>
                <p>The <dfn id=
                "dom-peerconnection-remotedescription"><code>remoteDescription</code></dfn>
                attribute MUST return <code><a data-for=
                "RTCPeerConnection">pendingRemoteDescription</a></code> if it
                is not null and otherwise it MUST return <code><a data-for=
                "RTCPeerConnection">currentRemoteDescription</a></code>.</p>
              </dd>
              <dt><code>currentRemoteDescription</code> of type <span class=
              "idlAttrType"><a>RTCSessionDescription</a></span>, readonly ,
              nullable</dt>
              <dd>
                <p>The <code><a data-for=
                "RTCPeerConnection">currentRemoteDescription</a></code>
                attribute represents the last remote
                <code><a>RTCSessionDescription</a></code> that was successfully
                negotiated the last time the <code>RTCPeerConnection</code>
                transitioned into the stable state plus any remote candidates
                that have been supplied via <code><a data-for=
                "RTCPeerConnection">addIceCandidate()</a></code> since the
                offer or answer was created.</p>
                <p>The <dfn id=
                "dom-peerconnection-currentremotedesc"><code>currentRemoteDescription</code></dfn>
                attribute MUST return the value that algorithms in this
                specification set it to, completed with any remote candidates
                that have been supplied via <code><a data-for=
                "RTCPeerConnection">addIceCandidate()</a></code> since the
                offer or answer was created. Prior to being set, it returns
                null.</p>
              </dd>
              <dt><code>pendingRemoteDescription</code> of type <span class=
              "idlAttrType"><a>RTCSessionDescription</a></span>, readonly ,
              nullable</dt>
              <dd>
                <p>The <code><a data-for=
                "RTCPeerConnection">pendingRemoteDescription</a></code>
                attribute represents a remote
                <code><a>RTCSessionDescription</a></code> that is in the
                process of being negotiated, completed with any remote
                candidates that have been supplied via <code><a data-for=
                "RTCPeerConnection">addIceCandidate()</a></code> since the
                offer or answer was created. If the
                <code>RTCPeerConnection</code> is in the stable state, the
                value is null. This attribute is updated by <code><a data-for=
                "RTCPeerConnection">setLocalDescription</a></code>.</p>
                <p>The <dfn id=
                "dom-peerconnection-pendingremotedesc"><code>pendingRemoteDescription</code></dfn>
                attribute MUST return the value that algorithms in this
                specification set it to, completed with any remote candidates
                that have been supplied via <code><a data-for=
                "RTCPeerConnection">addIceCandidate()</a></code> since the
                offer or answer was created. Prior to being set, it returns
                null.</p>
              </dd>
              <dt><code>signalingState</code> of type <span class=
              "idlAttrType"><a>RTCSignalingState</a></span>, readonly</dt>
              <dd>
                <p>The <dfn id=
                "dom-peerconnection-signaling-state"><code>signalingState</code></dfn>
                attribute MUST return the <code><a data-for=
                "RTCPeerConnection">RTCPeerConnection</a></code> object's
                <a>signaling state</a>.</p>
              </dd>
              <dt><code>iceGatheringState</code> of type <span class=
              "idlAttrType"><a>RTCIceGatheringState</a></span>, readonly</dt>
              <dd>
                <p>The <dfn id=
                "dom-peerconnection-ice-gathering-state"><code>iceGatheringState</code></dfn>
                attribute MUST return the <a>ICE gathering state</a> of the
                <code>RTCPeerConnection</code> instance.</p>
              </dd>
              <dt><code>iceConnectionState</code> of type <span class=
              "idlAttrType"><a>RTCIceConnectionState</a></span>, readonly</dt>
              <dd>
                <p>The <dfn id=
                "dom-peerconnection-ice-connection-state"><code>iceConnectionState</code></dfn>
                attribute MUST return the <a>ICE connection state</a> of the
                <code>RTCPeerConnection</code> instance.</p>
              </dd>
              <dt><code>connectionState</code> of type <span class=
              "idlAttrType"><a>RTCPeerConnectionState</a></span>, readonly</dt>
              <dd>
                <p>The <dfn id=
                "dom-peerconnection-connection-state"><code>connectionState</code></dfn>
                attribute MUST return the aggregate of the states of the
                <a><code>DtlsTransport</code></a>s and
                <a><code>IceTransport</code></a>s of the
                <a><code>RTCPeerConnection</code></a>, as describe in the
                values of the <a><code>RTCPeerConnectionState</code></a>
                enum.</p>
              </dd>
              <dt><code>canTrickleIceCandidates</code> of type <span class=
              "idlAttrType"><a>boolean</a></span>, readonly , nullable</dt>
              <dd>
                <p>The <dfn><code>canTrickleIceCandidates</code></dfn>
                attribute indicates whether the remote peer is able to accept
                trickled ICE candidates [[TRICKLE-ICE]]. The value is
                determined based on whether a remote description indicates
                support for trickle ICE, as defined in <span data-jsep=
                "cantrickle">[[!JSEP]]</span>. Prior to the completion of
                <a data-for=
                "RTCPeerConnection"><code>setRemoteDescription</code></a>, this
                value is <code>null</code>.</p>
              </dd>
              <dt><dfn><code>defaultIceServers</code></dfn> of type
              <span class="idlAttrType">FrozenArray&lt;<a>RTCIceServer</a>&gt;</span>,
              static readonly</dt>
              <dd>
                <p>The <code>defaultIceServers</code> attribute provides a list
                of ICE servers that are configured into the browser. A browser
                might be configured to use local or private STUN or TURN
                servers. This method allows an application to learn about these
                servers and optionally use them.</p>
                <p class="fingerprint">This list is likely to be persisent and
                is the same across origins. It thus increases the
                fingerprinting surface of the browser. In privacy-sensitive
                contexts, browsers can consider mitigations such as only
                providing this data to "trusted" origins (or not providing it
                at all.)
              </dd>
              <dt><dfn><code>onnegotiationneeded</code></dfn> of type
              <span class="idlAttrType"><a>EventHandler</a></span></dt>
              <dd>The event type of this event handler is
              <code><a>negotiationneeded</a></code>.</dd>
              <dt><dfn><code>onicecandidate</code></dfn> of type <span class=
              "idlAttrType"><a>EventHandler</a></span></dt>
              <dd>The event type of this event handler is
              <code><a>icecandidate</a></code>.</dd>
              <dt><dfn><code>onicecandidateerror</code></dfn> of type
              <span class="idlAttrType"><a>EventHandler</a></span></dt>
              <dd>The event type of this event handler is
              <code><a>icecandidateerror</a></code>.</dd>
              <dt><dfn><code>onsignalingstatechange</code></dfn> of type
              <span class="idlAttrType"><a>EventHandler</a></span></dt>
              <dd>The event type of this event handler is
              <code><a>signalingstatechange</a></code>.</dd>
              <dt><dfn><code>oniceconnectionstatechange</code></dfn> of type
              <span class="idlAttrType"><a>EventHandler</a></span></dt>
              <dd>The event type of this event handler is
              <code><a>iceconnectionstatechange</a></code></dd>
              <dt><dfn><code>onicegatheringstatechange</code></dfn> of type
              <span class="idlAttrType"><a>EventHandler</a></span></dt>
              <dd>The event type of this event handler is
              <code><a>icegatheringstatechange</a></code>.</dd>
              <dt><dfn><code>onconnectionstatechange</code></dfn> of type
              <span class="idlAttrType"><a>EventHandler</a></span></dt>
              <dd>The event type of this event handler is
              <code><a>connectionstatechange</a></code>.</dd>
            </dl>
          </section>
          <section>
            <h2>Methods</h2>
            <dl data-link-for="RTCPeerConnection" data-dfn-for=
            "RTCPeerConnection" class="methods">
              <dt><dfn><code>createOffer</code></dfn></dt>
              <dd>
                <p>The createOffer method generates a blob of SDP that contains
                an RFC 3264 offer with the supported configurations for the
                session, including descriptions of the local
                <code>MediaStreamTrack</code>s attached to this
                <code>RTCPeerConnection</code>, the codec/RTP/RTCP options
                supported by this implementation, and any candidates that have
                been gathered by the <a>ICE Agent</a>. The <code>options</code>
                parameter may be supplied to provide additional control over
                the offer generated.</p>
                <p>As an offer, the generated SDP will contain the full set of
                capabilities supported by the session (as opposed to an answer,
                which will include only a specific negotiated subset to use);
                for each SDP line, the generation of the SDP MUST follow the
                appropriate process for generating an offer. In the event
                <code>createOffer</code> is called after the session is
                established, <code>createOffer</code> will generate an offer
                that is compatible with the current session, incorporating any
                changes that have been made to the session since the last
                complete offer-answer exchange, such as addition or removal of
                tracks. If no changes have been made, the offer will include
                the capabilities of the current local description as well as
                any additional capabilities that could be negotiated in an
                updated offer.</p>
                <p>Session descriptions generated by <code>createOffer</code>
                MUST be immediately usable by <code>setLocalDescription</code>
                without causing an error as long as
                <code>setLocalDescription</code> is called reasonably soon. If
                a system has limited resources (e.g. a finite number of
                decoders), <code>createOffer</code> needs to return an offer
                that reflects the current state of the system, so that
                <code>setLocalDescription</code> will succeed when it attempts
                to acquire those resources. The session descriptions MUST
                remain usable by <code>setLocalDescription</code> without
                causing an error until at least the end of the fulfillment
                callback of the returned promise. Calling this method is needed
                to get the ICE user name fragment and password.</p>
                <p>The value for <code>certificates</code> in the
                <code><a>RTCConfiguration</a></code> for the
                <code>RTCPeerConnection</code> is used to produce a set of
                certificate fingerprints. These certificate fingerprints are
                used in the construction of SDP and as input to requests for
                identity assertions.</p>
                <p>If the <code>RTCPeerConnection</code> is configured to
                generate Identity assertions by calling
                <code>setIdentityProvider</code>, then the session description
                SHALL contain an appropriate assertion.</p>
                <p class="fingerprint">The SDP generation process exposes a
                subset of the media capabilities of the underlying system,
                which provides generally persistent cross-origin information on
                the device. It thus increases the fingerprinting surface of the
                application. In privacy-sensitive contexts, browsers can
                consider mitigations such as generating SDP matching only a
                common subset of the capabilities.</p>
                <p>When the method is called, the User Agent MUST run the
                following steps:</p>
                <ol>
                  <li>
                    <p>Let <var>connection</var> be the
                    <code><a>RTCPeerConnection</a></code> object on which the
                    method was invoked.</p>
                  </li>
                  <li>
                    <p>Return the result of <a href=
                    "#enqueue-an-operation">enqueuing</a> the following
                    steps:</p>
                    <ol>
                      <li>
                        <p>Let <var>p</var> be a new promise.</p>
                      </li>
                      <li>
                        <p>In parallel, start the process to generate an SDP
                        offer, as described in <span data-jsep=
                        "create-offer">[[!JSEP]]</span>.</p>
                        <ol>
                          <li>
                            <p>If the process to generate an SDP offer failed
                            for any reason, or if the identity provider was
                            unable to produce an identity assertion, the User
                            Agent MUST queue a task that runs the following
                            steps:</p>
                            <ol>
                              <li>
                                <p>If <var>connection</var>'s [[<a>isClosed</a>]]
                                slot is <code>true</code>, then abort these
                                steps.</p>
                              </li>
                              <li>
                                <p>If the identity provider was unable to
                                produce an identity assertion, reject
                                <var>p</var> with a <code>DOMException</code>
                                object whose <code>name</code> attribute has
                                the value <code>NotReadableError</code>, and
                                abort these steps.</p>
                              </li>
                              <li>
                                <p>Reject <var>p</var> with a
                                <code>DOMException</code> object whose
                                <code>name</code> attribute has the value
                                <code>OperationError</code>.</p>
                              </li>
                            </ol>
                          </li>
                          <li>
                            <p>If an SDP offer, <var>sdpString</var>, was
                            successfully generated, the User Agent MUST queue a
                            task that runs the following steps:</p>
                            <ol>
                              <li>
                                <p>If <var>connection</var>'s [[<a>isClosed</a>]]
                                slot is <code>true</code>, then abort these
                                steps.</p>
                              </li>
                              <li>
                                <p>Let <var>offer</var> be a newly created
                                <code><a>RTCSessionDescriptionInit</a></code>
                                dictionary with its <code>type</code> member
                                initialized to the string <code>"offer"</code>
                                and its <code>sdp</code> member initialized to
                                <var>sdpString</var>.</p>
                              </li>
                              <li>
                                <p>Resolve <var>p</var> with
                                <var>offer</var>.</p>
                              </li>
                            </ol>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <p>Return <var>p</var>.</p>
                      </li>
                    </ol>
                  </li>
                </ol>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">options</td>
                      <td class="prmType"><code>RTCOfferOptions</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptTrue"><span role="img" aria-label=
                      "True">&#10004;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em>
                  <code>Promise&lt;RTCSessionDescriptionInit&gt;</code>
                </div>
              </dd>
              <dt><dfn><code>createAnswer</code></dfn></dt>
              <dd>
                <p>The <code>createAnswer</code> method generates an [[!SDP]]
                answer with the supported configuration for the session that is
                compatible with the parameters in the remote configuration.
                Like <code>createOffer</code>, the returned blob contains
                descriptions of the local <code>MediaStreamTrack</code>s
                attached to this <code>RTCPeerConnection</code>, the
                codec/RTP/RTCP options negotiated for this session, and any
                candidates that have been gathered by the <a>ICE Agent</a>. The
                <code>options</code> parameter may be supplied to provide
                additional control over the generated answer.</p>
                <p>As an answer, the generated SDP will contain a specific
                configuration that, along with the corresponding offer,
                specifies how the media plane should be established. The
                generation of the SDP MUST follow the appropriate process for
                generating an answer.</p>
                <p>Session descriptions generated by createAnswer MUST be
                immediately usable by <code>setLocalDescription</code> without
                causing an error as long as <code>setLocalDescription</code> is
                called reasonably soon. Like <code>createOffer</code>, the
                returned description SHOULD reflect the current state of the
                system. The session descriptions MUST remain usable by
                <code>setLocalDescription</code> without causing an error until
                at least the end of the fulfillment callback of the returned
                promise. Calling this method is needed to get the ICE user name
                fragment and password.</p>
                <p>An answer can be marked as provisional, as described in
                <span data-jsep="use-of-provisional-answer">[[!JSEP]]</span>,
                by setting the <code><a data-for=
                "RTCSessionDescription">type</a></code> to
                <code>pranswer</code>.</p>
                <p>If the <code>RTCPeerConnection</code> is configured to
                generate Identity assertions by calling
                <a>setIdentityProvider</a>, then the session description SHALL
                contain an appropriate assertion.</p>
                <p>When the method is called, the User Agent MUST run the
                following steps:</p>
                <ol>
                  <li>
                    <p>Let <var>connection</var> be the
                    <code><a>RTCPeerConnection</a></code> object on which the
                    method was invoked.</p>
                  </li>
                  <li>
                    <p>Return the result of <a href=
                    "#enqueue-an-operation">enqueuing</a> the following
                    steps:</p>
                    <ol>
                      <li>
                        <p>If <code><a data-for=
                        "RTCPeerConnection">remoteDescription</a></code> is
                        <code>null</code> return a promise rejected with an
                        <code>InvalidStateError</code>.</p>
                      </li>
                      <li>
                        <p>Let <var>p</var> be a new promise.</p>
                      </li>
                      <li>
                        <p>In parallel, start the process to generate an SDP
                        answer, as described in <span data-jsep=
                        "generating-an-answer">[[!JSEP]]</span>.</p>
                        <ol>
                          <li>
                            <p>If the process to generate an SDP answer failed
                            for any reason, or if the identity provider was
                            unable to produce an identity assertion, the User
                            Agent MUST queue a task that runs the following
                            steps:</p>
                            <ol>
                              <li>
                                <p>If <var>connection</var>'s [[<a>isClosed</a>]]
                                slot is <code>true</code>, then abort these
                                steps.</p>
                              </li>
                              <li>
                                <p>If the identity provider was unable to
                                produce an identity assertion, reject
                                <var>p</var> with a <code>DOMException</code>
                                object whose <code>name</code> attribute has
                                the value <code>NotReadableError</code>, and
                                abort these steps.</p>
                              </li>
                              <li>
                                <p>Reject <var>p</var> with a
                                <code>DOMException</code> object whose
                                <code>name</code> attribute has the value
                                <code>OperationError</code>.</p>
                              </li>
                            </ol>
                          </li>
                          <li>
                            <p>If an SDP answer, <var>sdpString</var>, was
                            successfully generated, the User Agent MUST queue a
                            task that runs the following steps:</p>
                            <ol>
                              <li>
                                <p>If <var>connection</var>'s [[<a>isClosed</a>]]
                                slot is <code>true</code>, then abort these
                                steps.</p>
                              </li>
                              <li>
                                <p>Let <var>answer</var> be a newly created
                                <code><a>RTCSessionDescriptionInit</a></code>
                                dictionary with its <code>type</code> member
                                initialized to the string <code>"answer"</code>
                                and its <code>sdp</code> member initialized to
                                <var>sdpString</var>.</p>
                              </li>
                              <li>
                                <p>Unless all non-stopped <code>
                                <a>RTCRtpTransceiver</a></code>s are
                                represented in <var>answer</var>, mark
                                <var>connection</var> as needing
                                negotiation.</p>
                              </li>
                              <li>
                                <p>Resolve <var>p</var> with
                                <var>answer</var>.</p>
                              </li>
                            </ol>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <p>Return <var>p</var>.</p>
                      </li>
                    </ol>
                  </li>
                </ol>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">options</td>
                      <td class="prmType"><code>RTCAnswerOptions</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptTrue"><span role="img" aria-label=
                      "True">&#10004;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em>
                  <code>Promise&lt;RTCSessionDescriptionInit&gt;</code>
                </div>
              </dd>
              <dt><code>setLocalDescription</code></dt>
              <dd>
                <p>The <dfn id=
                "dom-peerconnection-setlocaldescription"><code>setLocalDescription</code></dfn>
                method instructs the <code><a>RTCPeerConnection</a></code> to
                apply the supplied
                <code><a>RTCSessionDescriptionInit</a></code> as the local
                description.</p>
                <p>This API changes the local media state. In order to
                successfully handle scenarios where the application wants to
                offer to change from one media format to a different,
                incompatible format, the <code><a>RTCPeerConnection</a></code>
                MUST be able to simultaneously support use of both the current
                and pending local descriptions (e.g. support codecs that exist
                in both descriptions) until a final answer is received, at
                which point the <code><a>RTCPeerConnection</a></code> can fully
                adopt the pending local description, or rollback to the current
                description if the remote side rejected the change.</p>
                <p>When the method is invoked, the User Agent MUST return the
                result of <a href="#set-description">setting the
                RTCSessionDescription</a> indicated by the method's first
                argument.</p>
                <p><span data-jsep="configurable-sdp-paramete">[[!JSEP]]</span>
                specifies what elements of the SDP returned by
                <code>createOffer</code> can be changed before passing it to
                <code>setLocalDescription</code>.</p>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">description</td>
                      <td class="prmType">
                      <code>RTCSessionDescriptionInit</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em> <code>Promise&lt;void&gt;</code>
                </div>
              </dd>
              <dt><code>setRemoteDescription</code></dt>
              <dd>
                <p>The <dfn id=
                "dom-peerconnection-setremotedescription"><code>setRemoteDescription</code></dfn>
                method instructs the <code><a>RTCPeerConnection</a></code> to
                apply the supplied
                <code><a>RTCSessionDescriptionInit</a></code> as the remote
                offer or answer. This API changes the local media state.</p>
                <p>When the method is invoked, the User Agent MUST return the
                result of <a href="#set-description">setting the
                RTCSessionDescription</a> indicated by the method's first
                argument.</p>
                <p>In addition, a remote description is processed to
                determine and verify the identity of the peer.</p>
                <p>If an <code>a=identity</code> attribute is present in the
                session description, the browser <a href=
                "#sec.identity-verify-assertion">validates the identity
                assertion.</a>.</p>
                <p>If the "peerIdentity" configuration is applied to the
                <code><a>RTCPeerConnection</a></code>, this establishes a
                <dfn id="target-peer-identity">target peer identity</dfn> of
                the provided value. Alternatively, if the
                <code><a>RTCPeerConnection</a></code> has previously
                authenticated the identity of the peer (that is, there is a
                current value for <code><a data-for=
                "RTCPeerConnection">peerIdentity</a></code> ), then this also
                establishes a <a>target peer identity</a>.</p>
                <p>The <a>target peer identity</a> cannot be changed once set.
                Once set, if a different value is provided, the user agent MUST
                reject the returned promise with
                <code>InvalidModificationError</code> and abort this operation.
                The <code><a>RTCPeerConnection</a></code> MUST be closed if the
                validated peer identity does not match the <a>target peer
                identity</a>.</p>
                <p>If there is no <a>target peer identity</a>, then
                <code>setRemoteDescription</code> does not await the completion
                of identity validation.</p>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">description</td>
                      <td class="prmType">
                      <code>RTCSessionDescriptionInit</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em> <code>Promise&lt;void&gt;</code>
                </div>
              </dd>
              <dt><dfn><code>addIceCandidate</code></dfn></dt>
              <dd>
                <p>The <dfn id=
                "dom-peerconnection-addicecandidate"><code>addIceCandidate()</code></dfn>
                method provides a remote candidate to the <a>ICE Agent</a>.
                This method can also be used to indicate the end of remote
                candidates when called with a <code>null</code> value for
                <code>candidate</code>. The only members of the argument used
                by this method are <code><a data-for=
                "RTCIceCandidate">candidate</a></code>, <code><a data-for=
                "RTCIceCandidate">sdpMid</a></code> and <code><a data-for=
                "RTCIceCandidate">sdpMLineIndex</a></code>; the rest are
                ignored. When the method is invoked, the User Agent MUST run
                the following steps:</p>
                <ol>
                  <li>
                    <p>Let <var>candidate</var> be the methods argument.</p>
                  </li>
                  <li>
                    <p>Let <var>connection</var> be the
                    <code><a>RTCPeerConnection</a></code> object on which the
                    method was invoked.</p>
                  </li>
                  <li>
                    <p>If <var>candidate</var> is not <code>null</code> but is
                    missing values for both <var>sdpMid</var> and
                    <var>sdpMLineIndex</var>, return a promise rejected with a
                    <code>TypeError</code>.</p>
                  </li>
                  <li>
                    <p>Return the result of <a href=
                    "#enqueue-an-operation">enqueuing</a> the following
                    steps:</p>
                    <ol>
                      <li>
                        <p>Let <var>p</var> be a new promise.</p>
                      </li>
                      <li>
                        <p>If <var>candidate</var> is <code>null</code>, the
                        User Agent MUST queue a task that runs the following
                        steps, and abort these steps:</p>
                        <ol>
                          <li>
                            <p>If <var>connection</var>'s [[<a>isClosed</a>]]
                            slot is <code>true</code>, abort these steps.</p>
                          </li>
                          <li>
                            <p>For each <a>media description</a> in the last
                            successfully applied remote description, perform
                            the processing for an end-of-candidates indication
                            for said <a>media description</a> as defined in
                            [[TRICKLE-ICE]].</p>
                          </li>
                          <li>
                            <p>Resolve <var>p</var> with
                            <code>undefined</code>.</p>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <p>In parallel, add the ICE candidate
                        <var>candidate</var> as described in <span data-jsep=
                        "addicecandidate">[[!JSEP]]</span>.
                        <ol>
                          <li>
                            <p>If <var>candidate</var> could not be successfully
                            added the User Agent MUST queue a task that runs
                            the following steps:</p>
                            <ol>
                              <li>
                                <p>If <var>connection</var>'s [[<a>isClosed</a>]]
                                slot is <code>true</code>, then abort these
                                steps.</p>
                              </li>
                              <li>
                                <p>Reject <var>p</var> with a
                                <code>DOMException</code> object whose
                                <code>name</code> attribute has the value
                                <code>OperationError</code> and abort these
                                steps.</p>
                              </li>
                            </ol>
                          </li>
                          <li>
                            <p>If <var>candidate</var> is applied successfully,
                            the User Agent MUST queue a task that runs the
                            following steps:</p>
                            <ol>
                              <li>
                                <p>If <var>connection</var>'s [[<a>isClosed</a>]]
                                slot is <code>true</code>, then abort these
                                steps.</p>
                              </li>
                              <li>
                                <p>Let <var>remoteDescription</var> be
                                <var>connection</var>'s <code><a data-for=
                                "RTCPeerConnection">pendingRemoteDescription</a></code>
                                if not null, otherwise <var>connection</var>'s
                                <code><a data-for=
                                "RTCPeerConnection">currentRemoteDescription</a></code>.</p>
                              </li>
                              <li>
                                <p>Add <var>candidate</var> to
                                <var>remoteDescription</var>.</p>
                              </li>
                              <li>
                                <p>If the <a>ICE Agent</a> is not currently
                                checking candidate pairs, the <a>ICE Agent</a> MUST
                                start checking candidate pairs and <a data-lt=
                                "update the ICE connection state">update
                                <var>connection</var>'s ICE connection state</a>
                                to <code>checking</code>.</p>
                              </li>
                              <li>
                                <p>Resolve <var>p</var> with
                                <code>undefined</code>.</p>
                              </li>
                            </ol>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <p>Return <var>p</var>.</p>
                      </li>
                    </ol>
                  </li>
                </ol>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">candidate</td>
                      <td class="prmType"><code>(RTCIceCandidateInit or
                      RTCIceCandidate)</code></td>
                      <td class="prmNullTrue"><span role="img" aria-label=
                      "True">&#10004;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em> <code>Promise&lt;void&gt;</code>
                </div>
              </dd>
              <dt><dfn><code>getConfiguration</code></dfn></dt>
              <dd>
                <p>Returns a <code><a>RTCConfiguration</a></code> object
                representing the current configuration of this
                <code><a>RTCPeerConnection</a></code> object.</p>
                <p>When this method is call, the user agent MUST a construct
                new <code><a>RTCConfiguration</a></code> object to be returned,
                and initialize it using the <a>ICE Agent</a>'s <a>ICE
                transports setting</a> and <a>ICE servers list</a>.</p>
                <p>The returned configuration MUST include a
                <code>certificates</code> attribute containing the candidate
                set of certificates used for connecting to peers. This
                attribute contains the certificates chosen by the application,
                or the certificates generated by the <a>user agent</a> for use
                with this <code>RTCPeerConnection</code> instance.</p>
                <div>
                  <em>No parameters.</em>
                </div>
                <div>
                  <em>Return type:</em> <code>RTCConfiguration</code>
                </div>
              </dd>
              <dt><code>setConfiguration</code></dt>
              <dd>
                <p>The <code>setConfiguration</code> method updates the <a>ICE
                Agent</a> process of gathering local candidates and pinging
                remote candidates.</p>
                <p>This call may result in a change to the state of the <a>ICE
                Agent</a>, and may result in a change to media state if it
                results in connectivity being established.</p>
                <p>When the <dfn><code>setConfiguration</code></dfn> method is
                invoked, the user agent MUST run the following steps:</p>
                <ol>
                  <li>
                    <p>Let <var>connection</var> be the
                    <code><a>RTCPeerConnection</a></code> on which the method
                    was invoked.</p>
                  </li>
                  <li>
                    <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
                    <code>true</code>, throw an <code>InvalidStateError</code>
                    exception and abort these steps.</p>
                  </li>
                  <li>
                    <p><a>Set the configuration</a> specified by the methods
                    argument on <var>connection</var>.</p>
                  </li>
                </ol>
                <p>To <dfn data-lt="set the configuration" id=
                "set-pc-configuration">set a configuration</dfn>, run the
                following steps:</p>
                <ol>
                  <li>Let <var>configuration</var> be the
                  <code><a>RTCConfiguration</a></code> dictionary to be
                  processed.</li>
                  <li>Let <var>connection</var> be the target
                  <code><a>RTCPeerConnection</a></code> object.</li>
                  <li>If <code><var>configuration</var>.peerIdentity</code> is
                  set and its value differs from the <a>target peer
                  identity</a>, throw an <code>InvalidModificationError</code>.
                  </li>
                  <li>If <code><var>configuration</var>.certificates</code> is
                  set and the set of certificates differs from the ones used
                  when <var>connection</var> was constructed, throw an
                  <code>InvalidModificationError</code>.</li>
                  <li>
                    <p>Let the value of
                    <code><var>configuration</var>.<a data-for=
                    "RTCConfiguration">iceTransportPolicy</a></code> be the
                    <a>ICE Agent</a>'s <dfn id="ice-transports-setting">ICE
                    transports setting</dfn>.</p>
                  </li>
                  <li>
                    <p>Let the value of
                    <code><var>configuration</var>.<a data-for=
                    "RTCConfiguration">bundlePolicy</a></code> be
                    <var>connection</var>'s bundle policy.</p>
                  </li>
                  <li>
                    <p>Let the value of
                    <code><var>configuration</var>.<a data-for=
                    "RTCConfiguration">iceCandidatePoolSize</a></code> be the
                    <a>ICE Agent</a>'s prefetched <dfn>ICE candidate pool
                    size</dfn> as defined in <span data-jsep=
                    "ice-candidate-pool constructor">[[!JSEP]]</span>.</p>
                  </li>
                  <li>
                    <p>Let <var>validatedServers</var> be an empty list.</p>
                  </li>
                  <li>
                    <p>If <code><var>configuration</var>.<a data-for=
                    "RTCConfiguration">iceServers</a></code> is defined, then
                    run the following steps for each element:</p>
                    <ol>
                      <li>
                        <p>Let <var>server</var> be the current list
                        element.</p>
                      </li>
                      <li>
                        <p>If <code><var>server</var>.urls</code> is a string,
                        let <code><var>server</var>.urls</code> be a list
                        consisting of just that string.</p>
                      </li>
                      <li>
                        <p>For each <var>url</var> in
                        <code><var>server</var>.urls</code> parse
                        <var>url</var> and obtain <var>scheme name</var>. If
                        the <var>scheme name</var> is not implemented by the
                        browser, or if parsing based on the syntax defined in
                        [[!RFC7064]] and [[!RFC7065]] fails, throw a
                        <code>SyntaxError</code> and abort these steps.</p>
                      </li>
                      <li>
                        <p>If <var>scheme name</var> is <code>turn</code> or
                        <code>turns</code>, and either of
                        <code><var>server</var>.username</code> or
                        <code><var>server</var>.credential</code> are omitted,
                        then throw an <code>InvalidAccessError</code> and abort
                        these steps.</p>
                      </li>
                      <li>
                        <p>Append<var>server</var> to
                        <var>validatedServers</var>.</p>
                      </li>
                    </ol>
                    <p>Let <var>validatedServers</var> be the <a>ICE
                    Agent</a>'s <dfn id="ice-servers-list">ICE servers
                    list</dfn>.</p>
                    <p>If a new list of servers replaces the <a>ICE Agent</a>'s
                    existing ICE servers list, no action will be taken until
                    the <code><a>RTCPeerConnection</a></code>'s <a>ICE
                    gathering state</a> transitions to <code>gathering</code>.
                    If a script wants this to happen immediately, it should do
                    an ICE restart.</p>
                  </li>
                </ol>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">configuration</td>
                      <td class="prmType"><code>RTCConfiguration</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em> <code>void</code>
                </div>
              </dd>
              <dt><code>close</code></dt>
              <dd>
                <p>When the <dfn><code>close</code></dfn> method is invoked,
                the user agent MUST run the following steps:</p>
                <ol>
                  <li>
                    <p>Let <var>connection</var> be the
                    <code><a>RTCPeerConnection</a></code> object on which the
                    method was invoked.</p>
                  </li>
                  <li>
                    <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
                    <code>true</code>, abort these steps.</p>
                  </li>
                  <li>
                    <p>
                      Destroy <var>connection</var>'s <a>ICE Agent</a>,
                      abruptly ending any active ICE processing and any active
                      streaming, and releasing any relevant resources (e.g. TURN
                      permissions).
                    </p>
                  </li>
                  <li>
                    <p>Let <var>senders</var> be the result of executing the
                     <code><a>CollectSenders</a></code> algorithm.
                      For every <code><a>RTCRtpSender</a></code> <var>sender</var> in
                      <var>senders</var>,
                      set <code><var>sender.transport.state</var></code> and
                      <code><var>sender.transport.transport.state</var></code> to
                      "closed". If <code><var>sender.rtcpTransport</var></code>
                      is set, set <code><var>sender.rtcpTransport.state</var></code>
                      and <code><var>sender.rtcpTransport.transport.state</var></code>
                      to "closed".
                    </p>
                  </li>
                  <li>
                    <p>Let <var>receivers</var> be the result of executing
                      the <code><a>CollectReceivers</a></code> algorithm.
                      For every <code><a>RTCRtpReceiver</a></code> <var>receiver</var> in
                      <var>receivers</var>,
                      set <code><var>receiver.transport.state</var></code> and
                      <code><var>receiver.transport.transport.state</var></code> to
                      "closed". If <code><var>receiver.rtcpTransport</var></code>
                      is set, set <code><var>receiver.rtcpTransport.state</var></code>
                      and <code><var>receiver.rtcpTransport.transport.state</var></code>
                      to "closed".
                    </p>
                  </li>
                  <li>
                    <p>
                      All <code><a>RTCRtpSender</a></code>s in
                      <var>senders</var> are now
                      considered <a>stopped</a>.
                    </p>
                  </li>
                  <li>
                    <p>
                      All <code><a>RTCRtpReceiver</a></code>s in
                      <var>receivers</var> are now
                      considered <a>stopped</a>.
                    </p>
                  </li>
                  <li>
                    <p>Set <var>connection</var>'s [[<a>isClosed</a>]] slot to
                    <code>true</code>.</p>
                  </li>
                </ol>
                <div>
                  <em>No parameters.</em>
                </div>
                <div>
                  <em>Return type:</em> <code>void</code>
                </div>
              </dd>
            </dl>
          </section>
        </div>
      </section>
      <section>
        <h3>Legacy Interface Extensions</h3>
        <div class="note">
          These methods are kept on <code><a>RTCPeerConnection</a></code> for
          legacy purposes.
        </div>
        <div>
          <pre class="idl">partial interface RTCPeerConnection {
    Promise&lt;void&gt; createOffer (RTCSessionDescriptionCallback successCallback, RTCPeerConnectionErrorCallback failureCallback, optional RTCOfferOptions options);
    Promise&lt;void&gt; setLocalDescription (RTCSessionDescriptionInit description, VoidFunction successCallback, RTCPeerConnectionErrorCallback failureCallback);
    Promise&lt;void&gt; createAnswer (RTCSessionDescriptionCallback successCallback, RTCPeerConnectionErrorCallback failureCallback);
    Promise&lt;void&gt; setRemoteDescription (RTCSessionDescriptionInit description, VoidFunction successCallback, RTCPeerConnectionErrorCallback failureCallback);
    Promise&lt;void&gt; addIceCandidate ((RTCIceCandidateInit or RTCIceCandidate) candidate, VoidFunction successCallback, RTCPeerConnectionErrorCallback failureCallback);
    Promise&lt;void&gt; getStats (MediaStreamTrack? selector, RTCStatsCallback successCallback, RTCPeerConnectionErrorCallback failureCallback);
};</pre>
          <section>
            <h2>Methods</h2>
            <dl data-link-for="RTCPeerConnection" data-dfn-for=
            "RTCPeerConnection" class="methods">
              <dt><dfn data-lt="createOffer!overload-1" data-lt-nodefault=
              "true"><code>createOffer</code></dfn></dt>
              <dd>
                <p>When the <code>createOffer</code> method is called, the user
                agent MUST run the following steps:</p>
                <ol>
                  <li>
                    <p>Let <var>successCallback</var> be the method's first
                    argument.</p>
                  </li>
                  <li>
                    <p>Let <var>failureCallback</var> be the callback indicated
                    by the method's second argument.</p>
                  </li>
                  <li>
                    <p>Let <var>options</var> be the callback indicated by the
                    method's third argument.</p>
                  </li>
                  <li>
                    <p>Run the steps specified by
                    <code><a>RTCPeerConnection</a></code>'s <a data-for=
                    "RTCPeerConnection">createOffer()</a> method with
                    <var>options</var> as the sole argument, and let
                    <var>p</var> be the resulting promise.</p>
                  </li>
                  <li>
                    <p>Upon fulfillment of <var>p</var> with value
                    <var>offer</var>, invoke <var>successCallback</var> with
                    <var>offer</var> as the argument.</p>
                  </li>
                  <li>
                    <p>Upon rejection of <var>p</var> with reason <var>r</var>,
                    invoke <var>failureCallback</var> with <var>r</var> as the
                    argument.</p>
                  </li>
                  <li>
                    <p>Return a promise resolved with
                    <code>undefined</code>.</p>
                  </li>
                </ol>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">successCallback</td>
                      <td class="prmType">
                      <code>RTCSessionDescriptionCallback</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">failureCallback</td>
                      <td class="prmType">
                      <code>RTCPeerConnectionErrorCallback</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">options</td>
                      <td class="prmType"><code>RTCOfferOptions</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptTrue"><span role="img" aria-label=
                      "True">&#10004;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em> <code>Promise&lt;void&gt;</code>
                </div>
              </dd>
              <dt><dfn data-lt="setLocalDescription!overload-1"
              data-lt-nodefault=
              "true"><code>setLocalDescription</code></dfn></dt>
              <dd>
                <p>When the <code>setLocalDescription</code> method is called,
                the user agent MUST run the following steps:</p>
                <ol>
                  <li>
                    <p>Let <var>description</var> be the method's first
                    argument.</p>
                  </li>
                  <li>
                    <p>Let <var>successCallback</var> be the callback indicated
                    by the method's second argument.</p>
                  </li>
                  <li>
                    <p>Let <var>failureCallback</var> be the callback indicated
                    by the method's third argument.</p>
                  </li>
                  <li>
                    <p>Run the steps specified by
                    <code><a>RTCPeerConnection</a></code>'s <a data-for=
                    "RTCPeerConnection">setLocalDescription</a> method with
                    <var>description</var> as the sole argument, and let
                    <var>p</var> be the resulting promise.</p>
                  </li>
                  <li>
                    <p>Upon fulfillment of <var>p</var>, invoke
                    <var>successCallback</var> with <code>undefined</code> as
                    the argument.</p>
                  </li>
                  <li>
                    <p>Upon rejection of <var>p</var> with reason <var>r</var>,
                    invoke <var>failureCallback</var> with <var>r</var> as the
                    argument.</p>
                  </li>
                  <li>
                    <p>Return a promise resolved with
                    <code>undefined</code>.</p>
                  </li>
                </ol>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">description</td>
                      <td class="prmType">
                      <code>RTCSessionDescriptionInit</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">successCallback</td>
                      <td class="prmType"><code>VoidFunction</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">failureCallback</td>
                      <td class="prmType">
                      <code>RTCPeerConnectionErrorCallback</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em> <code>Promise&lt;void&gt;</code>
                </div>
              </dd>
              <dt><dfn data-lt="createAnswer!overload-1" data-lt-nodefault=
              "true"><code>createAnswer</code></dfn></dt>
              <dd>
                <p>When the <code>createAnswer</code> method is called, the
                user agent MUST run the following steps:</p>
                <ol>
                  <li>
                    <p>Let <var>successCallback</var> be the method's first
                    argument.</p>
                  </li>
                  <li>
                    <p>Let <var>failureCallback</var> be the callback indicated
                    by the method's second argument.</p>
                  </li>
                  <li>
                    <p>Run the steps specified by
                    <code><a>RTCPeerConnection</a></code>'s <a data-for=
                    "RTCPeerConnection">createAnswer()</a> method with no
                    arguments, and let <var>p</var> be the resulting
                    promise.</p>
                  </li>
                  <li>
                    <p>Upon fulfillment of <var>p</var> with value
                    <var>answer</var>, invoke <var>successCallback</var> with
                    <var>answer</var> as the argument.</p>
                  </li>
                  <li>
                    <p>Upon rejection of <var>p</var> with reason <var>r</var>,
                    invoke <var>failureCallback</var> with <var>r</var> as the
                    argument.</p>
                  </li>
                  <li>
                    <p>Return a promise resolved with
                    <code>undefined</code>.</p>
                  </li>
                </ol>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">successCallback</td>
                      <td class="prmType">
                      <code>RTCSessionDescriptionCallback</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">failureCallback</td>
                      <td class="prmType">
                      <code>RTCPeerConnectionErrorCallback</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em> <code>Promise&lt;void&gt;</code>
                </div>
              </dd>
              <dt><dfn data-lt="setRemoteDescription!overload-1"
              data-lt-nodefault=
              "true"><code>setRemoteDescription</code></dfn></dt>
              <dd>
                <p>When the <code>setRemoteDescription</code> method is called,
                the user agent MUST run the following steps:</p>
                <ol>
                  <li>
                    <p>Let <var>description</var> be the method's first
                    argument.</p>
                  </li>
                  <li>
                    <p>Let <var>successCallback</var> be the callback indicated
                    by the method's second argument.</p>
                  </li>
                  <li>
                    <p>Let <var>failureCallback</var> be the callback indicated
                    by the method's third argument.</p>
                  </li>
                  <li>
                    <p>Run the steps specified by
                    <code><a>RTCPeerConnection</a></code>'s <a data-for=
                    "RTCPeerConnection">setRemoteDescription</a> method with
                    <var>description</var> as the sole argument, and let
                    <var>p</var> be the resulting promise.</p>
                  </li>
                  <li>
                    <p>Upon fulfillment of <var>p</var>, invoke
                    <var>successCallback</var> with <code>undefined</code> as
                    the argument.</p>
                  </li>
                  <li>
                    <p>Upon rejection of <var>p</var> with reason <var>r</var>,
                    invoke <var>failureCallback</var> with <var>r</var> as the
                    argument.</p>
                  </li>
                  <li>
                    <p>Return a promise resolved with
                    <code>undefined</code>.</p>
                  </li>
                </ol>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">description</td>
                      <td class="prmType">
                      <code>RTCSessionDescriptionInit</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">successCallback</td>
                      <td class="prmType"><code>VoidFunction</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">failureCallback</td>
                      <td class="prmType">
                      <code>RTCPeerConnectionErrorCallback</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em> <code>Promise&lt;void&gt;</code>
                </div>
              </dd>
              <dt><code>addIceCandidate</code></dt>
              <dd>
                <p>When the <code>addIceCandidate</code> method is called, the
                user agent MUST run the following steps:</p>
                <ol>
                  <li>
                    <p>Let <var>candidate</var> be the method's first
                    argument.</p>
                  </li>
                  <li>
                    <p>Let <var>successCallback</var> be the callback indicated
                    by the method's second argument.</p>
                  </li>
                  <li>
                    <p>Let <var>failureCallback</var> be the callback indicated
                    by the method's third argument.</p>
                  </li>
                  <li>
                    <p>Run the steps specified by
                    <code><a>RTCPeerConnection</a></code>'s <a data-for=
                    "RTCPeerConnection">addIceCandiddate()</a> method with
                    <var>candidate</var> as the sole argument, and let
                    <var>p</var> be the resulting promise.</p>
                  </li>
                  <li>
                    <p>Upon fulfillment of <var>p</var>, invoke
                    <var>successCallback</var> with <code>undefined</code> as
                    the argument.</p>
                  </li>
                  <li>
                    <p>Upon rejection of <var>p</var> with reason <var>r</var>,
                    invoke <var>failureCallback</var> with <var>r</var> as the
                    argument.</p>
                  </li>
                  <li>
                    <p>Return a promise resolved with
                    <code>undefined</code>.</p>
                  </li>
                </ol>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">candidate</td>
                      <td class="prmType"><code>(RTCIceCandidateInit or
                      RTCIceCandidate)</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">successCallback</td>
                      <td class="prmType"><code>VoidFunction</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">failureCallback</td>
                      <td class="prmType">
                      <code>RTCPeerConnectionErrorCallback</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em> <code>Promise&lt;void&gt;</code>
                </div>
              </dd>
              <dt><dfn><code>getStats</code></dfn></dt>
              <dd>
                <p>When the <code>getStats</code> method is called, the user
                agent MUST run the following steps:</p>
                <ol>
                  <li>
                    <p>Let <var>selector</var> be the method's first
                    argument.</p>
                  </li>
                  <li>
                    <p>Let <var>successCallback</var> be the callback indicated
                    by the method's second argument.</p>
                  </li>
                  <li>
                    <p>Let <var>failureCallback</var> be the callback indicated
                    by the method's third argument.</p>
                  </li>
                  <li>
                    <p>Run the steps specified by
                    <code><a>RTCPeerConnection</a></code>'s <a data-for=
                    "RTCPeerConnection">getStats()</a> method with
                    <var>selector</var> as the sole argument, and let
                    <var>p</var> be the resulting promise.</p>
                  </li>
                  <li>
                    <p>Upon fulfillment of <var>p</var> with value
                    <var>report</var>, invoke <var>successCallback</var> with
                    <var>report</var> as the argument.</p>
                  </li>
                  <li>
                    <p>Upon rejection of <var>p</var> with reason <var>r</var>,
                    invoke <var>failureCallback</var> with <var>r</var> as the
                    argument.</p>
                  </li>
                  <li>
                    <p>Return a promise resolved with
                    <code>undefined</code>.</p>
                  </li>
                </ol>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">selector</td>
                      <td class="prmType"><code>MediaStreamTrack</code></td>
                      <td class="prmNullTrue"><span role="img" aria-label=
                      "True">&#10004;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">successCallback</td>
                      <td class="prmType"><code>RTCStatsCallback</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">failureCallback</td>
                      <td class="prmType">
                      <code>RTCPeerConnectionErrorCallback</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
                <div>
                  <em>Return type:</em> <code>Promise&lt;void&gt;</code>
                </div>
              </dd>
            </dl>
          </section>
        </div>
      </section>
      <section>
        <h2>Garbage collection</h2>
        <p>An <code><a>RTCPeerConnection</a></code> object MUST not be garbage
        collected as long as any event can cause an event handler to be
        triggered on the object. When the object's [[<a>isClosed</a>]] internal
        slot is <code>true</code>, no such event handler can be triggered and
        it is therefore safe to garbage collect the object.</p>
        <p>All <code><a>RTCDataChannel</a></code> and
        <code><a>MediaStreamTrack</a></code> objects that are connected to a
        <code><a>RTCPeerConnection</a></code> have a strong reference to the
        <code><a>RTCPeerConnection</a></code> object.</p>
      </section>
    </section>
    <section>
      <h3>State Definitions</h3>
      <section>
        <h4>RTCSignalingState Enum</h4>
        <div>
          <pre class="idl">enum RTCSignalingState {
    "stable",
    "have-local-offer",
    "have-remote-offer",
    "have-local-pranswer",
    "have-remote-pranswer"
};</pre>
          <table data-link-for="RTCSignalingState" data-dfn-for=
          "RTCSignalingState" class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code>stable</code></dfn></td>
                <td>There is no offer&shy;answer exchange in progress. This is
                also the initial state in which case the local and remote
                descriptions are empty.</td>
              </tr>
              <tr>
                <td><dfn><code>have-local-offer</code></dfn></td>
                <td>A local description, of type "offer", has been successfully
                applied.</td>
              </tr>
              <tr>
                <td><dfn><code>have-remote-offer</code></dfn></td>
                <td>A remote description, of type "offer", has been
                successfully applied.</td>
              </tr>
              <tr>
                <td><dfn><code>have-local-pranswer</code></dfn></td>
                <td>A remote description of type "offer" has been successfully
                applied and a local description of type "pranswer" has been
                successfully applied.</td>
              </tr>
              <tr>
                <td><dfn><code>have-remote-pranswer</code></dfn></td>
                <td>A local description of type "offer" has been successfully
                applied and a remote description of type "pranswer" has been
                successfully applied.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <figure>
          <img alt="signalling state transition diagram" src=
          "images/peerstates.svg" width="600">
          <figcaption>
            Non-normative signalling state transitions diagram
          </figcaption>
        </figure>
        <p>An example set of transitions might be:</p>
        <dl>
          <dt>Caller transition:</dt>
          <dd>
            <ul>
              <li>new RTCPeerConnection(): <code>stable</code></li>
              <li>setLocal(offer): <code>have-local-offer</code></li>
              <li>setRemote(pranswer): <code>have-remote-pranswer</code></li>
              <li>setRemote(answer): <code>stable</code></li>
            </ul>
          </dd>
          <dt>Callee transition:</dt>
          <dd>
            <ul>
              <li>new RTCPeerConnection(): <code>stable</code></li>
              <li>setRemote(offer): <code>have-remote-offer</code></li>
              <li>setLocal(pranswer): <code>have-local-pranswer</code></li>
              <li>setLocal(answer): <code>stable</code></li>
            </ul>
          </dd>
        </dl>
      </section>
      <section>
        <h4>RTCIceGatheringState Enum</h4>
        <div>
          <pre class="idl">enum RTCIceGatheringState {
    "new",
    "gathering",
    "complete"
};</pre>
          <table data-link-for="RTCIceGatheringState" data-dfn-for=
          "RTCIceGatheringState" class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code>new</code></dfn></td>
                <td>The object was just created, and no networking has occurred
                yet.</td>
              </tr>
              <tr>
                <td><dfn><code>gathering</code></dfn></td>
                <td>
                  The <a>ICE agent</a> is in the process of gathering
                  candidates for this RTCPeerConnection.
                </td>
              </tr>
              <tr>
                <td><dfn><code>complete</code></dfn></td>
                <td>
                  The <a>ICE agent</a> has completed gathering. Events such as
                  adding a new interface or a new TURN server will cause the
                  state to go back to gathering.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section>
        <h4>RTCPeerConnectionState Enum</h4>
        <div>
          <pre class="idl">enum RTCPeerConnectionState {
    "new",
    "connecting",
    "connected",
    "disconnected",
    "failed",
    "closed"
};</pre>
          <table data-link-for="RTCPeerConnectionState" data-dfn-for=
          "RTCPeerConnectionState" class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code>new</code></dfn></td>
                <td>Any of the <code><a>RTCIceTransport</a></code>s or
                <code><a>RTCDtlsTransport</a></code>s are in the
                <code>new</code> state and none of the transports are in the
                <code>connecting</code>, <code>checking</code>,
                <code>failed</code> or <code>disconnected</code> state, or all
                transports are in the <code>closed</code> state.</td>
              </tr>
              <tr>
                <td><dfn><code>connecting</code></dfn></td>
                <td>Any of the <code><a>RTCIceTransport</a></code>s or
                <code><a>RTCDtlsTransport</a></code>s are in the
                <code>connecting</code> or <code>checking</code> state and none
                of them is in the <code>failed</code> state.</td>
              </tr>
              <tr>
                <td><dfn><code>connected</code></dfn></td>
                <td>All <code><a>RTCIceTransport</a></code>s and
                <code><a>RTCDtlsTransport</a></code>s are in the
                <code>connected</code>, <code>completed</code> or
                <code>closed</code> state and at least of them is in the
                <code>connected</code> or <code>completed</code> state.</td>
              </tr>
              <tr>
                <td><dfn><code>disconnected</code></dfn></td>
                <td>Any of the <code><a>RTCIceTransport</a></code>s or
                <code><a>RTCDtlsTransport</a></code>s are in the
                <code>disconnected</code> state and none of them are in the
                <code>failed</code> or <code>connecting</code> or
                <code>checking</code> state.</td>
              </tr>
              <tr>
                <td><dfn><code>failed</code></dfn></td>
                <td>Any of the <code><a>RTCIceTransport</a></code>s or
                <code><a>RTCDtlsTransport</a></code>s are in a
                <code>failed</code> state.</td>
              </tr>
              <tr>
                <td><dfn><code>closed</code></dfn></td>
                <td>
                  The <code><a>RTCPeerConnection</a></code> object's
                  [[<a>isClosed</a>]] slot is <code>true</code>.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section>
        <h4>RTCIceConnectionState Enum</h4>
        <div>
          <pre class="idl">enum RTCIceConnectionState {
    "new",
    "checking",
    "connected",
    "completed",
    "failed",
    "disconnected",
    "closed"
};</pre>
          <table data-link-for="RTCIceConnectionState" data-dfn-for=
          "RTCIceConnectionState" class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code>new</code></dfn></td>
                <td>Any of the <code><a>RTCIceTransport</a></code>s are in the
                <code>new</code> state and none of them are in the
                <code>checking</code>, <code>failed</code> or
                <code>disconnected</code> state.</td>
              </tr>
              <tr>
                <td><dfn><code>checking</code></dfn></td>
                <td>Any of the <code><a>RTCIceTransport</a></code>s are in the
                <code>checking</code> state and none of them are in the
                <code>failed</code> or <code>disconnected</code> state.</td>
              </tr>
              <tr>
                <td><dfn><code>connected</code></dfn></td>
                <td>All <code><a>RTCIceTransport</a></code>s are in the
                <code>connected</code>, <code>completed</code> or
                <code>closed</code> state and at least one of them is in the
                <code>connected</code> state.</td>
              </tr>
              <tr>
                <td><dfn><code>completed</code></dfn></td>
                <td>All <code><a>RTCIceTransport</a></code>s are in the
                <code>completed</code> or <code>closed</code> state and at
                least one of them is in the <code>completed</code> state.</td>
              </tr>
              <tr>
                <td><dfn><code>failed</code></dfn></td>
                <td>Any of the <code><a>RTCIceTransport</a></code>s are in the
                <code>failed</code> state.</td>
              </tr>
              <tr>
                <td><dfn><code>disconnected</code></dfn></td>
                <td>Any of the <code><a>RTCIceTransport</a></code>s are in the
                <code>disconnected</code> state and none of them are in the
                <code>failed</code> state.</td>
              </tr>
              <tr>
                <td><dfn><code>closed</code></dfn></td>
                <td>All of the <code><a>RTCIceTransport</a></code>s are in the
                <code>closed</code> state.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>Note that if an <code><a>RTCIceTransport</a></code> is discarded as
        a result of signaling (e.g. RTCP mux or BUNDLE), or created as a result
        of signaling (e.g. adding a new <a>media description</a>), the state
        may advance directly from one state to another.</p>
      </section>
    </section>
    <section>
      <h3>Callback Definitions</h3>
      <section>
        <h4>RTCPeerConnectionErrorCallback</h4>
        <div>
          <pre class="idl">
          callback RTCPeerConnectionErrorCallback = void (DOMException error);</pre>
          <section>
            <h2>Callback <a class="idlType">RTCPeerConnectionErrorCallback</a>
            Parameters</h2>
            <dl data-link-for="RTCPeerConnectionErrorCallback" data-dfn-for=
            "RTCPeerConnectionErrorCallback" class="callback-members">
              <dt><code>error</code> of type <span class=
              "idlMemberType"><a>DOMException</a></span></dt>
              <dd>An error object encapsulating information about what went
              wrong.</dd>
            </dl>
          </section>
        </div>
      </section>
      <section>
        <h4>RTCSessionDescriptionCallback</h4>
        <div>
          <pre class="idl">
          callback RTCSessionDescriptionCallback = void (RTCSessionDescription sdp);</pre>
          <section>
            <h2>Callback <a class="idlType">RTCSessionDescriptionCallback</a>
            Parameters</h2>
            <dl data-link-for="RTCSessionDescriptionCallback" data-dfn-for=
            "RTCSessionDescriptionCallback" class="callback-members">
              <dt><code>sdp</code> of type <span class=
              "idlMemberType"><a>RTCSessionDescription</a></span></dt>
              <dd>The object containing the SDP [[!SDP]].</dd>
            </dl>
          </section>
        </div>
      </section>
    </section>
    <section>
      <h3>Error Handling</h3>
      <section>
        <h4>General Principles</h4>
        <p>All methods that return promises are governed by the standard error
        handling rules of promises. Methods that do not return promises may
        throw exceptions to indicate errors.</p>
        <p>Legacy-methods may only throw exceptions to indicate invalid state
        and other programming errors. For example, when a legacy-method is
        called when the <code><a>RTCPeerConnection</a></code> is in an invalid
        state or a state in which that particular method is not allowed to be
        executed, it will throw an exception. In all other cases, legacy
        methods MUST provide an error object to the error callback.</p>
      </section>
    </section>
    <section>
      <h3>Session Description Model</h3>
      <section>
        <h4>RTCSdpType</h4>
        <p>The RTCSdpType enum describes the type of an
        <code><a>RTCSessionDescriptionInit</a></code> or
        <code><a>RTCSessionDescription</a></code> instance.</p>
        <div>
          <pre class="idl">enum RTCSdpType {
    "offer",
    "pranswer",
    "answer",
    "rollback"
};</pre>
          <table data-link-for="RTCSdpType" data-dfn-for="RTCSdpType" class=
          "simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code>offer</code></dfn></td>
                <td>
                  <p>An <code>RTCSdpType</code> of <code>offer</code> indicates
                  that a description MUST be treated as an [[!SDP]] offer.</p>
                </td>
              </tr>
              <tr>
                <td><dfn><code>pranswer</code></dfn></td>
                <td>
                  <p>An <code>RTCSdpType</code> of <code>pranswer</code>
                  indicates that a description MUST be treated as an [[!SDP]]
                  answer, but not a final answer. A description used as an SDP
                  <code>pranswer</code> may be applied as a response to an SDP
                  offer, or an update to a previously sent SDP pranswer.</p>
                </td>
              </tr>
              <tr>
                <td><dfn><code>answer</code></dfn></td>
                <td>
                  <p>An <code>RTCSdpType</code> of <code>answer</code>
                  indicates that a description MUST be treated as an [[!SDP]]
                  final answer, and the offer-answer exchange MUST be
                  considered complete. A description used as an SDP answer may
                  be applied as a response to an SDP offer or as an update to a
                  previously sent SDP pranswer.</p>
                </td>
              </tr>
              <tr>
                <td><dfn><code>rollback</code></dfn></td>
                <td>
                  <p>An <code>RTCSdpType</code> of <code>rollback</code>
                  indicates that a description MUST be treated as canceling the
                  current SDP negotiation and moving the SDP [[!SDP]] offer and
                  answer back to what it was in the previous stable state. Note
                  the local or remote SDP descriptions in the previous stable
                  state could be null if there has not yet been a successful
                  offer-answer negotiation.</p>
                  <p>If the <code><a data-for=
                  "RTCRtpTransceiver">mid</a></code> value of an
                  <code><a>RTCRtpTransceiver</a></code> was set to a non-null
                  value by an <code><a>RTCSessionDescription</a></code> that is
                  rolled back, the <code><a data-for=
                  "RTCRtpTransceiver">mid</a></code> value will be set back to
                  null, as defined by <span data-jsep=
                  "rollback">[[!JSEP]]</span>.</p>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section>
        <h4>RTCSessionDescription Class</h4>
        <p>The <code>RTCSessionDescription</code> class is used by
        <code><a>RTCPeerConnection</a></code> to expose local and remote
        session descriptions. Attributes on this interface are mutable for
        legacy reasons.</p>
        <div>
          <pre class="idl">
          [ Constructor (RTCSessionDescriptionInit descriptionInitDict)]
interface RTCSessionDescription {
    readonly        attribute RTCSdpType type;
    readonly        attribute DOMString  sdp;
    serializer = {attribute};
};</pre>
          <section>
            <h2>Constructors</h2>
            <dl data-link-for="RTCSessionDescription" data-dfn-for=
            "RTCSessionDescription" class="constructors">
              <dt><code>RTCSessionDescription</code></dt>
              <dd>
                The <dfn id=
                "dom-sessiondescription"><code>RTCSessionDescription()</code></dfn>
                constructor takes a dictionary argument,
                <var>descriptionInitDict</var>, whose content is used to
                initialize the new <code><a>RTCSessionDescription</a></code>
                object. This constructor is deprecated; it exists for legacy
                compatibility reasons only.
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">descriptionInitDict</td>
                      <td class="prmType">
                      <code>RTCSessionDescriptionInit</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
              </dd>
            </dl>
          </section>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="RTCSessionDescription" data-dfn-for=
            "RTCSessionDescription" class="attributes">
              <dt><dfn><code>type</code></dfn> of type <span class=
              "idlAttrType"><a>RTCSdpType</a></span>, readonly</dt>
              <dd>The type of this RTCSessionDescription.</dd>
              <dt><dfn><code>sdp</code></dfn> of type <span class=
              "idlAttrType"><a>DOMString</a></span>, readonly</dt>
              <dd>The string representation of the SDP [[!SDP]].</dd>
            </dl>
          </section>
          <section>
            <h2>Serializer</h2>
            <div>
              <p>Instances of this interface are serialized as a map with
              entries for each of the serializable attributes.</p>
            </div>
          </section>
        </div>
        <div>
          <pre class="idl">dictionary RTCSessionDescriptionInit {
    required RTCSdpType type;
             DOMString  sdp;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCSessionDescriptionInit</a>
            Members</h2>
            <dl data-link-for="RTCSessionDescriptionInit" data-dfn-for=
            "RTCSessionDescriptionInit" class="dictionary-members">
              <dt><dfn><code>type</code></dfn> of type <span class=
              "idlMemberType"><a>RTCSdpType</a></span>, required</dt>
              <dd>DOMString sdp</dd>
              <dt><dfn><code>sdp</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>The string representation of the SDP [[!SDP]]; if
              <code>type</code> is <code>rollback</code>, this member can be
              left undefined.</dd>
            </dl>
          </section>
        </div>
      </section>
    </section>
    <section>
      <h3>Session Negotiation Model</h3>
      <p>Many changes to state of an <code><a>RTCPeerConnection</a></code> will
      require communication with the remote side via the signaling channel, in
      order to have the desired effect. The app can be kept informed as to when
      it needs to do signaling, by listening to the
      <code>negotiationneeded</code> event.</p>
      <section>
        <h4>Setting Negotiation-Needed</h4>
        <p>If an operation is performed on an
        <code><a>RTCPeerConnection</a></code> that requires signaling, the
        connection will be marked as needing negotiation. Examples of such
        operations include adding or stopping a track, or adding the first data
        channel.</p>
        <p>Internal changes within the implementation can also result in the
        connection being marked as needing negotiation.</p>
      </section>
      <section>
        <h4>Clearing Negotiation-Needed</h4>
        <p>The <dfn data-lt=
        "clear the negotiation-needed flag">negotiation-needed flag is
        cleared</dfn> when <code>setLocalDescription</code> is called (either
        for an offer or answer), and the supplied description matches the state
        of the tracks/datachannels that currenly exist on the
        <code><a>RTCPeerConnection</a></code>. Specifically, this means that
        all tracks have an associated section in the local description
        with their MSID, and, if any data channels have been created, a data
        section exists in the local description.</p>
        <p>Note that <code>setLocalDescription(answer)</code> will clear the
        negotiation-needed flag only if the offer had a corresponding section
        for all the tracks/datachannels on the answerer side. Otherwise, a new
        offer by the answerer is still needed, and so the state is not
        cleared.</p>
      </section>
      <section>
        <h4>Firing An Event</h4>
        <p>When the <code><a>RTCPeerConnection</a></code> <var>connection</var>
        is marked as negotiation-needed, and it was not already marked as
        such:</p>
        <ul>
          <li>If the <a>signaling state</a> is <code>stable</code>, schedule a
          task to check the negotiation-needed flag and, if still set, fire a
          <a>negotiationneeded</a> event on <var>connection</var>.
          </li>
          <li>Otherwise, do nothing. If necessary, an event will be fired
          during <code>setLocalDescription</code> or
          <code>setRemoteDescription</code> processing, as described
          above.</li>
        </ul>
      </section>
    </section>
    <section>
      <h3>Interfaces for Connectivity Establishment</h3>
      <section>
        <h4>RTCIceCandidate Interface</h4>
        <p>This interface describes an ICE candidate.</p>
        <div>
          <pre class="idl">
          [ Constructor (RTCIceCandidateInit candidateInitDict)]
interface RTCIceCandidate {
    readonly        attribute DOMString               candidate;
    readonly        attribute DOMString?              sdpMid;
    readonly        attribute unsigned short?         sdpMLineIndex;
    readonly        attribute DOMString               foundation;
    readonly        attribute unsigned long           priority;
    readonly        attribute DOMString               ip;
    readonly        attribute RTCIceProtocol          protocol;
    readonly        attribute unsigned short          port;
    readonly        attribute RTCIceCandidateType     type;
    readonly        attribute RTCIceTcpCandidateType? tcpType;
    readonly        attribute DOMString?              relatedAddress;
    readonly        attribute unsigned short?         relatedPort;
    serializer = {candidate, sdpMid, sdpMLineIndex};
};</pre>
          <section>
            <h2>Constructors</h2>
            <dl data-link-for="RTCIceCandidate" data-dfn-for="RTCIceCandidate"
            class="constructors">
              <dt><code>RTCIceCandidate</code></dt>
              <dd>
                The <dfn><code>RTCIceCandidate()</code></dfn> constructor takes
                a dictionary argument, <var>candidateInitDict</var>, whose
                content is used to initialize the new
                <a class=
                "idlType"><code>RTCIceCandidate</code></a> object. When run, if
                both the <code><a>sdpMid</a></code> and
                <code><a>sdpMLineIndex</a></code> dictionary members are
                <code>null</code>, throw a <code>TypeError</code>.
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">candidateInitDict</td>
                      <td class="prmType"><code>RTCIceCandidateInit</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
              </dd>
            </dl>
          </section>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="RTCIceCandidate" data-dfn-for="RTCIceCandidate"
            class="attributes">
              <dt><dfn><code>candidate</code></dfn> of type <span class=
              "idlAttrType"><a>DOMString</a></span>, readonly</dt>
              <dd>This carries the <code>candidate-attribute</code> as defined
              in section 15.1 of [[!ICE]].</dd>
              <dt><dfn><code>sdpMid</code></dfn> of type <span class=
              "idlAttrType"><a>DOMString</a></span>, readonly , nullable</dt>
              <dd>If not <code>null</code>, this contains the identifier of the
              "media stream identification" as defined in [[!RFC5888]] for the
              media component this candidate is associated with.</dd>
              <dt><dfn><code>sdpMLineIndex</code></dfn> of type <span class=
              "idlAttrType"><a>unsigned short</a></span>, readonly ,
              nullable</dt>
              <dd>
                If not <code>null</code>, this indicates the index (starting at
                zero) of the <a>media description</a> in the SDP this candidate
                is associated with.
              </dd>
              <dt><dfn><code>foundation</code></dfn> of type <span class=
              "idlAttrType"><a>DOMString</a></span>, readonly</dt>
              <dd>A unique identifier that allows ICE to correlate candidates
              that appear on multiple
              <code><a>RTCIceTransport</a></code>s.</dd>
              <dt><dfn><code>priority</code></dfn> of type <span class=
              "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
              <dd>The assigned priority of the candidate.</dd>
              <dt><dfn><code>ip</code></dfn> of type <span class=
              "idlAttrType"><a>DOMString</a></span>, readonly</dt>
              <dd>
                <p>The IP address of the candidate.</p>
                <div class="note">
                  <p>The IP addresses exposed in candidates gathered via ICE
                  and made visibile to the application in
                  <code>RTCIceCandidate</code> instances can reveal more
                  information about the device and the user (e.g. location,
                  local network topology) than the user might have expected in
                  a non-WebRTC enabled browser.</p>
                  <p>These IP addresses are always exposed to the application,
                  and potentially exposed to the communicating party, and can
                  be exposed without any specific user consent (e.g. for peer
                  connections used with data channels, or to receive media
                  only).</p>
                  <p class="fingerprint">These IP addresses can also be used as
                  temporary or persistent cross-origin states, and thus
                  contribute to the fingerprinting surface of the device.</p>
                  <p>Applications can avoid exposing IP addresses to the
                  communicating party, either temporarily or permanently, by
                  forcing the <a>ICE Agent</a> to report only relay candidates
                  via the <code>iceTransportPolicy</code> member of
                  <code><a>RTCConfiguration</a></code>, or by not signalling
                  non-relay ICE candidates (e.g. until the user has accepted to
                  share media).</p>
                  <p>To limit the IP addresses exposed to the application
                  itself, browsers can offer their users different policies
                  regarding sharing local IP addresses, as defined in
                  [[RTCWEB-IP-HANDLING]].</p>
                </div>
              </dd>
              <dt><dfn><code>protocol</code></dfn> of type <span class=
              "idlAttrType"><a>RTCIceProtocol</a></span>, readonly</dt>
              <dd>The protocol of the candidate
              (<code>udp</code>/<code>tcp</code>).</dd>
              <dt><dfn><code>port</code></dfn> of type <span class=
              "idlAttrType"><a>unsigned short</a></span>, readonly</dt>
              <dd>The port of the candidate.</dd>
              <dt><dfn><code>type</code></dfn> of type <span class=
              "idlAttrType"><a>RTCIceCandidateType</a></span>, readonly</dt>
              <dd>The type of the candidate.</dd>
              <dt><dfn><code>tcpType</code></dfn> of type <span class=
              "idlAttrType"><a>RTCIceTcpCandidateType</a></span>, readonly ,
              nullable</dt>
              <dd>If <code>protocol</code> is <code>tcp</code>,
              <code>tcpType</code> represents the type of TCP candidate.
              Otherwise, <code>tcpType</code> is <code>null</code>.</dd>
              <dt><code>relatedAddress</code> of type <span class=
              "idlAttrType"><a>DOMString</a></span>, readonly , nullable</dt>
              <dd>For a candidate that is derived from another, such as a relay
              or reflexive candidate, the <dfn>relatedAddress</dfn> is the IP
              address of the candidate that it is derived from. For host
              candidates, the <code>relatedAddress</code> is
              <code>null</code>.</dd>
              <dt><code>relatedPort</code> of type <span class=
              "idlAttrType"><a>unsigned short</a></span>, readonly ,
              nullable</dt>
              <dd>For a candidate that is derived from another, such as a relay
              or reflexive candidate, the <dfn>relatedPort</dfn> is the port of
              the candidate that it is derived from. For host candidates, the
              <code>relatedPort</code> is <code>null</code>.</dd>
            </dl>
          </section>
          <section>
            <h2>Serializer</h2>
            <div>
              <p>Instances of this interface are serialized as a map with
              entries for the following attributes: candidate, sdpMid,
              sdpMLineIndex.</p>
            </div>
          </section>
        </div>
        <div>
          <pre class="idl">dictionary RTCIceCandidateInit {
    required DOMString       candidate;
             DOMString?      sdpMid = null;
             unsigned short? sdpMLineIndex = null;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCIceCandidateInit</a>
            Members</h2>
            <dl data-link-for="RTCIceCandidateInit" data-dfn-for=
            "RTCIceCandidateInit" class="dictionary-members">
              <dt><dfn><code>candidate</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, required</dt>
              <dd></dd>
              <dt><dfn><code>sdpMid</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, nullable, defaulting to
              <code>null</code></dt>
              <dd></dd>
              <dt><dfn><code>sdpMLineIndex</code></dfn> of type <span class=
              "idlMemberType"><a>unsigned short</a></span>, nullable,
              defaulting to <code>null</code></dt>
              <dd></dd>
            </dl>
          </section>
        </div>
        <section>
          <h4>RTCIceProtocol Enum</h4>
          <p>The <dfn>RTCIceProtocol</dfn> represents the protocol of the ICE
          candidate.</p>
          <div>
            <pre class="idl">enum RTCIceProtocol {
    "udp",
    "tcp"
};</pre>
            <table data-link-for="RTCIceProtocol" data-dfn-for="RTCIceProtocol"
            class="simple">
              <tbody>
                <tr>
                  <th colspan="2">Enumeration description</th>
                </tr>
                <tr>
                  <td><dfn><code>udp</code></dfn></td>
                  <td>A UDP candidate, as described in [[!ICE]].</td>
                </tr>
                <tr>
                  <td><dfn><code>tcp</code></dfn></td>
                  <td>A TCP candidate, as described in [[!RFC6544]].</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section>
          <h4>RTCIceTcpCandidateType Enum</h4>
          <p>The <dfn>RTCIceTcpCandidateType</dfn> represents the type of the
          ICE TCP candidate, as defined in [[!RFC6544]].</p>
          <div>
            <pre class="idl">enum RTCIceTcpCandidateType {
    "active",
    "passive",
    "so"
};</pre>
            <table data-link-for="RTCIceTcpCandidateType" data-dfn-for=
            "RTCIceTcpCandidateType" class="simple">
              <tbody>
                <tr>
                  <th colspan="2">Enumeration description</th>
                </tr>
                <tr>
                  <td><dfn><code>active</code></dfn></td>
                  <td>An <code>active</code> TCP candidate is one for which the
                  transport will attempt to open an outbound connection but
                  will not receive incoming connection requests.</td>
                </tr>
                <tr>
                  <td><dfn><code>passive</code></dfn></td>
                  <td>A <code>passive</code> TCP candidate is one for which the
                  transport will receive incoming connection attempts but not
                  attempt a connection.</td>
                </tr>
                <tr>
                  <td><dfn><code>so</code></dfn></td>
                  <td>An <code>so</code> candidate is one for which the
                  transport will attempt to open a connection simultaneously
                  with its peer.</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section>
          <h4>RTCIceCandidateType Enum</h4>
          <p>The <dfn>RTCIceCandidateType</dfn> represents the type of the ICE
          candidate, as defined in [[!ICE]] section 15.1.</p>
          <div>
            <pre class="idl">enum RTCIceCandidateType {
    "host",
    "srflx",
    "prflx",
    "relay"
};</pre>
            <table data-link-for="RTCIceCandidateType" data-dfn-for=
            "RTCIceCandidateType" class="simple">
              <tbody>
                <tr>
                  <th colspan="2">Enumeration description</th>
                </tr>
                <tr>
                  <td><dfn><code>host</code></dfn></td>
                  <td>A host candidate, as defined in Section 4.1.1.1 of
                  [[!ICE]].</td>
                </tr>
                <tr>
                  <td><dfn><code>srflx</code></dfn></td>
                  <td>A server reflexive candidate, as defined in Section
                  4.1.1.2 of [[!ICE]].</td>
                </tr>
                <tr>
                  <td><dfn><code>prflx</code></dfn></td>
                  <td>A peer reflexive candidate, as defined in Section 4.1.1.2
                  of [[!ICE]].</td>
                </tr>
                <tr>
                  <td><dfn><code>relay</code></dfn></td>
                  <td>A relay candidate, as defined in Section 7.1.3.2.1 of
                  [[!ICE]].</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
      </section>
      <section>
        <h4>RTCPeerConnectionIceEvent</h4>
        <p>The <code>icecandidate</code> event of the RTCPeerConnection uses
        the <code><a>RTCPeerConnectionIceEvent</a></code> interface.</p>
        <p><dfn data-lt="Fire an ice candidate event">Firing an
        <code><a>RTCPeerConnectionIceEvent</a></code> event named
        <var>e</var></dfn> with an <code><a>RTCIceCandidate</a></code>
        <var>candidate</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code>RTCPeerConnectionIceEvent</code> interface with the
        <code>candidate</code> attribute set to the new ICE candidate, MUST be
        created and dispatched at the given target.</p>
        <p>When firing an <code><a>RTCPeerConnectionIceEvent</a></code> event
        that contains a <code><a>RTCIceCandidate</a></code> object, it MUST
        include values for both <a data-for=
        "RTCIceCandidate"><code>sdpMid</code></a> and <a data-for=
        "RTCIceCandidate"><code>sdpMLineIndex</code></a>. If the
        <code><a>RTCIceCandidate</a></code> is of type <code>srflx</code> or
        type <code>relay</code>, the <code>url</code> property of the event
        MUST be set to the URL of the ICE server from which the candidate was
        obtained.</p>
        <div>
          <pre class="idl">
          [ Constructor (DOMString type, RTCPeerConnectionIceEventInit eventInitDict)]
interface RTCPeerConnectionIceEvent : Event {
    readonly        attribute RTCIceCandidate? candidate;
    readonly        attribute DOMString?       url;
};</pre>
          <section>
            <h2>Constructors</h2>
            <dl data-link-for="RTCPeerConnectionIceEvent" data-dfn-for=
            "RTCPeerConnectionIceEvent" class="constructors">
              <dt><dfn><code>RTCPeerConnectionIceEvent</code></dfn></dt>
              <dd>
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">type</td>
                      <td class="prmType"><code>DOMString</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">eventInitDict</td>
                      <td class="prmType">
                      <code>RTCPeerConnectionIceEventInit</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
              </dd>
            </dl>
          </section>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="RTCPeerConnectionIceEvent" data-dfn-for=
            "RTCPeerConnectionIceEvent" class="attributes">
              <dt><dfn><code>candidate</code></dfn> of type <span class=
              "idlAttrType"><a>RTCIceCandidate</a></span>, readonly ,
              nullable</dt>
              <dd>
                <p>The <code>candidate</code> attribute is the
                <code><a>RTCIceCandidate</a></code> object with the new ICE
                candidate that caused the event.</p>
                <p>This attribute is set to <code>null</code> when an event is
                generated to indicate the end of candidate gathering.</p>
                <p class="note">Even where there are multiple media components,
                only one event containing a <code>null</code> candidate is
                fired.</p>
              </dd>
              <dt><dfn><code>url</code></dfn> of type <span class=
              "idlAttrType"><a>DOMString</a></span>, readonly , nullable</dt>
              <dd>
                <p>The <code>url</code> attribute is the STUN or TURN URL that
                identifies the STUN or TURN server used to gather this
                candidate. If the candidate was not gathered from a STUN or
                TURN server, this parameter will be set to
                <code>null</code>.</p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">
          dictionary RTCPeerConnectionIceEventInit : EventInit {
             RTCIceCandidate candidate;
             DOMString       url;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCPeerConnectionIceEventInit</a>
            Members</h2>
            <dl data-link-for="RTCPeerConnectionIceEventInit" data-dfn-for=
            "RTCPeerConnectionIceEventInit" class="dictionary-members">
              <dt><dfn><code>candidate</code></dfn> of type <span class=
              "idlMemberType"><a>RTCIceCandidate</a></span></dt>
              <dd>
                <p>See <a data-for="RTCPeerConnection">the
                <code>candidate</code> attribute of the
                <code>RTCPeerConnectionIceEvent</code> interface</a>.</p>
              </dd>
              <dt><dfn><code>url</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd></dd>
            </dl>
          </section>
        </div>
      </section>
      <section>
        <h4>RTCPeerConnectionIceErrorEvent</h4>
        <p>The <code>icecandidateerror</code> event of the RTCPeerConnection
        uses the <code><a>RTCPeerConnectionIceErrorEvent</a></code>
        interface.</p>
        <div>
          <pre class="idl">
          [ Constructor (DOMString type, RTCPeerConnectionIceErrorEventInit eventInitDict)]
interface RTCPeerConnectionIceErrorEvent : Event {
    readonly        attribute DOMString      hostCandidate;
    readonly        attribute DOMString      url;
    readonly        attribute unsigned short errorCode;
    readonly        attribute USVString      errorText;
};</pre>
          <section>
            <h2>Constructors</h2>
            <dl data-link-for="RTCPeerConnectionIceErrorEvent" data-dfn-for=
            "RTCPeerConnectionIceErrorEvent" class="constructors">
              <dt><dfn><code>RTCPeerConnectionIceErrorEvent</code></dfn></dt>
              <dd>
                readonly attribute DOMString hostCandidate
                <table class="parameters">
                  <tbody>
                    <tr>
                      <th>Parameter</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td class="prmName">type</td>
                      <td class="prmType"><code>DOMString</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                    <tr>
                      <td class="prmName">eventInitDict</td>
                      <td class="prmType">
                      <code>RTCPeerConnectionIceErrorEventInit</code></td>
                      <td class="prmNullFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmOptFalse"><span role="img" aria-label=
                      "False">&#10008;</span></td>
                      <td class="prmDesc"></td>
                    </tr>
                  </tbody>
                </table>
              </dd>
            </dl>
          </section>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="RTCPeerConnectionIceErrorEvent" data-dfn-for=
            "RTCPeerConnectionIceErrorEvent" class="attributes">
              <dt><dfn><code>hostCandidate</code></dfn> of type <span class=
              "idlAttrType"><a>DOMString</a></span>, readonly</dt>
              <dd>
                <p>The <code>hostCandidate</code> attribute is the local IP
                address and port used to communicate with the STUN or TURN
                server.</p>
                <p>On a multihomed system, multiple interfaces may be used to
                contact the server, and this attribute allows the application
                to figure out on which one the failure occurred.</p>
                <p>If use of multiple interfaces has been prohibited for
                privacy reasons, this attribute will be set to 0.0.0.0:0 or
                [::]:0, as appropriate.</p>
              </dd>
              <dt><dfn><code>url</code></dfn> of type <span class=
              "idlAttrType"><a>DOMString</a></span>, readonly</dt>
              <dd>
                <p>The <code>url</code> attribute is the STUN or TURN URL that
                identifies the STUN or TURN server for which the failure
                occurred.</p>
              </dd>
              <dt><dfn><code>errorCode</code></dfn> of type <span class=
              "idlAttrType"><a>unsigned short</a></span>, readonly</dt>
              <dd>
                <p>The <code>errorCode</code> attribute is the numeric STUN
                error code returned by the STUN or TURN server
                [[STUN-PARAMETERS]].</p>
                <p>If no host candidate can reach the server,
                <code>errorCode</code> will be set to the value 701
                which is outside the STUN error code range.
                This error is only fired once per server URL while in
                the <code>RTCIceGatheringState</code> of "gathering".</p>
              </dd>
              <dt><dfn><code>errorText</code></dfn> of type <span class=
              "idlAttrType"><a>USVString</a></span>, readonly</dt>
              <dd>
                <p>The <code>errorText</code> attribute is the STUN reason text
                returned by the STUN or TURN server [[STUN-PARAMETERS]].</p>
                <p>If the server could not be reached, <code>errorText</code>
                will be set to an implementation-specific value providing
                details about the error.</p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">
          dictionary RTCPeerConnectionIceErrorEventInit : EventInit {
             DOMString      hostCandidate;
             DOMString      url;
             unsigned short errorCode;
             USVString      statusText;
};</pre>
          <section>
            <h2>Dictionary <a class=
            "idlType">RTCPeerConnectionIceErrorEventInit</a> Members</h2>
            <dl data-link-for="RTCPeerConnectionIceErrorEventInit"
            data-dfn-for="RTCPeerConnectionIceErrorEventInit" class=
            "dictionary-members">
              <dt><dfn><code>hostCandidate</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>DOMString url</dd>
              <dt><dfn><code>url</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>unsigned short errorCode</dd>
              <dt><dfn><code>errorCode</code></dfn> of type <span class=
              "idlMemberType"><a>unsigned short</a></span></dt>
              <dd>USVString statusText</dd>
              <dt><dfn><code>statusText</code></dfn> of type <span class=
              "idlMemberType"><a>USVString</a></span></dt>
              <dd></dd>
            </dl>
          </section>
        </div>
      </section>
    </section>
    <section>
      <h2>Priority and QoS Model</h2>
      <p>Many applications have multiple media flows of the same data type and
      often some of the flows are more important than others. WebRTC uses the
      priority and Quality of Service (QoS) framework described in
      [[!RTCWEB-TRANSPORT]] and [[!TSVWG-RTCWEB-QOS]] to provide priority and
      DSCP marking for packets that will help provide QoS in some networking
      environments. The priority setting can be used to indicate the relative
      priority of various flows. The priority API allows the JavaScript
      applications to tell the browser whether a particular media flow is high,
      medium, low or of very low importance to the application by setting the
      <code>priority</code> property of
      <code><a>RTCRtpEncodingParameters</a></code> objects to one of the
      following values.</p>
      <section>
        <h4>RTCPriorityType Enum</h4>
        <div>
          <pre class="idl">enum RTCPriorityType {
    "very-low",
    "low",
    "medium",
    "high"
};</pre>
          <table data-link-for="RTCPriorityType" data-dfn-for="RTCPriorityType"
          class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code>very-low</code></dfn></td>
                <td>See [[!RTCWEB-TRANSPORT]], Section 4.</td>
              </tr>
              <tr>
                <td><dfn><code>low</code></dfn></td>
                <td>See [[!RTCWEB-TRANSPORT]], Section 4.</td>
              </tr>
              <tr>
                <td><dfn><code>medium</code></dfn></td>
                <td>See [[!RTCWEB-TRANSPORT]], Section 4.</td>
              </tr>
              <tr>
                <td><dfn><code>high</code></dfn></td>
                <td>See [[!RTCWEB-TRANSPORT]], Section 4.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <p>Applications that use this API should be aware that often better
      overall user experience is obtained by lowering the priority of things
      that are not as important rather than raising the priority of the things
      that are.</p>
    </section>
    <section>
      <h2 id="sec.cert-mgmt">Certificate Management</h2>
      <p>The certificates that <code>RTCPeerConnection</code> instances use to
      authenticate with peers use the <a><code>RTCCertificate</code></a>
      interface. These objects can be explicitly generated by applications
      using the <code>generateCertificate</code> method on the connection and
      provided in the <a><code>RTCConfiguration</code></a> when constructing a
      new <code>RTCPeerConnection</code> instance.</p>
      <p>The explicit certificate management functions provided here are
      optional. If an application does not provide the
      <code>certificates</code> configuration option when constructing an
      <code>RTCPeerConnection</code> a new set of certificates MUST be
      generated by the <a>user agent</a>. That set MUST include an ECDSA
      certificate with a private key on the P-256 curve and a signature with a
      SHA-256 hash.</p>
      <div>
        <pre class="idl">partial interface RTCPeerConnection {
    static Promise&lt;RTCCertificate&gt; generateCertificate (AlgorithmIdentifier keygenAlgorithm);
};</pre>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="methods">
            <dt><dfn><code>generateCertificate</code></dfn>, static</dt>
            <dd>
              <p>The <code>generateCertificate</code> function causes the
              <a>user agent</a> to create and store an X.509 certificate
              [[!X509V3]] and corresponding private key. A handle to
              information is provided in the form of the
              <code>RTCCertificate</code> interface. The returned
              <code>RTCCertificate</code> can be used to control the
              certificate that is offered in the DTLS sessions established by
              <code>RTCPeerConnection</code>.</p>
              <p>The <var>keygenAlgorithm</var> argument is used to control how
              the private key associated with the certificate is generated. The
              <var>keygenAlgorithm</var> argument uses the WebCrypto
              [[!WebCryptoAPI]] <a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-AlgorithmIdentifier">
              <code>AlgorithmIdentifier</code></a> type. The
              <var>keygenAlgorithm</var> value MUST be a valid argument to
              <a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#SubtleCrypto-method-generateKey">
              <code>window.crypto.subtle.generateKey</code></a>; that is, the
              value MUST produce a non-error result when normalized according
              to the WebCrypto <a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#algorithm-normalization">
              algorithm normalization process</a> [[!WebCryptoAPI]] with an
              operation name of <code>generateKey</code> and a [[<a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-supportedAlgorithms">supportedAlgorithms</a>]]
              value specific to production of certificates for
              <code>RTCPeerConnection</code>. If the algorithm normalization
              process produces an error, the call to
              <code>generateCertificate</code> MUST be rejected with that
              error.</p>
              <p>Signatures produced by the generated key are used to
              authenticate the DTLS connection. The identified algorithm (as
              identified by the <code>name</code> of the normalized
              <code>AlgorithmIdentifier</code>) MUST be an asymmetric algorithm
              that can be used to produce a signature.</p>
              <p>The certificate produced by this process also contains a
              signature. The validity of this signature is only relevant for
              compatibility reasons. Only the public key and the resulting
              certificate fingerprint are used by
              <code>RTCPeerConnection</code>, but it is more likely that a
              certificate will be accepted if the certificate is well formed.
              The browser selects the algorithm used to sign the certificate; a
              browser SHOULD select SHA-256 [[!FIPS-180-4]] if a hash algorithm
              is needed.</p>
              <p>The resulting certificate MUST NOT include information that
              can be linked to a user or <a>user agent</a>. Randomized values
              for distinguished name and serial number SHOULD be used.</p>
              <p>An optional <code>expires</code> attribute MAY be added to the
              <var>keygenAlgorithm</var> parameter. If this contains a
              <code><a>DOMTimeStamp</a></code> value, it indicates the maximum
              time that the <code><a>RTCCertificate</a></code> is valid for
              relative to the current time. A <a>user agent</a> sets the
              <code><a data-for="RTCCertificate">expires</a></code> attribute
              of the returned <code><a>RTCCertificate</a></code> to the current
              time plus the value of the <code>expires</code> attribute.
              However, a <a>user agent</a> MAY choose to limit the period over
              which an <code><a>RTCCertificate</a></code> is valid.</p>
              <p>A <a>user agent</a> MUST reject a call to
              <code>generateCertificate()</code> with a
              <code>DOMException</code> of type <code>NotSupportedError</code>
              if the <var>keygenAlgorithm</var> parameter identifies an
              algorithm that the <a>user agent</a> cannot or will not use to
              generate a certificate for <code>RTCPeerConnection</code>.</p>
              <p>The following values MUST be supported by a <a>user agent</a>:
              <code>{ name: "<a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#rsassa-pkcs1">RSASSA-PKCS1-v1_5</a>",
              modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]),
              hash: "SHA-256" }</code>, and <code>{ name: "<a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#ecdsa">ECDSA</a>",
              namedCurve: "<a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-NamedCurve">P-256</a>"
              }</code>.</p>
              <p class="note">It is expected that a <a>user agent</a> will have
              a small or even fixed set of values that it will accept.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">keygenAlgorithm</td>
                    <td class="prmType"><code>AlgorithmIdentifier</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em>
                <code>Promise&lt;RTCCertificate&gt;</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <section>
        <h2>RTCCertificate Interface</h2>
        <p>The <dfn><code>RTCCertificate</code></dfn> interface represents a
        certificate used to authenticate WebRTC communications. In addition to
        the visible properties, internal slots contain a handle to the
        generated private keying materal ([[<dfn id=
        "RTCCertificate-handle">handle</dfn>]]) and a certificate ([[<dfn id=
        "RTCCertificate-certificate">certificate</dfn>]]) that
        <code>RTCPeerConnection</code> uses to authenticate with a peer.</p>
        <div>
          <pre class="idl">interface RTCCertificate {
    readonly        attribute DOMTimeStamp expires;
    AlgorithmIdentifier getAlgorithm ();
};</pre>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="RTCCertificate" data-dfn-for="RTCCertificate"
            class="attributes">
              <dt><dfn><code>expires</code></dfn> of type <span class=
              "idlAttrType"><a>DOMTimeStamp</a></span>, readonly</dt>
              <dd>
                <p>The <var>expires</var> attribute indicates the date and time
                in milliseconds relative to 1970-01-01T00:00:00Z after which
                the certificate will be considered invalid by the browser.
                After this time, attempts to construct an
                <code>RTCPeerConnection</code> using this certificate fail.</p>
                <p>Note that this value might not be reflected in a
                <code>notAfter</code> parameter in the certificate itself.</p>
              </dd>
            </dl>
          </section>
          <section>
            <h2>Methods</h2>
            <dl data-link-for="RTCCertificate" data-dfn-for="RTCCertificate"
            class="methods">
              <dt><dfn><code>getAlgorithm</code></dfn></dt>
              <dd>
                <p>Returns the value of <var>keygenAlgorithm</var> passed in
                the call to <code>generateCertificate()</code>.</p>
                <div>
                  <em>No parameters.</em>
                </div>
                <div>
                  <em>Return type:</em> <code>AlgorithmIdentifier</code>
                </div>
              </dd>
            </dl>
          </section>
        </div>
        <p>For the purposes of this API, the [[<a>certificate</a>]] slot
        contains unstructured binary data.</p>
        <p>Note that a <code>RTCCertificate</code> might not directly hold
        private keying material, this might be stored in a secure module.</p>
        <p>The <code>RTCCertificate</code> object can be stored and retrieved
        from persistent storage by an application. When a <a>user agent</a> is
        required to obtain a structured clone [[!HTML]] of a
        <code>RTCCertificate</code> object, it performs the following
        steps:</p>
        <ol>
          <li>Let <var>input</var> and <var>memory</var> be the corresponding
          inputs defined by the internal structured cloning algorithm, where
          <var>input</var> represents a <code>RTCCertificate</code> object to
          be cloned.</li>
          <li>Let <var>output</var> be a newly constructed
          <code>RTCCertificate</code> object.</li>
          <li>Copy the value of the <code>expires</code> attribute from
          <var>input</var> to <var>output</var>.</li>
          <li>Let the [[<a>certificate</a>]] internal slot of <var>output</var>
          be set to the result of invoking the internal structured clone
          algorithm recursively on the corresponding internal slots of
          <var>input</var>, with the slot contents as the new
          "<var>input</var>" argument and <var>memory</var> as the new
          "<var>memory</var>" argument.
          </li>
          <li>Let the [[<a>handle</a>]] internal slot of <var>output</var>
          refer to the same private keying material represented by the
          [[<a>handle</a>]] internal slot of <var>input</var>.
          </li>
        </ol>
      </section>
    </section>
  </section>
  <section>
    <h2>RTP Media API</h2>
    <p>The <dfn>RTP media API</dfn> lets a web application send and receive
    <code>MediaStreamTrack</code>s over a peer-to-peer connection. Tracks, when
    added to a <code>RTCPeerConnection</code>, result in signaling; when this
    signaling is forwarded to a remote peer, it causes corresponding tracks to
    be created on the remote side.</p>
    <p>The actual encoding and transmission of <code>MediaStreamTrack</code>s
    is managed through objects called <code><a>RTCRtpSender</a></code>s.
    Similarly, the reception and decoding of <code>MediaStreamTrack</code>s is
    managed through objects called <code><a>RTCRtpReceiver</a></code>s. Each
    track to be sent is associated with exactly one
    <code><a>RTCRtpSender</a></code>, and each track to be received is
    associated with exactly one <code><a>RTCRtpReceiver</a></code>.</p>
    <p>The encoding and transmission of each <code>MediaStreamTrack</code>
    SHOULD be made such that its characteristics (width, height and frameRate
    for video tracks; volume, sampleSize, sampleRate and channelCount for audio
    tracks) are to a reasonable degree retained by the track created on the
    remote side. There are situations when this does not apply, there may for
    example be resource constraints at either endpoint or in the network or
    there may be <code><a>RTCRtpSender</a></code> settings applied that
    instruct the implementation to act differently.</p>
    <p><code><a>RTCRtpSender</a></code>s are created when the application
    attaches a <code>MediaStreamTrack</code> to a
    <code><a>RTCPeerConnection</a></code>, via the <code>addTrack</code>
    method. <code><a>RTCRtpReceiver</a></code>s, on the other hand, are created
    when remote signaling indicates new tracks are available, and each new
    <code>MediaStreamTrack</code> and its associated
    <code><a>RTCRtpReceiver</a></code> are surfaced to the application via the
    <code>ontrack</code> event. Both <code><a>RTCRtpSender</a></code> and
    <code><a>RTCRtpReceiver</a></code> objects are created by the
    <code>addTransceiver</code> method.</p>
    <p>A <code><a>RTCPeerConnection</a></code> object contains a <dfn id=
    "transceivers-set" data-lt="set of transceivers">set of
    <code><a>RTCRtpTransceiver</a></code>s</dfn>,
    representing the paired senders and receivers with some shared state.
    This set is initialized to the empty set when the
    <code><a>RTCPeerConnection</a></code> object is created.</p>
    <section>
      <h3>RTCPeerConnection Interface Extensions</h3>
      <p>The RTP media API extends the <code><a>RTCPeerConnection</a></code>
      interface as described below.</p>
      <div>
        <pre class="idl">partial interface RTCPeerConnection {
    sequence&lt;RTCRtpSender&gt;      getSenders ();
    sequence&lt;RTCRtpReceiver&gt;    getReceivers ();
    sequence&lt;RTCRtpTransceiver&gt; getTransceivers ();
    RTCRtpSender                addTrack (MediaStreamTrack track, MediaStream... streams);
    void                        removeTrack (RTCRtpSender sender);
    RTCRtpTransceiver           addTransceiver ((MediaStreamTrack or DOMString) trackOrKind, optional RTCRtpTransceiverInit init);
                    attribute EventHandler ontrack;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="attributes">
            <dt><dfn><code>ontrack</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>The event type of this event handler is
              <code><a>track</a></code>.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="methods">
            <dt><code>getSenders</code></dt>
            <dd>
              <p>Returns a sequence of <code><a>RTCRtpSender</a></code> objects
              representing the RTP senders that are currently attached to this
              <code><a>RTCPeerConnection</a></code> object.</p>
              <p>The <dfn id=
              "dom-peerconnection-getsenders"><code>getSenders</code></dfn>
              method MUST return the result of executing the
              <code><a>CollectSenders</a></code> algorithm.<p>
              <p>We define the <dfn>CollectSenders</dfn> algorithm as
              follows:</p>
              <ol>
                <li>Let <var>transceivers</var> be the result of executing
                the <code><a>CollectTransceivers</a></code> algorithm.</li>
                <li>Let <var>senderset</var> be a new empty set.</li>
                <li>For each <var>transceiver</var> in <var>transceivers</var>,
                  <ol>
                    <li>Let <var>sender</var> be
                      <var>transceiver</var>.sender.</li>
                    <li>Add <var>sender</var> to <var>senderset</var>.</li>
                  </ol>
                </li>
                <li>Let <var>senders</var> be a new sequence consisting of
              all the <code><a>RTCRtpSender</a></code> objects in
              <var>senderset</var>.
              The conversion from the senders set to the sequence
              is user agent defined and the order does not have
              to be stable between calls.
                <li>Return <var>senders</var>.
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>sequence&lt;RTCRtpSender&gt;</code>
              </div>
            </dd>
            <dt><code>getReceivers</code></dt>
            <dd>
              <p>Returns a sequence of <code><a>RTCRtpReceiver</a></code>
              objects representing the RTP receivers that are currently
              attached to this <code><a>RTCPeerConnection</a></code>
              object.</p>
              <p>The <dfn id=
              "dom-peerconnection-getreceivers"><code>getReceivers</code></dfn>
              method MUST return the result of executing
              the <code><a>CollectReceivers</a></code> algorithm.<p>
              <p>We define the <dfn>CollectReceivers</dfn> algorithm as
              follows:</p>
              <ol>
                <li>Let <var>transceivers</var> be the result of executing
                the <code><a>CollectTransceivers</a></code> algorithm.</li>
                <li>Let <var>receiverset</var> be a new empty set.</li>
                <li>For each <var>transceiver</var> in <var>transceivers</var>,
                  <ol>
                    <li>Let <var>receiver</var> be
                      <var>transceiver</var>.receiver.</li>
                    <li>Add <var>receiver</var> to <var>receiverset</var>.</li>
                  </ol>
                </li>
                <li>Let <var>receivers</var> be a new sequence consisting of
              all the <code><a>RTCRtpReceiver</a></code> objects in
              <var>receiverset</var>.
              The conversion from the receivers set to the sequence
              is user agent defined and the order does not have
              to be stable between calls.
                <li>Return <var>receivers</var>.
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>sequence&lt;RTCRtpReceiver&gt;</code>
              </div>
            </dd>
            <dt><code>getTransceivers</code></dt>
            <dd>
              <p>Returns a sequence of <code><a>RTCRtpTransceiver</a></code>
              objects representing the RTP transceivers that are currently
              attached to this <code><a>RTCPeerConnection</a></code>
              object.</p>
              <p>The <dfn id=
              "dom-peerconnection-gettranseceivers"><code>getTransceivers</code></dfn>
              method MUST return the result of executing the
              <code><a>CollectTransceivers</a></code> algorithm.<p>
              <p>We define the <dfn>CollectTransceivers</dfn> algorithm as
              follows:</p>
              <ol>
                <li>Let <var>transceivers</var> be a new sequence that
                represents a snapshot of
              all the <code><a>RTCRtpTransceiver</a></code> objects in this
              <code><a>RTCPeerConnection</a></code> object's <a>set of
              transceivers</a>. The conversion from the transceiver set to the
              sequence is user agent defined and the order
              does not have to be stable between calls.</li>
                <li>Return <var>transceivers</var>.</li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>sequence&lt;RTCRtpTransceiver&gt;</code>
              </div>
            </dd>
            <dt><code>addTrack</code></dt>
            <dd>
              <p>Adds a new track to the <code><a>RTCPeerConnection</a></code>,
              and indicates that it is contained in the specified
              <code>MediaStream</code>s.</p>
              <p>When the <dfn><code>addTrack</code></dfn> method is invoked,
              the user agent MUST run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>connection</var> be the
                  <code><a>RTCPeerConnection</a></code> object on which this
                  method was invoked.</p>
                </li>
                <li>
                  <p>Let <var>track</var> be the <code>
                  <a>MediaStreamTrack</a></code> object indicated by the
                  method's first argument.</p>
                </li>
                <li>
                  <p>Let <var>streams</var> be a list of <code>
                  <a>MediaStream</a></code> objects constructed from the
                  method's remaining arguments, or an empty list if the method
                  was called with a single argument.</p>
                </li>
                <li>
                  <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
                  <code>true</code>, throw an <code>InvalidStateError</code>
                  exception and abort these steps.</p>
                </li>
                <li>
                  <p>Let <var>senders</var> be the result of executing the
                    <code><a>CollectSenders</a></code> algorithm.
                    If an <code><a>RTCRtpSender</a></code> for
                  <var>track</var> already exists in <var>senders</var>,
                  throw an
                  <code>InvalidAccessError</code> exception and abort these
                  steps.</p>
                </li>
                <li>
                  <p>The steps below describe how to determine if an existing
                  sender can be reused. Doing so will cause future calls to
                  <code>createOffer</code> and <code>createAnswer</code> to
                  mark the corresponding <a>media description</a> as
                  <code>sendrecv</code> or <code>sendonly</code>
                  and add the MSID of the track added, as defined in
                  <span data-jsep="subsequent-offers subsequent-answers">[[!JSEP]]</span>.</p>
                  <p>If any <code><a>RTCRtpSender</a></code> object in
                  <var>senders</var> matches all the
                  following criteria, let <var>sender</var> be that object, or
                  <code>null</code> otherwise:</p>
                  <ul>
                    <li>
                      <p>The sender's track is null.</p>
                    </li>
                    <li>
                      <p>The <a>transceiver kind</a> of the
                      <code><a>RTCRtpTransceiver</a></code>, associated with
                      the sender, matches <var>track</var>'s kind.</p>
                    </li>
                    <li>
                      <p>The sender has never been used to send. More
                      precisely, the <code><a>RTCRtpTransceiver</a></code>
                      associated with the sender has always had a direction of
                      either <code>recvonly</code> or
                      <code>inactive</code>.</p>
                    </li>
                  </ul>
                </li>
                <li>
                  <p>If <var>sender</var> is not <code>null</code>, run the
                  following steps to use that sender:</p>
                  <ol>
                    <li>
                      <p>Set <var>sender.track</var> to <var>track</var>.</p>
                    </li>
                    <li>
                      <p>Set <var>sender</var>'s
                      [[<a>associated MediaStreams</a>]] to
                      <var>streams</var>.</p>
                    </li>
                    <li>
                      <p>Enable sending direction on the <code>
                      <a>RTCRtpTransceiver</a></code> associated with
                      <var>sender</var>.</p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>If <var>sender</var> is <code>null</code>, run the
                  following steps:</p>
                  <ol>
                    <li>
                      <p><a>Create an RTCRtpSender</a> with <var>track</var>
                      and <var>streams</var> and let <var>sender</var> be the
                      result.</p>
                    </li>
                    <li>
                      <p><a>Create an RTCRtpReceiver</a> with
                      <var>track.kind</var> as kind and let <var>receiver</var>
                      be the result.</p>
                    </li>
                    <li>
                      <p><a>Create an RTCRtpTransceiver</a> with
                      <var>sender</var> and <var>receiver</var> and let
                      <var>transceiver</var> be the result.</p>
                    </li>
                    <li>
                      <p>Add <var>transceiver</var> to <var>connection</var>'s
                      <a href="#transceivers-set">set of transceivers</a> </p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>A track could have contents that are inaccessible to the
                  application. This can be due to being marked with a
                  <code>peerIdentity</code> option or anything that would make
                  a track <a href=
                  "http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#cors-cross-origin">
                  CORS cross-origin</a>. These tracks can be supplied to the
                  <code>addTrack</code> method, and have an
                  <code><a>RTCRtpSender</a></code> created for them, but
                  content MUST NOT be transmitted, unless they are also marked
                  with <code>peerIdentity</code> and they meet the requirements
                  for sending (see <a href="#isolated-pc">isolated streams and
                  <code>RTCPeerConnection</code></a>).</p>
                  <p>All other tracks that are not accessible to the
                  application MUST NOT be sent to the peer, with silence
                  (audio), black frames (video) or equivalently absent content
                  being sent in place of track content.</p>
                  <p>Note that this property can change over time.</p>
                </li>
                <li>
                  <p>Mark <var>connection</var> as needing negotiation.</p>
                </li>
                <li>
                  <p>Return <var>sender</var>.</p>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">track</td>
                    <td class="prmType"><code>MediaStreamTrack</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">streams</td>
                    <td class="prmType"><code>MediaStream</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>RTCRtpSender</code>
              </div>
            </dd>
            <dt><code>removeTrack</code></dt>
            <dd>
              <p>Stops sending media from <var>sender</var>. The
              <code><a>RTCRtpSender</a></code> will still appear in
              <code>getSenders</code>. Doing so will cause future calls to
              <code>createOffer</code> to mark the <a>media description</a> for
              the corresponding transceiver as <code>recvonly</code> or
              <code>inactive</code>, as defined in <span data-jsep=
              "subsequent-offers">[[!JSEP]]</span>. <!-- onended --></p>
              <p>When the other peer stops sending a track in this manner, an
              <code title="event-MediaStreamTrack-ended">ended</code> event is
              fired at the <code><a>MediaStreamTrack</a></code> object.</p>
              <p>When the <dfn><code>removeTrack</code></dfn> method is
              invoked, the user agent MUST run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>connection</var> be the
                  <code><a>RTCPeerConnection</a></code> object on which the
                  <code><a>RTCRtpSender</a></code>, <var>sender</var>, is to be
                  stopped.</p>
                </li>
                <li>
                  <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
                  <code>true</code>, throw an <code>InvalidStateError</code>
                  exception and abort these steps.</p>
                </li>
                <li>
                  <p>Let <var>senders</var> be the result of executing the
                    <code><a>CollectSenders</a></code> algorithm.
                    If <var>sender</var> is <a>stopped</a> or not in
                  <var>senders</var>, then abort
                  these steps.</p>
                </li>
                <li>
                  <p><a>Stop</a> <var>sender</var>.</p>
                </li>
                <li>
                  <p>Mark <var>connection</var> as needing negotiation.</p>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">sender</td>
                    <td class="prmType"><code>RTCRtpSender</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>addTransceiver</code></dfn></dt>
            <dd>
              <p>Create a new <code><a>RTCRtpTransceiver</a></code> and add it
              to the <a>set of transceivers</a>.</p>
              <p>Adding a transceiver will cause future calls to
              <code>createOffer</code> to add a <a>media description</a> for
              the corresponding transceiver, as defined in <span data-jsep=
              "subsequent-offers">[[!JSEP]]</span>.</p>
              <p>The initial value of <code><a data-for=
              "RTCRtpTransceiver">mid</a></code> is null. Setting a new
              <code><a>RTCSessionDescription</a></code> may change it to a
              non-null value, as defined in <span data-jsep=
              "processing-a-local-desc processing-a-remote-desc">[[!JSEP]]</span>.</p>
              <p>When this method is invoked, the User Agent MUST run the
              following steps:</p>
              <ol>
                <li>
                  <p>If the dictionary argument is present, and it has a
                  <code>streams</code> member, let <var>streams</var> be that
                  list of <code> <a>MediaStream</a></code> objects, or an empty
                  list otherwise.</p>
                </li>
                <li>
                  <p>If the dictionary argument is present, and it has a
                  <code>sendEncodings</code> member, let
                  <var>sendEncodings</var> be that list of <code>
                  <a>RTCRtpEncodingParameters</a></code> objects, or an empty
                  list otherwise.</p>
                </li>
                <li>
                  <p>If the first argument is a string, let it be
                  <var>kind</var> and run the following steps:</p>
                  <ol>
                    <li>
                      <p>If <var>kind</var> is not a legal <code>
                      <a>MediaStreamTrack</a></code> <code>kind</code>, throw a
                      <code>TypeError</code> and abort these, and all further
                      steps.</p>
                    </li>
                    <li>
                      <p>Let <var>track</var> be <code>null</code>.</p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>If the first argument is a <code>
                  <a>MediaStreamTrack</a></code>, let it be <var>track</var>
                  and let <var>kind</var> be <var>track.kind</var>.</p>
                </li>
                <li>
                  <p><a>Create an RTCRtpSender</a> with <var>track</var>,
                  <var>streams</var> and <var>sendEncodings</var> and let
                  <var>sender</var> be the result.</p>
                  <p>If <var>sendEncodings</var> is set, then subsequent
                  calls to <code>createOffer</code> will be configured to send
                  multiple RTP encodings as defined in <span data-jsep=
                  "subsequent-offers initial-offers">[[!JSEP]]</span>. When
                  <code>setRemoteDescription</code> is called with a
                  corresponding remote description that is able to receive
                  multiple RTP encodings as defined in [[!JSEP]], the <code>
                  <a>RTCRtpSender</a></code> may send multiple RTP encodings
                  and the parameters retrieved via the transceiver's
                  <code>sender.getParameters()</code> will reflect the
                  encodings negotiated.</p> <p>RID values passed into
                  <code>init.sendEncodings</code> must be composed only of
                  case-sensitive alphanumeric characters (a-z, A-Z, 0-9) up to
                  a maximum of 16 characters.</p>
                </li>
                <li>
                  <p><a>Create an RTCRtpReceiver</a> with <var>kind</var> and
                  let <var>receiver</var> be the result. This specification
                  does not define how to configure <code>createOffer</code>
                  to receive multiple RTP encodings. However when
                  <code>setRemoteDescription</code> is called with a
                  corresponding remote description that is able to send
                  multiple RTP encodings as defined in [[!JSEP]], the <code>
                  <a>RTCRtpReceiver</a></code> may receive multiple RTP encodings
                  and the parameters retrieved via the transceiver's
                  <code>receiver.getParameters()</code> will reflect the
                  encodings negotiated.</p>
                </li>
                <li>
                  <p><a>Create an RTCRtpTransceiver</a> with <var>sender</var>
                  and <var>receiver</var> and let <var>transceiver</var> be the
                  result.</p>
                </li>
                <li>
                  <p>Return <var>transceiver</var>.</p>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">trackOrKind</td>
                    <td class="prmType"><code>(MediaStreamTrack or
                    DOMString)</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">init</td>
                    <td class="prmType"><code>RTCRtpTransceiverInit</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>RTCRtpTransceiver</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCRtpTransceiverInit {
             RTCRtpTransceiverDirection         direction = "sendrecv";
             sequence&lt;MediaStream&gt;              streams;
             sequence&lt;RTCRtpEncodingParameters&gt; sendEncodings;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpTransceiverInit</a>
          Members</h2>
          <dl data-link-for="RTCRtpTransceiverInit" data-dfn-for=
          "RTCRtpTransceiverInit" class="dictionary-members">
            <dt><dfn><code>direction</code></dfn> of type <span class=
            "idlMemberType"><a>RTCRtpTransceiverDirection</a></span>,
            defaulting to <code>"sendrecv"</code></dt>
            <dd>The direction of the <code>RTCRtpTransceiver</code>.</dd>
            <dt><dfn><code>streams</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>MediaStream</a>&gt;</span></dt>
            <dd>
              <p>When the remote PeerConnection's ontrack event fires
              corresponding to the <code><a>RTCRtpReceiver</a></code> being
              added, these are the streams that will be put in the event.</p>
            </dd>
            <dt><dfn><code>sendEncodings</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpEncodingParameters</a>&gt;</span></dt>
            <dd>
              <p>A sequence containing parameters for sending RTP encodings of
              media.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">enum RTCRtpTransceiverDirection {
    "sendrecv",
    "sendonly",
    "recvonly",
    "inactive"
};</pre>
        <table data-link-for="RTCRtpTransceiverDirection" data-dfn-for=
        "RTCRtpTransceiverDirection" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code>sendrecv</code></dfn></td>
              <td>
                The <code><a>RTCRtpTransceiver</a></code>'s
                <code><a>RTCRtpSender</a></code> <var>sender</var>
                will offer to send RTP, and will send RTP if the
                remote peer accepts and
                <code><var>sender.getParameters().encodings[i].active</var></code>
                is "true" for any value of <var>i</var>. The
                <code><a>RTCRtpTransceiver</a></code>'s
                <code><a>RTCRtpReceiver</a></code> will offer to receive RTP,
                and will receive RTP if the remote peer accepts.
              </td>
            </tr>
            <tr>
              <td><dfn><code>sendonly</code></dfn></td>
              <td>
                The <code><a>RTCRtpTransceiver</a></code>'s
                <code><a>RTCRtpSender</a></code> <var>sender</var>
                will offer to send RTP, and will send RTP if the
                remote peer accepts and
                <code><var>sender.getParameters().encodings[i].active</var></code>
                is "true" for any value of <var>i</var>. The
                <code><a>RTCRtpTransceiver</a></code>'s
                <code><a>RTCRtpReceiver</a></code> will not offer to receive
                RTP, and will not receive RTP.
              </td>
            </tr>
            <tr>
              <td><dfn><code>recvonly</code></dfn></td>
              <td>
                The <code><a>RTCRtpTransceiver</a></code>'s
                <code><a>RTCRtpSender</a></code> will not offer to send RTP,
                and will not send RTP. The <code><a>RTCRtpTransceiver</a></code>'s
                <code><a>RTCRtpReceiver</a></code> will offer to receive RTP,
                and will receive RTP if the remote peer accepts.
              </td>
            </tr>
            <tr>
              <td><dfn><code>inactive</code></dfn></td>
              <td>
                The <code><a>RTCRtpTransceiver</a></code>'s
                <code><a>RTCRtpSender</a></code> will not offer to send RTP,
                and will not send RTP. The <code><a>RTCRtpTransceiver</a></code>'s
                <code><a>RTCRtpReceiver</a></code> will not offer to receive
                RTP, and will not receive RTP.
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <section>
        <h4>Processing Remote MediaStreamTracks</h4>
        <p>Rejection of incoming <code><a>MediaStreamTrack</a></code> objects
        can be done by the application, after receiving the track, by stopping
        it.</p>
        <p>To <dfn id="dispatch-receiver">dispatch a receiver</dfn> for an
        incoming media description <span data-jsep=
        "applying-a-remote-desc">[[!JSEP]]</span>, the user agent MUST run the
        following steps:</p>
        <ol>
          <li>
            <p>Let <var>connection</var> be the
            <code><a>RTCPeerConnection</a></code> expecting this media.</p>
          </li>
          <li>
            <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
            <code>true</code>, abort these steps.</p>
          </li>
          <li>
            <p>Let <var>streams</var> be a list of
            <code><a>MediaStream</a></code> objects that the sender indicated
            the sent <code><a>MediaStreamTrack</a></code> being a part of. The
            information needed to collect these objects is part of the media
            description.</p>
          </li>
          <li>
            <p>Run the following steps to create a track representing the
            incoming media description:</p>
            <ol>
              <li>
                <p>Create a <code><a>MediaStreamTrack</a></code> object
                <var>track</var> to represent the media description. The source
                of <var>track</var> is a <dfn>remote source</dfn> provided by
                <var>connection</var>.</p>
              </li>
              <li>
                <p>Initialize <code><var>track</var>.kind</code> attribute to
                <code>audio</code> or <code>video</code> depending on the media
                type of the media description.</p>
              </li>
              <li>
                <p>Initialize <code><var>track</var>.id</code> attribute to the
                media description track id.</p>
              </li>
              <li>
                <p>Initialize <code><var>track</var>.label</code> attribute to
                <code>remote audio</code> or <code>remote video</code>
                depending on the media type of the media description.</p>
              </li>
              <li>
                <p>Initialize <code><var>track</var>.readyState</code>
                attribute to <code>live</code>.</p>
              </li>
              <li>
                <p>Initialize <code><var>track</var>.muted</code> attribute to
                <code>true</code>. See the <a><code>MediaStreamTrack</code></a>
                section about how the <code>muted</code> attribute reflects if
                a <code><a>MediaStreamTrack</a></code> is receiving media data
                or not.</p>
              </li>
            </ol>
          </li>
          <li>
            <p>Add <var>track</var> to all <code><a>MediaStream</a></code>
            objects in <var>streams</var>.</p>
            <p class="note">This will result in an addtrack event being fired
            at each MediaStream as described in [[!GETUSERMEDIA]].</p>
          </li>
          <li>
            <p>Create a new <code><a>RTCRtpReceiver</a></code> object
            <var>receiver</var> for <var>track</var>, and add it to
            <var>connection</var>'s set of receivers.</p>
          </li>
          <li>
            <p>Fire an event named <code title=
            "event-track"><a>track</a></code> with <var>transceiver</var>,
            <var>track</var>, and <var>streams</var> at the
            <var>connection</var> object.</p>
          </li>
        </ol>
        <p>When an <code><a>RTCPeerConnection</a></code> finds that a track
        from the remote peer has been removed, the user agent MUST follow these
        steps:</p>
        <ol>
          <li>
            <p>Let <var>connection</var> be the
            <code><a>RTCPeerConnection</a></code> associated with the track
            being removed.</p>
          </li>
          <li>
            <p>Let <var>track</var> be the <code><a>MediaStreamTrack</a></code>
            object that represents the track being removed, if any. If there
            isn't one, then abort these steps.</p>
          </li>
          <li>
            <p>By definition, <var>track</var> is now ended.</p>
            <p class="note">A task is thus <span title=
            "queue a task">queued</span> to update <var>track</var> and fire an
            event.</p>
          </li>
          <li>
            <p>Queue a task to run the following substeps:</p>
            <ol>
              <li>
                <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
                <code>true</code>, abort these steps.</p>
              </li><!-- close() was probably called just before this
           task ran -->
              <li>
                <p>Remove the <code><a>RTCRtpReceiver</a></code> associated
                with <var>track</var> from <var>connection</var>'s set of
                receivers.</p>
              </li>
            </ol>
          </li>
        </ol>
        <div class="issue">
          <p>Since the beginning of this specification, remote
          MediaStreamTracks have been created by the setRemoteDescription call,
          one track for each non-rejected <a>media description</a> in the
          remote description. This meant that at the caller, MediaStreamTracks
          were not created until the answer was received, and any media
          received prior to a remote description (AKA "early media") would be
          discarded. If any form of remote description is provided (either an
          answer or a pranswer), this issue does not occur.</p>
          <p>If we want to allow early media to be played out, minor changes
          are necessary. Fundamentally, we would need to change when tracks are
          created for the offerer; this would have to happen either as a result
          of setLocalDescription, or when media packets are received. This
          ensures that these objects can be created and connected to media
          elements for playout.</p>
          <p>However, there are three consequences to this potential
          change:</p>
          <ol>
            <li>Media may arrive before the remote DTLS fingerprint has been
            received. This means that media could be played out before the
            validity of the DTLS fingerprint has been established, which may be
            hard to explain to users. As such, it is recommended that media not
            be played out unless some TBD RTCConfiguration property (e.g.
            AllowUnverifiedMedia) has been set.</li>
            <li>The information needed to correlate MediaStreamTracks with
            their enclosing MediaStreams will not yet be present when the
            tracks are initially generated. Therefore, the implementation will
            need to create dummy MediaStream objects for each MediaStreamTrack,
            and then possibly change the associated MediaStream for each track
            when the remote description is received (e.g. if it indicates that
            an audio and video MediaStreamTrack should be combined into a
            single MediaStream). Since media elements act on MediaStreams, some
            complex reshuffling may need to occur when the remote description
            is received.</li>
            <li>The track events fired and their timing will change. For the
            offerer, ontrack will now fire during setLocalDescription, once for
            each track being offered, and track.onended will fire during
            setRemoteDescription for any offered tracks that were rejected. For
            the answerer, ontrack will continue to fire during
            setRemoteDescription, as it does today (this is necessary to allow
            the answerer to reject offered tracks by stopping them).</li>
          </ol>
          <p>For now, we simply make note of this issue, until it can be
          considered fully by the WG.</p>
        </div>
      </section>
    </section>
    <section>
      <h3>RTCRtpSender Interface</h3>
      <p>The <code><dfn>RTCRtpSender</dfn></code> interface allows an application
      to control how a given <code>MediaStreamTrack</code> is encoded and
      transmitted to a remote peer. When <code>setParameters</code> is called
      on an <code><a>RTCRtpSender</a></code> object, the encoding is changed
      appropriately.</p>
      <p>An <code><a>RTCRtpSender</a></code> can be <dfn id=
      "sender-stopped">stopped</dfn>, which indicates that it will no longer
      send any media.</p>
      <p>To <dfn>create an RTCRtpSender</dfn> with a <code>
      <a>MediaStreamTrack</a></code>, <var>track</var>, a list of <code>
      <a>MediaStream</a></code> objects, <var>streams</var>, and optionally a
      list of <code><a>RTCRtpEncodingParameters</a></code> objects,
      <var>sendEncodings</var>, run the following steps:</p>
      <ol>
        <li>
          <p>Let <var>sender</var> be a new <code><a>RTCRtpSender</a></code>
          object.</p>
        </li>
        <li>
          <p>Set <var>sender.track</var> to <var>track</var>.</p>
        </li>
        <li>
          <p>Let <var>sender</var> have an [[<dfn>associated
          MediaStreams</dfn>]] internal slot, representing a list of <code>
          <a>MediaStream</a></code> objects that the <code>
          <a>MediaStreamTrack</a></code> object of this sender is associated
          with.</p>
        </li>
        <li>
          <p>Set <var>sender</var>'s [[<a>associated MediaStreams</a>]] slot to
          <var>streams</var>.</p>
        </li>
        <li>
          <p>Let <var>sender</var> have a [[<dfn>send encodings</dfn>]]
          internal slot, representing a list of <code>
          <a>RTCRtpEncodingParameters</a></code> objects, initialized to an
          empty list.</p>
        </li>
        <li>
          <p>If <var>sendEncodings</var> is given as input to this algorithm,
          set the [[<a>send encodings</a>]] slot to
          <var>sendEncodings</var>.</p>
        </li>
        <li>
          <p>Return <var>sender</var>.</p>
        </li>
      </ol>
      <div>
        <pre class="idl">interface RTCRtpSender {
    readonly        attribute MediaStreamTrack? track;
    readonly        attribute RTCDtlsTransport?  transport;
    readonly        attribute RTCDtlsTransport? rtcpTransport;
    static RTCRtpCapabilities getCapabilities (DOMString kind);
    Promise&lt;void&gt;             setParameters (optional RTCRtpParameters parameters);
    RTCRtpParameters          getParameters ();
    Promise&lt;void&gt;             replaceTrack (MediaStreamTrack withTrack);
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCRtpSender" data-dfn-for="RTCRtpSender" class=
          "attributes">
            <dt><dfn><code>track</code></dfn> of type <span class=
            "idlAttrType"><a>MediaStreamTrack</a></span>, readonly ,
            nullable</dt>
            <dd>
              <p>The <code>track</code> attribute is the track that is
              associated with this <code><a>RTCRtpSender</a></code> object.</p>
            </dd>
            <dt><dfn><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly, nullable</dt>
            <dd>
              <p>The <code>transport</code> attribute is the transport over
              which media from <code>track</code> is sent in the form of RTP
              packets. Prior to construction of the
              <code><a>RTCDtlsTransport</a></code> object, the <code>transport</code>
              attribute will be null. When BUNDLE is used, multiple
              <code><a>RTCRtpSender</a></code> objects will share one
              <code>transport</code> and will all send RTP and RTCP over
              the same transport.</p>
            </dd>
            <dt><dfn><code>rtcpTransport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly ,
            nullable</dt>
            <dd>
              <p>The <code>rtcpTransport</code> attribute is the transport over
              which RTCP is sent and received. Prior to construction of the
              <code><a>RTCDtlsTransport</a></code> object, the <code>rtcpTransport</code>
              attribute will be null. When RTCP mux is used
              (or BUNDLE, which mandates RTCP mux), <code>rtcpTransport</code>
              will be null, and both RTP and RTCP traffic will flow over the
              transport described by <code>transport</code>.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCRtpSender" data-dfn-for="RTCRtpSender" class=
          "methods">
            <dt><code>getCapabilities</code>, static</dt>
            <dd>
              <p>The <dfn><code>RTCRtpSender.getCapabilities</code></dfn>
              method returns the most optimist view on the capabilities of the
              system for sending media of the given kind. It does not reserve
              any resources, ports, or other state but is meant to provide a
              way to discover the types of capabilities of the browser
              including which codecs may be supported.</p>
              <p class="fingerprint">These capabilities provide generally
              persistent cross-origin information on the device and thus
              increases the fingerprinting surface of the application. In
              privacy-sensitive contexts, browsers can consider mitigations
              such as reporting only a common subset of the capabilities.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">kind</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>RTCRtpCapabilities</code>
              </div>
            </dd>
            <dt><dfn><code>setParameters</code></dfn></dt>
            <dd>
              <p>The <code>setParameters</code> method updates how
              <code>track</code> is encoded and transmitted to a remote
              peer.</p>
              <p>When the <code>setParameters</code> method is called, the user
              agent MUST run the following steps:</p>
              <ol>
                <li>Let <var>sender</var> be the
                <code><a>RTCRtpSender</a></code> object on which
                <code>setParameters</code> is invoked.</li>
                <li>Let <var>p</var> be a new promise.</li>
                <li>Return <var>p</var>, performing the next steps in
                parallel.</li>
                <li>If any parameter in the <var>parameters</var> argument,
                marked as a <dfn>Read-only parameter</dfn>, has a value that is
                different from the corresponding parameter value returned from
                <code><a data-link-for=
                "RTCRtpSender">getParameters()</a></code>, abort these steps
                and return a promise rejected with
                <code>InvalidModificationError</code>. Note that this also
                applies to <var>transactionId</var>.</li>
                <li>If the <code>scaleResolutionDownBy</code> parameter in the
                <var>parameters</var> argument has a value less than 1.0, abort
                these steps and return a promise rejected with
                <code>RangeError</code>.</li>
                <li>Set the <code><a>RTCRtpSender</a></code>'s internal
                <var>transactionId</var> slot to a previously unused
                value.</li>
                <li>Resolve <var>p</var> with <code>undefined</code>.</li>
              </ol>
              <p>If codecs are reordered, the new order indicates the
              preference for sending, with the first codec being the codec with
              highest preference. If a codec is removed, that codec will not be
              used to send. The effect of reordering or removing codecs lasts
              until the codecs are renegotiated. After the codecs are
              renegotiated, they are set to the value negotiated, and
              <code>setParameters</code> needs to be called again to re-apply
              codec preferences.</p>
              <p><code>setParameters</code> does not cause SDP renegotiation
              and can only be used to change what the media stack is sending or
              receiving within the envelope negotiated by Offer/Answer. The
              attributes in the <code><a>RTCRtpParameters</a></code> dictionary
              are designed to not enable this, so attributes like
              <code>ssrc</code> that cannot be changed are read only. Other
              things, like bitrate, are controlled using limits such as
              <code>maxBitrate</code>, where the User Agent needs to ensure it
              does not exceed the maximum bitrate specified by
              <code>maxBitrate</code>, while at the same time making sure it
              satisfies constraints on bitrate specified in other places such
              as the SDP.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">parameters</td>
                    <td class="prmType"><code>RTCRtpParameters</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;void&gt;</code>
              </div>
            </dd>
            <dt><code>getParameters</code></dt>
            <dd>
              <p>The <dfn><code>getParameters</code></dfn> method returns the
              <code><a>RTCRtpSender</a></code> object's current parameters for
              how <code>track</code> is encoded and transmitted to a remote
              <code><a>RTCRtpReceiver</a></code>. It may used with
              <code>setParameters</code> to change the parameters in the
              following way:</p>
              <pre class="example highlight">
              var params = sender.getParameters();
// ... make changes to RTCRtpParameters
params.encodings[0].active = false;
sender.setParameters(params)
            </pre>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>RTCRtpParameters</code>
              </div>
            </dd>
            <dt><code>replaceTrack</code></dt>
            <dd>
              <p>Attempts to replace the track being sent with another track
              provided, without renegotiation.</p>
              <p>To avoid track identifiers changing on the remote receiving
              end when a track is replaced, the sender MUST retain the original
              track identifier and stream associations and use these in
              subsequent negotiations.</p>
              <p>When the <dfn><code>replaceTrack</code></dfn> method is
              invoked, the user agent MUST run the following steps:</p>
              <ol>
                <li>Let <var>sender</var> be the
                <code><a>RTCRtpSender</a></code> object on which
                <code>replaceTrack</code> is invoked.</li>
                <li>
                  <p>Let <var>connection</var> be the
                  <code><a>RTCPeerConnection</a></code> object that created
                  <var>sender</var>.</p>
                </li>
                <li>
                  <p>If <var>sender</var> is <a>stopped</a>, return a promise
                  rejected with an <code>InvalidStateError</code>.</p>
                </li>
                <li>
                  <p>Let <var>withTrack</var> be the argument to this
                  method.</p>
                </li>
                <li>
                  <p>Let <var>transceiver</var> be the
                  <code><a>RTCRtpTransceiver</a></code> object associated with
                  <var>sender</var>.</p>
                </li>
                <li>
                  <p>If <code><var>withTrack</var>.kind</code> differs from the
                  <a>transceiver kind</a> of <var>transceiver</var>, return a
                  promise rejected with a <code>TypeError</code>.</p>
                </li>
                <li>
                  <p>If <var>transceiver</var> is not yet associated with a
                  <a>media description</a> <span data-jsep=
                  "rtptransceivers">[[!JSEP]]</span>, then set
                  <var>sender</var>'s <code><a data-for=
                  "RTCRtpSender">track</a></code> attribute to
                  <var>withTrack</var>, and return a promise resolved with
                  <code>undefined</code>.</p>
                </li>
                <li>
                  <p>Let <var>p</var> be a new promise.</p>
                </li>
                <li>
                  <p>Run the following steps in parallel:</p>
                  <ol>
                    <li>
                      <p>Determine if negotiation is needed to transmit
                      <var>withTrack</var> in place of the sender's existing
                      track. Negotiation is not needed if the sender's existing
                      track is ended (which appears as though the track was
                      muted). Ignore which <code>MediaStream</code> the track
                      resides in and the <code>id</code> attribute of the track
                      in this determination. If negotiation is needed, then
                      reject <var>p</var> with
                      <code>InvalidModificationError</code> and abort these
                      steps.</p>
                    </li>
                    <li>
                      <p>Have the sender switch seamlessly to transmitting
                      <var>withTrack</var> instead of the sender's existing track,
                      without negotiating.</p>
                    </li>
                    <li>
                      <p>Queue a task that sets <var>sender</var>'s
                      <code><a data-for="RTCRtpSender">track</a></code>
                      attribute to <var>withTrack</var>, and resolves
                      <var>p</var> with <code>undefined</code>.</p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>Return <var>p</var>.</p>
                </li>
              </ol>
              <div class="note">
                <p>Changing dimensions and/or frame rates might not require
                negotiation. Cases that may require negotiation include:</p>
                <ol>
                  <li>Changing a resolution to a value outside of the
                  negotiated imageattr bounds, as described in
                  [[!RFC6236]].</li>
                  <li>Changing a frame rate to a value that causes the block
                  rate for the codec to be exceeded.</li>
                  <li>A video track differing in raw vs. pre-encoded
                  format.</li>
                  <li>An audio track having a different number of
                  channels.</li>
                  <li>Sources that also encode (typically hardware encoders)
                  might be unable to produce the negotiated codec; similarly,
                  software sources might not implement the codec that was
                  negotiated for an encoding source.</li>
                </ol>
              </div>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">withTrack</td>
                    <td class="prmType"><code>MediaStreamTrack</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;void&gt;</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCRtpParameters {
             DOMString                                 transactionId;
             sequence&lt;RTCRtpEncodingParameters&gt;        encodings;
             sequence&lt;RTCRtpHeaderExtensionParameters&gt; headerExtensions;
             RTCRtcpParameters                         rtcp;
             sequence&lt;RTCRtpCodecParameters&gt;           codecs;
             RTCDegradationPreference                  degradationPreference = "balanced";
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpParameters</a> Members</h2>
          <dl data-link-for="RTCRtpParameters" data-dfn-for="RTCRtpParameters"
          class="dictionary-members">
            <dt><dfn><code>transactionId</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>An unique identifier for the last set of parameters applied.
              Ensures that setParameters can only be called based on a previous
              getParameters, and that there are no intervening changes.</p>
            </dd>
            <dt><dfn><code>encodings</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpEncodingParameters</a>&gt;</span></dt>
            <dd>
              <p>A sequence containing parameters for RTP encodings of
              media.</p>
            </dd>
            <dt><dfn><code>headerExtensions</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpHeaderExtensionParameters</a>&gt;</span></dt>
            <dd>
              <p>A sequence containing parameters for RTP header
              extensions.</p>
            </dd>
            <dt><dfn><code>rtcp</code></dfn> of type <span class=
            "idlMemberType"><a>RTCRtcpParameters</a></span></dt>
            <dd>
              <p>Parameters used for RTCP.</p>
            </dd>
            <dt><dfn><code>codecs</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpCodecParameters</a>&gt;</span></dt>
            <dd>
              <p>
                A sequence containing the media codecs that an <code><a>RTCRtpSender</a></code>
                will choose from, as well as entries for RTX, RED and FEC mechanisms.
                Corresponding to each media codec where retransmission via RTX is enabled,
                there will be an entry in <code>codecs[]</code> with a <code>mimeType</code>
                attribute indicating retransmission via "audio/rtx" or "video/rtx", and an
                <code>sdpFmtpLine</code> attribute (providing the "apt" and "rtx-time"
                parameters).
              </p>
            </dd>
            <dt><dfn><code>degradationPreference</code></dfn> of type
            <span class="idlMemberType"><a>RTCDegradationPreference</a></span>,
            defaulting to <code>"balanced"</code></dt>
            <dd>
              <p>When bandwidth is constrained and the
              <code><a>RtpSender</a></code> needs to choose between degrading
              resolution or degrading framerate,
              <code>degradationPreference</code> indicates which is
              preferred.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCRtpEncodingParameters {
             unsigned long       ssrc;
             RTCRtpRtxParameters rtx;
             RTCRtpFecParameters fec;
             RTCDtxStatus        dtx;
             boolean             active;
             RTCPriorityType     priority;
             unsigned long       maxBitrate;
             unsigned long       maxFramerate;
             DOMString           rid;
             double              scaleResolutionDownBy = 1.0;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpEncodingParameters</a>
          Members</h2>
          <dl data-link-for="RTCRtpEncodingParameters" data-dfn-for=
          "RTCRtpEncodingParameters" class="dictionary-members">
            <dt><dfn><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The SSRC of the RTP source stream of this encoding (non-RTX,
              non-FEC RTP stream). <a>Read-only parameter</a>.</p>
            </dd>
            <dt><dfn><code>rtx</code></dfn> of type <span class=
            "idlMemberType"><a>RTCRtpRtxParameters</a></span></dt>
            <dd>
              <p>The parameters used for RTX, or unset if RTX is not being
              used.</p>
            </dd>
            <dt><dfn><code>fec</code></dfn> of type <span class=
            "idlMemberType"><a>RTCRtpFecParameters</a></span></dt>
            <dd>
              <p>The parameters used for FEC, or unset if FEC is not being
              used.</p>
            </dd>
            <dt><dfn><code>dtx</code></dfn> of type <span class=
            "idlMemberType"><a>RTCDtxStatus</a></span></dt>
            <dd>
              <p>
                For an <code><a>RTCRtpSender</a></code>, indicates whether
                discontinuous transmission will be used. Setting it to
                <code>disabled</code> causes discontinuous transmission
                to be turned off. Setting it to <code>enabled</code>
                causes discontinuous transmission to be turned on if
                it was negotiated (either via a codec-specific parameter
                or via negotiation of the CN codec). This attribute is
                ignored by a video sender.
              </p>
            <dt><dfn><code>active</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span></dt>
            <dd>
              <p>For an <code><a>RTCRtpSender</a></code>, indicates that this
              encoding is actively being sent. Setting it to false causes this
              encoding to no longer be sent. Setting it to true causes this
              encoding to be sent. For an <code><a>RTCRtpReceiver</a></code>,
              indicates that this encoding is being decoded. Setting it to
              false causes this encoding to no longer be decoded. Setting it to
              true causes this encoding to be decoded.</p>
            </dd>
            <dt><dfn><code>priority</code></dfn> of type <span class=
            "idlMemberType"><a>RTCPriorityType</a></span></dt>
            <dd>
              <p>Indicates the priority of this encoding. It is specified in
              [[!RTCWEB-TRANSPORT]], Section 4.</p>
            </dd>
            <dt><dfn><code>maxBitrate</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>Indicates the maximum bitrate that can be used to send this
              encoding. The encoding may also be further constrained by other
              limits (such as maxFramerate or per-transport or per-session
              bandwidth limits) below the maximum specified here. maxBitrate is
              the Transport Independent Application Specific Maximum (TIAS)
              bandwidth defined in [[RFC3890]] Section 6.2.2, which is the
              maximum bandwidth needed without counting IP or other transport
              layers like TCP or UDP.</p>
            </dd>
            <dt><dfn><code>maxFramerate</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>Indicates the maximum framerate that can be used to send this
              encoding.</p>
            </dd>
            <dt><dfn><code>rid</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>If set, this RTP encoding will be sent with the RID
              header extension as defined
              by <span data-jsep="initial-offers">[[!JSEP]]</span>. The
              RID is not modifiable via
              <code>setParameters</code>. It can only be set or modified in
              <code>addTransceiver</code> or <code>addTrack</code>.</p>
            </dd>
            <dt><dfn><code>scaleResolutionDownBy</code></dfn> of type
            <span class="idlMemberType"><a>double</a></span>, defaulting to
            <code>1.0</code></dt>
            <dd>
              <p>If the sender's <code>kind</code> is "video", the video's
              resolution will be scaled down in each dimension by the given
              value before sending. For example, if the value is 2.0, the video
              will be scaled down by a factor of 2 in each dimension, resulting
              in sending a video of one quarter the size. If the value is 1.0,
              the video will not be affected. The value must be greater than or
              equal to 1.0.</p>
            </dd>
          </dl>
          <p>Usage of the attributes is defined in the table below:</p>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Attribute</th>
                            <th>Type</th>
                            <th>Receiver/Sender</th>
                            <th>Read/Write</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr id="def-ssrc*">
                           <td><dfn>ssrc</dfn></td>
                            <td>
                                <code>unsigned long</code>
                            </td>
                            <td>Receiver/Sender</td>
                            <td>Read-only</td>
                        </tr>
                        <tr id="def-fec*">
                           <td><dfn>fec</dfn></td>
                            <td>
                                <code><a>RTCRtpFecParameters</a></code>
                            </td>
                            <td>Receiver/Sender</td>
                            <td>Read-only</td>
                        </tr>
                        <tr id="def-dtx*">
                           <td><dfn>dtx</dfn></td>
                            <td>
                                <code><a>RTCDtxStatus</a></code>
                            </td>
                            <td>Sender</td>
                            <td>Read/Write</td>
                        </tr>
                        <tr id="def-rtx*">
                           <td><dfn>rtx</dfn></td>
                            <td>
                                <code><a>RTCRtpRtxParameters</a></code>
                            </td>
                            <td>Receiver/Sender</td>
                            <td>Read-only</td>
                        </tr>
                        <tr id="def-active*">
                           <td><dfn>active</dfn></td>
                            <td>
                                <code>boolean</code>
                            </td>
                            <td>Sender</td>
                            <td>Read/Write</td>
                        </tr>
                        <tr id="def-priority*">
                           <td><dfn>priority</dfn></td>
                            <td>
                                <code><a>RTCPriorityType</a></code>
                             </td>
                            <td>Sender</td>
                            <td>Read/Write</td>
                        </tr>
                        <tr id="def-maxbitrate*">
                           <td><dfn>maxBitrate</dfn></td>
                            <td>
                                <code>unsigned long</code>
                            </td>
                            <td>Sender</td>
                            <td>Read/Write</td>
                        </tr>
                        <tr id="def-maxframerate*">
                           <td><dfn>maxFramerate</dfn></td>
                            <td>
                                <code>unsigned long</code>
                            </td>
                            <td>Sender</td>
                            <td>Read/Write</td>
                        </tr>
                        <tr id="def-scaleresolution*">
                           <td><dfn>scaleResolutionDownBy</dfn></td>
                            <td>
                                <code>double</code>
                            </td>
                            <td>Sender</td>
                            <td>Read/Write</td>
                        </tr>
                        <tr id="def-rid*">
                           <td><dfn>rid</dfn></td>
                            <td>
                                <code>DOMString</code>
                            </td>
                            <td>Receiver/Sender</td>
                            <td>Read-only</td>
                        </tr>
                    </tbody>
                </table>
        </section>
      </div>
      <div>
         <pre class="idl">enum RTCDtxStatus {
         "disabled",
         "enabled"
         };</pre>
         <table data-link-for="RTCDtxStatus" data-dfn-for="RTCDtxStatus" class="simple">
           <tbody>
             <tr>
               <th colspan="2">Enumeration description</th>
             </tr>
             <tr>
               <td><dfn><code>disabled</code></dfn></td>
               <td>
                 <p>Discontinuous transmission is disabled.</p>
               </td>
             </tr>
             <tr>
               <td><dfn><code>enabled</code></dfn></td>
               <td>
                 <p>Discontinuous transmission is enabled if negotiated.</p>
               </td>
             </tr>
           </tbody>
         </table>
      </div>
      <div>
        <pre class="idl">enum RTCDegradationPreference {
    "maintain-framerate",
    "maintain-resolution",
    "balanced"
};</pre>
        <table data-link-for="RTCDegradationPreference" data-dfn-for=
        "RTCDegradationPreference" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code>maintain-framerate</code></dfn></td>
              <td>
                <p>Degrade resolution in order to maintain framerate.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code>maintain-resolution</code></dfn></td>
              <td>
                <p>Degrade framerate in order to maintain resolution.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code>balanced</code></dfn></td>
              <td>
                <p>Degrade a balance of framerate and resolution.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <div>
        <pre class="idl">dictionary RTCRtpRtxParameters {
             unsigned long ssrc;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpRtxParameters</a>
          Members</h2>
          <dl data-link-for="RTCRtpRtxParameters" data-dfn-for=
          "RTCRtpRtxParameters" class="dictionary-members">
            <dt><dfn><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The SSRC of the RTP stream for RTX. <a>Read-only
              parameter</a>.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCRtpFecParameters {
             unsigned long ssrc;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpFecParameters</a>
          Members</h2>
          <dl data-link-for="RTCRtpFecParameters" data-dfn-for=
          "RTCRtpFecParameters" class="dictionary-members">
            <dt><dfn><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The SSRC of the RTP stream for FEC. <a>Read-only
              parameter</a>.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCRtcpParameters {
             DOMString cname;
             boolean   reducedSize;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtcpParameters</a> Members</h2>
          <dl data-link-for="RTCRtcpParameters" data-dfn-for=
          "RTCRtcpParameters" class="dictionary-members">
            <dt><dfn><code>cname</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The Canonical Name (CNAME) used by RTCP (e.g. in SDES
              messages). <a>Read-only parameter</a>.</p>
            </dd>
            <dt><dfn><code>reducedSize</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span></dt>
            <dd>
              <p>Whether reduced size RTCP [[RFC5506]] is configured (if true)
              or compound RTCP as specified in [[RFC3550]] (if false).
              <a>Read-only parameter</a>.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCRtpHeaderExtensionParameters {
             DOMString      uri;
             unsigned short id;
             boolean        encrypted;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpHeaderExtensionParameters</a>
          Members</h2>
          <dl data-link-for="RTCRtpHeaderExtensionParameters" data-dfn-for=
          "RTCRtpHeaderExtensionParameters" class="dictionary-members">
            <dt><dfn><code>uri</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The URI of the RTP header extension, as defined in
              [[RFC5285]]. <a>Read-only parameter</a>.</p>
            </dd>
            <dt><dfn><code>id</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span></dt>
            <dd>
              <p>The value put in the RTP packet to identify the header
              extension. <a>Read-only parameter</a>.</p>
            </dd>
            <dt><dfn><code>encrypted</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span></dt>
            <dd>
              <p>Whether the header extension is encryted or not. <a>Read-only
              parameter</a>.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCRtpCodecParameters {
             unsigned short payloadType;
             DOMString      mimeType;
             unsigned long  clockRate;
             unsigned short channels = 1;
             DOMString      sdpFmtpLine;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpCodecParameters</a>
          Members</h2>
          <dl data-link-for="RTCRtpCodecParameters" data-dfn-for=
          "RTCRtpCodecParameters" class="dictionary-members">
            <dt><dfn><code>payloadType</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span></dt>
            <dd>
              <p>The RTP payload type. This value can be set to control which
              codec should be used to send a given encoding.</p>
            </dd>
            <dt><dfn><code>mimeType</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The codec MIME media type/subtype. Valid media types
              and subtypes are listed in [[IANA-RTP-2]].</p>
            </dd>
            <dt><dfn><code>clockRate</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The codec clock rate expressed in Hertz.</p>
            </dd>
            <dt><dfn><code>channels</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span>, defaulting to
            <code>1</code></dt>
            <dd>
              <p>The number of channels (mono=1, stereo=2).</p>
            </dd>
            <dt><dfn><code>sdpFmtpLine</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The a=fmtp line in the SDP corresponding to the codec, as
              defined by <span data-jsep="parsing-a-desc">[[!JSEP]]</span>.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCRtpCapabilities {
             sequence&lt;RTCRtpCodecCapability&gt;           codecs;
             sequence&lt;RTCRtpHeaderExtensionCapability&gt; headerExtensions;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpCapabilities</a> Members</h2>
          <dl data-link-for="RTCRtpCapabilities" data-dfn-for=
          "RTCRtpCapabilities" class="dictionary-members">
            <dt><dfn><code>codecs</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpCodecCapability</a>&gt;</span></dt>
            <dd>
              <p>
                Supported media codecs as well as entries for RTX, RED and FEC mechanisms.
                There will only be a single entry in <code>codecs[]</code> for retransmission
                via RTX.
              </p>
            </dd>
            <dt><dfn><code>headerExtensions</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpHeaderExtensionCapability</a>&gt;</span></dt>
            <dd>
              <p>Supported RTP header extensions.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCRtpCodecCapability {
             DOMString mimeType;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpCodecCapability</a>
          Members</h2>
          <dl data-link-for="RTCRtpCodecCapability" data-dfn-for=
          "RTCRtpCodecCapability" class="dictionary-members">
            <dt><dfn><code>mimeType</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The codec MIME media type/subtype. Valid media types
              and subtypes are listed in [[IANA-RTP-2]].</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCRtpHeaderExtensionCapability {
             DOMString uri;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpHeaderExtensionCapability</a>
          Members</h2>
          <dl data-link-for="RTCRtpHeaderExtensionCapability" data-dfn-for=
          "RTCRtpHeaderExtensionCapability" class="dictionary-members">
            <dt><dfn><code>uri</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The URI of the RTP header extension, as defined in
              [[RFC5285]].</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>RTCRtpReceiver Interface</h3>
      <p>The <code>RTCRtpReceiver</code> interface allows an application to
      control the receipt of a <code>MediaStreamTrack</code>. When attributes
      on an <code>RTCRtpReceiver</code> are modified, a negotiation is
      triggered to signal the changes regarding what the application wants to
      receive to the other side.</p>
      <p>To <dfn>create an RTCRtpReceiver</dfn> with kind, <var>kind</var>, and
      optionally an id string, <var>id</var>, run the following steps:</p>
      <ol>
        <li>
          <p>Let <var>sender</var> be a new <code><a>RTCRtpSender</a></code>
          object.</p>
        </li>
        <li>
          <p>Let <var>track</var> be a new <code><a>MediaStreamTrack</a></code>
          object [[!GETUSERMEDIA]].</p>
        </li>
        <li>
          <p>Initialize <var>track.kind</var> to <var>kind</var>.
        </li>
        <li>
          <p>If an id, <var>id</var>, was given as input to this algorithm,
          initialize <var>track.id</var> to <var>id</var>. (Otherwise the value
          generated when <var>track</var> was created will be used.)</p>
        </li>
        <li>
          <p>Initialize <var>track.label</var> to the result of concatenating
          the string <code>"remote "</code> with <var>kind</var>.
        </li>
        <li>
          <p>Initialize <var>track.readyState</var> to <code>live</code>.</p>
        </li>
        <li>
          <p>initialize <var>track.muted</var> to <code>true</code>. See the
          <a><code>MediaStreamTrack</code></a> section about how the
          <code>muted</code> attribute reflects if a <code>
          <a>MediaStreamTrack</a></code> is receiving media data or not.</p>
        </li>
        <li>
          <p>Set <var>sender.track</var> to <var>track</var>.</p>
        </li>
        <li>
          <p>Return <var>sender</var>.</p>
        </li>
      </ol>
      <div>
        <pre class="idl">interface RTCRtpReceiver {
    readonly        attribute MediaStreamTrack  track;
    readonly        attribute RTCDtlsTransport?  transport;
    readonly        attribute RTCDtlsTransport? rtcpTransport;
    static RTCRtpCapabilities          getCapabilities (DOMString kind);
    RTCRtpParameters                   getParameters ();
    sequence&lt;RTCRtpContributingSource&gt; getContributingSources ();
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCRtpReceiver" data-dfn-for="RTCRtpReceiver"
          class="attributes">
            <dt><dfn><code>track</code></dfn> of type <span class=
            "idlAttrType"><a>MediaStreamTrack</a></span>, readonly</dt>
            <dd>
            <p>
                The <code id="dom-rtpreceiver-track">track</code>
                attribute is the track that is associated with this
                <code><a>RTCRtpReceiver</a></code> object. Note that
                <code>track.stop()</code> is final, although clones
                are not affected. Since <code>receiver.track.stop()</code> does
                not implicitly stop <var>receiver</var>,
                Receiver Reports continue to be sent.
            </p>
            </dd>
            <dt><code>transport</code> of type <span class=
            "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly, nullable</dt>
            <dd>
              <p>The <dfn><code>transport</code></dfn> attribute is the
              transport over which media for the receiver's <code>track</code>
              is received in the form of RTP packets. Prior to construction of the
              <code><a>RTCDtlsTransport</a></code> object, the <code>transport</code>
              attribute will be null. When BUNDLE is used, multiple
              <code><a>RTCRtpReceiver</a></code> objects will share one
              <code>transport</code> and will all receive RTP and RTCP over
              the same transport.</p>
            </dd>
            <dt><code>rtcpTransport</code> of type <span class=
            "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly ,
            nullable</dt>
            <dd>
              <p>The <dfn><code>rtcpTransport</code></dfn> attribute is the
              transport over which RTCP is sent and received. Prior to
              construction of the <code><a>RTCDtlsTransport</a></code> object,
              the <code>rtcpTransport</code> attribute will be null. When
              RTCP mux is used (or BUNDLE, which mandates RTCP mux),
              <code>rtcpTransport</code> will be null, and both RTP and
              RTCP traffic will flow over <code>transport</code>.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCRtpReceiver" data-dfn-for="RTCRtpReceiver"
          class="methods">
            <dt><code>getCapabilities</code>, static</dt>
            <dd>
              <p>The <dfn><code>RTCRtpReceiver.getCapabilities</code></dfn>
              method returns the most optimistic view of the capabilities of
              the system for receiving media of the given kind. It does not
              reserve any resources, ports, or other state but is meant to
              provide a way to discover the types of capabilities of the
              browser including which codecs may be supported.</p>
              <p class="fingerprint">These capabilities provide generally
              persistent cross-origin information on the device and thus
              increases the fingerprinting surface of the application. In
              privacy-sensitive contexts, browsers can consider mitigations
              such as reporting only a common subset of the capabilities.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">kind</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>RTCRtpCapabilities</code>
              </div>
            </dd>
            <dt><dfn><code>getParameters</code></dfn></dt>
            <dd>
              <p>The <code>getParameters</code> method returns the
              <code>RTCRtpReceiver</code> object's current parameters for how
              <code>track</code> is decoded.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>RTCRtpParameters</code>
              </div>
            </dd>
            <dt><dfn><code>getContributingSources</code></dfn></dt>
            <dd>
              <p>Returns an <code><a>RTCRtpContributingSource</a></code> for
              each unique CSRC or SSRC received by this RTCRtpReceiver in the
              last 10 seconds.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>sequence&lt;RTCRtpContributingSource&gt;</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <p>The <dfn>RTCRtpContributingSource</dfn> objects contain information
      about a given contributing source, including the time the most recent
      time a packet was received from the source. The browser MUST keep
      information from RTP packets received in the previous 10 seconds. Each
      time an RTP packet is received, the
      <code><a>RTCRtpContributingSource</a></code> objects are updated. If the
      RTP packet contains CSRCs, then the
      <code><a>RTCRtpContributingSource</a></code> objects corresponding to
      those CSRCs are updated. If the RTP packet contains no CSRCs, then the
      <code><a>RTCRtpContributingSource</a></code> object corresponding to the
      SSRC is updated.</p>
      <div>
        <pre class="idl">interface RTCRtpContributingSource {
    readonly        attribute DOMHighResTimeStamp timestamp;
    readonly        attribute unsigned long       source;
    readonly        attribute byte?               audioLevel;
    readonly        attribute boolean?            voiceActivityFlag;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCRtpContributingSource" data-dfn-for=
          "RTCRtpContributingSource" class="attributes">
            <dt><dfn><code>timestamp</code></dfn> of type <span class=
            "idlAttrType"><a>DOMHighResTimeStamp</a></span>, readonly</dt>
            <dd>
              <p>The timestamp of type DOMHighResTimeStamp [[!HIGHRES-TIME]],
              indicating the time of reception of the most recent RTP packet
              containing the source. The timestamp is defined in
              [[!HIGHRES-TIME]] and corresponds to a local clock.</p>
            </dd>
            <dt><dfn><code>source</code></dfn> of type <span class=
            "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
            <dd>
              <p>The CSRC or SSRC value of the contributing source.</p>
            </dd>
            <dt><dfn><code>audioLevel</code></dfn> of type <span class=
            "idlAttrType"><a>byte</a></span>, readonly , nullable</dt>
            <dd>
              <p>The audio level contained in the last RTP packet received from
              this source. If the source was set from an SSRC, this will be the
              level value defined in [[!RFC6464]]. If an RFC 6464 extension
              header is not present, the browser will compute the value as if
              it had come from RFC 6464 and use that. If the source was set
              from a CSRC, this will be the level value defined in
              [[!RFC6465]]. RFC 6464 and 6465 define the level as a integral
              value from 0 to 127 representing the audio level in negative
              decibels relative to the loudest signal that they system could
              possibly encode. Thus, 0 represents the loudest signal the system
              could possibly encode, and 127 represents silence.</p>
            </dd>
            <dt><dfn><code>voiceActivityFlag</code></dfn> of type <span class=
            "idlAttrType"><a>boolean</a></span>, readonly , nullable</dt>
            <dd>
              <p>Whether the last RTP packet received from this source contains
              voice activity (true) or not (false). Since the "V" bit is
              supported in [[!RFC6464]] but not [[!RFC6465]], the
              <var>voiceActivityFlag</var> attribute will only be set for RTP
              packets received from peers enabling the client-mixer header
              extension with the "vad" extension set to "on".</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>RTCRtpTransceiver Interface</h3>
      <p>The <a><code>RTCRtpTransceiver</code></a> interface represents a
      combination of an <a><code>RTCRtpSender</code></a> and an
      <a><code>RTCRtpReceiver</code></a> that share a common
      <code>mid</code>.</p>
      <p>The <dfn>transceiver kind</dfn> of an
      <code><a>RTCRtpTransceiver</a></code> is defined by the kind of the
      associated <code><a>RTCRtpReceiver</a></code>'s
      <code><a>MediaStreamTrack</a></code> object.</p>
      <p>To <dfn>create an RTCRtpTransceiver</dfn> with an <code>
      <a>RTCRtpReceiver</a></code> object, <var>receiver</var>, and an <code>
      <a>RTCRtpSender</a></code> object, <var>sender</var>, run the following
      steps:</p>
      <ol>
        <li>
          <p>Let <var>transceiver</var> be a new <code>
          <a>RTCRtpTransceiver</a></code> object.</p>
        </li>
        <li>
          <p>Set <var>transceiver.sender</var> to <var>sender</var>.</p>
        </li>
        <li>
          <p>Set <var>transceiver.receiver</var> to <var>receiver</var>.</p>
        </li>
        <li>
          <p>Set <var>transceiver.stopped</var> to <code>false</code>.</p>
        </li>
        <li>
          <p>Return <var>transceiver</var>.</p>
        </li>
      </ol>      <div>
        <pre class="idl">interface RTCRtpTransceiver {
    readonly        attribute DOMString?                 mid;
    [SameObject]
    readonly        attribute RTCRtpSender               sender;
    [SameObject]
    readonly        attribute RTCRtpReceiver             receiver;
    readonly        attribute boolean                    stopped;
    readonly        attribute RTCRtpTransceiverDirection direction;
    void setDirection (RTCRtpTransceiverDirection direction);
    void stop ();
    void setCodecPreferences (sequence&lt;RTCRtpCodecCapability&gt; codecs);
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCRtpTransceiver" data-dfn-for=
          "RTCRtpTransceiver" class="attributes">
            <dt><code>mid</code> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly , nullable</dt>
            <dd>
              <p>The <dfn id="dom-rtptransceiver-mid"><code>mid</code></dfn>
              attribute is the <code>mid</code> negotatiated and present in the
              local and remote descriptions as defined in
              <span data-jsep="initial-offers initial-answers">[[!JSEP]]</span>.
              Before negotiation is complete, the <code>mid</code> value may
              be null. If there is no MID value in the remote SDP, and no MID
              value was previously assigned, a random value will be created for
              the <code>mid</code> as described in <span data-jsep=
              "ice-candidate-format">[[!JSEP]]</span> when the remote SDP is
              set. After rollbacks, the value may change from a non-null value
              to null.</p>
            </dd>
            <dt><dfn><code>sender</code></dfn> of type <span class=
            "idlAttrType"><a>RTCRtpSender</a></span>, readonly</dt>
            <dd>
              <p>The <code>sender</code> attribute is the
              <a><code>RTCRtpSender</code></a> corresponding to the RTP media
              that may be sent with mid = <a><code>mid</code></a>.</p>
            </dd>
            <dt><dfn><code>receiver</code></dfn> of type <span class=
            "idlAttrType"><a>RTCRtpReceiver</a></span>, readonly</dt>
            <dd>
              <p>The <code>receiver</code> attribute is the
              <a><code>RTCRtpReceiver</code></a> corresponding to the RTP media
              that may be received with mid = <a><code>mid</code></a>.</p>
            </dd>
            <dt><dfn><code>stopped</code></dfn> of type <span class=
            "idlAttrType"><a>boolean</a></span>, readonly</dt>
            <dd>
              <p>The <code>stopped</code> attribute indicates that the sender
              of this transceiver will no longer send, and that the receiver
              will no longer receive. It is true if either <code>stop</code>
              has been called or if setting the local or remote description has
              caused the <a><code>RTCRtpReceiver</code></a> to be stopped.</p>
            </dd>
            <dt><dfn><code>direction</code></dfn> of type <span class=
            "idlAttrType"><a>RTCRtpTransceiverDirection</a></span>,
            readonly</dt>
            <dd>
              <p>The <var>direction</var> attribute indicates the direction of
              this transceiver. The value of <var>direction</var> is
              independent of the value of <var>encodings[].active</var> since
              one cannot be deduced from the other. If the <code>stop()</code>
              method is called, <var>direction</var> retains the value it had
              prior to calling <code>stop()</code>.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCRtpTransceiver" data-dfn-for=
          "RTCRtpTransceiver" class="methods">
            <dt><code>setDirection</code></dt>
            <dd>
              <p>The <dfn id=
              "dom-rtptransceiver-setdirection"><code>setDirection</code></dfn>
              method sets the direction of the <code>RTCRtpTransceiver</code>.
              Calls to <code>setDirection()</code> do not take effect immediately.
              Instead, future calls to <code>createOffer</code> and
              <code>createAnswer</code> mark the corresponding media
              description as <code>sendrecv</code>, <code>sendonly</code>,
              <code>recvonly</code> or <code>inactive</code> as defined in
              <span data-jsep=
              "subsequent-offers subsequent-answers">[[!JSEP]]</span>. Calling
              <code>setDirection()</code> sets the negotiation-needed flag.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">direction</td>
                    <td class="prmType">
                    <code>RTCRtpTransceiverDirection</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><code>stop</code></dt>
            <dd>
              <p>The <dfn><code>stop</code></dfn> method stops the
              <a><code>RTCRtpTransceiver</code></a>. The sender of this
              transceiver will no longer send, the receiver will no longer
              receive, and the negotiation-needed flag is set.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>setCodecPreferences</code></dfn></dt>
            <dd>
              <p>The <code>setCodecPreferences</code> method overrides the
              default codec preferences used by the <a>user agent</a>. When
              generating a session description using either
              <code>createOffer</code> or <code>createAnswer</code>, the
              <a>user agent</a> MUST use the indicated codecs, in the order
              specified in the <var>codecs</var> argument, for the media
              section corresponding to this <code>RTCRtpTransceiver</code>.
              Note that calls to <code>createAnswer</code> will use only the
              common subset of these codecs and the codecs that appear in the
              offer.</p>
              <p>This method allows applications to disable the negotiation of
              specific codecs. It also allows an application to cause a remote
              peer to prefer the codec that appears first in the list for
              sending.</p>
              <p>Codec preferences remain in effect for all calls to
              <code>createOffer</code> and <code>createAnswer</code> that
              include this <code>RTCRtpTransceiver</code> until this method is
              called again. Setting <var>codecs</var> to an empty sequence
              resets codec preferences to any default value.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">codecs</td>
                    <td class="prmType">
                    <code>sequence&lt;RTCRtpCodecCapability&gt;</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
        <section>
          <h3>"Hold" functionality</h3>
          <p>
            Together, the <code>setDirection</code>, <code>getParameters</code>,
            <code>setParameters</code> and <code>replaceTrack</code> methods enable
            developers to implement "hold" scenarios.
          </p>
          <p>To send music to a peer and cease rendering received audio:</p>
          <pre class="example highlight">
            // Assume we have an audio transceiver and a music track named musicTrack
            audio.sender.replaceTrack(musicTrack);
            // Set the direction to send-only (requires negotiation)
            audio.setDirection("sendonly");
          </pre>
          <p>To stop sending audio to a peer:</p>
          <pre class="example highlight">
            var params = audio.sender.getParameters();
            params.encodings[0].active = false;
            audio.sender.setParameters(params);
          </pre>
          <p>To re-enable sending audio captured from a microphone as well as rendering of received audio:</p>
          <pre class="example highlight">
            //assume we have an audio transceiver and a microphone track named micTrack
            audio.sender.replaceTrack(micTrack);
            // Set the direction to sendrecv (requires negotiation)
            audio.setDirection("sendrecv");
          </pre>
          <p>To re-enable sending audio to a peer:</p>
          <pre class="example highlight">
            var params = audio.sender.getParameters();
            params.encodings[0].active = true;
            audio.sender.setParameters(params);
          </pre>
      </section>
    </section>
    <section>
      <h3>RTCDtlsTransport Interface</h3>
      <p>The <code><a>RTCDtlsTransport</a></code> interface allows an
      application access to information about the Datagram Transport Layer
      Security (DTLS) transport over which RTP and RTCP packets are sent and
      received by <code><a>RTCRtpSender</a></code> and
      <code><a>RTCRtpReceiver</a></code> objects, as well other data such as
      SCTP packets sent and received by data channels. In particular, DTLS adds
      security to an underlying transport, and the
      <code>RTCDtlsTransport</code> interface allows access to information
      about the underlying transport and the security added.
      <code><a>RTCDtlsTransport</a></code> objects are constructed
      as a result of calls to <code>setLocalDescription()</code>
      and <code>setRemoteDescription()</code>.</p>
      <div>
        <pre class="idl">interface RTCDtlsTransport {
    readonly        attribute RTCIceTransport       transport;
    readonly        attribute RTCDtlsTransportState state;
    sequence&lt;ArrayBuffer&gt; getRemoteCertificates ();
                    attribute EventHandler          onstatechange;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDtlsTransport" data-dfn-for="RTCDtlsTransport"
          class="attributes">
            <dt><dfn><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceTransport</a></span>, readonly</dt>
            <dd>
              <p>The <code>transport</code> attribute is the underlying
              transport that is used to send and receive packets. The
              underlying transport may not be shared between multiple active
              <code><a>RTCDtlsTransport</a></code> objects.</p>
            </dd>
            <dt><dfn><code>state</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDtlsTransportState</a></span>, readonly</dt>
            <dd>
              <p>The <code>state</code> attribute MUST return the state of the
              transport.</p>
            </dd>
            <dt><dfn><code>onstatechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              This event handler, of event handler event type
              <code><a>statechange</a></code>, MUST be fired any time the
              <a data-for="RTCDTLSTransport"><code>RTCDtlsTransport</code>
              state</a> changes.
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCDtlsTransport" data-dfn-for="RTCDtlsTransport"
          class="methods">
            <dt><dfn><code>getRemoteCertificates</code></dfn></dt>
            <dd>
              <p>Returns the certificate chain in use by the remote side, with
              each certificate encoded in binary Distinguished Encoding Rules
              (DER) [[!X690]]. <code>getRemoteCertificates()</code> will return
              an empty list prior to selection of the remote certificate, which
              will be completed by the time
              <code><a>RTCDtlsTransportState</a></code> transitions to
              "connected".</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>sequence&lt;ArrayBuffer&gt;</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <h3>RTCDtlsTransportState Enum</h3>
      <div>
        <pre class="idl">enum RTCDtlsTransportState {
    "new",
    "connecting",
    "connected",
    "closed",
    "failed"
};</pre>
        <table data-link-for="RTCDtlsTransportState" data-dfn-for=
        "RTCDtlsTransportState" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code>new</code></dfn></td>
              <td>DTLS has not started negotiating yet.</td>
            </tr>
            <tr>
              <td><dfn><code>connecting</code></dfn></td>
              <td>DTLS is in the process of negotiating a secure
              connection.</td>
            </tr>
            <tr>
              <td><dfn><code>connected</code></dfn></td>
              <td>DTLS has completed negotiation of a secure connection.</td>
            </tr>
            <tr>
              <td><dfn><code>closed</code></dfn></td>
              <td>The transport has been closed.</td>
            </tr>
            <tr>
              <td><dfn><code>failed</code></dfn></td>
              <td>The transport has failed as the result of an error (such as a
              failure to validate the remote fingerprint).</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section>
      <h3>RTCIceTransport Interface</h3>
      <p>The <code><a>RTCIceTransport</a></code> interface allows an
      application access to information about the ICE transport over which
      packets are sent and received. In particular, ICE manages peer-to-peer
      connections which involve state which the application may want to
      access. <code><a>RTCIceTransport</a></code> objects are constructed
      as a result of calls to <code>setLocalDescription()</code>
      and <code>setRemoteDescription()</code>.</p>
      <div>
        <pre class="idl">interface RTCIceTransport {
    readonly        attribute RTCIceRole           role;
    readonly        attribute RTCIceComponent      component;
    readonly        attribute RTCIceTransportState state;
    readonly        attribute RTCIceGatheringState gatheringState;
    sequence&lt;RTCIceCandidate&gt; getLocalCandidates ();
    sequence&lt;RTCIceCandidate&gt; getRemoteCandidates ();
    RTCIceCandidatePair?      getSelectedCandidatePair ();
    RTCIceParameters?         getLocalParameters ();
    RTCIceParameters?         getRemoteParameters ();
                    attribute EventHandler         onstatechange;
                    attribute EventHandler         ongatheringstatechange;
                    attribute EventHandler         onselectedcandidatepairchange;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCIceTransport" data-dfn-for="RTCIceTransport"
          class="attributes">
            <dt><code>role</code> of type <span class=
            "idlAttrType"><a>RTCIceRole</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-icetransport-role"><code>role</code></dfn>
              attribute MUST return the ICE role of the transport.</p>
            </dd>
            <dt><code>component</code> of type <span class=
            "idlAttrType"><a>RTCIceComponent</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-icetransport-component"><code>component</code></dfn>
              attribute MUST return the ICE component of the transport. When
              RTP/RTCP mux is used, a single
              <code><a>RTCIceTransport</a></code> transports both RTP and RTCP
              and <code>component</code> is set to "RTP".</p>
            </dd>
            <dt><code>state</code> of type <span class=
            "idlAttrType"><a>RTCIceTransportState</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-icetransport-state"><code>state</code></dfn>
              attribute MUST return the state of the transport.</p>
            </dd>
            <dt><dfn><code>gatheringState</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceGatheringState</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-icetransport-gatheringstate"><code>gathering
              state</code></dfn> attribute MUST return the gathering state of
              the transport.</p>
            </dd>
            <dt><dfn><code>onstatechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              This event handler, of event handler event type
              <code><a>statechange</a></code>, MUST be fired any time the
              <a data-for="RTCIceTransport"><code>RTCIceTransport</code>
              state</a> changes.
            </dd>
            <dt><dfn><code>ongatheringstatechange</code></dfn> of type
            <span class="idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              This event handler, of event handler event type
              <code><a>gatheringstatechange</a></code>, MUST be fired any time
              the <a data-for=
              "RTCIceTransport"><code>RTCIceTransport</code>gathering state</a>
              changes.
            </dd>
            <dt><dfn><code>onselectedcandidatepairchange</code></dfn> of type
            <span class="idlAttrType"><a>EventHandler</a></span></dt>
            <dd>This event handler, of event handler event type
            <code><a>selectedcandidatepairchange</a></code>, MUST be fired any
            time the <code><a>RTCIceTransport</a></code>'s selected candidate
            pair changes.</dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCIceTransport" data-dfn-for="RTCIceTransport"
          class="methods">
            <dt><dfn><code>getLocalCandidates</code></dfn></dt>
            <dd>
              <p>Returns a sequence describing the local ICE candidates
              gathered for this <code><a>RTCIceTransport</a></code> and sent in
              <code><a data-for=
              "RTCPeerConnection">onicecandidate</a></code></p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>sequence&lt;RTCIceCandidate&gt;</code>
              </div>
            </dd>
            <dt><dfn><code>getRemoteCandidates</code></dfn></dt>
            <dd>
              <p>Returns a sequence describing the remote ICE candidates
              received by this <code><a>RTCIceTransport</a></code> via
              <code><a data-for=
              "RTCPeerConnection">addIceCandidate()</a></code></p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>sequence&lt;RTCIceCandidate&gt;</code>
              </div>
            </dd>
            <dt><dfn><code>getSelectedCandidatePair</code></dfn></dt>
            <dd>
              <p>Returns the selected candidate pair on which packets are sent,
              or <code>null</code> if there is no such pair.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>RTCIceCandidatePair</code>,
                nullable
              </div>
            </dd>
            <dt><dfn><code>getLocalParameters</code></dfn></dt>
            <dd>
              <p>Returns the local ICE parameters received by this
              <code><a>RTCIceTransport</a></code> via <code><a data-for=
              "RTCPeerConnection">setLocalDescription</a></code>, or
              <code>null</code> if the parameters have not yet been
              received.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>RTCIceParameters</code>, nullable
              </div>
            </dd>
            <dt><dfn><code>getRemoteParameters</code></dfn></dt>
            <dd>
              <p>Returns the remote ICE parameters received by this
              <code><a>RTCIceTransport</a></code> via <code><a data-for=
              "RTCPeerConnection">setRemoteDescription</a></code> or
              <code>null</code> if the parameters have not yet been
              received.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>RTCIceParameters</code>, nullable
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCIceParameters {
             DOMString usernameFragment;
             DOMString password;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCIceParameters</a> Members</h2>
          <dl data-link-for="RTCIceParameters" data-dfn-for="RTCIceParameters"
          class="dictionary-members">
            <dt><dfn><code>usernameFragment</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The ICE username fragment as defined in [[!ICE]], Section
              7.1.2.3.</p>
            </dd>
            <dt><dfn><code>password</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The ICE password as defined in [[!ICE]], Section 7.1.2.3.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCIceCandidatePair {
             RTCIceCandidate local;
             RTCIceCandidate remote;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCIceCandidatePair</a>
          Members</h2>
          <dl data-link-for="RTCIceCandidatePair" data-dfn-for=
          "RTCIceCandidatePair" class="dictionary-members">
            <dt><dfn><code>local</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceCandidate</a></span></dt>
            <dd>
              <p>The local ICE candidate.</p>
            </dd>
            <dt><dfn><code>remote</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceCandidate</a></span></dt>
            <dd>
              <p>The remote ICE candidate.</p>
            </dd>
          </dl>
        </section>
      </div>
      <h3>RTCIceTransportState Enum</h3>
      <div>
        <pre class="idl">enum RTCIceTransportState {
    "new",
    "checking",
    "connected",
    "completed",
    "failed",
    "disconnected",
    "closed"
};</pre>
        <table data-link-for="RTCIceTransportState" data-dfn-for=
        "RTCIceTransportState" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code>new</code></dfn></td>
              <td>The <code><a>RTCIceTransport</a></code> is gathering
              candidates and/or waiting for remote candidates to be supplied,
              and has not yet started checking.</td>
            </tr>
            <tr>
              <td><dfn><code>checking</code></dfn></td>
              <td>The <code><a>RTCIceTransport</a></code> has received at least
              one remote candidate and is checking candidate pairs and has
              either not yet found a connection or consent checks [[!RFC7675]]
              have failed on all previously successful candidate pairs. In
              addition to checking, it may also still be gathering.</td>
            </tr>
            <tr>
              <td><dfn><code>connected</code></dfn></td>
              <td>The <code><a>RTCIceTransport</a></code> has found a usable
              connection, but is still checking other candidate pairs to see if
              there is a better connection. It may also still be gathering
              and/or waiting for additional remote candidates. If consent
              checks [[!RFC7675]] fail on the connection in use, and there are
              no other successful candidate pairs available, then the state
              transitions to "checking" (if there are candidate pairs remaining
              to be checked) or "disconnected" (if there are no candidate pairs
              to check, but the peer is still gathering and/or waiting for
              additional remote candidates).</td>
            </tr>
            <tr>
              <td><dfn><code>completed</code></dfn></td>
              <td>The <code><a>RTCIceTransport</a></code> has finished
              gathering, received an indication that there are no more remote
              candidates, finished checking all candidate pairs and found a
              connection. If consent checks [[!RFC7675]] subsequently fail on
              all successful candidate pairs, the state transitions to
              "failed".</td>
            </tr>
            <tr>
              <td><dfn><code>failed</code></dfn></td>
              <td>The <code><a>RTCIceTransport</a></code> has finished
              gathering, received an indication that there are no more remote
              candidates, finished checking all candidate pairs, and all pairs
              have either failed connectivity checks or have lost consent.</td>
            </tr>
            <tr>
              <td><dfn><code>disconnected</code></dfn></td>
              <td>The ICE agent has determined that connectivity is currently
              lost for this <code><a> RTCIceTransport</a></code>. This is more
              aggressive than <code>failed</code>, and may trigger
              intermittently (and resolve itself without action) on a flaky
              network. The way this state is determined is implementation
              dependent. Examples include:
              <ul>
                <li>Losing the network interface for the connection in use.</li>
                <li>Repeatedly failing to receive a response to STUN
                requests.</li>
              </ul>
              Alternatively, the <code><a>RTCIceTransport</a></code> has
              finished checking all existing candidates pairs and failed to find
              a connection (or consent checks [[!RFC7675]] once successful, have
              now failed), but it is still gathering and/or waiting for
              additional remote candidates.</td>
            </tr>
            <tr>
              <td><dfn><code>closed</code></dfn></td>
              <td>The <code><a>RTCIceTransport</a></code> has shut down and is
              no longer responding to STUN requests.</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>The <code>failed</code> and <code>completed</code> states require an
      indication that there are no additional remote candidates. This can be
      indicated either by <a data-link-for=
      "RTCPeerConnection">canTrickleIceCandidates</a> being set to
      <code>false</code>, or the processing of an end-of-candidates indication
      as described in [[!JSEP]].</p>
      <p>Some example transitions might be:</p>
      <ul>
        <li>(<code><a>RTCIceTransport</a></code> first created, as a result of
        <code>setLocalDescription</code> or <code>setRemoteDescription</code>):
        <code>new</code></li>
        <li>(<code>new</code>, remote candidates received):
        <code>checking</code></li>
        <li>(<code>checking</code>, found usable connection):
        <code>connected</code></li>
        <li>(<code>checking</code>, checks fail but gathering still in
        progress): <code>disconnected</code></li>
        <li>(<code>checking</code>, gave up): <code>failed</code></li>
        <li>(<code>disconnected</code>, new local candidates):
        <code>checking</code></li>
        <li>(<code>connected</code>, finished all checks):
        <code>completed</code></li>
        <li>(<code>completed</code>, lost connectivity):
        <code>disconnected</code></li>
        <li>(any state, ICE restart occurs): <code>new</code></li>
        <li><code>RTCPeerConnection.close()</code>: <code>closed</code></li>
      </ul>
      <figure>
        <img alt="ICE transport state transition diagram" src="images/icetransportstate.svg"
        width="600">
        <figcaption>
          Non-normative ICE transport state transition diagram
        </figcaption>
      </figure>
      <h3>RTCIceRole Enum</h3>
      <div>
        <pre class="idl">enum RTCIceRole {
    "controlling",
    "controlled"
};</pre>
        <table data-link-for="RTCIceRole" data-dfn-for="RTCIceRole" class=
        "simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code>controlling</code></dfn></td>
              <td>A controlling agent as defined by [[!ICE]], Section 3.</td>
            </tr>
            <tr>
              <td><dfn><code>controlled</code></dfn></td>
              <td>A controlled agent as defined by [[!ICE]], Section 3.</td>
            </tr>
          </tbody>
        </table>
      </div>
      <h3>RTCIceComponent Enum</h3>
      <div>
        <pre class="idl">enum RTCIceComponent {
    "RTP",
    "RTCP"
};</pre>
        <table data-link-for="RTCIceComponent" data-dfn-for="RTCIceComponent"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code>RTP</code></dfn></td>
              <td>The ICE Transport is used for RTP (or RTP/RTCP-multiplexing),
              as defined in [[!ICE]], Section 4.1.1.1. Protocols multiplexed
              with RTP (e.g. data channel) share its component ID.</td>
            </tr>
            <tr>
              <td><dfn><code>RTCP</code></dfn></td>
              <td>The ICE Transport is used for RTCP as defined by [[!ICE]],
              Section 4.1.1.1.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section>
      <h3>RTCTrackEvent</h3>
      <p>The <code><a>track</a></code> event uses the
      <code><a>RTCTrackEvent</a></code> interface.</p>
      <p><dfn id="fire-track-event" data-lt="fire track event">Firing an
      RTCTrackEvent event named <var>e</var></dfn> with an
      <code><a>RTCRtpReceiver</a></code> <var>receiver</var>, a
      <code><a>MediaStreamTrack</a></code> <var>track</var> and a
      <code>MediaStream</code>[] <var>streams</var>, means that an event with
      the name <var>e</var>, which does not bubble (except where otherwise
      stated) and is not cancelable (except where otherwise stated), and which
      uses the <code><a>RTCTrackEvent</a></code> interface with the
      <code><a data-for="RTCTrackEvent">receiver</a></code> attribute set to
      <var>receiver</var>, <code><a data-for="RTCTrackEvent">track</a></code>
      attribute set to <var>track</var>, <code><a data-for=
      "RTCTrackEvent">streams</a></code> attribute set to <var>streams</var>,
      MUST be created and dispatched at the given target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCTrackEventInit eventInitDict)]
interface RTCTrackEvent : Event {
    readonly        attribute RTCRtpReceiver           receiver;
    readonly        attribute MediaStreamTrack         track;
    readonly        attribute FrozenArray&lt;MediaStream&gt; streams;
    readonly        attribute RTCRtpTransceiver        transceiver;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCTrackEvent" data-dfn-for="RTCTrackEvent" class=
          "constructors">
            <dt><dfn><code>RTCTrackEvent</code></dfn></dt>
            <dd>
              readonly attribute RTCRtpReceiver receiver
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType"><code>RTCTrackEventInit</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCTrackEvent" data-dfn-for="RTCTrackEvent" class=
          "attributes">
            <dt><code>receiver</code> of type <span class=
            "idlAttrType"><a>RTCRtpReceiver</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-trackevent-receiver"><code>receiver</code></dfn> attribute
              represents the <code><a>RTCRtpReceiver</a></code> object
              associated with the event.</p>
            </dd>
            <dt><dfn><code>track</code></dfn> of type <span class=
            "idlAttrType"><a>MediaStreamTrack</a></span>, readonly</dt>
            <dd>
              <p>The <code>track</code> attribute represents the
              <code><a>MediaStreamTrack</a></code> object that is associated
              with the <code><a>RTCRtpReceiver</a></code> identified by
              <code>receiver</code>.</p>
            </dd>
            <dt><code>streams</code> of type <span class=
            "idlAttrType">FrozenArray&lt;<a>MediaStream</a>&gt;</span>,
            readonly</dt>
            <dd>
              <p>The <dfn><code>streams</code></dfn> attribute returns an array
              of <code><a>MediaStream</a></code> objects representing the
              <code><a>MediaStream</a></code>s that this event's
              <code>track</code> is a part of.</p>
            </dd>
            <dt><code>transceiver</code> of type <span class=
            "idlAttrType"><a>RTCRtpTransceiver</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-trackevent-transceiver"><code>transceiver</code></dfn>
              attribute represents the <code><a>RTCRtpTransceiver</a></code>
              object associated with the event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCTrackEventInit : EventInit {
    required RTCRtpReceiver        receiver;
    required MediaStreamTrack      track;
             sequence&lt;MediaStream&gt; streams = [];
    required RTCRtpTransceiver     transceiver;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCTrackEventInit</a> Members</h2>
          <dl data-link-for="RTCTrackEventInit" data-dfn-for=
          "RTCTrackEventInit" class="dictionary-members">
            <dt><dfn><code>receiver</code></dfn> of type <span class=
            "idlMemberType"><a>RTCRtpReceiver</a></span>, required</dt>
            <dd>
              <p>The <code>receiver</code> attribute represents the
              <code><a>RTCRtpReceiver</a></code> object associated with the
              event.</p>
            </dd>
            <dt><dfn><code>track</code></dfn> of type <span class=
            "idlMemberType"><a>MediaStreamTrack</a></span>, required</dt>
            <dd>
              <p>The <code>track</code> attribute represents the
              <code><a>MediaStreamTrack</a></code> object that is associated
              with the <code><a>RTCRtpReceiver</a></code> identified by
              <code>receiver</code>.</p>
            </dd>
            <dt><dfn><code>streams</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>MediaStream</a>&gt;</span>,
            defaulting to <code>[]</code></dt>
            <dd>
              <p>The <code>streams</code> attribute returns an array of
              <code><a>MediaStream</a></code> objects representing the
              <code><a>MediaStream</a></code>s that this event's
              <code>track</code> is a part of.</p>
            </dd>
            <dt><dfn><code>transceiver</code></dfn> of type <span class=
            "idlMemberType"><a>RTCRtpTransceiver</a></span>, required</dt>
            <dd>
              <p>The <code>transceiver</code> attribute represents the
              <code><a>RTCRtpTransceiver</a></code> object associated with the
              event.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  </section>
  <section>
    <h2>Peer-to-peer Data API</h2>
    <p>The Peer-to-peer Data API lets a web application send and receive
    generic application data peer-to-peer. The API for sending and receiving
    data models the behavior of WebSockets [[WEBSOCKETS-API]].</p>
    <section>
      <h3>RTCPeerConnection Interface Extensions</h3>
      <p>The Peer-to-peer data API extends the
      <code><a>RTCPeerConnection</a></code> interface as described below.</p>
      <div>
        <pre class="idl">partial interface RTCPeerConnection {
    readonly        attribute RTCSctpTransport? sctp;
    RTCDataChannel createDataChannel ([TreatNullAs=EmptyString] USVString label, optional RTCDataChannelInit dataChannelDict);
                    attribute EventHandler      ondatachannel;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="attributes">
            <dt><dfn><code>sctp</code></dfn> of type <span class=
            "idlAttrType"><a>RTCSctpTransport</a></span>, readonly ,
            nullable</dt>
            <dd>
              <p>The SCTP transport over which SCTP data is sent and received.
              If SCTP has not been negotiated, the value is null.</p>
            </dd>
            <dt><dfn><code>ondatachannel</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>datachannel</a></code>.</dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="methods">
            <dt><code>createDataChannel</code></dt>
            <dd>
              <p>Creates a new <code><a>RTCDataChannel</a></code> object with
              the given label. The <code><a>RTCDataChannelInit</a></code>
              dictionary can be used to configure properties of the underlying
              channel such as <!--priority and--> data reliability.</p>
              <p>When the <dfn id=
              "dom-peerconnection-createdatachannel"><code>createDataChannel</code></dfn>
              method is invoked, the user agent MUST run the following
              steps.</p>
              <ol>
                <li>
                  <p>Let <var>connection</var> be the
                  <code><a>RTCPeerConnection</a></code> object on which the
                  method is invoked.</p>
                </li>
                <li>
                  <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
                  <code>true</code>, throw an <code>InvalidStateError</code>
                  exception and abort these steps.</p>
                </li>
                <li>
                  <p>Let <var>channel</var> be a newly created
                  <code><a>RTCDataChannel</a></code> object.</p>
                </li>
                <li>
                  <p>Initialize <var>channel</var>'s <code><a data-for=
                  "RTCDataChannel">label</a></code> attribute to the value of
                  the first argument.</p>
                </li>
                <li>
                  <p>If the second (dictionary) argument is present, set
                  <var>channel</var>'s <code><a data-for=
                  "RTCDataChannel">ordered</a></code>, <code><a data-for=
                  "RTCDataChannel">maxPacketLifeTime</a></code>,
                  <code><a data-for="RTCDataChannel">maxRetransmits</a></code>,
                  <code><a data-for="RTCDataChannel">protocol</a></code>,
                  <code><a data-for="RTCDataChannel">negotiated</a></code> and
                  <code><a data-for="RTCDataChannel">id</a></code> attributes
                  to the values of their corresponding dictionary members (if
                  present in the dictionary).</p>
                </li>
                <li>If <code>negotiated</code> is false and <code>label</code>
                is longer than 65535 bytes long, <a href=
                "http://heycam.github.io/webidl/#dfn-throw">throw</a> a <code>
                  TypeError</code>.
                </li>
                <li>If <code>negotiated</code> is false and
                <code>protocol</code> is longer than 65535 bytes long,
                  <a href="http://heycam.github.io/webidl/#dfn-throw">throw</a>
                  a <code>TypeError</code>.
                </li>
                <li>
                  <p>If both the <code><a data-for=
                  "RTCDataChannel">maxPacketLifeTime</a></code> and
                  <code><a data-for="RTCDataChannel">maxRetransmits</a></code>
                  attributes are set (not null), then throw a
                  <code>SyntaxError</code> exception and abort these steps.</p>
                </li>
                <li>
                  <p>If an attribute, either <code><a data-for=
                  "RTCDataChannel">maxPacketLifeTime</a></code> or
                  <code><a data-for="RTCDataChannel">maxRetransmits</a></code>,
                  has been set to indicate unreliable mode, and that value
                  exceeds the maximum value supported by the user agent, the
                  value MUST be set to the user agents maximum value.</p>
                </li>
                <li>
                  <p>If <code><a data-for="RTCDataChannel">id</a></code>
                  attribute is uninitialized (not set via the dictionary),
                  initialize it to a value generated by the user agent,
                  according to the WebRTC DataChannel Protocol specification,
                  and skip to the next step. Otherwise, if the value of the
                  <code><a data-for="RTCDataChannel">id</a></code> attribute is
                  taken by an existing <code><a>RTCDataChannel</a></code>,
                  throw a <code>ResourceInUse</code> exception and abort these
                  steps.</p>
                </li>
                <li>
                  <p>Return <var>channel</var> and continue the following steps
                  in the background.</p>
                </li>
                <li>
                  <p>Create <var>channel</var>'s associated <a>underlying data
                  transport</a> and configure it according to the relevant
                  properties of <var>channel</var>.</p>
                </li>
                <li>
                  <p>If <var>channel</var> was the first RTCDataChannel created
                  on <var>connection</var>, mark <var>connection</var> as
                  needing negotiation.</p>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">label</td>
                    <td class="prmType"><code>USVString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">dataChannelDict</td>
                    <td class="prmType"><code>RTCDataChannelInit</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>RTCDataChannel</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <section>
        <h3>RTCSctpTransport Interface</h3>
        <p>The <code><a>RTCSctpTransport</a></code> interface allows an
        application access to information about the SCTP data channels tied to
        a particular SCTP association.</p>
        <div>
          <pre class="idl">interface RTCSctpTransport {
    readonly        attribute RTCDtlsTransport transport;
    readonly        attribute unsigned long    maxMessageSize;
};</pre>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="RTCSctpTransport" data-dfn-for=
            "RTCSctpTransport" class="attributes">
              <dt><dfn><code>transport</code></dfn> of type <span class=
              "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly</dt>
              <dd>
                <p>The transport over which all SCTP packets for data channels
                will be sent and received.</p>
              </dd>
              <dt><dfn><code>maxMessageSize</code></dfn> of type <span class=
              "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
              <dd>
                <p>The maximum size of data that can be passed to
                <code><a>RTCDataChannel</a></code>'s <code><a data-for=
                "RTCDataChannel">send()</a></code> method.</p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
    </section>
    <section>
      <h3>RTCDataChannel</h3>
      <p>The <code><a>RTCDataChannel</a></code> interface represents a
      bi-directional data channel between two peers. A
      <code><a>RTCDataChannel</a></code> is created via a factory method on an
      <code><a>RTCPeerConnection</a></code> object. The messages sent between
      the browsers are described in [[!RTCWEB-DATA]] and
      [[!RTCWEB-DATA-PROTOCOL]].</p>
      <p>There are two ways to establish a connection with
      <code><a>RTCDataChannel</a></code>. The first way is to simply create a
      <code><a>RTCDataChannel</a></code> at one of the peers with the
      <code><a data-for="RTCDataChannelInit">negotiated</a></code>
      <code><a>RTCDataChannelInit</a></code> dictionary member unset or set to
      its default value false. This will announce the new channel in-band and
      trigger a <code><a>RTCDataChannelEvent</a></code> with the corresponding
      <code><a>RTCDataChannel</a></code> object at the other peer. The second
      way is to let the application negotiate the
      <code><a>RTCDataChannel</a></code>. To do this, create a
      <code><a>RTCDataChannel</a></code> object with the <code><a data-for=
      "RTCDataChannelInit">negotiated</a></code>
      <code><a>RTCDataChannelInit</a></code> dictionary member set to true, and
      signal out-of-band (e.g. via a web server) to the other side that it
      SHOULD create a corresponding <code><a>RTCDataChannel</a></code> with the
      <code><a data-for="RTCDataChannelInit">negotiated</a></code>
      <code><a>RTCDataChannelInit</a></code> dictionary member set to true and
      the same <code><a data-for="RTCDataChannel">id</a></code>. This will
      connect the two separately created <code><a>RTCDataChannel</a></code>
      objects. The second way makes it possible to create channels with
      asymmetric properties and to create channels in a declarative way by
      specifying matching <code><a data-for=
      "RTCDataChannelInit">id</a></code>s.</p>
      <p>Each <code><a>RTCDataChannel</a></code> has an associated
      <dfn data-lt="data transport">underlying data transport</dfn> that is
      used to transport actual data to the other peer. The transport properties
      of the <a>underlying data transport</a>, such as in order delivery
      settings and reliability mode, are configured by the peer as the channel
      is created. The properties of a channel cannot change after the channel
      has been created. The actual wire protocol between the peers is specified
      by the WebRTC DataChannel Protocol specification [[RTCWEB-DATA]].</p>
      <p>A <code><a>RTCDataChannel</a></code> can be configured to operate in
      different reliability modes. A reliable channel ensures that the data is
      delivered at the other peer through retransmissions. An unreliable
      channel is configured to either limit the number of retransmissions (
      <code><a data-for="RTCDataChannelInit">maxRetransmits</a></code> ) or set
      a time during which transmissions (including retransmissions) are allowed
      ( <code><a data-for="RTCDataChannelInit">maxPacketLifeTime</a></code> ).
      These properties can not be used simultaneously and an attempt to do so
      will result in an error. Not setting any of these properties results in a
      reliable channel.</p>
      <p>A <code><a>RTCDataChannel</a></code>, created with <code><a data-for=
      "RTCPeerConnection">createDataChannel</a></code> or dispatched via a
      <code><a>RTCDataChannelEvent</a></code>, MUST initially be in the
      <code>connecting</code> state. When the
      <code><a>RTCDataChannel</a></code> object's <a>underlying data
      transport</a> is ready, the user agent MUST <a>announce the
      <code>RTCDataChannel</code> as open</a>.</p>
      <p>When the user agent is to <dfn data-lt=
      "announce the rtcdatachannel as open" id=
      "announce-datachannel-open">announce a <code>RTCDataChannel</code> as
      open</dfn>, the user agent MUST queue a task to run the following
      steps:</p>
      <ol>
        <li>
          <p>If the associated <code><a>RTCPeerConnection</a></code> object's
          [[<a>isClosed</a>]] slot is <code>true</code>, abort these steps.</p>
        </li>
        <li>
          <p>Let <var>channel</var> be the <code><a>RTCDataChannel</a></code>
          object to be announced.</p>
        </li>
        <li>
          <p>Set <var>channel</var>'s <code><a data-for=
          "RTCDataChannel">readyState</a></code> attribute to
          <code>open</code>.</p>
        </li>
        <li>
          <p>Fire a simple event named <code><a>open</a></code> at
          <var>channel</var>.</p>
        </li>
      </ol>
      <p>When an <a>underlying data transport</a> is to be announced (the other
      peer created a channel with <code><a data-for=
      "RTCDataChannelInit">negotiated</a></code> unset or set to false), the
      user agent of the peer that did not initiate the creation process MUST
      queue a task to run the following steps:</p>
      <ol>
        <li>
          <p>If the associated <code><a>RTCPeerConnection</a></code> object's
          [[<a>isClosed</a>]] slot is <code>true</code>, abort these steps.</p>
        </li>
        <li>
          <p>Let <var>channel</var> be a newly created
          <code><a>RTCDataChannel</a></code> object.</p>
        </li>
        <li>
          <p>Let <var>configuration</var> be an information bundle received
          from the other peer as a part of the process to establish the
          <a>underlying data transport</a> described by the WebRTC DataChannel
          Protocol specification [[!RTCWEB-DATA-PROTOCOL]].</p>
        </li>
        <li>
          <p>Initialize <var>channel</var>'s <code><a data-for=
          "RTCDataChannel">label</a></code>, <code><a data-for=
          "RTCDataChannel">ordered</a></code>, <code><a data-for=
          "RTCDataChannel">maxPacketLifeTime</a></code>, <code><a data-for=
          "RTCDataChannel">maxRetransmits</a></code>, <code><a data-for=
          "RTCDataChannel">protocol</a></code>, <code><a data-for=
          "RTCDataChannel">negotiated</a></code> and <code><a data-for=
          "RTCDataChannel">id</a></code> attributes to their corresponding
          values in <var>configuration</var>.</p>
        </li>
        <li>
          <p>Set <var>channel</var>'s <code><a data-for=
          "RTCDataChannel">readyState</a></code> attribute to
          <code>connecting</code>.</p>
        </li>
        <li>
          <p><a>Fire a datachannel event</a> named
          <code><a>datachannel</a></code> with <var>channel</var> at the
          <code><a>RTCPeerConnection</a></code> object.</p>
        </li>
      </ol>
      <p>An <code><a>RTCDataChannel</a></code> object's <a>underlying data
      transport</a> may be torn down in a non-abrupt manner by running the
      <dfn id="data-transport-closing-procedure">closing procedure</dfn>. When
      that happens the user agent MUST, unless the procedure was initiated by
      the <code><a data-for="RTCDataChannel">close</a></code> method, queue a
      task that sets the object's <code><a data-for=
      "RTCDataChannel">readyState</a></code> attribute to <code>closing</code>.
      This will eventually render the <a>data transport</a> <a>closed</a>.</p>
      <p>When a <code><a>RTCDataChannel</a></code> object's <a>underlying data
      transport</a> has been <dfn id="data-transport-closed">closed</dfn>, the
      user agent MUST queue a task to run the following steps:</p>
      <ol>
        <li>
          <p>Let <var>channel</var> be the <code><a>RTCDataChannel</a></code>
          object whose <a data-lt="data transport">transport</a> was
          closed.</p>
          <div class="issue">
            The data transport protocol will specify what happens to, e.g.
            buffered data, when the data transport is closed.
          </div>
        </li>
        <li>
          <p>Set <var>channel</var>'s <code><a data-for=
          "RTCDataChannel">readyState</a></code> attribute to
          <code>closed</code>.</p>
        </li>
        <li>
          <p>If the <a data-lt="data transport">transport</a> was closed
          <dfn id="data-transport-closed-error">with an error</dfn>, fire an
          NetworkError event at <var>channel</var>.</p>
        </li>
        <li>
          <p>Fire a simple event named <code title=
          "event-RTCDataChannel-close"><a>close</a></code> at
          <var>channel</var>.</p>
        </li>
      </ol>
      <div>
        <pre class="idl">interface RTCDataChannel : EventTarget {
    readonly        attribute USVString           label;
    readonly        attribute boolean             ordered;
    readonly        attribute unsigned short?     maxPacketLifeTime;
    readonly        attribute unsigned short?     maxRetransmits;
    readonly        attribute USVString           protocol;
    readonly        attribute boolean             negotiated;
    readonly        attribute unsigned short      id;
    readonly        attribute RTCDataChannelState readyState;
    readonly        attribute unsigned long       bufferedAmount;
                    attribute unsigned long       bufferedAmountLowThreshold;
                    attribute EventHandler        onopen;
                    attribute EventHandler        onbufferedamountlow;
                    attribute EventHandler        onerror;
                    attribute EventHandler        onclose;
    void close ();
                    attribute EventHandler        onmessage;
                    attribute DOMString           binaryType;
    void send (USVString data);
    void send (Blob data);
    void send (ArrayBuffer data);
    void send (ArrayBufferView data);
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDataChannel" data-dfn-for="RTCDataChannel"
          class="attributes">
            <dt><code>label</code> of type <span class=
            "idlAttrType"><a>USVString</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-datachannel-label"><code>label</code></dfn>
              attribute represents a label that can be used to distinguish this
              <code><a>RTCDataChannel</a></code> object from other
              <code><a>RTCDataChannel</a></code> objects. Scripts are allowed
              to create multiple <code><a>RTCDataChannel</a></code> objects
              with the same label. The attribute MUST return the value to which
              it was set when the <code><a>RTCDataChannel</a></code> object was
              created.</p>
            </dd>
            <dt><code>ordered</code> of type <span class=
            "idlAttrType"><a>boolean</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-ordered"><code>ordered</code></dfn> attribute
              returns true if the <code><a>RTCDataChannel</a></code> is
              ordered, and false if other of order delivery is allowed. The
              attribute MUST be initialized to true by default and MUST return
              the value to which it was set when the
              <code><a>RTCDataChannel</a></code> was created.</p>
            </dd>
            <dt><code>maxPacketLifeTime</code> of type <span class=
            "idlAttrType"><a>unsigned short</a></span>, readonly ,
            nullable</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-maxpacketlifetime"><code>maxPacketLifeTime</code></dfn>
              attribute returns the length of the time window (in milliseconds)
              during which transmissions and retransmissions may occur in
              unreliable mode, or null if unset. The attribute MUST be
              initialized to null by default and MUST return the value to which
              it was set when the <code><a>RTCDataChannel</a></code> was
              created.</p>
            </dd>
            <dt><code>maxRetransmits</code> of type <span class=
            "idlAttrType"><a>unsigned short</a></span>, readonly ,
            nullable</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-maxretransmits"><code>maxRetransmits</code></dfn>
              attribute returns the maximum number of retransmissions that are
              attempted in unreliable mode, or null if unset. The attribute
              MUST be initialized to null by default and MUST return the value
              to which it was set when the <code><a>RTCDataChannel</a></code>
              was created.</p>
            </dd>
            <dt><code>protocol</code> of type <span class=
            "idlAttrType"><a>USVString</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-protocol"><code>protocol</code></dfn> attribute
              returns the name of the sub-protocol used with this
              <code><a>RTCDataChannel</a></code> if any, or the empty string
              otherwise. The attribute MUST be initialized to the empty string
              by default and MUST return the value to which it was set when the
              <code><a>RTCDataChannel</a></code> was created.</p>
            </dd>
            <dt><code>negotiated</code> of type <span class=
            "idlAttrType"><a>boolean</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-negotiated"><code>negotiated</code></dfn>
              attribute returns true if this <code><a>RTCDataChannel</a></code>
              was negotiated by the application, or false otherwise. The
              attribute MUST be initialized to false by default and MUST return
              the value to which it was set when the
              <code><a>RTCDataChannel</a></code> was created.</p>
            </dd>
            <dt><dfn><code>id</code></dfn> of type <span class=
            "idlAttrType"><a>unsigned short</a></span>, readonly</dt>
            <dd>
              <p>The <code>id</code> attribute returns the id for this
              <code><a>RTCDataChannel</a></code>. The id was either assigned by
              the user agent at channel creation time or selected by the
              script. The attribute MUST return the value to which it was set
              when the <code><a>RTCDataChannel</a></code> was created.</p>
            </dd>
            <dt><code>readyState</code> of type <span class=
            "idlAttrType"><a>RTCDataChannelState</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-readystate"><code>readyState</code></dfn>
              attribute represents the state of the <code>RTCDataChannel</code>
              object. It MUST return the value to which the user agent last set
              it (as defined by the processing model algorithms).</p>
            </dd>
            <dt><code>bufferedAmount</code> of type <span class=
            "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-bufferedamount"><code>bufferedAmount</code></dfn>
              attribute MUST return the number of bytes of application data
              (UTF-8 text and binary data) that have been queued using
              <code><a data-for="RTCDataChannel">send()</a></code> but that, as
              of the last time the event loop started executing a task, had not
              yet been transmitted to the network. (This thus includes any text
              sent during the execution of the current task, regardless of
              whether the user agent is able to transmit text asynchronously
              with script execution.) This does not include framing overhead
              incurred by the protocol, or buffering done by the operating
              system or network hardware. If the channel is closed, this
              attribute's value will only increase with each call to the
              <code><a data-for="RTCDataChannel">send()</a></code> method (the
              attribute does not reset to zero once the channel closes).</p>
            </dd>
            <dt><code>bufferedAmountLowThreshold</code> of type <span class=
            "idlAttrType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The <dfn><code>bufferedAmountLowThreshold</code></dfn>
              attribute sets the threshold at which the <code><a data-for=
              "RTCDataChannel">bufferedAmount</a></code> is considered to be
              low. When the <code><a data-for=
              "RTCDataChannel">bufferedAmount</a></code> decreases from above
              this threshold to equal or below it, the <code title=
              "event-RTCDataChannel-bufferedamountlow"><a>bufferedamountlow</a></code>
              event fires. The <code><a data-for=
              "RTCDataChannel">bufferedAmountLowThreshold</a></code> is
              initially zero on each new <code><a>RTCDataChannel</a></code>,
              but the application may change its value at any time.</p>
            </dd>
            <dt><dfn><code>onopen</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>open</a></code>.</dd>
            <dt><dfn><code>onbufferedamountlow</code></dfn> of type
            <span class="idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>bufferedamountlow</a></code>.</dd>
            <dt><dfn><code>onerror</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>error</a></code>.</dd>
            <dt><dfn><code>onclose</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>close</a></code>.</dd>
            <dt><dfn><code>onmessage</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>message</a></code>.</dd>
            <dt><code>binaryType</code> of type <span class=
            "idlAttrType"><a>DOMString</a></span></dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-binarytype"><code>binaryType</code></dfn>
              attribute MUST, on getting, return the value to which it was last
              set. On setting, the user agent MUST set the IDL attribute to the
              new value. When a <code><a>RTCDataChannel</a></code> object is
              created, the <code><a data-for=
              "RTCDataChannel">binaryType</a></code> attribute MUST be
              initialized to the string "<code>blob</code>".</p>
              <p>This attribute controls how binary data is exposed to scripts.
              See the [[WEBSOCKETS-API]] for more information.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCDataChannel" data-dfn-for="RTCDataChannel"
          class="methods">
            <dt><code>close</code></dt>
            <dd>
              <p>Closes the <code><a>RTCDataChannel</a></code>. It may be
              called regardless of whether the
              <code><a>RTCDataChannel</a></code> object was created by this
              peer or the remote peer.</p>
              <p>When the <dfn>close</dfn> method is called, the user agent
              MUST run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>channel</var> be the
                  <code><a>RTCDataChannel</a></code> object which is about to
                  be closed.</p>
                </li>
                <li>
                  <p>If <var>channel</var>'s <code><a data-for=
                  "RTCDataChannel">readyState</a></code> is
                  <code>closing</code> or <code>closed</code>, then abort these
                  steps.</p>
                </li>
                <li>
                  <p>Set <var>channel</var>'s <code><a data-for=
                  "RTCDataChannel">readyState</a></code> attribute to
                  <code>closing</code>.</p>
                </li>
                <li>
                  <p>If the <code><a>closing procedure</a></code> has not
                  started yet, start it.</p>
                </li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code><a data-for=
              "RTCDataChannel">send()</a></code> algorithm with argument type
              <code>string</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>USVString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn data-lt="send!overload-1" data-lt-nodefault=
            "true"><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code><a data-for=
              "RTCDataChannel">send()</a></code> algorithm with argument type
              <code>Blob</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>Blob</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn data-lt="send!overload-2" data-lt-nodefault=
            "true"><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code><a data-for=
              "RTCDataChannel">send()</a></code> algorithm with argument type
              <code>ArrayBuffer</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>ArrayBuffer</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn data-lt="send!overload-3" data-lt-nodefault=
            "true"><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code><a data-for=
              "RTCDataChannel">send()</a></code> algorithm with argument type
              <code>ArrayBufferView</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>ArrayBufferView</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCDataChannelInit {
             boolean        ordered = true;
             unsigned short maxPacketLifeTime;
             unsigned short maxRetransmits;
             USVString      protocol = "";
             boolean        negotiated = false;
             unsigned short id;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDataChannelInit</a> Members</h2>
          <dl data-link-for="RTCDataChannelInit" data-dfn-for=
          "RTCDataChannelInit" class="dictionary-members">
            <dt><dfn><code>ordered</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to
            <code>true</code></dt>
            <dd>
              <p>If set to false, data is allowed to be delivered out of order.
              The default value of true, guarantees that data will be delivered
              in order.</p>
            </dd>
            <dt><dfn><code>maxPacketLifeTime</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span></dt>
            <dd>
              <p>Limits the time during which the channel will transmit or
              retransmit data if not acknowledged. This value may be clamped if
              it exceeds the maximum value supported by the user agent.</p>
            </dd>
            <dt><dfn><code>maxRetransmits</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span></dt>
            <dd>
              <p>Limits the number of times a channel will retransmit data if
              not successfully delivered. This value may be clamped if it
              exceeds the maximum value supported by the user agent.</p>
            </dd>
            <dt><dfn><code>protocol</code></dfn> of type <span class=
            "idlMemberType"><a>USVString</a></span>, defaulting to
            <code>""</code></dt>
            <dd>
              <p>Subprotocol name used for this channel.</p>
            </dd>
            <dt><dfn><code>negotiated</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to
            <code>false</code></dt>
            <dd>
              <p>The default value of false tells the user agent to announce
              the channel in-band and instruct the other peer to dispatch a
              corresponding <code><a>RTCDataChannel</a></code> object. If set
              to true, it is up to the application to negotiate the channel and
              create a <code><a>RTCDataChannel</a></code> object with the same
              <code><a data-for="RTCDataChannel">id</a></code> at the other
              peer.</p>
            </dd>
            <dt><dfn><code>id</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span></dt>
            <dd>
              <p>Overrides the default selection of id for this channel.</p>
            </dd>
          </dl>
        </section>
      </div>
      <p>The <dfn><code>send()</code></dfn> method is overloaded to handle
      different data argument types. When any version of the method is called,
      the user agent MUST run the following steps:</p>
      <ol>
        <li>
          <p>Let <var>channel</var> be the <code><a>RTCDataChannel</a></code>
          object on which data is to be sent.</p>
        </li>
        <li>
          <p>If <var>channel</var>'s <a data-for=
          "RTCDataChannel"><code>readyState</code></a> attribute is
          <code>connecting</code>, throw an <code>InvalidStateError</code>
          exception and abort these steps.</p>
        </li>
        <li>
          <p>Execute the sub step that corresponds to the type of the methods
          argument:</p>
          <ul>
            <li>
              <p><code>string</code> object:</p>
              <p>Let <var>data</var> be the object and increase the
              <code><a data-for="RTCDataChannel">bufferedAmount</a></code>
              attribute by the number of bytes needed to express
              <var>data</var> as UTF-8.</p>
            </li>
            <li>
              <p><code>Blob</code> object:</p>
              <p>Let <var>data</var> be the raw data represented by the
              <code>Blob</code> object and increase the <code><a data-for=
              "RTCDataChannel">bufferedAmount</a></code> attribute by the size
              of data, in bytes.</p>
            </li>
            <li>
              <p><code>ArrayBuffer</code> object:</p>
              <p>Let <var>data</var> be the data stored in the buffer described
              by the <code>ArrayBuffer</code> object and increase the
              <code><a data-for="RTCDataChannel">bufferedAmount</a></code>
              attribute by the length of the <code>ArrayBuffer</code> in
              bytes.</p>
            </li>
            <li>
              <p><code>ArrayBufferView</code> object:</p>
              <p>Let <var>data</var> be the data stored in the section of the
              buffer described by the <code>ArrayBuffer</code> object that the
              <code>ArrayBufferView</code> object references and increase the
              <code><a data-for="RTCDataChannel">bufferedAmount</a></code>
              attribute by the length of the <code>ArrayBufferView</code> in
              bytes.</p>
            </li>
          </ul>
        </li>
        <li>
          <p>If <var>channel</var>'s <a>underlying data transport</a> is not
          established yet, or if the <code><a>closing procedure</a></code> has
          started, then abort these steps.</p>
        </li>
        <li>
          <p>Attempt to send <var>data</var> on <var>channel</var>'s
          <a>underlying data transport</a>; if the data cannot be sent, e.g.
          because it would need to be buffered but the buffer is full, the user
          agent MUST abruptly <a>close</a> <var>channel</var>'s <a>underlying
          data transport</a> <a>with an error</a>.</p>
        </li>
      </ol>
      <div>
        <pre class="idl">enum RTCDataChannelState {
    "connecting",
    "open",
    "closing",
    "closed"
};</pre>
        <table data-link-for="RTCDataChannelState" data-dfn-for=
        "RTCDataChannelState" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code>connecting</code></dfn></td>
              <td>
                <p>The user agent is attempting to establish the <a>underlying
                data transport</a>. This is the initial state of a
                <code><a>RTCDataChannel</a></code> object created with
                <code><a data-for=
                "RTCPeerConnection">createDataChannel</a></code>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code>open</code></dfn></td>
              <td>
                <p>The <a>underlying data transport</a> is established and
                communication is possible. This is the initial state of a
                <code><a>RTCDataChannel</a></code> object dispatched as a part
                of a <code><a>RTCDataChannelEvent</a></code>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code>closing</code></dfn></td>
              <td>
                <p>The <code><a data-lt=
                "closing procedure">procedure</a></code> to close down the
                <a>underlying data transport</a> has started.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code>closed</code></dfn></td>
              <td>
                <p>The <a>underlying data transport</a> has been
                <code><a>closed</a></code> or could not be established.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section>
      <h3>RTCDataChannelEvent</h3>
      <p>The <code><a>datachannel</a></code> event uses the
      <code><a>RTCDataChannelEvent</a></code> interface.</p>
      <p><dfn id="fire-a-datachannel-event" data-lt=
      "fire a datachannel event">Firing a datachannel event named
      <var>e</var></dfn> with a <code><a>RTCDataChannel</a></code>
      <var>channel</var> means that an event with the name <var>e</var>, which
      does not bubble (except where otherwise stated) and is not cancelable
      (except where otherwise stated), and which uses the
      <code><a>RTCDataChannelEvent</a></code> interface with the
      <code><a data-for="RTCDataChannelEvent">channel</a></code> attribute set
      to <var>channel</var>, MUST be created and dispatched at the given
      target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCDataChannelEventInit eventInitDict)]
interface RTCDataChannelEvent : Event {
    readonly        attribute RTCDataChannel channel;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCDataChannelEvent" data-dfn-for=
          "RTCDataChannelEvent" class="constructors">
            <dt><dfn><code>RTCDataChannelEvent</code></dfn></dt>
            <dd>
              readonly attribute RTCDataChannel channel
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType">
                    <code>RTCDataChannelEventInit</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDataChannelEvent" data-dfn-for=
          "RTCDataChannelEvent" class="attributes">
            <dt><code>channel</code> of type <span class=
            "idlAttrType"><a>RTCDataChannel</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannelevent-channel"><code>channel</code></dfn>
              attribute represents the <code><a>RTCDataChannel</a></code>
              object associated with the event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCDataChannelEventInit : EventInit {
             RTCDataChannel channel;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDataChannelEventInit</a>
          Members</h2>
          <dl data-link-for="RTCDataChannelEventInit" data-dfn-for=
          "RTCDataChannelEventInit" class="dictionary-members">
            <dt><dfn><code>channel</code></dfn> of type <span class=
            "idlMemberType"><a>RTCDataChannel</a></span></dt>
            <dd>
              <p class="issue">TODO</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>Garbage Collection</h3>
      <p>A <code><a>RTCDataChannel</a></code> object MUST not be garbage
      collected if its</p>
      <ul>
        <li>
          <p><code><a data-for="RTCDataChannel">readyState</a></code> is
          <code>connecting</code> and at least one event listener is registered
          for <code>open</code> events, <code>message</code> events,
          <code>error</code> events, or <code>close</code> events.</p>
        </li>
        <li>
          <p><code><a data-for="RTCDataChannel">readyState</a></code> is
          <code>open</code> and at least one event listener is registered for
          <code>message</code> events, <code>error</code> events, or
          <code>close</code> events.</p>
        </li>
        <li>
          <p><code><a data-for="RTCDataChannel">readyState</a></code> is
          <code>closing</code> and at least one event listener is registered
          for <code>error</code> events, or <code>close</code> events.</p>
        </li>
        <li>
          <p><a>underlying data transport</a> is established and data is queued
          to be transmitted.</p>
        </li>
      </ul>
    </section>
  </section>
  <section>
    <h3>Peer-to-peer DTMF</h3>
    <p>This section describes an interface on <code><a>RTCRtpSender</a></code>
    to send DTMF (phone keypad) values across an
    <code><a>RTCPeerConnection</a></code>. Details of how DTMF is sent to the
    other peer are described in [[!RTCWEB-AUDIO]].</p>
    <section>
      <h3>RTCRtpSender Interface Extensions</h3>
      <p>The Peer-to-peer DTMF API extends the <code><a>RTCRtpSender</a></code>
      interface as described below.</p>
      <div>
        <pre class="idl">partial interface RTCRtpSender {
    readonly        attribute RTCDTMFSender? dtmf;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCRtpSender" data-dfn-for="RTCRtpSender" class=
          "attributes">
            <dt><code>dtmf</code> of type <span class=
            "idlAttrType"><a>RTCDTMFSender</a></span>, readonly , nullable</dt>
            <dd>
              <p>The <dfn>dtmf</dfn> attribute returns a RTCDTMFSender which
              can be used to send DTMF. A null value indicates that this
              RTCRtpSender cannot send DTMF.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h4>RTCDTMFSender</h4>
      <div>
        <pre class="idl">
interface RTCDTMFSender : EventTarget {
    void insertDTMF (DOMString tones, optional unsigned long duration = 100, optional unsigned long interToneGap = 70);
                    attribute EventHandler ontonechange;
    readonly        attribute DOMString    toneBuffer;
    readonly        attribute long         duration;
    readonly        attribute long         interToneGap;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDTMFSender" data-dfn-for="RTCDTMFSender" class=
          "attributes">
            <dt><dfn><code>ontonechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>The event type of this event handler is
              <code><a>tonechange</a></code>.</p>
            </dd>
            <dt><code>toneBuffer</code> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-RTCDTMFSender-tonebuffer"><code>toneBuffer</code></dfn>
              attribute MUST return a list of the tones remaining to be played
              out. For the syntax, content, and interpretation of this list,
              see <code><a>insertDTMF</a></code>.</p>
            </dd>
            <dt><code>duration</code> of type <span class=
            "idlAttrType"><a>long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-RTCDTMFSender-duration"><code>duration</code></dfn>
              attribute MUST return the current tone duration value. This value
              will be the value last set via the <code><a>insertDTMF</a></code>
              method, or the default value of 100 ms if
              <code><a>insertDTMF</a></code> was called without specifying the
              duration.</p>
            </dd>
            <dt><code>interToneGap</code> of type <span class=
            "idlAttrType"><a>long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-RTCDTMFSender-intertonegap"><code>interToneGap</code></dfn>
              attribute MUST return the current value of the between-tone gap.
              This value will be the value last set via the
              <code><a>insertDTMF</a></code> method, or the default value of 70
              ms if <code><a>insertDTMF</a></code> was called without
              specifying the interToneGap.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCDTMFSender" data-dfn-for="RTCDTMFSender" class=
          "methods">
            <dt><code>insertDTMF</code></dt>
            <dd>
              <p>An <code><a>RTCDTMFSender</a></code> object's <dfn id=
              "dom-RTCDTMFSender-insertDTMF"><code>insertDTMF</code></dfn>
              method is used to send DTMF tones.</p>
              <p>The tones parameter is treated as a series of characters. The
              characters 0 through 9, A through D, #, and * generate the
              associated DTMF tones. The characters a to d are equivalent to A
              to D. The character ',' indicates a delay of 2 seconds before
              processing the next character in the tones parameter. All other
              characters MUST be considered <dfn id=
              "dtmf-unrecognized">unrecognized</dfn>. As noted in
              [[RTCWEB-AUDIO]] Section 3, support for the characters 0 through
              9, A through D, #, and * are required.</p>
              <p>The duration parameter indicates the duration in ms to use for
              each character passed in the tones parameters. The duration
              cannot be more than 8000 ms or less than 40 ms. The default
              duration is 100 ms for each tone.</p>
              <p>The interToneGap parameter indicates the gap between tones. The
              user agent clamps it to at least 30 ms. The default value is 70
              ms.</p>
              <p>The browser MAY increase the duration and interToneGap times
              to cause the times that DTMF start and stop to align with the
              boundaries of RTP packets but it MUST not increase either of them
              by more than the duration of a single RTP audio packet.</p>
              <p>When the <code><a>insertDTMF()</a></code> method is invoked,
              the user agent MUST run the following steps:</p>
              <ol>
                <li>Set the object's <code><a data-for=
                "RTCDTMFSender">toneBuffer</a></code> attribute to the value of
                the first argument, the <code><a data-for=
                "RTCDTMFSender">duration</a></code> attribute to the value of
                the second argument, and the <code><a data-for=
                "RTCDTMFSender">interToneGap</a></code> attribute to the value
                of the third argument.</li>
                <li>If <code><a data-for="RTCDTMFSender">toneBuffer</a></code>
                contains any <a>unrecognized</a> characters, throw an
                <code>InvalidCharacterError</code> exception and abort these
                steps.
                </li>
                <li>If <code><a data-for="RTCDTMFSender">toneBuffer</a></code>
                is an empty string, return.</li>
                <li>If the value of the <code><a data-for=
                "RTCDTMFSender">duration</a></code> attribute is less than 40,
                set it to 40. If, on the other hand, the value is greater than
                6000, set it to 6000.</li>
                <li>If the value of the <code><a data-for=
                "RTCDTMFSender">interToneGap</a></code> attribute is less than
                30, set it to 30.</li>
                <li>If a <em>Playout task</em> is scheduled to be run; abort
                these steps; otherwise queue a task that runs the following
                steps (<em>Playout task</em>):
                  <ol>
                    <li>If <code><a data-for=
                    "RTCDTMFSender">toneBuffer</a></code> is an empty string,
                    fire an event named <code><a>tonechange</a></code> with an
                    empty string at the <code><a>RTCDTMFSender</a></code>
                    object and abort these steps.</li>
                    <li>Remove the first character from <code><a data-for=
                    "RTCDTMFSender">toneBuffer</a></code> and let that
                    character be <var>tone</var>.</li>
                    <li>Start playout of <var>tone</var> for <code><a data-for=
                    "RTCDTMFSender">duration</a></code> ms on the associated
                    RTP media stream, using the appropriate codec.</li>
                    <li>Queue a task to be executed in <code><a data-for=
                    "RTCDTMFSender">duration</a></code> + <code><a data-for=
                    "RTCDTMFSender">interToneGap</a></code> ms from now that
                    runs the steps labelled <em>Playout task</em>.</li>
                    <li>Fire an event named <code><a>tonechange</a></code> with
                    a string consisting of <var>tone</var> at the
                    <code><a>RTCDTMFSender</a></code> object.</li>
                  </ol>
                </li>
              </ol>
              <p>Calling <code><a data-for=
              "RTCDTMFSender">insertDTMF</a></code> with an empty tones
              parameter can be used to cancel all tones queued to play after
              the currently playing tone.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">tones</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">duration</td>
                    <td class="prmType"><code>unsigned long = 100</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">interToneGap</td>
                    <td class="prmType"><code>unsigned long = 70</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>RTCDTMFToneChangeEvent</h3>
      <p>The <code><a>tonechange</a></code> event uses the
      <code><a>RTCDTMFToneChangeEvent</a></code> interface.</p>
      <p><dfn id="fire-a-tonechange-event" data-lt=
      "fire a tonechange event">Firing a tonechange event named
      <var>e</var></dfn> with a <code>DOMString</code> <var>tone</var> means
      that an event with the name <var>e</var>, which does not bubble (except
      where otherwise stated) and is not cancelable (except where otherwise
      stated), and which uses the <code><a>RTCDTMFToneChangeEvent</a></code>
      interface with the <code><a data-for=
      "RTCDTMFToneChangeEvent">tone</a></code> attribute set to
      <var>tone</var>, MUST be created and dispatched at the given target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCDTMFToneChangeEventInit eventInitDict)]
interface RTCDTMFToneChangeEvent : Event {
    readonly        attribute DOMString tone;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCDTMFToneChangeEvent" data-dfn-for=
          "RTCDTMFToneChangeEvent" class="constructors">
            <dt><dfn><code>RTCDTMFToneChangeEvent</code></dfn></dt>
            <dd>
              readonly attribute DOMString tone
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType">
                    <code>RTCDTMFToneChangeEventInit</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDTMFToneChangeEvent" data-dfn-for=
          "RTCDTMFToneChangeEvent" class="attributes">
            <dt><code>tone</code> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly</dt>
            <dd>
              <p>The <dfn><code>tone</code></dfn> attribute contains the
              character for the tone that has just begun playout (see
              <code><a>insertDTMF</a></code> ). If the value is the empty
              string, it indicates that the previous tone has completed
              playback.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCDTMFToneChangeEventInit : EventInit {
             DOMString tone;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDTMFToneChangeEventInit</a>
          Members</h2>
          <dl data-link-for="RTCDTMFToneChangeEventInit" data-dfn-for=
          "RTCDTMFToneChangeEventInit" class="dictionary-members">
            <dt><dfn><code>tone</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p class="issue">TODO</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  </section>
  <section>
    <h2 id="sec.stats-model">Statistics Model</h2>
    <section>
      <h3>Introduction</h3>
      <p>The basic statistics model is that the browser maintains a set of
      statistics referenced by a <dfn id="stats-selector">selector</dfn>. The
      selector may, for example, be a <code>MediaStreamTrack</code>. For a
      track to be a valid selector, it MUST be a <code>MediaStreamTrack</code>
      that is sent or received by the <code><a>RTCPeerConnection</a></code>
      object on which the stats request was issued. The calling Web application
      provides the selector to the <code><a data-for=
      "RTCPeerConnection">getStats()</a></code> method and the browser emits
      (in the JavaScript) a set of statistics that it believes is relevant to
      the selector.</p>
      <div class="issue">
        Evaluate the need for other selectors than MediaStreamTrack.
      </div>
      <p>The statistics returned are designed in such a way that repeated
      queries can be linked by the <code><a>RTCStats</a></code> <a data-for=
      "RTCStats">id</a> dictionary member. Thus, a Web application can make
      measurements over a given time period by requesting measurements at the
      beginning and end of that period.</p>
    </section>
    <section>
      <h3>RTCPeerConnection Interface Extensions</h3>
      <p>The Statistics API extends the <code><a>RTCPeerConnection</a></code>
      interface as described below.</p>
      <div>
        <pre class="idl">partial interface RTCPeerConnection {
    Promise&lt;RTCStatsReport&gt; getStats (optional MediaStreamTrack? selector = null);
};</pre>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="methods">
            <dt><code>getStats</code></dt>
            <dd>
              <p>Gathers stats for the given <a>selector</a> and reports the
              result asynchronously.</p>
              <p>When the <dfn id=
              "widl-RTCPeerConnection-getStats-Promise-RTCStatsReport--MediaStreamTrack-selector">
              <code>getStats()</code></dfn> method is invoked, the user agent
              MUST run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>selectorArg</var> be the methods first
                  argument.</p>
                </li>
                <li>
                  <p>If <var>selectorArg</var> is neither <code>null</code> nor
                  a valid <a>selector</a>, return a promise rejected with a
                  <code>TypeError</code>.</p>
                </li>
                <li>
                  <p>Let <var>p</var> be a new promise.</p>
                </li>
                <li>
                  <p>Run the following steps in parallel:</p>
                  <ol>
                    <li>
                      <p>Start gathering the stats indicated by
                      <var>selectorArg</var>. If <var>selectorArg</var> is
                      null, stats MUST be gathered for the whole
                      <code><a>RTCPeerConnection</a></code> object.</p>
                    </li>
                    <li>
                      <p>When the relevant stats have been gathered, resolve
                      <var>p</var> with a new
                      <code><a>RTCStatsReport</a></code> object, representing
                      the gathered stats.</p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>Return <var>p</var>.</p>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">selector</td>
                    <td class="prmType"><code>MediaStreamTrack =
                    null</code></td>
                    <td class="prmNullTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em>
                <code>Promise&lt;RTCStatsReport&gt;</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>RTCStatsCallback</h3>
      <div>
        <pre class="idl">
        callback RTCStatsCallback = void (RTCStatsReport report);</pre>
        <section>
          <h2>Callback <a class="idlType">RTCStatsCallback</a> Parameters</h2>
          <dl data-link-for="RTCStatsCallback" data-dfn-for="RTCStatsCallback"
          class="callback-members">
            <dt><code>report</code> of type <span class=
            "idlMemberType"><a>RTCStatsReport</a></span></dt>
            <dd>
              <p>A <code><a>RTCStatsReport</a></code> representing the gathered
              stats.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>RTCStatsReport Object</h3>
      <p>The <code><a data-for="RTCPeerConnection">getStats()</a></code> method
      delivers a successful result in the form of an
      <code><a>RTCStatsReport</a></code> object. An
      <code><a>RTCStatsReport</a></code> object is a map between strings that
      identify the inspected objects (<a data-for=
      "RTCStats"><code>id</code></a> attribute in <code>RTCStats</code>
      instances), and their corresponding <code><a>RTCStats</a></code>-derived
      dictionaries.</p>
      <p>An <code><a>RTCStatsReport</a></code> may be composed of several
      <code><a>RTCStats</a></code>-derived dictionaries, each reporting stats
      for one underlying object that the implementation thinks is relevant for
      the <a>selector</a>. One achieves the total for the <a>selector</a> by
      summing over all the stats of a certain type; for instance, if a
      <code>MediaStreamTrack</code> is carried by multiple SSRCs over the
      network, the <code><a>RTCStatsReport</a></code> may contain one
      <code>RTCStats</code>-derived dictionary per SSRC (which can be
      distinguished by the value of the "ssrc" stats attribute).</p>
      <div>
        <pre class="idl">interface RTCStatsReport {
    readonly maplike&lt;DOMString, object&gt;;
};</pre>
        <p>This interface has "entries", "forEach", "get", "has", "keys",
        "values", @@iterator methods and a "size" getter brought by
        <code>readonly maplike</code>.</p>
        <p>Use these to retrieve the various dictionaries descended from
        <code><a>RTCStats</a></code> that this stats report is composed of. The
        set of supported property names [[!WEBIDL-1]] is defined as the ids of
        all the <code><a>RTCStats</a></code>-derived dictionaries that have
        been generated for this stats report.</p>
      </div>
    </section>
    <section>
      <h3>RTCStats Dictionary</h3>
      <p>An <code><a>RTCStats</a></code> dictionary represents the stats
      gathered by inspecting a specific object relevant to a <a>selector</a>.
      The <code><a>RTCStats</a></code> dictionary is a base type that specifies
      as set of default attributes, such as <a data-for=
      "RTCStats">timestamp</a> and <a data-for="RTCStats">type</a>. Specific
      stats are added by extending the <code><a>RTCStats</a></code>
      dictionary.</p>
      <p>Note that while stats names are standardized, any given implementation
      may be using experimental values or values not yet known to the Web
      application. Thus, applications MUST be prepared to deal with unknown
      stats.</p>
      <div class="issue">
        Need to define an IANA registry for this and populate with pointers to
        existing things such as the RTCP statistics.
      </div>
      <p>Statistics need to be synchronized with each other in order to yield
      reasonable values in computation; for instance, if "bytesSent" and
      "packetsSent" are both reported, they both need to be reported over the
      same interval, so that "average packet size" can be computed as "bytes /
      packets" - if the intervals are different, this will yield errors. Thus
      implementations MUST return synchronized values for all stats in an
      <code><a>RTCStats</a></code>-derived dictionary.</p>
      <div>
        <pre class="idl">dictionary RTCStats {
             DOMHighResTimeStamp timestamp;
             RTCStatsType        type;
             DOMString           id;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCStats</a> Members</h2>
          <dl data-link-for="RTCStats" data-dfn-for="RTCStats" class=
          "dictionary-members">
            <dt><code>timestamp</code> of type <span class=
            "idlMemberType"><a>DOMHighResTimeStamp</a></span></dt>
            <dd>
              <p>The <dfn><code>timestamp</code></dfn>, of type
              <code>DOMHighResTimeStamp</code> [[!HIGHRES-TIME]], associated
              with this object. The time is relative to the UNIX epoch (Jan 1,
              1970, UTC).</p>
            </dd>
            <dt><code>type</code> of type <span class=
            "idlMemberType"><a>RTCStatsType</a></span></dt>
            <dd>
              <p>The type of this object.</p>
              <p>The <dfn><code>type</code></dfn> attribute MUST be initialized
              to the name of the most specific type this
              <code><a>RTCStats</a></code> dictionary represents.</p>
            </dd>
            <dt><code>id</code> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>A unique <dfn><code>id</code></dfn> that is associated with
              the object that was inspected to produce this
              <code><a>RTCStats</a></code> object. Two
              <code><a>RTCStats</a></code> objects, extracted from two
              different <code><a>RTCStatsReport</a></code> objects, MUST have
              the same id if they were produced by inspecting the same
              underlying object. User agents are free to pick any format for
              the id as long as it meets the requirements above.</p>
              <div class="issue">
                Consider naming id something that indicates that the id refers
                to the underlying object that was inspected to produce the
                stats, instead of being an id for the JavaScript object.
                Suggestions: statsObjectId, reporterId, srcId.
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">enum RTCStatsType {
    "inboundrtp",
    "outboundrtp"
};</pre>
        <table data-link-for="RTCStatsType" data-dfn-for="RTCStatsType" class=
        "simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code>inboundrtp</code></dfn></td>
              <td>Inbound RTP.</td>
            </tr>
            <tr>
              <td><dfn><code>outboundrtp</code></dfn></td>
              <td>Outbound RTP.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section>
      <h3>Derived Stats Dictionaries</h3>
      <div>
        <pre class="idl">dictionary RTCRTPStreamStats : RTCStats {
             unsigned long ssrc;
             DOMString     remoteId;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRTPStreamStats</a> Members</h2>
          <dl data-link-for="RTCRTPStreamStats" data-dfn-for=
          "RTCRTPStreamStats" class="dictionary-members">
            <dt><dfn><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>...</p>
            </dd>
            <dt><dfn><code>remoteId</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The <code>remoteId</code> can be used to look up the
              corresponding <code><a>RTCStats</a></code> object that represents
              stats reported by the other peer.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
        dictionary RTCInboundRTPStreamStats : RTCRTPStreamStats {
             unsigned long packetsReceived;
             unsigned long bytesReceived;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCInboundRTPStreamStats</a>
          Members</h2>
          <dl data-link-for="RTCInboundRTPStreamStats" data-dfn-for=
          "RTCInboundRTPStreamStats" class="dictionary-members">
            <dt><dfn><code>packetsReceived</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>...</p>
            </dd>
            <dt><dfn><code>bytesReceived</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>...</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
        dictionary RTCOutboundRTPStreamStats : RTCRTPStreamStats {
             unsigned long packetsSent;
             unsigned long bytesSent;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCOutboundRTPStreamStats</a>
          Members</h2>
          <dl data-link-for="RTCOutboundRTPStreamStats" data-dfn-for=
          "RTCOutboundRTPStreamStats" class="dictionary-members">
            <dt><dfn><code>packetsSent</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>...</p>
            </dd>
            <dt><dfn><code>bytesSent</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>...</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>Example</h3>
      <p>Consider the case where the user is experiencing bad sound and the
      application wants to determine if the cause of it is packet loss. The
      following example code might be used:</p>
      <pre class="example highlight">var baselineReport, currentReport;
var selector = pc.getSenders()[0].track;

pc.getStats(selector).then(function (report) {
    baselineReport = report;
})
.then(function() {
    return new Promise(function(resolve) {
        setTimeout(resolve, aBit); // ... wait a bit
    });
})
.then(function() {
    return pc.getStats(selector);
})
.then(function (report) {
    currentReport = report;
    processStats();
})
.catch(function (error) {
  log(error.toString());
});

function processStats() {
    // compare the elements from the current report with the baseline
    currentReport.forEach (now =&gt; {
        if (now.type != "outboundrtp")
            return;

        // get the corresponding stats from the baseline report
        base = baselineReport.get(now.id);

        if (base) {
            remoteNow = currentReport.get(now.remoteId);
            remoteBase = baselineReport.get(base.remoteId);

            var packetsSent = now.packetsSent - base.packetsSent;
            var packetsReceived = remoteNow.packetsReceived - remoteBase.packetsReceived;

            // if fractionLost is &gt; 0.3, we have probably found the culprit
            var fractionLost = (packetsSent - packetsReceived) / packetsSent;
        }
    }
}
</pre>
    </section>
  </section>
  <section>
    <h2 id="sec.identity-proxy">Identity</h2>
    <section>
      <h3>Identity Provider Interaction</h3>
      <p>WebRTC offers and answers (and hence the channels established by
      <code><a>RTCPeerConnection</a></code> objects) can be authenticated by
      using a web-based Identity Provider (IdP). The idea is that the entity
      sending an offer or answer acts as the Authenticating Party (AP) and
      obtains an identity assertion from the IdP which it attaches to the
      session description. The consumer of the session description (i.e., the
      <code><a>RTCPeerConnection</a></code> on which
      <code>setRemoteDescription</code> is called) acts as the Relying Party
      (RP) and verifies the assertion.</p>
      <p>The interaction with the IdP is designed to decouple the browser from
      any particular identity provider; the browser need only know how to load
      the IdP's JavaScript, the location of which is determined by the IdP's
      identity, and the generic interface to generating and validating
      assertions. The IdP provides whatever logic is necessary to bridge the
      generic protocol to the IdP's specific requirements. Thus, a single
      browser can support any number of identity protocols, including being
      forward compatible with IdPs which did not exist at the time the browser
      was written.</p>
      <section>
        <h4 id="sec.identity-proxy-communications">Identity Provider
        Selection</h4>
        <p>An IdP is used to generate an identity assertion as follows:</p>
        <ol>
          <li>If the <code>setIdentityProvider()</code> method has been called,
          the IdP provided shall be used.</li>
          <li>If the <code>setIdentityProvider()</code> method has not been
          called, then the user agent MAY use an IdP configured into the
          browser.</li>
        </ol>
        <p>In order to verify assertions, the IdP domain name and protocol are
        taken from the <code>domain</code> and <code>protocol</code> fields of
        the identity assertion.</p>
      </section>
      <section>
        <h4 id="sec.create-identity-proxy">Instantiating an IdP Proxy</h4>
        <p>In order to communicate with the IdP, the user agent loads the IdP
        JavaScript from the IdP. The URI for the IdP script is a well-known URI
        formed from the <q>domain</q> and <q>protocol</q> fields, as specified
        in [[!RTCWEB-SECURITY-ARCH]].</p>
        <p>The IdP MAY generate an HTTP redirect to another "https" origin, the
        browser MUST treat a redirect to any other scheme as a fatal error.</p>
        <p>The user agent instantiates an isolated interpreted context, a
        JavaScript <a href=
        "http://people.mozilla.org/~jorendorff/es6-draft.html#sec-code-realms"><dfn>
        realm</dfn></a> that operates in the origin of the loaded JavaScript.
        Note that a redirect will change the origin of the loaded script.</p>
        <p>The <a>realm</a> is populated with a global that implements
        both the <code><a>RTCIdentityProviderGlobalScope</a></code> and
        <code>WorkerGlobalScope</code> [[!WEBWORKERS]] interfaces.</p>
        <p>The user agent provides an instance of
        <code><a>RTCIdentityProviderRegistrar</a></code> named
        <var>rtcIdentityProvider</var> in the global scope of the <a>realm</a>.
        This object is used by the IdP to interact with the user agent.</p>
        <div>
          <pre class="idl">[Global, Exposed=RTCIdentityProviderGlobalScope]
interface RTCIdentityProviderGlobalScope : WorkerGlobalScope {
    readonly        attribute RTCIdentityProviderRegistrar rtcIdentityProvider;
};</pre>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="RTCIdentityProviderGlobalScope" data-dfn-for=
            "RTCIdentityProviderGlobalScope" class="attributes">
              <dt><dfn><code>rtcIdentityProvider</code></dfn> of type
              <span class=
              "idlAttrType"><a>RTCIdentityProviderRegistrar</a></span>,
              readonly</dt>
              <dd>This object is used by the IdP to register an
              <code><a>RTCIdentityProvider</a></code> instance with the
              browser.</dd>
            </dl>
          </section>
        </div>
        <section>
          <h2 id="sec.implement-idp">Implementing an IdP Securely</h2>
          <p>An environment that mimics the identity provider realm can be
          provided by any script. However, only scripts running in the origin
          of the IdP are able to generate an identical environment. Other
          origins can load and run the IdP proxy code, but they will be unable
          to replicate data that is unique to the origin of the IdP.</p>
          <p>This means that it is critical that an IdP use data that is
          restricted to its own origin when generating identity assertions.
          Otherwise, another origin could load the IdP script and use it to
          impersonate users.</p>
          <p>The data that the IdP script uses could be stored on the client
          (for example, in <a href=
          "http://www.w3.org/TR/IndexedDB/">IndexedDB</a>) or loaded from
          servers. Data that is acquired from a server SHOULD require
          credentials and be protected from cross-origin access.</p>
          <p>There is no risk to the integrity of identity assertions if an IdP
          validates an identity assertion without using origin-private
          data.</p>
        </section>
      </section>
    </section>
    <section>
      <h2 id="sec.register-idp">Registering an IdP Proxy</h2>
      <p>An IdP proxy implements the <code><a>RTCIdentityProvider</a></code>
      methods, which are the means by which the user agent is able to request
      that an identity assertion be generated or validated.</p>
      <p>Once instantiated, the IdP script is executed. The IdP MUST call the
      <code>register()</code> function on the
      <code><a>RTCIdentityProviderRegistrar</a></code> instance during script
      execution. If an IdP is not registered during this script execution, the
      user agent cannot use the IdP proxy and MUST fail any future attempt to
      interact with the IdP.</p>
      <div>
        <pre class="idl">[Exposed=RTCIdentityProviderGlobalScope]
interface RTCIdentityProviderRegistrar {
    void register (RTCIdentityProvider idp);
};</pre>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCIdentityProviderRegistrar" data-dfn-for=
          "RTCIdentityProviderRegistrar" class="methods">
            <dt><dfn><code>register</code></dfn></dt>
            <dd>
              <p>This method is invoked by the IdP when its script is first
              executed. This registers <code><a>RTCIdentityProvider</a></code>
              methods with the user agent.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">idp</td>
                    <td class="prmType"><code>RTCIdentityProvider</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <section>
        <h2>Interface Exposed by Identity Providers</h2>
        <p>The callback functions in <code>RTCIdentityProvider</code> are
        exposed by identity providers and is called by
        <code>RTCPeerConnection</code> to acquire or validate identity
        assertions.</p>
        <div>
          <pre class="idl">dictionary RTCIdentityProvider {
    required GenerateAssertionCallback generateAssertion;
    required ValidateAssertionCallback validateAssertion;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCIdentityProvider</a>
            Members</h2>
            <dl data-link-for="RTCIdentityProvider" data-dfn-for=
            "RTCIdentityProvider" class="dictionary-members">
              <dt><dfn><code>generateAssertion</code></dfn> of type
              <span class="idlMemberType"><a>GenerateAssertionCallback</a></span>,
              required</dt>
              <dd>
                <p>A user agent invokes this method on the IdP to request the
                generation of an identity assertion.</p>
                <p>The IdP provides a promise that resolves to an
                <code><a>RTCIdentityAssertionResult</a></code> to successfully
                generate an identity assertion. Any other value, or a rejected
                promise, is treated as an error.</p>
              </dd>
              <dt><dfn><code>validateAssertion</code></dfn> of type
              <span class="idlMemberType"><a>ValidateAssertionCallback</a></span>,
              required</dt>
              <dd>
                <p>A user agent invokes this method on the IdP to request the
                validation of an identity assertion.</p>
                <p>The IdP returns a Promise that resolves to an
                <code><a>RTCIdentityValidationResult</a></code> to successfully
                validate an identity assertion and to provide the actual
                identity. Any other value, or a rejected promise, is treated as
                an error.</p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">
          callback GenerateAssertionCallback = Promise&lt;RTCIdentityAssertionResult&gt; (DOMString contents, DOMString origin, optional DOMString usernameHint);</pre>
          <section>
            <h2>Callback <a class="idlType">GenerateAssertionCallback</a>
            Parameters</h2>
            <dl data-link-for="GenerateAssertionCallback" data-dfn-for=
            "GenerateAssertionCallback" class="callback-members">
              <dt><code>contents</code> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>The <var>contents</var> parameter includes the information
              that the user agent wants covered by the identity assertion. A
              successful validation of the provided assertion MUST produce this
              string.</dd>
              <dt><code>origin</code> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>
                The <var>origin</var> parameter identifies the origin of the
                <code><a>RTCPeerConnection</a></code> that triggered this
                request. An IdP can use this information as input to policy
                decisions about use. This value is generated by the <a>user
                agent</a> based on the origin of the document that created the
                <code>RTCPeerConnection</code> and therefore can be trusted to
                be correct.
              </dd>
              <dt><code>usernameHint</code> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>The IdP selects the identity to assert. The optional
              <var>usernameHint</var> parameter is the same value that was
              passed to <code>setIdentityProvider</code>.</dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">
          callback ValidateAssertionCallback = Promise&lt;RTCIdentityValidationResult&gt; (DOMString assertion, DOMString origin);</pre>
          <section>
            <h2>Callback <a class="idlType">ValidateAssertionCallback</a>
            Parameters</h2>
            <dl data-link-for="ValidateAssertionCallback" data-dfn-for=
            "ValidateAssertionCallback" class="callback-members">
              <dt><code>assertion</code> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>The <var>assertion</var> parameter includes the assertion
              that was recovered from an <code>a=identity</code> in the session
              description; that is, the value that was part of the
              <code><a>RTCIdentityAssertionResult</a></code> provided by the
              IdP that generated the assertion.</dd>
              <dt><code>origin</code> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>The <var>origin</var> parameter identifies the origin of the
              <code><a>RTCPeerConnection</a></code> that triggered this
              request. An IdP can use this information as input to policy
              decisions about use.</dd>
            </dl>
          </section>
        </div>
      </section>
      <section>
        <h2>Identity Assertion and Validation Results</h2>
        <div>
          <pre class="idl">dictionary RTCIdentityAssertionResult {
    required RTCIdentityProviderDetails idp;
    required DOMString                  assertion;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCIdentityAssertionResult</a>
            Members</h2>
            <dl data-link-for="RTCIdentityAssertionResult" data-dfn-for=
            "RTCIdentityAssertionResult" class="dictionary-members">
              <dt><dfn><code>idp</code></dfn> of type <span class=
              "idlMemberType"><a>RTCIdentityProviderDetails</a></span>,
              required</dt>
              <dd>
                <p>An IdP provides these details to identify the IdP that
                validates the identity assertion. This struct contains the same
                information that is provided to
                <code>setIdentityProvider</code>.</p>
              </dd>
              <dt><dfn><code>assertion</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, required</dt>
              <dd>
                <p>An identity assertion. This is an opaque string that MUST
                contain all information necessary to assert identity. This
                value is consumed by the validating IdP.</p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">dictionary RTCIdentityProviderDetails {
    required DOMString domain;
             DOMString protocol = "default";
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCIdentityProviderDetails</a>
            Members</h2>
            <dl data-link-for="RTCIdentityProviderDetails" data-dfn-for=
            "RTCIdentityProviderDetails" class="dictionary-members">
              <dt><dfn><code>domain</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, required</dt>
              <dd>
                <p>The domain name of the IdP that validated the associated
                identity assertion.</p>
              </dd>
              <dt><dfn><code>protocol</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, defaulting to
              <code>"default"</code></dt>
              <dd>
                <p>The protocol parameter used for the IdP.</p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">dictionary RTCIdentityValidationResult {
    required DOMString identity;
    required DOMString contents;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCIdentityValidationResult</a>
            Members</h2>
            <dl data-link-for="RTCIdentityValidationResult" data-dfn-for=
            "RTCIdentityValidationResult" class="dictionary-members">
              <dt><dfn><code>identity</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, required</dt>
              <dd>
                <p>The validated identity of the peer.</p>
              </dd>
              <dt><dfn><code>contents</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, required</dt>
              <dd>
                <p>The payload of the identity assertion. An IdP that validates
                an identity assertion MUST return the same string that was
                provided to the original IdP that generated the assertion.</p>
                <p>The user agent uses the <var>contents</var> string to
                determine if the identity assertion matches the session
                description.</p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
    </section>
    <section>
      <h3 id="sec.identity-proxy-assertion-request">Requesting Identity
      Assertions</h3>
      <p>The identity assertion request process is triggered by a call to
      <code>createOffer</code>, <code>createAnswer</code>, or
      <code>getIdentityAssertion</code>. When these calls are invoked and an
      identity provider has been set, the following steps are executed:</p>
      <ol>
        <li>
          <p>The <code>RTCPeerConnection</code> instantiates an IdP as
          described in <a href="#sec.identity-proxy-communications">Identity
          Provider Selection</a> and <a href="#sec.register-idp">Registering an
          IdP Proxy</a>. If the IdP cannot be loaded, instantiated, or the IdP
          proxy is not registered, this process fails.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> invokes the <code><a data-for=
          "RTCIdentityProvider">generateAssertion</a></code> method on the
          <code><a>RTCIdentityProvider</a></code> methods registered by the
          IdP.</p>
          <p>The <code>RTCPeerConnection</code> generates the
          <var>contents</var> parameter to this method as described in
          [[!RTCWEB-SECURITY-ARCH]]. The value of <var>contents</var> includes
          the fingerprint of the certificate that was selected or generated
          during the construction of the <code>RTCPeerConnection</code>. The
          <var>origin</var> parameter contains the origin of the script that
          calls the <code>RTCPeerConnection</code> method that triggers this
          behavior. The <var>usernameHint</var> value is the same value that is
          provided to <code>setIdentityProvider</code>, if any such value was
          provided.</p>
        </li>
        <li>
          <p>The IdP proxy returns a Promise to the
          <code>RTCPeerConnection</code>.  The IdP proxy is expected to
          generate the identity assertion asynchronously.</p>
          <p>If the user has been authenticated by the IdP, and the IdP is
          able to generate an identity assertion, the IdP resolves the
          promise with an identity assertion in the form of an
          <code><a>RTCIdentityAssertionResult</a></code>.</p>
          <p>This step depends entirely on the IdP. The methods by which an IdP
          authenticates users or generates assertions is not specified, though
          they could involve interacting with the IdP server or other
          servers.</p>
        </li>
        <li>
          <p>If the IdP proxy produces an error or returns a promise that does
          not resolve to a valid
          <code><a>RTCIdentityValidationResult</a></code> (see <a href=
          "#sec.idp-error-handling"></a>), then identity validation fails.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> MAY store the identity
          assertion for use with future offers or answers. If a fresh identity
          assertion is needed for any reason, applications can create a new
          <code>RTCPeerConnection</code>.</p>
        </li>
        <li>
          <p>If the identity request was triggered by a
          <code>createOffer()</code> or <code>createAnswer()</code>, then the
          assertion is converted to a JSON string, base64-encoded and inserted
          into an <code>a=identity</code> attribute in the session
          description.</p>
        </li>
      </ol>
      <p>If assertion generation fails, then the promise for the corresponding
      function call is rejected with a <code>DOMException</code> that has the
      name <code>OperationError</code>.</p>
      <section>
        <h4 id="sec.idp-loginneeded">User Login Procedure</h4>
        <p>An IdP MAY reject an attempt to generate an identity assertion if it
        is unable to verify that a user is authenticated. This might be due to
        the IdP not having the necessary authentication information available
        to it (such as cookies).</p>
        <p>Rejecting the promise returned by <code><a data-for=
        "RTCIdentityProvider">generateAssertion</a></code> will cause the error
        to propagate to the application. Login errors are indicated by
        rejecting the promise with an object that has a <code>name</code>
        attribute set to "IdpLoginError".</p>
        <p>If the rejection object also contains a <code>loginUrl</code>
        attribute, this value will be passed to the application in the
        <code>idpLoginUrl</code> attribute. This URL might link to page where a
        user can enter their (IdP) username and password, or otherwise provide
        any information the IdP needs to authorize a assertion request.</p>
        <p>An application can load the login URL in an IFRAME or popup window;
        the resulting page then SHOULD provide the user with an opportunity to
        enter any information necessary to complete the authorization
        process.</p>
        <p>Once the authorization process is complete, the page loaded in the
        IFRAME or popup sends a message using <var>postMessage</var>
        [[!webmessaging]] to the page that loaded it (through the <var><a href=
        "http://www.w3.org/html/wg/drafts/html/master/browsers.html#dom-opener">
        window.opener</a></var> attribute for popups, or through <var><a href=
        "http://www.w3.org/html/wg/drafts/html/master/browsers.html#dom-parent">
        window.parent</a></var> for pages loaded in an IFRAME). The message
        MUST consist of the <var>DOMString</var> "LOGINDONE". This message
        informs the application that another attempt at generating an identity
        assertion is likely to be successful.</p>
      </section>
    </section>
    <section>
      <h3 id="sec.identity-verify-assertion">Verifying Identity Assertions</h3>
      <p>Identity assertion validation happens when <code><a data-for=
      "RTCPeerConnection">setRemoteDescription</a></code> is invoked on
      <code><a>RTCPeerConnection</a></code>. The process runs asynchronously,
      meaning that validation of an identity assertion might not block the
      completion of <code>setRemoteDescription</code>.</p>
      <p>The identity assertion request process involves the following
      asynchronous steps:</p>
      <ol>
        <li>
          <p>The <code>RTCPeerConnection</code> awaits any prior identity
          validation. Only one identity validation can run at a time for an
          <code>RTCPeerConnection</code>. This can happen because the
          resolution of <code>setRemoteDescription</code> is not blocked by
          identity validation unless there is a <a>target peer
          identity</a>.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> loads the identity assertion
          from the session description and decodes the base64 value, then
          parses the resulting JSON. The <var>idp</var> parameter of the
          resulting dictionary contains a <var>domain</var> and an optional
          <var>protocol</var> value that identifies the IdP, as described in
          [[!RTCWEB-SECURITY-ARCH]].</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> instantiates the identified IdP
          as described in <a href="#sec.identity-proxy-communications"></a> and
          <a href="#sec.register-idp"></a>. If the IdP cannot be loaded,
          instantiated or the IdP proxy is not registered, this process
          fails.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> invokes the <code><a data-for=
          "RTCIdentityProvider">validateAssertion</a></code> method registered
          by the IdP.</p>
          <p>The <var>assertion</var> parameter is taken from the decoded
          identity assertion. The <var>origin</var> parameter contains the
          origin of the script that calls the <code>RTCPeerConnection</code>
          method that triggers this behavior.</p>
        </li>
        <li>
          <p>The IdP proxy returns a promise and performs the validation
          process asynchronously.</p>
          <p>The IdP proxy verifies the identity assertion using whatever means
          necessary. Depending on the authentication protocol this could
          involve interacting with the IdP server.</p>
        </li>
        <li>
          <p>If the IdP proxy produces an error or returns a promise that does
          not resolve to a valid
          <code><a>RTCIdentityValidationResult</a></code> (see <a href=
          "#sec.idp-error-handling"></a>), then identity validation fails.</p>
        </li>
        <li>
          <p>Once the assertion is successfully verified, the IdP proxy
          resolves the promise with an
          <code><a>RTCIdentityValidationResult</a></code> containing the
          validated identity and the original contents that are the payload of
          the assertion.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> decodes the <code><a data-for=
          "RTCIdentityValidationResult">contents</a></code> and validates that
          it contains a fingerprint value for every <code>a=fingerprint</code>
          attribute in the session description. This ensures that the
          certificate used by the remote peer for communications is covered by
          the identity assertion.</p>
          <p class="note">A <a>user agent</a> is required to fail to
          communicate with peers that offer a certificate that doesn't match an
          <code>a=fingerprint</code> line in the negotiated session
          description.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> validates that the domain
          portion of the identity matches the domain of the IdP as described in
          [[!RTCWEB-SECURITY-ARCH]]. If this check fails then the identity
          validation fails.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> resolves the <code><a data-for=
          "RTCPeerConnection">peerIdentity</a></code> attribute with a new
          instance of <code>RTCIdentityAssertion</code> that includes the IdP
          domain and peer identity.</p>
        </li>
        <li>
          <p>The <a>user agent</a> MAY display identity information to a user
          in its UI. Any user identity information that is displayed in this
          fashion MUST use a mechanism that cannot be spoofed by content.</p>
        </li>
      </ol>
      <p>If identity validation fails, the <code><a data-for=
      "RTCPeerConnection">peerIdentity</a></code> promise is rejected with a
      <code>DOMException</code> that has a name of
      <code>OperationError</code>.</p>
      <p>If identity validation fails and there is a <a>target peer
      identity</a> for the <code>RTCPeerConnection</code>, the promise returned
      by <code>setRemoteDescription</code> MUST be rejected with the same
      <code>DOMException</code>.</p>
      <p>If identity validation fails and there is no a <a>target peer
      identity</a>, the value of the <code><a data-for=
      "RTCPeerConnection">peerIdentity</a></code> MUST be set to a new,
      unresolved promise instance. This permits the use of renegotiation (or a
      subsequent answer, if the session description was a provisional answer)
      to resolve or reject the identity.</p>
    </section>
    <section>
      <h2 id="sec.idp-error-handling">IdP Error Handling</h2>
      <p>Errors in IdP processing will - in most cases - result in the failure
      of the procedure that invoked the IdP proxy. This will result in the
      rejection of the promise returned by <code><a data-for=
      "RTCPeerConnection">getIdentityAssertion</a></code>, <code><a data-for=
      "RTCPeerConnection">createOffer</a></code>, or <code><a data-for=
      "RTCPeerConnection">createAnswer</a></code>. An IdP proxy error causes a
      <code><a data-for="RTCPeerConnection">setRemoteDescription</a></code>
      promise to be rejected if there is a <a>target peer identity</a>; IdP
      errors in calls to <code><a data-for=
      "RTCPeerConnection">setRemoteDescription</a></code> where there is no
      <a>target peer identity</a> cause the <code><a data-for=
      "RTCPeerConnection">peerIdentity</a></code> promise to be rejected
      instead.</p>
      <p>If an error occurs these promises are rejected with a
      <code>DOMException</code> that has a name of <code>OperationError</code>
      if an error occurs in interacting with the IdP proxy. The following
      scenarios result in errors:</p>
      <ul>
        <li>
          <p>A <code>RTCPeerConnection</code> might be configured with an
          identity provider, but that identity provider could register a
          <code>RTCIdentityProvider</code> with invalid methods. Any procedure
          that attempts to invoke such an identity provider fails.</p>
        </li>
        <li>
          <p>An apparently valid identity provider might fail in several ways.
          If an identity provider throws an exception or returns a promise that
          is ultimately rejected, then the procedure that depends on the IdP
          MUST also fail.</p>
        </li>
        <li>
          <p>The <a>user agent</a> SHOULD limit the time that allows for an IdP
          to run. This includes both the loading of the <a href=
          "#sec.identity-proxy-communications">IdP proxy</a> and the identity
          assertion generation or validation. Failure to do so potentially
          causes the corresponding operation to take an indefinite amount of
          time. This timer can be cancelled when the IdP proxy produces a
          response. Expiration of this timer is treated like any other type of
          IdP failure.</p>
        </li>
        <li>
          <p>Even when the IdP proxy produces a positive result, the procedure
          that uses this information might still fail. Additional validation of
          a <a>RTCIdentityValidationResult</a> value is still necessary. The
          procedure for <a href="#sec.identity-verify-assertion">validation of
          identity assertions</a> describes additional steps that are required
          to successfully validate the output of the IdP proxy.</p>
        </li>
      </ul>
    </section>
    <section>
      <h3>RTCPeerConnection Interface Extensions</h3>
      <p>The Identity API extends the <code><a>RTCPeerConnection</a></code>
      interface as described below.</p>
      <div>
        <pre class="idl">partial interface RTCPeerConnection {
    void               setIdentityProvider (DOMString provider, optional DOMString protocol, optional DOMString usernameHint);
    Promise&lt;DOMString&gt; getIdentityAssertion ();
    readonly        attribute Promise&lt;RTCIdentityAssertion&gt; peerIdentity;
    readonly        attribute DOMString?                    idpLoginUrl;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="attributes">
            <dt><dfn><code>peerIdentity</code></dfn> of type <span class=
            "idlAttrType">Promise&lt;<a>RTCIdentityAssertion</a>&gt;</span>,
            readonly</dt>
            <dd>
              <p>A promise that resolves with the identity of the peer if the
              identity is successfully validated.</p>
              <p>This promise is rejected if an identity assertion is present
              in a remote session description and validation of that assertion
              fails for any reason. If the promise is rejected, a new
              unresolved value is created, unless there a <a>target peer
              identity</a> has been established. If this promise successfully
              resolves, the value will not change.</p>
            </dd>
            <dt><dfn><code>idpLoginUrl</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly , nullable</dt>
            <dd>
              <p>The URL that an application can navigate to so that the user
              can login to the IdP, as described in <a href=
              "#sec.idp-loginneeded"></a>.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="methods">
            <dt><code>setIdentityProvider</code></dt>
            <dd>
              <p>Sets the identity provider to be used for a given
              <code>RTCPeerConnection</code> object. Applications need not make
              this call; if the browser is already configured for an IdP, then
              that configured IdP might be used to get an assertion.</p>
              <p>When the <dfn><code>setIdentityProvider</code></dfn> method is
              invoked, the user agent MUST run the following steps:</p>
              <ol>
                <li>
                  <p>If the <code><a>RTCPeerConnection</a></code> object's
                  [[<a>isClosed</a>]] slot is <code>true</code>, throw an
                  <code>InvalidStateError</code> exception and abort these
                  steps.</p>
                </li>
                <li>
                  <p>Set the current identity provider values to the triplet
                  (<code>provider</code>, <code>protocol</code>,
                  <code>usernameHint</code>).</p>
                </li>
                <li>
                  <p>If any identity provider value has changed, discard any
                  stored identity assertion.</p>
                </li>
              </ol>
              <p>Identity provider information is not used until an identity
              assertion is required, either in response to a call to
              <code>getIdentityAssertion</code>, or a session description is
              requested with a call to either <code>createOffer</code> or
              <code>createAnswer</code>.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">provider</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">protocol</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">usernameHint</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>getIdentityAssertion</code></dfn></dt>
            <dd>
              <p>Initiates the process of obtaining an identity assertion.
              Applications need not make this call. It is merely intended to
              allow them to start the process of obtaining identity assertions
              before a call is initiated. If an identity is needed, either
              because the browser has been configured with a default identity
              provider or because the <code>setIdentityProvider</code> method
              was called, then an identity will be automatically requested when
              an offer or answer is created.</p>
              <p>When <code>getIdentityAssertion</code> is invoked, queue a
              task to run the following steps:</p>
              <ol>
                <li>
                  <p>If the <code><a>RTCPeerConnection</a></code> object's
                  [[<a>isClosed</a>]] slot is <code>true</code>, throw an
                  <code>InvalidStateError</code> exception and abort these
                  steps.</p>
                </li>
                <li>
                  <p><a href="#sec.identity-proxy-assertion-request">Request an
                  identity assertion</a> from the IdP.</p>
                </li>
                <li>
                  <p>Resolve the promise with the base64 and JSON encoded
                  assertion.</p>
                </li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>Promise&lt;DOMString&gt;</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">[Constructor(DOMString idp, DOMString name)]
interface RTCIdentityAssertion {
                    attribute DOMString idp;
                    attribute DOMString name;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCIdentityAssertion" data-dfn-for=
          "RTCIdentityAssertion" class="attributes">
            <dt><dfn><code>idp</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span></dt>
            <dd>
              <p>The domain name of the identity provider that validated this
              identity.</p>
            </dd>
            <dt><dfn><code>name</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span></dt>
            <dd>
              <p>An RFC5322-conformant [[RFC5322]] representation of the
              verified peer identity. This identity will have been verified via
              the procedures described in [[!RTCWEB-SECURITY-ARCH]].</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>Examples</h3>
      <p>The identity system is designed so that applications need not take any
      special action in order for users to generate and verify identity
      assertions; if a user has configured an IdP into their browser, then the
      browser will automatically request/generate assertions and the other side
      will automatically verify them and display the results. However,
      applications may wish to exercise tighter control over the identity
      system as shown by the following examples.</p>
      <div>
        <p>This example shows how to configure the identity provider and
        protocol.</p>
        <pre class="example highlight">
        pc.setIdentityProvider("example.com", "default", "alice@example.com");
</pre>
      </div>
      <div>
        <p>This example shows how to consume identity assertions inside a Web
        application.</p>
        <pre class="example highlight">  pc.peerIdentity.then(identity =&gt;
    console.log("IdP= " + identity.idp + " identity=" + identity.name));
</pre>
      </div>
    </section>
  </section>
  <section>
    <h2>Media Stream API Extensions for Network Use</h2>
    <section>
      <h3>Introduction</h3>
      <p>The <code>MediaStreamTrack</code> interface, as defined in the
      [[!GETUSERMEDIA]] specification, typically represents a stream of data of
      audio or video. One or more <code>MediaStreamTrack</code>s can be
      collected in a <code>MediaStream</code> (strictly speaking, a
      <code>MediaStream</code> as defined in [[!GETUSERMEDIA]] may contain zero
      or more <code>MediaStreamTrack</code> objects).</p>
      <p>A <code>MediaStreamTrack</code> may be extended to represent a media
      flow that either comes from or is sent to a remote peer (and not just the
      local camera, for instance). The extensions required to enable this
      capability on the <code>MediaStreamTrack</code> object will be described
      in this section. How the media is transmitted to the peer is described in
      [[!RTCWEB-RTP]], [[!RTCWEB-AUDIO]], and [[!RTCWEB-TRANSPORT]].</p>
      <p>A <code>MediaStreamTrack</code> sent to another peer will appear as
      one and only one <code>MediaStreamTrack</code> to the recipient. A peer
      is defined as a user agent that supports this specification. In addition,
      the sending side application can indicate what <code>MediaStream</code>
      object(s) the <code>MediaStreamTrack</code> is member of. The
      corresponding <code>MediaStream</code> object(s) on the receiver side
      will be created (if not already present) and populated accordingly.</p>
      <p>As also described earlier in this document, the objects
      <code>RTCRtpSender</code> and <code>RTCRtpReceiver</code> can be used by
      the application to get more fine grained control over the transmission
      and reception of <code>MediaStreamTrack</code>s.</p>
      <p>Channels are the smallest unit considered in the
      <code>MediaStream</code> specification. Channels are intended to be
      encoded together for transmission as, for instance, an RTP payload type.
      All of the channels that a codec needs to encode jointly MUST be in the
      same <code>MediaStreamTrack</code> and the codecs SHOULD be able to
      encode, or discard, all the channels in the track.</p>
      <p>The concepts of an input and output to a given
      <code>MediaStreamTrack</code> apply in the case of
      <code>MediaStreamTrack</code> objects transmitted over the network as
      well. A <code><a>MediaStreamTrack</a></code> created by an
      <code><a>RTCPeerConnection</a></code> object (as described previously in
      this document) will take as input the data received from a remote peer.
      Similarly, a <code>MediaStreamTrack</code> from a local source, for
      instance a camera via [[!GETUSERMEDIA]], will have an output that
      represents what is transmitted to a remote peer if the object is used
      with an <code><a>RTCPeerConnection</a></code> object.</p>
      <p>The concept of duplicating <code>MediaStream</code> and
      <code>MediaStreamTrack</code> objects as described in [[!GETUSERMEDIA]]
      is also applicable here. This feature can be used, for instance, in a
      video-conferencing scenario to display the local video from the user's
      camera and microphone in a local monitor, while only transmitting the
      audio to the remote peer (e.g. in response to the user using a "video
      mute" feature). Combining different <code>MediaStreamTrack</code> objects
      into new <code>MediaStream</code> objects is useful in certain
      situations.</p>
      <p class="note">In this document, we only specify aspects of the
      following objects that are relevant when used along with an
      <code><a>RTCPeerConnection</a></code>. Please refer to the original
      definitions of the objects in the [[!GETUSERMEDIA]] document for general
      information on using <code>MediaStream</code> and
      <code>MediaStreamTrack</code>.</p>
    </section>
    <section>
      <h3>MediaStream</h3>
      <section>
        <h4>id</h4>
        <p>The <code><a href=
        "https://w3c.github.io/mediacapture-main/#dom-mediastream-id">id</a></code>
        attribute specified in <code>MediaStream</code> returns an id that is
        unique to this stream, so that streams can be recognized at the remote
        end of the <code><a>RTCPeerConnection</a></code> API.</p>
        <p>When a <code><a>MediaStream</a></code> is created to represent a
        stream obtained from a remote peer, the <code><a href=
        "https://w3c.github.io/mediacapture-main/#dom-mediastream-id">id</a></code>
        attribute is initialized from information provided by the remote
        source.</p>
        <p class="note">The id of a <code><a>MediaStream</a></code> object is
        unique to the source of the stream, but that does not mean it is not
        possible to end up with duplicates. For example, the tracks of a
        locally generated stream could be sent from one user agent to a remote
        peer using <code><a>RTCPeerConnection</a></code> and then sent back to
        the original user agent in the same manner, in which case the original
        user agent will have multiple streams with the same id (the
        locally-generated one and the one received from the remote peer).</p>
      </section>
    </section>
    <section>
      <h3>MediaStreamTrack</h3>
      <p>A <code>MediaStreamTrack</code> object's reference to its
      <code>MediaStream</code> in the non-local media source case (an RTP
      source, as is the case for <code>MediaStreamTrack</code>s received over
      an <code><a>RTCPeerConnection</a></code> ) is always strong.</p>
      <p>When an <code><a>RTCPeerConnection</a></code> receives data on an RTP
      source for the first time, it MUST <a>update the muted state</a> of the
      corresponding <code><a>MediaStreamTrack</a></code> with the value
      <code>false</code>.</p>
      <p>When an <code><a>RTCPeerConnection</a></code>'s RTP source is
      temporarily unable to receive media due to a loss of connection or if a
      mute signal has been received, it MUST <a>update the muted state</a> of
      the corresponding <code><a>MediaStreamTrack</a></code> with the value
      <code>true</code>. When media data is available again, the <a data-lt=
      "update the muted state">muted state MUST be updated</a> with the value
      <code>false</code>.</p>
      <p class="issue">The mute signal mentioned in the previous paragraph is
      yet to be defined.</p>
      <p>The procedure <dfn data-lt="update the muted state" id=
      "update-track-muted">update a track's muted state</dfn> is specified in
      [[!GETUSERMEDIA]].</p>
      <p>When a track comes from a remote peer and the remote peer has
      permanently stopped sending data the <code>ended</code> event MUST be
      fired on the track, as specified in [[!GETUSERMEDIA]].</p>
      <p class="issue">How do you know when it has stopped? This seems like an
      SDP question, not a media-level question. (Suggestion: when the track is
      ended, either through port 0, or removing the a=msid attrib)</p>
      <p>When a <a>remote source</a> is notified that a
      <code><a>MediaStreamTrack</a></code>, using the source, has
      <code>ended</code> [[!GETUSERMEDIA]] the User Agent MAY choose to free
      resources allocated for the incoming stream, for instance turn off the
      decoder.</p>
      <section>
        <h4>MediaTrackSupportedConstraints, MediaTrackCapabilities,
        MediaTrackConstraints and MediaTrackSettings</h4>
        <p>The basics of <code>MediaTrackSupportedConstraints</code>,
        <code>MediaTrackCapabilites</code>,
        <code>MediaTrackConstraints</code> and
        <code>MediaTrackSettings</code> is outlined in
        [[!GETUSERMEDIA]]. However, the <code>MediaTrackSettings</code>
        for a <code>MediaStreamTrack</code> sourced by a
        <code><a>RTCPeerConnection</a></code> will only be populated to the
        extent that data is supplied by means of the remote
        <code><a>RTCSessionDescription</a></code> applied via
        <code>setRemoteDescription</code> and the actual RTP data. This means
        that certain settings, such as <code>facingMode</code>,
        <code>echoCancellation</code> , <code>latency</code>,
        <code>deviceId</code> and <code>groupId</code>, will
        always return null.</p>
      </section>
    </section>
    <section>
      <h3>Isolated Media Streams</h3>
      <p>A MediaStream acquired using <code>getUserMedia()</code> is, by
      default, accessible to an application. This means that the application is
      able to access the contents of tracks, modify their content, and send
      that media to any peer it chooses.</p>
      <p>WebRTC supports calling scenarios where media is sent to a
      specifically identified peer, without the contents of media streams being
      accessible to applications. This is enabled by use of the
      <code>peerIdentity</code> parameter to <code>getUserMedia()</code>.</p>
      <p>An application willingly relinquishes access to media by including a
      <code>peerIdentity</code> parameter in the
      <code>MediaStreamConstraints</code>. This attribute is set to a
      <code>DOMString</code> containing the identity of a specific peer.</p>
      <p>The <code>MediaStreamConstraints</code> dictionary is expanded to
      include the <code>peerIdentity</code> parameter.</p>
      <div>
        <pre class="idl">partial dictionary MediaStreamConstraints {
             DOMString peerIdentity;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">MediaStreamConstraints</a>
          Members</h2>
          <dl data-link-for="MediaStreamConstraints" data-dfn-for=
          "MediaStreamConstraints" class="dictionary-members">
            <dt><dfn><code>peerIdentity</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>If set, <code>peerIdentity</code> isolates media from the
              application. Media can only be sent to the identified peer.</p>
            </dd>
          </dl>
        </section>
      </div>
      <p>A user that is prompted to provide consent for access to a camera or
      microphone can be shown the value of the <code>peerIdentity</code>
      parameter, so that they can be informed that the consent is more narrowly
      restricted.</p>
      <p>When the <code><dfn>peerIdentity</dfn></code> option is supplied to
      <code>getUserMedia()</code>, all of the <code>MediaStreamTrack</code>s in
      the resulting <code>MediaStream</code> are isolated so that content is
      not accessible to any application. Isolated
      <code>MediaStreamTrack</code>s can be used for two purposes:</p>
      <ul>
        <li>
          <p>Displayed in an appropriate media tag (e.g., a video or audio
          element). The browser MUST ensure that content is inaccessible to the
          application by ensuring that the resulting content is given the same
          protections as content that is <a href=
          "http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#cors-cross-origin">
          CORS cross-origin</a>, as described in the relevant <a href=
          "http://www.w3.org/html/wg/drafts/html/master/semantics.html#security-and-privacy-considerations">
          Security and privacy considerations section</a> of [[HTML5]].</p>
        </li>
        <li>
          <p>Used as the argument to <a data-for=
          "RTCPeerConnection">addTrack</a> on an
          <code><a>RTCPeerConnection</a></code> instance, subject to the
          restrictions in <a href="#isolated-pc">isolated streams and
          RTCPeerConnection</a>.</p>
        </li>
      </ul>
      <p>A <code>MediaStreamTrack</code> that is added to another
      <code>MediaStream</code> remains isolated. When an isolated
      <code>MediaStreamTrack</code> is added to a <code>MediaStream</code> with
      a different peerIdentity, the <code>MediaStream</code> gets a combination
      of isolation restrictions. A <code>MediaStream</code> containing
      <code>MediaStreamTrack</code> instances with mixed isolation properties
      can be displayed, but cannot be sent using
      <code><a>RTCPeerConnection</a></code>.</p>
      <p>Any <code>peerIdentity</code> property MUST be retained on cloned
      copies of <code>MediaStreamTrack</code>s.</p>
      <!-- Any stream or track that might be derived from an isolated stream,
           such as
           through <a href="https://www.w3.org/TR/streamproc/#media-element-extensions">captureStreamUntilEnded
           or captureStream</a>, MUST also retain any isolation protections.
        -->
      <section id="isolated-track">
        <h4>Extended MediaStreamTrack Properties</h4>
        <p><code>MediaStreamTrack</code> is expanded to include an
        <var>isolated</var> attribute and a corresponding event. This allows an
        application to quickly and easily determine whether a track is
        accessible.</p>
        <div>
          <pre class="idl">partial interface MediaStreamTrack {
    readonly        attribute boolean      isolated;
                    attribute EventHandler onisolationchange;
};</pre>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="MediaStreamTrack" data-dfn-for=
            "MediaStreamTrack" class="attributes">
              <dt><dfn><code>isolated</code></dfn> of type <span class=
              "idlAttrType"><a>boolean</a></span>, readonly</dt>
              <dd>
                <p>A <code>MediaStreamTrack</code> is isolated (and the
                corresponding <var>isolated</var> attribute set to
                <var>true</var>) when content is inaccessible to the owning
                document. This occurs as a result of setting the
                <var>peerIdentity</var> option. A track is also isolated if it
                comes from a cross origin source.</p>
              </dd>
              <dt><dfn><code>onisolationchange</code></dfn> of type
              <span class="idlAttrType"><a>EventHandler</a></span></dt>
              <dd>
                <p>This event handler, of type <a>isolationchange</a>, is fired
                when the value of the <var>isolated</var> attribute
                changes.</p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
      <section id="isolated-pc">
        <h4>Isolated Streams and RTCPeerConnection</h4>
        <p>A <code>MediaStreamTrack</code> with a <var>peerIdentity</var>
        option set can be added to any <code><a>RTCPeerConnection</a></code>.
        However, the content of an isolated track MUST NOT be transmitted
        unless all of the following constraints are met:</p>
        <ul>
          <li>
            <p>A <code>MediaStreamTrack</code> from a stream acquired using the
            <var>peerIdentity</var> option can be transmitted if the
            <code><a>RTCPeerConnection</a></code> has successfully <a href=
            "#sec.identity-verify-assertion">validated the identity</a> of the
            peer AND that identity is the same identity that was used in the
            <var>peerIdentity</var> option associated with the track. That is,
            the <code>name</code> attribute of the <code>peerIdentity</code>
            attribute of the <code><a>RTCPeerConnection</a></code> instance
            MUST match the value of the <code>peerIdentity</code> option passed
            to <code>getUserMedia()</code>.</p>
            <p>Rules for matching identity are described in
            [[!RTCWEB-SECURITY-ARCH]].</p>
          </li>
          <li>
            <p>The peer has indicated that it will respect the isolation
            properties of streams. That is, a DTLS connection with a promise to
            respect stream confidentiality, as defined in [[!RTCWEB-ALPN]] has
            been established.</p>
          </li>
        </ul>
        <p>Failing to meet these conditions means that no media can be sent for
        the affected <code>MediaStreamTrack</code>. Video MUST be replaced by
        black frames, audio MUST be replaced by silence, and equivalently
        information-free content MUST be provided for other media types.</p>
        <p>Remotely sourced <code>MediaStreamTrack</code>s MUST be isolated if
        they are received over a DTLS connection that has been negotiated with
        track isolation. This protects isolated media from the application in
        the receiving browser. These tracks MUST only be displayed to a user
        using the appropriate media element (e.g., &lt;video&gt; or
        &lt;audio&gt;).</p>
        <p>Any <code>MediaStreamTrack</code> that has the
        <var>peerIdentity</var> option set causes all tracks sent using the
        same <code><a>RTCPeerConnection</a></code> to be isolated at the
        receiving peer. All DTLS connections created for a
        <code><a>RTCPeerConnection</a></code> with isolated local streams MUST
        be negotiated so that media remains isolated at the remote peer. This
        causes non-isolated media to become isolated at the receiving peer if
        any isolated tracks are added to the same
        <code><a>RTCPeerConnection</a></code>.</p>
        <p class="note">Tracks that are not bound to a particular
        <var>peerIdentity</var> do not cause other streams to be isolated,
        these tracks simply do not have their content transmitted.</p>
        <p>If a stream becomes isolated after initially being accessible, or an
        isolated stream is added to an active session, then media for that
        stream is replaced by information-free content (e.g., black frames or
        silence).</p>
      </section>
      <section id="isolation-protection">
        <h4>Protection Afforded by Media Isolation</h4>
        <p>Media isolation ensures that the content of a
        <code>MediaStreamTrack</code> is not accessible to web applications.
        However, to ensure that media with a <var>peerIdentity</var> option set
        can be sent to peers, some meta-information about the media will be
        exposed to applications.</p>
        <p>Applications will be able to observe the parameters of the media
        that affect session negotiation and conversion into RTP. This includes
        the codecs that might be supported by the track, the bitrate, the
        number of packets, and the current settings that are set on the
        <code>MediaStreamTrack</code>.</p>
        <p>In particular, the <a href="#sec.stats-model">statistics</a> that
        <code><a>RTCPeerConnection</a></code> records are not reduced in
        capability. New statistics that might compromise isolation MUST be
        avoided, or explicitly suppressed for isolated streams.</p>
        <p>Most of these data are exposed to the network when the media is
        transmitted. Only the settings for the <code>MediaStreamTrack</code>
        present a new source of information. This can includes the frame rate
        and resolution of video tracks, the bandwidth of audio tracks, and
        other information about the source, which would not otherwise be
        revealed to a network observer. Since settings don't change at a high
        frequency or in response to changes in media content, settings only
        reveal limited reveal information about the content of a track.
        However, any setting that might change dynamically in response to the
        content of an isolated <code>MediaStreamTrack</code> MUST have changes
        suppressed.</p>
      </section>
    </section>
  </section>
  <section class="informative">
    <h2>Examples and Call Flows</h2>
    <section>
      <h3>Simple Peer-to-peer Example</h3>
      <div>
        <p>When two peers decide they are going to set up a connection to each
        other, they both go through these steps. The STUN/TURN server
        configuration describes a server they can use to get things like their
        public IP address or to set up NAT traversal. They also have to send
        data for the signaling channel to each other using the same out-of-band
        mechanism they used to establish that they were going to communicate in
        the first place.</p>
        <pre class="example highlight">
var signalingChannel = new SignalingChannel();
var configuration = { "iceServers": [{ "urls": "stuns:stun.example.org" }] };
var pc;

// call start() to initiate
function start() {
    pc = new RTCPeerConnection(configuration);

    // send any ice candidates to the other peer
    pc.onicecandidate = function (evt) {
        signalingChannel.send(JSON.stringify({ "candidate": evt.candidate }));
    };

    // let the "negotiationneeded" event trigger offer generation
    pc.onnegotiationneeded = function () {
        pc.createOffer().then(function (offer) {
            return pc.setLocalDescription(offer);
        })
        .then(function () {
            // send the offer to the other peer
            signalingChannel.send(JSON.stringify({ "desc": pc.localDescription }));
        })
        .catch(logError);
    };

    // once remote video track arrives, show it in the remote video element
    pc.ontrack = function (evt) {
        if (evt.track.kind === "video")
          remoteView.srcObject = evt.streams[0];
    };

    // get a local stream, show it in a self-view and add it to be sent
    navigator.mediaDevices.getUserMedia({ "audio": true, "video": true })
        .then(function (stream) {
            selfView.srcObject = stream;
            pc.addTrack(stream.getAudioTracks()[0], stream);
            pc.addTrack(stream.getVideoTracks()[0], stream);
        })
        .catch(logError);
}

signalingChannel.onmessage = function (evt) {
    if (!pc)
        start();

    var message = JSON.parse(evt.data);
    if (message.desc) {
        var desc = message.desc;

        // if we get an offer, we need to reply with an answer
        if (desc.type == "offer") {
            pc.setRemoteDescription(desc).then(function () {
                return pc.createAnswer();
            })
            .then(function (answer) {
                return pc.setLocalDescription(answer);
            })
            .then(function () {
                var str = JSON.stringify({ "desc": pc.localDescription });
                signalingChannel.send(str);
            })
            .catch(logError);
        } else if (desc.type == "answer") {
            pc.setRemoteDescription(desc).catch(logError);
        } else {
            log("Unsupported SDP type. Your code may differ here.");
        }
    } else
        pc.addIceCandidate(message.candidate).catch(logError);
};

function logError(error) {
    log(error.name + ": " + error.message);
}

</pre>
      </div>
    </section>
    <section>
      <h3>Simple Peer-to-peer Example with Warm-up</h3>
      <div>
        <p>When two peers decide they are going to set up a connection to each
        other and want to have the ICE, DTLS, and media connections "warmed up"
        such that they are ready to send and receive media immediately, they
        both go through these steps.</p>
        <pre class="example highlight">
var signalingChannel = new SignalingChannel();
var configuration = { "iceServers": [{ "urls": "stuns:stun.example.org" }] };
var pc;
var audio = null;
var audioSendTrack = null;
var video = null;
var videoSendTrack = null;
var started = false;

// Call warmp() to warm-up ICE, DTLS, and media, but not send media yet.
function warmup(answerer) {
    pc = new RTCPeerConnection(configuration);
    if (!answerer) {
      audio = pc.addTransceiver("audio");
      video = pc.addTransceiver("video");
    }

    // send any ice candidates to the other peer
    pc.onicecandidate = function (evt) {
        signalingChannel.send(JSON.stringify({ "candidate": evt.candidate }));
    };

    // let the "negotiationneeded" event trigger offer generation
    pc.onnegotiationneeded = function () {
        pc.createOffer().then(function (offer) {
            return pc.setLocalDescription(offer);
        })
        .then(function () {
            // send the offer to the other peer
            signalingChannel.send(JSON.stringify({ "desc": pc.localDescription }));
        })
        .catch(logError);
    };

    // once remote video track arrives, show it in the remote video element
    pc.ontrack = function (evt) {
        if (evt.track.kind === "audio") {
          if (answerer) {
            audio = evt.transceiver;
            audio.setDirection("sendrecv");
            if (started &amp;& audioSendTrack) {
              audio.sender.replaceTrack(audioSendTrack);
            }
          }
        } else if (evt.track.kind === "video") {
          if (answerer) {
            video = evt.transceiver;
            video.setDirection("sendrecv");
            if (started &amp;& videoSendTrack) {
              video.sender.replaceTrack(videoSendTrack);
            }
          }
          remoteView.srcObject = evt.streams[0];
        }
    };

    // get a local stream, show it in a self-view and add it to be sent
    navigator.mediaDevices.getUserMedia({ "audio": true, "video": true })
      .then(function (stream) {
        selfView.srcObject = stream;
        sendAudioTrack = stream.getVideoTracks()[0];
        if (started) {
          audio.sender.replaceTrack(sendAudioTrack);
        }
        sendVideoTrack = stream.getVideoTracks()[0];
        if (started) {
          video.sender.replaceTrack(sendVideoTrack);
        }
      })
      .catch(logError);
}

// Call start() to start sending media.
function start() {
  started = true;
  signalingChannel.send(JSON.stringify({ "start": true }));
}

signalingChannel.onmessage = function (evt) {
    if (!pc)
        warmup(true);

    var message = JSON.parse(evt.data);
    if (message.desc) {
        var desc = message.desc;

        // if we get an offer, we need to reply with an answer
        if (desc.type == "offer") {
            pc.setRemoteDescription(desc).then(function () {
                return pc.createAnswer();
            })
            .then(function (answer) {
                return pc.setLocalDescription(answer);
            })
            .then(function () {
                var str = JSON.stringify({ "desc": pc.localDescription });
                signalingChannel.send(str);
            })
            .catch(logError);
        } else
            pc.setRemoteDescription(desc).catch(logError);
    } else if (message.start) {
      started = true;
      if (audio &amp;& sendAudioTrack) {
        audio.sender.replaceTrack(sendVideoTrack);
      }
      if (video &amp;& sendVideoTrack) {
        video.sender.replaceTrack(sendVideoTrack);
      }
    } else
        pc.addIceCandidate(message.candidate).catch(logError);
};

function logError(error) {
    log(error.name + ": " + error.message);
}

</pre>
      </div>
    </section>
    <section>
      <h3>Simple Peer-to-peer Example with media before signaling</h3>
      <div>
        <p>The answerer may wish to send media in parallel with sending the
        answer, and the offerer may wish to render the media before the answer
        arrives.</p>
        <pre class="example highlight">
var signalingChannel = new SignalingChannel();
var configuration = { "iceServers": [{ "urls": "stuns:stun.example.org" }] };
var pc;

// call start() to initiate
function start() {
    pc = new RTCPeerConnection(configuration);

    // send any ice candidates to the other peer
    pc.onicecandidate = function (evt) {
        signalingChannel.send(JSON.stringify({ "candidate": evt.candidate }));
    };

    // let the "negotiationneeded" event trigger offer generation
    pc.onnegotiationneeded = function () {
        pc.createOffer().then(function (offer) {
            return pc.setLocalDescription(offer);
        })
        .then(function () {
            // send the offer to the other peer
            signalingChannel.send(JSON.stringify({ "desc": pc.localDescription }));
        })
        .catch(logError);
    };

    // get a local stream, show it in a self-view and add it to be sent
    navigator.mediaDevices.getUserMedia({ "audio": true, "video": true })
        .then(function (stream) {
            selfView.srcObject = stream;
            var remoteStream = new MediaStream();
            var audioSender = pc.addTrack(stream.getAudioTracks()[0], stream);
            var videoSender = pc.addTrack(stream.getVideoTracks()[0], stream);
            [audioSender, videoSender].forEach(function(sender) {
                remoteStream.addTrack(pc.getReceivers.find(function (receiver) {
                    return receiver.mid == sender.mid;
                }).track);
            });

            // Render the media even before ontrack fires.
            remoteView.srcObject = remoteStream;
        })
        .catch(logError);
}

signalingChannel.onmessage = function (evt) {
    if (!pc)
        start();

    var message = JSON.parse(evt.data);
    if (message.desc) {
        var desc = message.desc;

        // if we get an offer, we need to reply with an answer
        if (desc.type == "offer") {
            pc.setRemoteDescription(desc).then(function () {
                return pc.createAnswer();
            })
            .then(function (answer) {
                return pc.setLocalDescription(answer);
            })
            .then(function () {
                var str = JSON.stringify({ "desc": pc.localDescription });
                signalingChannel.send(str);
            })
            .catch(logError);
        } else
            pc.setRemoteDescription(desc).catch(logError);
    } else
        pc.addIceCandidate(message.candidate).catch(logError);
};

function logError(error) {
    log(error.name + ": " + error.message);
}

</pre>
      </div>
    </section>
    <section>
      <h3>Simple Simulcast Example</h3>
      <div>
        <p>A client wants to send multiple RTP encodings (simulcast) to a
        server.</p>
        <pre class="example highlight">
var signalingChannel = new SignalingChannel();
var configuration = { "iceServers": [{ "urls": "stuns:stun.example.org" }] };
var pc;

// call start() to initiate
function start() {
    pc = new RTCPeerConnection(configuration);

    // let the "negotiationneeded" event trigger offer generation
    pc.onnegotiationneeded = function () {
        pc.createOffer().then(function (offer) {
            return pc.setLocalDescription(offer);
        })
        .then(function () {
            // send the offer to the other peer
            signalingChannel.send(JSON.stringify({ "desc": pc.localDescription }));
        })
        .catch(logError);
    };

    // get a local stream, show it in a self-view and add it to be sent
    navigator.mediaDevices.getUserMedia({ "audio": true, "video": true })
        .then(function (stream) {
            selfView.srcObject = stream;
            pc.addTransceiver(stream.getAudioTracks()[0], {direction: "sendonly"});
            pc.addTransceiver(stream.getVideoTracks()[0], {
                direction: "sendonly",
                sendEncodings: [
                    {
                      rid: "f",
                    },
                    {
                      rid: "h",
                      scaleDownResolutionBy: 2.0
                    },
                    {
                      rid: "q",
                      scaleDownResolutionBy: 4.0
                    }
                ]
            });
        })
        .catch(logError);
}

signalingChannel.onmessage = function (evt) {
    var message = JSON.parse(evt.data);
    if (message.desc)
        pc.setRemoteDescription(message.desc).catch(logError);
    else
        pc.addIceCandidate(message.candidate).catch(logError);
};

function logError(error) {
    log(error.name + ": " + error.message);
}

</pre>
      </div>
    </section>
    <section>
      <h3>Advanced Peer-to-peer Example</h3>
      <div>
        <p>This example shows the more complete functionality.</p>
        <p class="issue">TODO</p>
        <pre class="example highlight">
</pre>
      </div>
    </section>
    <section>
      <h3>Peer-to-peer Data Example</h3>
      <div>
        <p>This example shows how to create a
        <code><a>RTCDataChannel</a></code> object and perform the offer/answer
        exchange required to connect the channel to the other peer. The
        <code><a>RTCDataChannel</a></code> is used in the context of a simple
        chat application and listeners are attached to monitor when the channel
        is ready, messages are received and when the channel is closed.</p>
        <pre class="example highlight">
var signalingChannel = new SignalingChannel();
var configuration = { "iceServers": [{ "urls": "stuns:stun.example.org" }] };
var pc;
var channel;

// call start(true) to initiate
function start(isInitiator) {
    pc = new RTCPeerConnection(configuration);

    // send any ice candidates to the other peer
    pc.onicecandidate = function (evt) {
        signalingChannel.send(JSON.stringify({ "candidate": evt.candidate }));
    };

    // let the "negotiationneeded" event trigger offer generation
    pc.onnegotiationneeded = function () {
        pc.createOffer().then(function (offer) {
            return pc.setLocalDescription(offer);
        })
        .then(function () {
            // send the offer to the other peer
            signalingChannel.send(JSON.stringify({ "desc": pc.localDescription }));
        })
        .catch(logError);
    };

    if (isInitiator) {
        // create data channel and setup chat
        channel = pc.createDataChannel("chat");
        setupChat();
    } else {
        // setup chat on incoming data channel
        pc.ondatachannel = function (evt) {
            channel = evt.channel;
            setupChat();
        };
    }
}

signalingChannel.onmessage = function (evt) {
    if (!pc)
        start(false);

    var message = JSON.parse(evt.data);
    if (message.desc) {
        var desc = message.desc;

        // if we get an offer, we need to reply with an answer
        if (desc.type == "offer") {
            pc.setRemoteDescription(desc).then(function () {
                return pc.createAnswer();
            })
            .then(function (answer) {
                return pc.setLocalDescription(answer);
            })
            .then(function () {
                var str = JSON.stringify({ "desc": pc.localDescription });
                signalingChannel.send(str);
            })
            .catch(logError);
        } else
            pc.setRemoteDescription(desc).catch(logError);
    } else
        pc.addIceCandidate(message.candidate).catch(logError);
};

function setupChat() {
    channel.onopen = function () {
        // e.g. enable send button
        enableChat(channel);
    };

    channel.onmessage = function (evt) {
        showChatMessage(evt.data);
    };
}

function sendChatMessage(msg) {
    channel.send(msg);
}

function logError(error) {
    log(error.name + ": " + error.message);
}

</pre>
      </div><!--div>
    <p>This simple example shows how configure two RTCDataChannel objects for different purposes.</p>
<p><pre   class='example highlight'>
// the chat channel is reliable and not as prioritized as game data
var chatChan = peerConn.createDataChannel("chat", { "priority": 1 });

// the game data channel is prioritized and unreliable low latency channel for high performance
var gameDataChan = peerConn.createDataChannel("data", { "reliable": false, "priority": 10 });
    </pre></p>
  </div-->
    </section>
    <section>
      <h3>Call Flow Browser to Browser</h3>
      <p class="issue">Editors' Note: This example flow needs to be discussed
      on the list and is likely wrong in many ways.</p>
      <p>This shows an example of one possible call flow between two browsers.
      This does not show the procedure to get access to local media or every
      callback that gets fired but instead tries to reduce it down to only show
      the key events and messages.</p>
      <p><img alt=
      "A message sequence chart detailing a call flow between two browsers"
      src="images/ladder-2party-simple.svg" style="width:100%"></p><!--
      <p>The following flow shows a more complete set of the callbacks and
      events that happen.</p>

      <p><img alt=
      "A more complete message sequence chart detailing a call flow between two browsers"
      src="images/ladder-2party-full.svg" style="width:100%"></p>
      -->
    </section>
    <section>
      <h3>DTMF Example</h3>
      <p>Examples assume that <var>sender</var> is an RTCRtpSender.</p>
      <p>Sending the DTMF signal "1234" with 500 ms duration per tone:</p>
      <pre class="example highlight">if (sender.dtmf) {
    var duration = 500;
    sender.dtmf.insertDTMF("1234", duration);
} else
    log("DTMF function not available");

</pre>
      <p>Send the DTMF signal "1234", and light up the active key using
      <code>lightKey(key)</code> while the tone is playing (assuming that
      <code>lightKey("")</code> will darken all the keys):</p>
      <pre class="example highlight">if (sender.dtmf) {
  sender.dtmf.ontonechange = function (e) {
      if (!e.tone)
          return;
      // light up the key when playout starts
      lightKey(e.tone);
      // turn off the light after tone duration
      setTimeout(lightKey, sender.duration, "");
  };
  sender.dtmf.insertDTMF("1234");
} else
    log("DTMF function not available");

</pre>
      <p>Send a 1-second "1" tone followed by a 2-second "2" tone:</p>
      <pre class="example highlight">if (sender.dtmf) {
  sender.dtmf.ontonechange = function (e) {
      if (e.tone == "1")
          sender.dtmf.insertDTMF("2", 2000);
  };
  sender.dtmf.isertDTMF("1", 1000);
} else
    log("DTMF function not available");

</pre>
      <p>It is always safe to append to the tone buffer. This example appends
      before any tone playout has started as well as during playout.</p>
      <pre class="example highlight">
if (sender.dtmf) {
  sender.dtmf.insertDTMF("123");
  // append more tones to the tone buffer before playout has begun
  sender.dtmf.insertDTMF(sender.toneBuffer + "456");

  sender.dtmf.ontonechange = function (e) {
      if (e.tone == "1")
          // append more tones when playout has begun
          sender.dtmf.insertDTMF(sender.toneBuffer + "789");
  };
} else
    log("DTMF function not available");

</pre>
      <p>Send the DTMF signal "123" and abort after sending "2".</p>
      <pre class="example highlight">if (sender.dtmf) {
  sender.dtmf.ontonechange = function (e) {
      if (e.tone == "2")
          // empty the buffer to not play any tone after "2"
          sender.dtmf.insertDTMF("");
  };
  sender.dtmf.insertDTMF("123");
} else
    log("DTMF function not available");
</pre>
    </section><!--
    <section>
      <h3>Call Flow Browser to MCU</h3>

      <p class="note">Editors' Note: This example flow needs to be discussed on
      the list and is likely wrong in many ways.</p>

      <p>This shows an example of one possible call flow between a centralized
      conferencing server and a browser. This does not show every callback that
      gets fired but instead tries to reduce it down to only show the key
      events and messages.</p>

      <p><img alt=
      "A message sequence chart detailing a call flow between a browser and a centralized conferencing server"
      src="images/ladder-mcu-simple.svg" style="width:100%"></p>
    </section>
-->
  </section>
  <section class="informative">
    <h2>Event summary</h2>
    <p>The following events fire on <code><a>RTCDataChannel</a></code>
    objects:</p>
    <table>
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id="event-datachannel-open"><code>open</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code><a>RTCDataChannel</a></code> object's <a>underlying data
            transport</a> has been established (or re-established).
          </td>
        </tr>
        <tr>
          <td><dfn id=
          "event-datachannel-message"><code>message</code></dfn></td>
          <td><code><a href=
          "http://www.w3.org/TR/webmessaging/#the-messageevent-interfaces">MessageEvent</a></code>
          [[!webmessaging]]</td>
          <td>A message was successfully received.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-datachannel-bufferedamountlow"><code>bufferedamountlow</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCDataChannel</a></code> object's
          <code><a data-for="RTCDataChannel">bufferedAmount</a></code>
          decreases from above its <code><a data-for=
          "RTCDataChannel">bufferedAmountLowThreshold</a></code> to less than
          or equal to its <code><a data-for=
          "RTCDataChannel">bufferedAmountLowThreshold</a></code>.</td>
        </tr>
        <tr>
          <td><code>error</code></td>
          <td><code><a>ErrorEvent</a></code></td>
          <td>Any error occured from the data channel.</td>
        </tr>
        <tr>
          <td><dfn id="event-datachannel-close"><code>close</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code><a>RTCDataChannel</a></code> object's <a>underlying data
            transport</a> has bee closed.
          </td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCPeerConnection</a></code>
    objects:</p>
    <table>
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id=
          "event-mediastream-connecting"><code>connecting</code></dfn></td>
          <td><code>Event</code></td>
          <td>
            <p class="issue">TODO</p>
          </td>
        </tr><!--
        <tr>
          <td><dfn title="event-MediaStream-error"><code>error</code></dfn></td>
          <td><code>Event</code></td>
          <td></td>
        </tr>
        <tr>
          <td><dfn title="event-MediaStream-close"><code>close</code></dfn></td>
          <td><code>Event</code></td>
          <td>The <code title="dom-RTCPeerConnection-close">close()</code> method was
            called. </td>
        </tr>
        <tr>
          <td>
            <dfn id="event-mediastream-message">
              <code>message</code>
            </dfn>
          </td>

          <td>
            <code>MessageEvent</code>
          </td>

          <td>A <a href="#data-udp-media-stream">data UDP media
          stream</a> message was received.</td>
        </tr>
        -->
        <tr>
          <td><dfn id="event-track"><code>track</code></dfn></td>
          <td><code><a>RTCTrackEvent</a></code></td>
          <td>
            A new incoming <code>MediaStreamTrack</code> has been created, and
            an associated <code>RTCRtpReceiver</code> has been added to the
            set of receivers.
          </td>
        </tr>
        <tr>
          <td><dfn id=
          "event-negotiation"><code>negotiationneeded</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The browser wishes to inform the application that session
          negotiation needs to be done (i.e. a createOffer call followed by
          setLocalDescription).</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-signalingstatechange"><code>signalingstatechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <a>signaling state</a> has changed. This state change is the
            result of either <code><a data-for=
            "RTCPeerConnection">setLocalDescription</a></code> or
            <code><a data-for=
            "RTCPeerConnection">setRemoteDescription</a></code> being invoked.
          </td>
        </tr>
        <tr>
          <td><dfn id=
          "event-iceconnectionstatechange"><code>iceconnectionstatechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code>RTCPeerConnection</code>'s <a>ICE connection state</a>
            has changed.
          </td>
        </tr>
        <tr>
          <td><dfn id=
          "event-icegatheringstatechange"><code>icegatheringstatechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code>RTCPeerConnection</code>'s <a>ICE gathering state</a> has
            changed.
          </td>
        </tr>
        <tr>
          <td><dfn id="event-icecandidate"><code>icecandidate</code></dfn></td>
          <td><code><a>RTCPeerConnectionIceEvent</a></code></td>
          <td>A new <code><a>RTCIceCandidate</a></code> is made available to
          the script.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-connectionstatechange"><code>connectionstatechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code>RTCPeerConnection</code> <a data-for="RTCPeerConnection"
            data-link-for="RTCPeerConnection">connectionState</a> has changed.
          </td>
        </tr>
        <tr>
          <td><dfn id=
          "event-icecandidateerror"><code>icecandidateerror</code></dfn></td>
          <td><code><a>RTCPeerConnectionIceErrorEvent</a></code></td>
          <td>A failure occured when gathering ICE candidates.</td>
        </tr>
        <tr>
          <td><dfn id="event-datachannel"><code>datachannel</code></dfn></td>
          <td><code><a>RTCDataChannelEvent</a></code></td>
          <td>A new <code><a>RTCDataChannel</a></code> is dispatched to the
          script in response to the other peer creating a channel.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-isolationchange"><code>isolationchange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>A new <code><a>Event</a></code> is dispatched to the script when
          the <var>isolated</var> attribute on a <code>MediaStreamTrack</code>
          changes.</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCDTMFSender</a></code>
    objects:</p>
    <table>
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id=
          "event-RTCDTMFSender-tonechange"><code>tonechange</code></dfn></td>
          <td><code><a>RTCDTMFToneChangeEvent</a></code></td>
          <td>The <code><a>RTCDTMFSender</a></code> object has either just
          begun playout of a tone (returned as the <code><a data-link-for=
          "RTCDTMFToneChangeEvent">tone</a></code> attribute) or just ended
          playout of a tone (returned as an empty value in the
          <code><a data-link-for="RTCDTMFToneChangeEvent">tone</a></code>
          attribute).</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCIceTransport</a></code>
    objects:</p>
    <table>
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id="event-icetransport-statechange" data-lt=
          "RTCIceTransport state change"><code>statechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCIceTransport</a></code> state changes.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-icetransport-gatheringstatechange"><code>gatheringstatechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCIceTransport</a></code> gathering state
          changes.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-icetransport-selectedcandidatepairchange"><code>selectedcandidatepairchange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCIceTransport</a></code>'s selected candidate pair
          changes.</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCDtlsTransport</a></code>
    objects:</p>
    <table>
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id="event-dtlstransport-statechange" data-lt=
          "RTCDtlsTransport state change" data-lt-nodefault=
          ""><code>statechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCDtlsTransport</a></code> state changes.</td>
        </tr>
      </tbody>
    </table>
  </section>
  <section class="informative">
    <h2>Privacy and Security Considerations</h2>
    <p>This section is non-normative; it specifies no new behaviour, but
    instead summarizes information already present in other parts of the
    specification. The overall security considerations of the general set of
    APIs and protocols used in WebRTC are described in
    [[RTCWEB-SECURITY-ARCH]].</p>
    <section>
      <h2>Impact on same origin policy</h2>
      <p>This document extends the Web platform with the ability to set up real
      time, direct communication between browsers and other devices, including
      other browsers.</p>
      <p>This means that data and media can be shared between applications
      running in different browsers, or between an application running in the
      same browser and something that is not a browser, something that is an
      extension to the usual barriers in the Web model against sending data
      between entities with different origins.</p>
      <p>The WebRTC specification provides no user prompts or chrome indicators
      for communication; it assumes that once the Web page has been allowed to
      access media, it is free to share that media with other entities as it
      chooses. Peer-to-peer exchanges of data view WebRTC datachannels can thus
      occur without any user explicit consent or involvement, similarly as a
      server-mediated exchange (e.g. via Web Sockets) could occur without user
      involvement.</p>
      <p>The <code><a>peerIdentity</a></code> mechanism loads and executes
      JavaScript code from a third-party server acting as an identity provider.
      That code is executed in a separate JavaScript realm and does not affect
      the protections afforded by the same origin policy.</p>
    </section>
    <section>
      <h2>Revealing IP addresses</h2>
      <p>Even without WebRTC, the Web server providing a Web application will
      know the public IP address to which the application is delivered. Setting
      up communications exposes additional information about the
      browser&#8217;s network context to the web application, and may include
      the set of (possibly private) IP addresses available to the browser for
      WebRTC use. Some of this information has to be passed to the
      corresponding party to enable the establishment of a communication
      session.</p>
      <p>Revealing IP addresses can leak location and means of connection; this
      can be sensitive. Depending on the network environment, it can also
      increase the fingerprinting surface and create persistent cross-origin
      state that cannot easily be cleared by the user.</p>
      <p>A connection will always reveal the IP addresses proposed for
      communication to the corresponding party. The application can limit this
      exposure by choosing not to use certain addresses using the settings
      exposed by the <a>RTCIceTransportPolicy</a> dictionary, and by using
      relays (for instance TURN servers) rather than direct connections between
      participants. One will normally assume that the IP address of TURN
      servers is not sensitive information. These choices can for instance be
      made by the application based on whether the user has indicated consent
      to start a media connection with the other party.</p>
      <p>Mitigating the exposure of IP addresses to the application itself
      requires limiting the IP addresses that can be used, which will impact
      the ability to communicate on the most direct path between endpoints.
      Browsers are encouraged to provide appropriate controls for deciding
      which IP addresses are made available to applications, based on the
      security posture desired by the user. The choice of which addresses to
      expose is controlled by local policy (see [[RTCWEB-IP-HANDLING]] for
      details).</p>
    </section>
    <section>
      <h2>Impact on local network</h2>
      <p>Since the browser is an active platform executing in a trusted network
      environment (inside the firewall), it is important to limit the damage
      that the browser can do to other elements on the local network, and it is
      important to protect data from interception, manipulation and
      modification by untrusted participants.</p>
      <p>Mitigations include:</p>
      <ul>
        <li>An UA will always request permission from the correspondent UA to
        communicate using ICE. This ensures that the UA can only send to
        partners who you have shared credentials with.</li>
        <li>An UA will always request ongoing permission to continue sending
        using ICE continued consent. This enables a receiver to withdraw
        consent to receive.</li>
        <li>An UA will always encrypt data, with strong per-session keying
        (DTLS-SRTP).</li>
        <li>An UA wil always use congestion control. This ensures that WebRTC
        cannot be used to flood the network.</li>
      </ul>
      <p>These measures are specified in the relevant IETF documents.</p>
    </section>
    <section>
      <h2>Confidentiality of Communications</h2>
      <p>The fact that communication is taking place cannot be hidden from
      adversaries that can observe the network, so this has to be regarded as
      public information.</p>
      <p>A mechanism, <code><a>peerIdentity</a></code>, is provided that gives
      Javascript the option of requesting media that the same javascript cannot
      access, but can only be sent to certain other entities.</p>
    </section>
    <section>
      <h2>Persistent information exposed by WebRTC</h2>
      <p>As described above, the list of IP addresses exposed by the WebRTC API
      can be used as a persistent cross-origin state.</p>
      <p>Beyond IP addresses, the WebRTC API exposes information about the
      underlying media system via the <code>RTCRtpSender.getCapabilities</code>
      and <code>RTCRtpReceiver.getCapabilities</code> methods, including
      detailed and ordered information about the codecs that the system is able
      to produce and consume. A subset of that information is likely to be
      represented in the SDP session descriptions generated, exposed and
      transmitted during <a href="#session-negotiation-model">session
      negotiation</a>. That information is in most cases persistent across time
      and origins, and increases the fingerprint surface of a given device.</p>
      <p>If set, the configured default ICE servers exposed by
      <a data-for="RTCPeerConnection">defaultIceServers</a> on
      <code>RTCPeerConnection</code> instances also provides persistent across
      time and origins information which increases the fingerprinting surface
      of a given browser.</p>
      <p>When establishing DTLS connections, the WebRTC API can generate
      certificates that can be persisted by the application (e.g. in
      IndexedDB). These certificates are not shared across origins, and get
      cleared when persistent storage is cleared for the origin.</p>
    </section>
  </section><!--section>
    <h2 id="sec-iana">IANA Registrations</h2>



    <p>IANA is requested to register the constraints defined in <a href=
    "#sec-constraints">Constraints Section</a> as specified in
    [[!RTCWEB-CONSTRAINTS]].</p>


    <section>
      <h3 id="sec-constraints">Constraints</h3>


      <p>TOOD: Need to change the naming and declaration of these constraints
      to match the constraints draft once that is a bit further along. The
      names here now are likely not quite right but they serve as a place
      holder.</p>


      <p class="issue">ISSUE: there are multiple ways to add constraints. How
      are multiple values reconciled?</p>


      <p>The following new constraints are defined that can be used with an
      <code>RTCPeerConnection</code> object:</p>


      <p>TODO items - need to register with IANA.</p>
    </section>
  </section-->
  <section>
    <h2>Change Log</h2>
    <p>This section will be removed before publication.</p>
    <!-- Why do the first two headings automatically convert to <h2>? -->
    <!-- Because you haven't added a <section> element around them
         and respec rewrites h? elements based on the section depth -->
    <h3>Changes since May 13, 2016</h3>
    <ol>
      <li>[#640, #641, #659, #679, #680, #681, #682, #686, #694,
          #696, #697, #707, #708, #711] General editorial fixes</li>
      <li>[#642] Editorial: make last arg of addTransceiver optional</li>
      <li>[#643] Document defaultIceServers as source of
      fingerprinting</li>
      <li>[#646] Create table of RTCRtpEncodingParameters for
      RtpSender/RtpReceiver</li>
      <li>[#648] Clarify MIME (media/sub-) type</li>
      <li>[#649] Example of how to do hold</li>
      <li>[#662] Clarify effect of RTCRtpReceiver.track.stop()</li>
      <li>[#663] Define a 7XX STUN error code</li>
      <li>[#665] Clarify when setDirection() acts</li>
      <li>[#666] Clarify that transports can be null</li>
      <li>[#676] Transceiver.stop() causes negotiationneeded to be set</li>
      <li>[#677] Clean up rtcpTransport description</li>
      <li>[#701] In addTrack, mention that MSID of new track is added</li>
      <li>[#702, #704] Define algs for creating sender/receiver/transceiver,
      then use them in addTrack() and addTransceiver()</li>
      <li>[#725] Change 'process to apply candidate' to 'add the ICE
      candidate'</li>
    </ol>
    <h3>Changes since February 15, 2016</h3>
    <ol>
      <li>[#475] Definition of Active for an RTCRtpReceiver</li>
      <li>[#500] Reserve and use RangeError for scaleResolutionDownBy <
      1.0</li>
      <li>[#504] Add getParameters() method to RTCRtpReceiver</li>
      <li>[#509] RID unmodifiable in setParameters()</li>
      <li>[#510] Gather spec text about the ICE Agent at one
      place</li>
      <li>[#512] Use 'connection' as configuration target instead of User
      Agent</li>
      <li>[#505] Add activateReceiver method to RTCRtpTransceiver</li>
      <li>[#516] Support for DTMF tones A-D</li>
      <li>[#499] Certificate API: add getAlgorithm method</li>
      <li>[#507] Make the definition of addIceCandidate() more explicit</li>
      <li>[#525] Add STUN Error Code reference</li>
      <li>[#524] Add error codes reference (RTCPeerConnectionIceErrorEvent)
      </li>
      <li>[#522] Let setting ice candidate pool size trigger start of
      gathering</li>
      <li>[#519] Relation between local track and outgoing encoding</li>
      <li>[#520] Add text about 'remote sources' and how they are stopped</li>
      <li>[#527] Enable trickling of end-of-candidates through addIceCandidate
      </li>
      <li>[#544] Remove "public" from ice transport policy</li>
      <li>[#547] Datachannel label and protocol are USVString</li>
      <li>[#552] Never close the RTCPeerConnection if setting a local/remote
      description fails</li>
      <li>[#535] Update MID to be random values when not received in offer</li>
      <li>[#553] Move 'closed' state from RTCSignalingState to
      RTCPeerConnectionState</li>
      <li>[#557] Splitting apart RTCIceConnectionState and
      RTCIceTransportState</li>
      <li>[#560] Changing from callback interface to dictionary for
      RTCIdentityProvider</li>
      <li>[#574] Make RTCSessionDescription readonly, and createOffer return
      dictionary</li>
      <li>[#577] Make RtpSender.track nullable</li>
      <li>[#587] Defining how track settings are set for remote tracks</li>
      <li>[#603] Add closed state and same state checks to update ice
      connection/gathering state steps</li>
      <li>[#604] ReplaceTrack: Use sender's transceiver to determine if a
      'simple track swap' is enough</li>
      <li>[#606] RTCIceCandidate: Use nullable members in init dictionary to
      describe constructor behavior</li>
      <li>[#466] Use an enum to describe directionality of RTP Stream</li>
      <li>[#602] addTransceiver(): Throw a TypeError on a bogus track kind</li>
      <li>[#610] Server cannot be reached - Issues with IPv6</li>
      <li>[#611] Clarify ICE consent freshness feedback</li>
      <li>[#618] Fix RTCPeerConnection legacy overloads</li>
      <li>[#620] RTCRtpTransceiver: add setDirection and readonly direction
      attribute</li>
      <li>[#625] Unifiy DTMF time with rtcweb WG</li>
      <li>[#630] Add ICE candidate type references</li>
      <li>[#635] pc.addTrack: Add kind check when reusing a sender and skip
      early returns</li>
      <li>[#636] replaceTrack: Use 'transceiver kind' instead of track.kind
      (track may be null)</li>
    </ol>
    <h3>Changes since January 26, 2016</h3>
    <ol>
      <li>[#485] Update SOTD as the document is now quite stable and the group
      is looking for wide review</li>
      <li>[#468, #335] Replace DOMError with DOMException</li>
      <li>[#472, #319] Update error reports to align with existing DOM
      Errors</li>
      <li>[#491, #479] Specify error when rejecting invalid SDP changes</li>
      <li>[#462] Add PeerConnection.activateSender() and update early media
      example</li>
      <li>[#434] Change setParameters call to be Async</li>
    </ol>
    <h3>Changes since December 22, 2015</h3>
    <ol>
      <li>[#179, #439] Document IP address leakage in RTCIceCandidate</li>
      <li>[#439] Complete security considerations based on security
      questionnaire and IP address discussions #439</li>
      <li>[#446] Non-nullable RTCTrackEvent args means Init dict members are
      required</li>
      <li>[#449] Clarify flow of SDP exchanges (Update simple p2p example)</li>
      <li>[#451] Clean up event handler attribute descriptions</li>
      <li>[#452, #438] Make replaceTrack() handle "not sending yet" case</li>
      <li>[#454] Add contributing source voice activity flag</li>
      <li>[#455, #439] Add references to parsing stun/turn URLs section</li>
      <li>[#456, #338] SDP changes between the createOffer and
      setLocalDescription (add JSEP reference)</li>
      <li>[#459] Add non-normative ICE state transitions</li>
      <li>[#460, #461] getRemoteCertificates() behavior in "new" and
      "connecting" states</li>
      <li>[#465, #140] Use ErrorEvent as interface for events emitted by
      RTCDataChannel.onerror</li>
      <li>[#469, #382, #373] Reject changes to peerIdentity and certificates in
      setConfiguration</li>
      <li>[#474, #406] Define RTCIceTransport.component when RTP/RTCP mux is in
      use</li>
    </ol>
    <h3>Changes since November 23, 2015</h3>
    <ol>
      <li>[#353] Plan X: Add an API for using RID to do simulcast</li>
      <li>[#365] Adding an accessor for the browser-configured ICE servers</li>
      <li>[#398] Make RtpTransceiver.mid nullable and remove RtpSender.mid and
      RtpReceiver.mid</li>
      <li>[#402, #391] Remove requirement about DTMF tones A-D</li>
      <li>[#403, #377] Use positive values for AudioLevel</li>
      <li>[#401, #267] Add bitrate definition</li>
      <li>[#404] Remove 'Events on MediaStream' section (duplicates new text in
      Media Capture spec)</li>
      <li>[#410, #328] Make RTCBundlePolicy Enum section normative</li>
      <li>[#411, #408] Clarify component for IceTransport when RTP/RTCP mux is
      used</li>
      <li>[#414] Define ReSpec processor for cross-reference to JSEP</li>
      <li>[#418] Make degradationPreference per-sender instead of
      per-encoding</li>
      <li>[#416] RTCRtpSender.replaceTrack() fixes (e.g. handle closed
      RTCPeerConnection)</li>
      <li>[#421] Require sdp in RTCSessionDescription{,Init}</li>
      <li>[#422] Remove confusing paragraph on fourth party interception</li>
      <li>[#423] Add specific references to JSEP where possible</li>
      <li>[#428] Don't create a default stream in 'dispatch a receiver'
      steps</li>
      <li>[#429] Adding expires attribute to generateCertificate</li>
      <li>[#430] Add maxFramerate knob for simulcast</li>
      <li>[#432] Update RTCIceTransportPolicy</li>
      <li>[#433] Use unsigned long ssrc in stats</li>
      <li>[#424] Editorial: Distinguish states from their attribute
      representation</li>
    </ol>
    <h3>Changes since October 6, 2015</h3>
    <ol>
      <li>[#325] Adding additional members to RTCIceCandidate dictionary</li>
      <li>[#327] Adding sha-256 to the certificate management options for
      RSA</li>
      <li>[#342] Using DOMTimestamp for RTCCertificate::expires</li>
      <li>[#293] Add RTCRtpTransceiver and PeerConnection.addMedia</li>
      <li>[#366, #343] Use RTCDegradationPreference</li>
      <li>[#374] Throw on too long label/protocol in createDataChannel()</li>
      <li>[#266] Tidy up setLocal/RemoteDescription processing model</li>
      <li>[#361] Adding setCodecPreferences to RTCRtpTransceiver</li>
      <li>[#371] Add RtcpMuxPolicy</li>
      <li>[#385, #312] Don't invoke public API in legacy function section</li>
      <li>[#394, #393] don't throw on empty iceServers list</li>
    </ol>
    <h3>Changes since September 22, 2015</h3>
    <ol>
      <li>[#289, #153] Add way to set size of ICE candidate pool</li>
      <li>[#256] Fix prose on getStats() wo/selector + move type check to sync
      section</li>
      <li>[#242] Remove SyntaxError on malformed ICE candidate</li>
      <li>[#284] Add icecandidateerror event for indicating ICE gathering
      errors</li>
      <li>[#298] Add support for codec reordering and removal in
      RtpParameters</li>
      <li>[#311] Fixing syntax for required RTCCertificate arguments</li>
      <li>[#280] Add extra IceTransport read-only attributes and methods</li>
      <li>[#291] Add PeerConnection.connectionState</li>
      <li>[#300, #4, #6, #276] Add API to get SSRC and audio levels</li>
      <li>[#301] Fix RTCStatsReport with object and maplike instead of
      getter</li>
      <li>[#302] (Partly) removing interface use for RTCSessionDescription and
      RTCIceCandidate</li>
      <li>[#314, #299] Update the operations queue to handle promises and
      closed signalling</li>
      <li>[#273] Add a bunch of fields to RtpParameters and
      RtpEncodingParameters</li>
    </ol>
    <h3>Changes since June 11, 2015</h3>
    <ol>
      <li>[#234] Add RTCRtpParameters, RTCRtpSender.getParameters, and
      RTCRtpSender.setParameters</li>
      <li>[#225] Support for pending and current SDP</li>
      <li>[#229] Removing the weird optionality from RTCSessionDescription and
      its constructor.</li>
      <li>[#235] Modernize getStats() with promises</li>
      <li>[#243] Mark candidate property of RTCIceCandidateInit required</li>
      <li>[#248] Fix error handling for certificate management</li>
      <li>[#259] Change type of RtpEncodingParameters.priority to an enum</li>
      <li>[#21, #262] Sort out 2119 MUSTs and SHOULDs</li>
      <li>[#268] Add RtpEncodingParameters.maxBitrate</li>
      <li>[#241] Add RtpSender.transport, RtpReceiver.transport,
      RTCDtlsTransport, RTCIceTransport, etc</li>
      <li>[#224, #261] Sort out when responding PeerConnection reaches
      iceConnetionState completed</li>
      <li>[#303] Replace track without renegotiation</li>
      <li>[#269] Add RTCRtpSender.getCapabilities and
      RTCRtpReceiver.getCapabilities</li>
    </ol>
    <h3>Changes since March 6, 2015</h3>
    <ol>
      <li>[PR #167] Removed RTCPeerConnection.createDTMFSender and added
      RTCRtpSender.dtmf, along with corresponding examples.</li>
      <li>[PR #184] RTCPeerConnection will NOT connect unless identity is
      verified.</li>
      <li>[PR #27] Documenting practice with candidate events</li>
      <li>[PR #203] Rewrote mitigations text for security considerations
      section</li>
      <li>[PR #192] Added support for auth tokens. Fixes #190</li>
      <li>[PR #207] Update ice config examples to use multiple urls and *s
      schemes</li>
      <li>[PR #210] Optional RTCConfiguration in RTCPC constructor</li>
      <li>[PR #171] Add RTCAnswerOptions (with common RTCOfferAnswerOptions
      dictionary)</li>
      <li>[PR #178] Identity provider interface redesign</li>
      <li>[PR #193] Add .mid property to sender/receiver. Fixes #191</li>
      <li>[PR #218] Enqueue addIceCandidate</li>
      <li>[PR #213 (1)] Rename updateIce() to setConfiguration()</li>
      <li>[PR #213 (2)] Make RTCPeerConnection.setConfiguration() replace the
      existing configuration</li>
      <li>[PR #214] Certificate management API (Bug 21880)</li>
      <li>[PR #220] Clarify muted state (proposed fix for issue #139)</li>
      <li>[PR #221] Define when RTCRtpReceivers are created and dispatced
      (issue #198)</li>
      <li>[PR #215] Adding expires attribute to certificate management</li>
      <li>[PR #233] Add a "bufferedamountlow" event</li>
    </ol>
    <h3>Changes since December 5, 2014</h3>
    <ol>
      <li>Properly define the negotiationneeded event, and its interactions
      with other API calls.</li>
      <li>Add support for RTCRtpSender and RTCRtpReceiver.</li>
      <li>Update misleading local/RemoteDescription attribute text.</li>
      <li>Add RTCBundlePolicy.</li>
      <li>All callback-based methods have been moved to a legacy section, and
      replaced by same-named overloads using Promises instead.</li>
      <li>[PR #194] Added first version of Security Considerations (more work
      needed)</li>
      <li>Updated identity provider structure.</li>
    </ol>
    <h3>Changes since June 4, 2014</h3>
    <ol>
      <li>Bug 25724: Allow garbage collection of closed PeerConnections</li>
      <li>Bug 27214: Add onicegatheringstatechange event</li>
      <li>Bug 26644: Fixing end of candidates event</li>
    </ol>
    <h3>Changes since April 10, 2014</h3>
    <ol>
      <li>Bug 25774: Mixed isolation</li>
    </ol>
    <h3>Changes since April 10, 2014</h3>
    <ol>
      <li>Bug 25855: Clarification about conformance requirements phrased as
      algorithms</li>
      <li>Bug 25892: SignalingStateChange event should be fired only if there
      is a change in signaling state.</li>
      <li>Bug 25152: createObjectURL used in examples is no longer supported by
      Media Capture and Streams.</li>
      <li>Bug 25976: DTMFSender.insertDTMF steps should validate the values of
      duration and interToneGap.</li>
      <li>Bug 25189: Mandatory errorCallback is missing in examples for
      getStats.</li>
      <li>Bug 25840: Creating DataChannel with same label.</li>
      <li>Updated comment above example ice state transitions (discussed in Bug
      25257).</li>
      <li>Updated insertDTMF() algorithm to ignore unrecognized characters (as
      discussed in bug 25977).</li>
      <li>Made formatting of references to ice connection state
      consistent.</li>
      <li>Made insertDTMF() throw on unrecognized characters (used to
      ignore).</li>
      <li>Removed requestIdentity from RTCConfiguration and
      RTCOfferAnswerOptions. Removed RTCOfferAnswerOptions as a result.</li>
      <li>Adding isolated property and associated event to
      MediaStreamTrack.</li>
    </ol>
    <h3>Changes since March 21, 2014</h3>
    <ol>
      <li>Changes to identity-related text:
        <ul>
          <li>Removed noaccess constraint</li>
          <li>Add the ability to peerIdentity constrain RTCPeerConnection,
          which limits communication to a single peer</li>
          <li>Change the way that the browser communicates with IdP to a
          message channel
          (http://www.w3.org/TR/webmessaging/#message-channels)</li>
          <li>Improved error feedback from IdP interactions (added new events
          with more detailed context)</li>
          <li>Changed the way that an IdP is able to request user login
          (LOGINNEEDED message)</li>
        </ul>
      </li>
      <li>Bug 25155: maxRetransmitTime is not the name of the SCTP concept it
      points to.</li>
    </ol>
    <h3>Changes since January 27, 2014</h3>
    <ol>
      <li>Refined identity assertion generation and validation.</li>
      <li>Default DTMF gap changed from 50 to 70 ms.</li>
      <li>Bug 24875: Examples in the WebRTC spec are not updated As per the
      modified API.</li>
    </ol>
    <h3>Changes since August 30, 2013</h3>
    <ol>
      <li>Make RTCPeerConnection close method be idempotent.</li>
      <li>Clarified ICE server configuration could contain URI types other than
      STUN and TURN.</li>
      <li>Changed the DTMF timing values.</li>
      <li>Allow offerToReceiveAudio/video indicate number of streams to
      offer.</li>
      <li>ACTION-98: Added text about clamping of maxRetransmitTime and
      maxRetransmits.</li>
      <li>ACTION-88: Removed nullable types from dictionaries (added attribute
      default values for attributes that would be left uninitialized without
      the init dictionary present.</li>
      <li>InvalidMediaStreamTrackError changed to InvalidParameter.</li>
      <li>Fire NetworkError when the data transport is closed with an
      error.</li>
      <li>Add an exception for data channel with trying to use existing
      code.</li>
      <li>Change maxRetransmits to be an unsigned type.</li>
      <li>Clarify state changes when ICE restarts.</li>
      <li>Added InvalidStateError exception for operations on a
      RTCPeerConnection that is closed.</li>
      <li>Major changes to Identity Proxy section.</li>
      <li>(ACTION: 95) Moved IceTransports (constraint) to RTCConfiguration
      dictionary.</li>
      <li>(ACTION: 95) Introduced RTCOfferAnswerOptions and RTCOfferOptions
      dictionaries.</li>
      <li>(ACTION: 95) Removed constraints argument from addStream() (and
      removed IANA Constraints section).</li>
      <li>Added validation of the RTCConfiguration dictionary argument(s).</li>
      <li>Added getConfiguration() on RTCPeerConnection.</li>
    </ol>
    <h3>Changes since June 3, 2013</h3>
    <ol>
      <li>Removed synchronous section left-overs.</li>
      <li>RTCIceServer now accepts multiple URLs.</li>
      <li>Redefined the meaning of negotiated for DataChannel.</li>
      <li>Made iceServers a sequence (instead of an Array).</li>
      <li>Updated error reporting (to use DOMError and camel cased names).</li>
      <li>Added success and failure callbacks to addIceCandidate().</li>
      <li>Made local/remoteDescription attributes nullable.</li>
      <li>Added username member to RTCIceServer dictionary.</li>
    </ol>
    <h3>Changes since March 22, 2013</h3>
    <ol>
      <li>Added IceRestart constraint.</li>
      <li>Big updates on DataChannel API to use new channel setup
      procedures.</li>
    </ol>
    <h3>Changes since Feb 22, 2013</h3>
    <ol>
      <li>Example review: Updated DTMF and Stats examples. Added text about
      when to fire "negotiationneeded" event to align with examples.</li>
      <li>Updated RTCPeerConnection state machine. Added a shared processing
      model for setLocalDescription()/setRemoteDescription().</li>
      <li>Updated simple callflow to match the current API.</li>
    </ol>
    <h3>Changes since Jan 16, 2013</h3>
    <ol>
      <li>Initial import of Statistics API to version 2.</li>
      <li>Integration of Statistics API version 2.5 started.</li>
      <li>Updated Statistics API to match Boston/list discussions.</li>
      <li>Extracted API extensions introduced by features, such as the P2P Data
      API, from the RTCPeerConnection API.</li>
      <li>Updated DTMF algorithm to dispatch an event when insertDTMF() is
      called with an empty string to cancel future tones.</li>
      <li>Updated DTMF algorithm to not cancel and reschedule if a playout task
      is running (only update toneBuffer and other values).</li>
    </ol>
    <h3>Changes since Dec 12, 2012</h3>
    <ol>
      <li>Changed AudioMediaStreamTrack to RTCDTMFSender and gave it its own
      section. Updated text to reflect most recent agreements. Also added
      examples section.</li>
      <li>Replaced the localStreams and remoteStreams attributes with functions
      returning sequences of MediaStream objects.</li>
      <li>Added spec text for attributes and methods adopted from the WebSocket
      interface.</li>
      <li>Changed the state ENUMs and transition diagrams.</li>
      <li>Aligned the data channel processing model a bit more with WebSockets
      (mainly closing the underlying transport).</li>
    </ol>
    <h3>Changes since Nov 13, 2012</h3>
    <ol>
      <li>Made some clarifications as to how operation queuing works, and fixed
      a few errors with the error handling description.</li>
      <li>Introduced new representation of tracks in a stream (removed
      MediaStreamTrackList). Added algorithm for creating a track to represent
      an incoming network media component.</li>
      <li>Renamed MediaStream.label to MediaStream.id (the definition needs
      some more work).</li>
    </ol>
    <h3>Changes since Nov 03, 2012</h3>
    <ol>
      <li>Added text describing the queuing mechanism for
      RTCPeerConnection.</li>
      <li>Updated simple P2P example to include all mandatory (error)
      callbacks.</li>
      <li>Updated P2P data example to include all mandatory (error) callbacks.
      Also added some missing RTC prefixes.</li>
    </ol>
    <h3>Changes since Oct 19, 2012</h3>
    <ol>
      <li>Clarified how createOffer() and createAnswer() use their
      callbacks.</li>
      <li>Made all failure callbacks mandatory.</li>
      <li>Added error object types, general error handling principles, and
      rules for when errors should be thrown.</li>
    </ol>
    <h3>Changes since Sept 23, 2012</h3>
    <ol>
      <li>Restructured the document layout and created separate sections for
      features like Peer-to-peer Data API, Statistics and Identity.</li>
    </ol>
    <h3>Changes since Aug 16, 2012</h3>
    <ol>
      <li>Replaced stringifier with serializer on RTCSessionDescription and
      RTCIceCandidate (used when JSON.stringify() is called).</li>
      <li>Removed offer and createProvisionalAnswer arguments from the
      createAnswer() method.</li>
      <li>Removed restart argument from the updateIce() method.</li>
      <li>Made RTCDataChannel an EventTarget</li>
      <li>Updated simple RTCPeerConnection example to match spec changes.</li>
      <li>Added section about RTCDataChannel garbage collection.</li>
      <li>Added stuff for identity proxy.</li>
      <li>Added stuff for stats.</li>
      <li>Added stuff peer and ice state reporting.</li>
      <li>Minor changes to sequence diagrams.</li>
      <li>Added a more complete RTCDataChannel example</li>
      <li>Various fixes from Dan's Idp API review.</li>
      <li>Patched the Stats API.</li>
    </ol>
    <h3>Changes since Aug 13, 2012</h3>
    <ol>
      <li>Made the RTCSessionDescription and RTCIceCandidate constructors take
      dictionaries instead of a strings. Also added detailed stringifier
      algorithm.</li>
      <li>Went through the list of issues (issue numbers are only valid with
      HEAD at fcda53c460). Closed (fixed/wontfix): 1, 8, 10, 13, 14, 16, 18,
      19, 22, 23, 24. Converted to notes: 4, 12. Updated: 9.</li>
      <li>Incorporate <a href=
      "http://lists.w3.org/Archives/Public/www-archive/2012Aug/0015.html">changes
      proposed</a> by Li Li.
      </li>
      <li>Use an enum for DataChannelState and fix IDLs where using an optional
      argument also requires all previous optional arguments to have a default
      value.</li>
    </ol>
    <h3>Changes since Jul 20, 2012</h3>
    <ol>
      <li>Added RTC Prefix to names (including the notes below).</li>
      <li>Moved to new definition of configuration and ice servers object.</li>
      <li>Added correlating lines to candidate structure.</li>
      <li>Converted setLocalDescription and setRemoteDescription to be
      asynchronous.</li>
      <li>Added call flows.</li>
    </ol>
    <h3>Changes since Jul 13, 2012</h3>
    <ol>
      <li>Removed peer attribute from RTCPeerConnectionIceEvent (duplicates
      functionality of Event.target attribute).</li>
      <li>Removed RTCIceCandidateCallback (no longer used).</li>
      <li>Removed RTCPeerConnectionEvent (we use a simple event instead).</li>
      <li>Removed RTCSdpType argument from setLocalDescription() and
      setRemoteDescription(). Updated simple example to match.</li>
    </ol>
    <h3>Changes since May 28, 2012</h3>
    <ol>
      <li>Changed names to use RTC Prefix.</li>
      <li>Changed the data structure used to pass in STUN and TURN servers in
      configuration.</li>
      <li>Updated simple RTCPeerConnection example (RTCPeerConnection
      constructor arguments; use icecandidate event).</li>
      <li>Initial import of new Data API.</li>
      <li>Removed some left-overs from the old Data Stream API.</li>
      <li>Renamed "underlying data channel" to "underlying data transport".
      Fixed closing procedures. Fixed some typos.</li>
    </ol>
    <h3>Changes since April 27, 2012</h3>
    <ol>
      <li>Major rewrite of RTCPeerConnection section to line up with IETF JSEP
      draft.</li>
      <li>Added simple RTCPeerConnection example. Initial update of
      RTCSessionDescription and RTCIceCandidate to support serialization and
      construction.</li>
    </ol>
    <h3>Changes since 21 April 2012</h3>
    <ol>
      <li>Moved MediaStream and related definitions to getUserMedia.</li>
      <li>Removed section "Obtaining local multimedia content".</li>
      <li>Updated getUserMedia() calls in examples (changes in Media Capture TF
      spec).</li>
      <li>Introduced MediaStreamTrackList interface with support for adding and
      removing tracks.</li>
      <li>Updated the algorithm that is run when RTCPeerConnection receives a
      stream (create new stream when negotiated instead of when data
      arrives).</li>
    </ol>
    <h3>Changes since 12 January 2012</h3>
    <ol>
      <li>Clarified the relation of Stream, Track, and Channel.</li>
    </ol>
    <h3>Changes since 17 October 2011</h3>
    <ol>
      <li>Tweak the introduction text and add a reference to the IETF RTCWEB
      group.</li>
      <li>Changed the first argument to getUserMedia to be an object.</li>
      <li>Added a MediaStreamHints object as a second argument to
      RTCPeerConnection.addStream.</li>
      <li>Added AudioMediaStreamTrack class and DTMF interface.</li>
    </ol>
    <h3>Changes since 23 August 2011</h3>
    <ol>
      <li>Separated the SDP and ICE Agent into separate agents and added
      explicit state attributes for each.</li>
      <li>Removed the send method from PeerConenction and associated callback
      function.</li>
      <li>Modified MediaStream() constructor to take a list of MediaStreamTrack
      objects instead of a MediaStream. Removed text about MediaStream parent
      and child relationship.</li>
      <li>Added abstract.</li>
      <li>Moved a few paragraphs from the MediaStreamTrack.label section to the
      MediaStream.label section (where they belong).</li>
      <li>Split MediaStream.tracks into MediaStream.audioTracks and
      MediaStream.videoTracks.</li>
      <li>Removed a sentence that implied that track access is limited to
      LocalMediaStream.</li>
      <li>Updated a few getUserMedia()-examples to use MediaStreamOptions.</li>
      <li>Replaced calls to URL.getObjectURL() with URL.createObjectURL() in
      example code.</li>
      <li>Fixed some broken getUserMedia() links.</li>
      <li>Introduced state handling on MediaStreamTrack (removed state handling
      from MediaStream).</li>
      <li>Reintroduced onended on MediaStream to simplify checking if all
      tracks are ended.</li>
      <li>Aligned the MediaStreamTrack ended event dispatching behavior with
      that of MediaStream.</li>
      <li>Updated the LocalMediaStream.stop() algorithm to implicitly use the
      end track algorithm.</li>
      <li>Replaced an occurrence the term finished track with ended track (to
      align with rest of spec).</li>
      <li>Moved (and extended) the explanation about track references and media
      sources from LocalMediaStream to MediaStreamTrack.</li>
    </ol>
  </section>
  <section class="appendix">
    <h2>Acknowledgements</h2>
    <p>The editors wish to thank the Working Group chairs and Team Contact,
    Harald Alvestrand, Stefan H&aring;kansson, Erik Lagerway and Dominique
    Haza&euml;l-Massieux, for their support. Substantial text in this
    specification was provided by many people including Martin Thomson, Harald
    Alvestrand, Justin Uberti, Eric Rescorla, Peter Thatcher, Jan-Ivar Bruaroey
    and Peter Saint-Andre. Dan Burnett would like to acknowledge the
    significant support received from Voxeo and Aspect during the development
    of this specification.</p>
    <p>The RTCRtpSender and RTCRtpReceiver objects were initially described in
    the <a href="https://www.w3.org/community/ortc/">W3C ORTC CG</a>, and have
    been adapted for use in this specification.</p>
  </section>
</body>
</html>
