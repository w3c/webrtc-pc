<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <link href="webrtc.css" rel="stylesheet">
    <title>
      WebRTC 1.0: Real-Time Communication Between Browsers
    </title>
    <script class="remove" src="respec-w3c-common.js" type="text/javascript">
    // // keep this comment //
    </script>
    <script class="remove" src="webrtc.js" type="text/javascript">
    // // keep
    this comment //
    </script>
  </head>
  <body>
    <p class='copyright'>
      Initial Author of this Specification was Ian Hickson, Google Inc., with
      the following copyright statement:<br>
      © Copyright 2004-2011 Apple Computer, Inc., Mozilla Foundation, and Opera
      Software ASA. You are granted a license to use, reproduce and create
      derivative works of this document. All subsequent changes since 26 July
      2011 done by the W3C WebRTC Working Group are under the following
      <a href='https://www.w3.org/Consortium/Legal/ipr-notice#Copyright'>Copyright</a>:<br>

      © 2011-2018 <a href='https://www.w3.org/'><abbr title=
      'World Wide Web Consortium'>W3C</abbr></a><sup>®</sup> (<a href=
      'https://www.csail.mit.edu/'><abbr title=
      'Massachusetts Institute of Technology'>MIT</abbr></a>, <a href=
      'https://www.ercim.eu/'><abbr title=
      'European Research Consortium for Informatics and Mathematics'>ERCIM</abbr></a>,
      <a href='https://www.keio.ac.jp/'>Keio</a>, <a href=
      'https://ev.buaa.edu.cn/'>Beihang</a>).  W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
    <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a rel="license" href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">permissive document license</a> rules
    apply.
    </p>
    <section id="abstract">
      <p>
        This document defines a set of ECMAScript APIs in WebIDL to allow media
        and generic application data to be sent to and received from another
        browser or device implementing the appropriate set of real-time
        protocols. This specification is being developed in conjunction with a
        protocol specification developed by the IETF RTCWEB group and an API
        specification to get access to local media devices.
      </p>
    </section>
    <section id="sotd" class="updateable-rec">
      <p>
        The API is based on preliminary work done in the WHATWG.
      </p>
      <p>
        The specification is feature complete and is expected to be stable with
        no further substantive change. Since the <a href=
        "https://www.w3.org/TR/2019/CR-webrtc-20191213/">previous Candidate
        Recommendation</a>, the following substantive changes have been brought
        to the specification:
      </p>
      <ul>
        <li>the specification allows administrative prohibiting of ICE
        candidates to help prevent WebRTC to be used for portscanning
        </li>
        <li>the support for setting multiple DTLS certificates has been
        deprecated
        </li>
        <li>
          <code>voiceActivityFlag</code> has been marked at risk for lack of
          implementation
        </li>
        <li>the state machine when closing a <code>PeerConnection</code> has
        been clarified
        </li>
        <li>Align with latest changes in <a href=
        "https://w3c.github.io/webrtc-stats/">WebRTC Statistics</a>
        </li>
      </ul>
      <p>
        Its <a href=
        "https://github.com/web-platform-tests/wpt/tree/master/webrtc">associated
        test suite</a> will be used to build an <a href=
        "https://w3c.github.io/webrtc-interop-reports/webrtc-pc-report.html">implementation
        report</a> of the API.
      </p>
      <p>
        To go into Proposed Recommendation status, the group expects to
        demonstrate implementation of each feature in at least two deployed
        browsers, and at least one implementation of each optional feature.
        Mandatory feature with only one implementation may be marked as
        optional in a revised Candidate Recommendation where applicable.
      </p>
    </section>
    <section class="informative" id="intro">
      <h2>
        Introduction
      </h2>
      <p>
        There are a number of facets to peer-to-peer communications and
        video-conferencing in HTML covered by this specification:
      </p>
      <ul>
        <li>Connecting to remote peers using NAT-traversal technologies such as
        ICE, STUN, and TURN.
        </li>
        <li>Sending the locally-produced tracks to remote peers and receiving
        tracks from remote peers.
        </li>
        <li>Sending arbitrary data directly to remote peers.
        </li>
      </ul>
      <p>
        This document defines the APIs used for these features. This
        specification is being developed in conjunction with a protocol
        specification developed by the <a href=
        "https://datatracker.ietf.org/wg/rtcweb/">IETF RTCWEB group</a> and an
        API specification to get access to local media devices [[GETUSERMEDIA]]
        developed by the WebRTC Working Group. An overview of the system can be
        found in [[RFC8825]] and [[RFC8826]].
      </p>
    </section>
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn>user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Conformance requirements phrased as algorithms or specific steps may be
        implemented in any manner, so long as the end result is equivalent. (In
        particular, the algorithms defined in this specification are intended
        to be easy to follow, and not intended to be performant.)
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined in
        this specification MUST implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]],
        as this specification uses that specification and terminology.
      </p>
    </section>
    <section>
      <h2>
        Terminology
      </h2>
      <p>
        The {{EventHandler}} interface, representing a callback used for event
        handlers, is defined in [[!HTML]].
      </p>
      <p>
        The concepts [= queue a task =] and [= networking task source =] are
        defined in [[!HTML]].
      </p>
      <p>
        The concept [= fire an event =] is defined in [[!DOM]].
      </p>
      <p>
        The terms [= event =], [= event handlers =] and [= event handler event
        types =] are defined in [[!HTML]].
      </p>
      <p>
        {{Performance.timeOrigin}} and {{Performance.now()}} are defined in
        [[!hr-time]].
      </p>
      <p>
        The terms <dfn class=fixme data-cite="HTML/structured-data.html#serializable-objects">serializable objects</dfn>, [= serialization steps =], and [=
        deserialization steps =] are defined in [[!HTML]].
      </p>
      <p>
        The terms {{MediaStream}}, {{MediaStreamTrack}}, and
        {{MediaStreamConstraints}} are defined in [[!GETUSERMEDIA]]. Note that
        {{MediaStream}} is extended in <a href="#mediastream-network-use"></a>
        in this document while {{MediaStreamTrack}} is extended in <a href=
        "#mediastreamtrack-network-use"></a> in this document.
      </p>
      <p>
        The term {{Blob}} is defined in [[!FILEAPI]].
      </p>
      <p>
        The term <dfn>media description</dfn> is defined in [[!RFC4566]].
      </p>
      <p>
        The term <dfn>media transport</dfn> is defined in [[!RFC7656]].
      </p>
      <p>
        The term <dfn>generation</dfn> is defined in [[RFC8838]] Section
        2.
      </p>
      <p>
        The terms <dfn data-cite="!WEBRTC-STATS#dfn-stats-object">stats
        object</dfn> and <dfn data-cite=
        "!WEBRTC-STATS#dfn-monitored-object">monitored object</dfn> are defined
        in [[!WEBRTC-STATS]].
      </p>
      <p>
        When referring to exceptions, the terms [= exception/throw =] and [=
        exception/created =] are defined in [[!WEBIDL]].
      </p>
      <p>
        The callback {{VoidFunction}} is defined in [[!WEBIDL]].
      </p>
      <p>
        The term "throw" is used as specified in [[!INFRA]]: it terminates the
        current processing steps.
      </p>
      <p>
        The terms <dfn data-lt="fulfill|fulfillment">fulfilled</dfn>,
        <dfn data-lt="reject|rejection|rejecting">rejected</dfn>, <dfn data-lt=
        "resolve|resolves">resolved</dfn>, <dfn>pending</dfn> and
        <dfn>settled</dfn> used in the context of Promises are defined in
        [[!ECMASCRIPT-6.0]].
      </p>
      <p>
        The terms <dfn>bundle</dfn>, <dfn>bundle-only</dfn> and
        <dfn>bundle-policy</dfn> are defined in [[!RFC8829]].
      </p>
      <p>
        The <dfn data-cite=
        "WebCryptoAPI/#dfn-AlgorithmIdentifier">AlgorithmIdentifier</dfn> is
        defined in [[!WebCryptoAPI]].
      </p>
      <p class="note">
        The general principles for Javascript APIs apply, including the
        principle of <a href=
        "https://w3ctag.github.io/design-principles/#js-rtc">run-to-completion</a>
        and no-data-races as defined in [[API-DESIGN-PRINCIPLES]]. That is,
        while a task is running, external events do not influence what's
        visible to the Javascript application. For example, the amount of data
        buffered on a data channel will increase due to "send" calls while
        Javascript is executing, and the decrease due to packets being sent
        will be visible after a task checkpoint.<br>
        It is the responsibility of the user agent to make sure the set of
        values presented to the application is consistent - for instance that
        getContributingSources() (which is synchronous) returns values for all
        sources measured at the same time.
      </p>
    </section>
    <section>
      <h2>
        Peer-to-peer connections
      </h2>
      <section>
        <h3>
          Introduction
        </h3>
        <p data-tests="RTCPeerConnection-remote-track-mute.https.html">
          An {{RTCPeerConnection}} instance allows an application to establish
          peer-to-peer communications with another {{RTCPeerConnection}}
          instance in another browser, or to another endpoint implementing the
          required protocols. Communications are coordinated by the exchange of
          control messages (called a signaling protocol) over a signaling
          channel which is provided by unspecified means, but generally by a
          script in the page via the server, e.g. using <a data-cite="?html/web-sockets.html#websocket">Web
          Sockets</a> or <code>XMLHttpRequest</code> [[?xhr]].
        </p>
      </section>
      <section>
        <h3>
          Configuration
        </h3>
        <section>
          <h4>
            <dfn>RTCConfiguration</dfn> Dictionary
          </h4>
          <p>
            The {{RTCConfiguration}} defines a set of parameters to configure
            how the peer-to-peer communication established via
            {{RTCPeerConnection}} is established or re-established.
          </p>
          <div>
            <pre class="idl">dictionary RTCConfiguration {
  sequence&lt;RTCIceServer&gt; iceServers;
  RTCIceTransportPolicy iceTransportPolicy;
  RTCBundlePolicy bundlePolicy;
  RTCRtcpMuxPolicy rtcpMuxPolicy;
  sequence&lt;RTCCertificate&gt; certificates;
  [EnforceRange] octet iceCandidatePoolSize = 0;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCConfiguration}} Members
              </h2>
              <dl data-link-for="RTCConfiguration" data-dfn-for=
              "RTCConfiguration" class="dictionary-members">
                <dt data-tests="RTCConfiguration-iceServers.html">
                  <dfn data-idl="">iceServers</dfn> of type <span class=
                  "idlMemberType">sequence&lt;{{RTCIceServer}}&gt;</span>
                </dt>
                <dd>
                  <p>
                    An array of objects describing servers available to be used
                    by ICE, such as STUN and TURN servers.
                  </p>
                </dd>
                <dt data-tests="RTCConfiguration-iceTransportPolicy.html">
                  <dfn data-idl="">iceTransportPolicy</dfn> of type
                  <span class="idlMemberType">{{RTCIceTransportPolicy}}</span>.
                </dt>
                <dd>
                  <p>
                    Indicates which candidates the [= ICE Agent =] is allowed
                    to use.
                  </p>
                </dd>
                <dt data-tests=
                "RTCConfiguration-bundlePolicy.html,RTCPeerConnection-iceConnectionState.https.html">
                  <dfn data-idl="">bundlePolicy</dfn> of type <span class=
                  "idlMemberType">{{RTCBundlePolicy}}</span>.
                </dt>
                <dd>
                  <p>
                    Indicates which <a data-lt="RTCBundlePolicy">media-bundling
                    policy</a> to use when gathering ICE candidates.
                  </p>
                </dd>
                <dt data-tests="RTCConfiguration-rtcpMuxPolicy.html">
                  <dfn data-idl="">rtcpMuxPolicy</dfn> of type <span class=
                  "idlMemberType">{{RTCRtcpMuxPolicy}}</span>.
                </dt>
                <dd>
                  <p>
                    Indicates which <a data-lt="RTCRtcpMuxPolicy">rtcp-mux
                    policy</a> to use when gathering ICE candidates.
                  </p>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-constructor.html,RTCCertificate.html">
                  <dfn data-idl="">certificates</dfn> of type <span class=
                  "idlMemberType">sequence&lt;{{RTCCertificate}}&gt;</span>
                </dt>
                <dd>
                  <p>
                    A set of certificates that the {{RTCPeerConnection}} uses
                    to authenticate.
                  </p>
                  <p>
                    Valid values for this parameter are created through calls
                    to the {{RTCPeerConnection/generateCertificate()}}
                    function.
                  </p>
                  <p>
                    Although any given DTLS connection will use only one
                    certificate, this attribute allows the caller to provide
                    multiple certificates that support different algorithms.
                    The final certificate will be selected based on the DTLS
                    handshake, which establishes which certificates are
                    allowed. The {{RTCPeerConnection}} implementation selects
                    which of the certificates is used for a given connection;
                    how certificates are selected is outside the scope of this
                    specification.
                  </p>
                  <p class="note">
                    Existing implementations only utilize the first certificate
                    provided; the others are ignored.
                  </p>
                  <p>
                    If this value is absent, then a default set of certificates
                    is generated for each {{RTCPeerConnection}} instance.
                  </p>
                  <p>
                    This option allows applications to establish key
                    continuity. An {{RTCCertificate}} can be persisted in
                    [[?INDEXEDDB]] and reused. Persistence and reuse also
                    avoids the cost of key generation.
                  </p>
                  <p>
                    The value for this configuration option cannot change after
                    its value is initially selected.
                  </p>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-constructor.html,RTCConfiguration-iceCandidatePoolSize.html">
                  <dfn data-idl="">iceCandidatePoolSize</dfn> of type
                  <span class="idlMemberType">octet</span>, defaulting to
                  <code>0</code>
                </dt>
                <dd>
                  <p>
                    Size of the prefetched ICE pool as defined in
                    <span data-jsep=
                    "ice-candidate-pool pc-constructor">[[!RFC8829]]</span>.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section>
          <h4>
            <dfn>RTCIceCredentialType</dfn> Enum
          </h4>
          <div>
            <pre class="idl">enum RTCIceCredentialType {
  "password"
};</pre>
            <table data-link-for="RTCIceCredentialType" data-dfn-for=
            "RTCIceCredentialType" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    Enumeration description
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td data-tests="RTCConfiguration-iceServers.html">
                    <dfn data-idl="">password</dfn>
                  </td>
                  <td>
                    The credential is a long-term authentication username and
                    password, as described in [[!RFC5389]], Section 10.2.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section>
          <h4>
            <dfn>RTCIceServer</dfn> Dictionary
          </h4>
          <p>
            The {{RTCIceServer}} dictionary is used to describe the STUN and
            TURN servers that can be used by the [= ICE Agent =] to establish a
            connection with a peer.
          </p>
          <div>
            <pre class="idl">dictionary RTCIceServer {
  required (DOMString or sequence&lt;DOMString&gt;) urls;
  DOMString username;
  DOMString credential;
  RTCIceCredentialType credentialType = "password";
};</pre>
            <section>
              <h2>
                Dictionary {{RTCIceServer}} Members
              </h2>
              <dl data-link-for="RTCIceServer" data-dfn-for="RTCIceServer"
              class="dictionary-members">
                <dt data-tests="RTCConfiguration-iceServers.html">
                  <dfn data-idl="">urls</dfn> of type <span class=
                  "idlMemberType">(DOMString or
                  sequence&lt;DOMString&gt;)</span>, required
                </dt>
                <dd>
                  <p>
                    STUN or TURN URI(s) as defined in [[!RFC7064]] and
                    [[!RFC7065]] or other URI types.
                  </p>
                </dd>
                <dt data-tests="RTCConfiguration-iceServers.html">
                  <dfn data-idl="">username</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd>
                  <p>
                    If this {{RTCIceServer}} object represents a TURN server,
                    and {{credentialType}} is
                    {{RTCIceCredentialType/"password"}}, then this attribute
                    specifies the username to use with that TURN server.
                  </p>
                </dd>
                <dt data-tests="RTCConfiguration-iceServers.html">
                  <dfn data-idl="">credential</dfn> of type {{DOMString}}
                </dt>
                <dd>
                  <p>
                    If this {{RTCIceServer}} object represents a TURN server,
                    then this attribute specifies the credential to use with
                    that TURN server.
                  </p>
                  <p>
                    If {{credentialType}} is
                    {{RTCIceCredentialType/"password"}}, {{credential}}
                    represents a long-term authentication password, as
                    described in [[!RFC5389]], Section 10.2.
                  </p>
                  <p class="note">
                    To support additional values of {{credentialType}},
                    {{credential}} may evolve in future as a union.
                  </p>
                </dd>
                <dt data-tests="RTCConfiguration-iceServers.html">
                  <dfn data-idl="">credentialType</dfn> of type <span class=
                  "idlMemberType">{{RTCIceCredentialType}}</span>, defaulting
                  to {{RTCIceCredentialType/"password"}}
                </dt>
                <dd>
                  <p>
                    If this {{RTCIceServer}} object represents a TURN server,
                    then this attribute specifies how <var>credential</var>
                    should be used when that TURN server requests
                    authorization.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
          <p>
            An example array of {{RTCIceServer}} objects is:
          </p>
          <pre class="example highlight">
[
  {urls: 'stun:stun1.example.net'},
  {urls: ['turns:turn.example.org', 'turn:turn.example.net'],
    username: 'user',
    credential: 'myPassword',
    credentialType: 'password'},
];
        </pre>
        </section>
        <section data-tests="RTCConfiguration-iceTransportPolicy.html">
          <h4>
            <dfn>RTCIceTransportPolicy</dfn> Enum
          </h4>
          <p>
            As described in <span data-jsep="pc-constructor">[[!RFC8829]]</span>, if
            the {{RTCConfiguration/iceTransportPolicy}} member of the
            {{RTCConfiguration}} is specified, it defines the <span data-jsep=
            "ice-candidate-policy">ICE candidate policy [[!RFC8829]]</span> the
            browser uses to surface the permitted candidates to the
            application; only these candidates will be used for connectivity
            checks.
          </p>
          <div>
            <pre class="idl">enum RTCIceTransportPolicy {
  "relay",
  "all"
};</pre>
            <table data-link-for="RTCIceTransportPolicy" data-dfn-for=
            "RTCIceTransportPolicy" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    Enumeration description (non-normative)
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <dfn data-idl="">relay</dfn>
                  </td>
                  <td>
                    <p>
                      The [= ICE Agent =] uses only media relay candidates such
                      as candidates passing through a TURN server.
                    </p>
                    <div class="note">
                      This can be used to prevent the remote endpoint from
                      learning the user's IP addresses, which may be desired in
                      certain use cases. For example, in a "call"-based
                      application, the application may want to prevent an
                      unknown caller from learning the callee's IP addresses
                      until the callee has consented in some way.
                    </div>
                  </td>
                </tr>
                <tr>
                  <td>
                    <dfn data-idl="">all</dfn>
                  </td>
                  <td>
                    <p>
                      The [= ICE Agent =] can use any type of candidate when
                      this value is specified.
                    </p>
                    <div class="note">
                      The implementation can still use its own candidate
                      filtering policy in order to limit the IP addresses
                      exposed to the application, as noted in the description
                      of {{RTCIceCandidate}}.{{RTCIceCandidate/address}}.
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section data-tests="RTCConfiguration-bundlePolicy.html">
          <h4>
            <dfn>RTCBundlePolicy</dfn> Enum
          </h4>
          <p>
            As described in <span data-jsep="pc-constructor">[[!RFC8829]]</span>,
            bundle policy affects which media tracks are negotiated if the
            remote endpoint is not bundle-aware, and what ICE candidates are
            gathered. If the remote endpoint is bundle-aware, all media tracks
            and data channels are bundled onto the same transport.
          </p>
          <div>
            <pre id="target-bundle-policy" class="idl">enum RTCBundlePolicy {
  "balanced",
  "max-compat",
  "max-bundle"
};</pre>
            <table data-link-for="RTCBundlePolicy" data-dfn-for=
            "RTCBundlePolicy" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    Enumeration description (non-normative)
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td data-tests=
                  "RTCRtpSender-transport.https.html,RTCPeerConnection-iceConnectionState.https.html">
                    <dfn data-idl="">balanced</dfn>
                  </td>
                  <td>
                    Gather ICE candidates for each media type in use (audio,
                    video, and data). If the remote endpoint is not
                    bundle-aware, negotiate only one audio and video track on
                    separate transports.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCRtpSender-transport.https.html,RTCPeerConnection-iceConnectionState.https.html">
                    <dfn data-idl="">max-compat</dfn>
                  </td>
                  <td>
                    Gather ICE candidates for each track. If the remote
                    endpoint is not bundle-aware, negotiate all media tracks on
                    separate transports.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCRtpSender-transport.https.html,RTCPeerConnection-iceConnectionState.https.html">
                    <dfn data-idl="">max-bundle</dfn>
                  </td>
                  <td>
                    Gather ICE candidates for only one track. If the remote
                    endpoint is not bundle-aware, negotiate only one media
                    track.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section data-tests="RTCConfiguration-rtcpMuxPolicy.html">
          <h4>
            <dfn>RTCRtcpMuxPolicy</dfn> Enum
          </h4>
          <p>
            As described in <span data-jsep="pc-constructor">[[!RFC8829]]</span>, the
            {{RTCRtcpMuxPolicy}} affects what ICE candidates are gathered to
            support non-multiplexed RTCP. The only value defined in this spec
            is {{RTCRtcpMuxPolicy/"require"}}.
          </p>
          <div>
            <pre id="target-rtcp-mux-policy" class="idl">
              enum RTCRtcpMuxPolicy {
                "require"
              };
            </pre>
            <table data-link-for="RTCRtcpMuxPolicy" data-dfn-for=
            "RTCRtcpMuxPolicy" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    Enumeration description (non-normative)
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <dfn data-idl="">require</dfn>
                  </td>
                  <td>
                    Gather ICE candidates only for RTP and multiplex RTCP on
                    the RTP candidates. If the remote endpoint is not capable
                    of rtcp-mux, session negotiation will fail.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section>
          <h4>
            Offer/Answer Options
          </h4>
          <p>
            These dictionaries describe the options that can be used to control
            the offer/answer creation process.
          </p>
          <div>
            <pre class="idl">dictionary RTCOfferAnswerOptions {};</pre>
            <section>
              <h2>
                Dictionary <dfn>RTCOfferAnswerOptions</dfn> Members
              </h2>
              <dl data-link-for="RTCOfferAnswerOptions" data-dfn-for=
              "RTCOfferAnswerOptions" class="dictionary-members"></dl>
            </section>
          </div>
          <div>
            <pre class="idl">dictionary RTCOfferOptions : RTCOfferAnswerOptions {
  boolean iceRestart = false;
};</pre>
            <section>
              <h2>
                Dictionary <dfn>RTCOfferOptions</dfn> Members
              </h2>
              <dl data-link-for="RTCOfferOptions" data-dfn-for=
              "RTCOfferOptions" class="dictionary-members">
                <dt data-tests="RTCPeerConnection-restartIce.https.html">
                  <dfn data-idl="">iceRestart</dfn> of type <span class=
                  "idlMemberType">boolean</span>, defaulting to
                  <code>false</code>
                </dt>
                <dd>
                  <p>
                    When the value of this dictionary member is
                    <code>true</code>, or the relevant {{RTCPeerConnection}}
                    object's {{RTCPeerConnection/[[LocalIceCredentialsToReplace]]}} slot is
                    not empty, then the generated description will have ICE
                    credentials that are different from the current credentials
                    (as visible in the
                    {{RTCPeerConnection/currentLocalDescription}} attribute's
                    SDP). Applying the generated description will restart ICE,
                    as described in section 9.1.1.1 of [[RFC5245]].
                  </p>
                  <p>
                    When the value of this dictionary member is
                    <code>false</code>, and the relevant {{RTCPeerConnection}}
                    object's {{RTCPeerConnection/[[LocalIceCredentialsToReplace]]}} slot is
                    empty, and the
                    {{RTCPeerConnection/currentLocalDescription}} attribute has
                    valid ICE credentials, then the generated description will
                    have the same ICE credentials as the current value from the
                    {{RTCPeerConnection/currentLocalDescription}} attribute.
                  </p>
                  <p class="note">
                    Performing an ICE restart is recommended when
                    {{RTCPeerConnection/iceConnectionState}} transitions to
                    {{RTCIceConnectionState/"failed"}}. An application may
                    additionally choose to listen for the
                    {{RTCPeerConnection/iceConnectionState}} transition to
                    {{RTCIceConnectionState/"disconnected"}} and then use other
                    sources of information (such as using
                    {{RTCPeerConnection/getStats}} to measure if the number of
                    bytes sent or received over the next couple of seconds
                    increases) to determine whether an ICE restart is
                    advisable.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
          <div>
            <p>
              The <dfn>RTCAnswerOptions</dfn> dictionary describe options
              specific to session description of type {{RTCSdpType/"answer"}}
              (none in this version of the specification).
            </p>
            <pre class="idl">dictionary RTCAnswerOptions : RTCOfferAnswerOptions {};</pre>
          </div>
        </section>
      </section>
      <section>
        <h3>
          State Definitions
        </h3>
        <section>
          <h4>
            <dfn>RTCSignalingState</dfn> Enum
          </h4>
          <div>
            <pre class="idl">enum RTCSignalingState {
  "stable",
  "have-local-offer",
  "have-remote-offer",
  "have-local-pranswer",
  "have-remote-pranswer",
  "closed"
};</pre>
            <table data-link-for="RTCSignalingState" data-dfn-for=
            "RTCSignalingState" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    Enumeration description
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-onsignalingstatechanged.https.html,RTCPeerConnection-setRemoteDescription.html">
                    <dfn data-idl="">stable</dfn>
                  </td>
                  <td>
                    There is no offer/answer exchange in progress. This is also
                    the initial state, in which case the local and remote
                    descriptions are empty.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-createOffer.html, RTCPeerConnection-setLocalDescription-offer.html,RTCPeerConnection-setLocalDescription.html,RTCPeerConnection-setRemoteDescription.html">
                    <dfn data-idl="">have-local-offer</dfn>
                  </td>
                  <td>
                    A local description, of type {{RTCSdpType/"offer"}}, has
                    been successfully applied.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-setLocalDescription-answer.html,RTCPeerConnection-setRemoteDescription-offer.html,RTCPeerConnection-setRemoteDescription-rollback.html,RTCPeerConnection-setRemoteDescription.html">
                    <dfn data-idl="">have-remote-offer</dfn>
                  </td>
                  <td>
                    A remote description, of type {{RTCSdpType/"offer"}}, has
                    been successfully applied.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-setLocalDescription-pranswer.html">
                    <dfn data-idl="">have-local-pranswer</dfn>
                  </td>
                  <td>
                    A remote description of type {{RTCSdpType/"offer"}} has
                    been successfully applied and a local description of type
                    {{RTCSdpType/"pranswer"}} has been successfully applied.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-setRemoteDescription-pranswer.html">
                    <dfn data-idl="">have-remote-pranswer</dfn>
                  </td>
                  <td>
                    A local description of type {{RTCSdpType/"offer"}} has been
                    successfully applied and a remote description of type
                    {{RTCSdpType/"pranswer"}} has been successfully applied.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-onsignalingstatechanged.https.html">
                    <dfn data-idl="">closed</dfn>
                  </td>
                  <td>
                    The {{RTCPeerConnection}} has been closed; its
                    {{RTCPeerConnection/[[IsClosed]]}} slot is <code>true</code>.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <figure>
            <img alt="signaling state transition diagram" src=
            "images/peerstates.svg" width="600">
            <figcaption>
              Non-normative signaling state transitions diagram. Method calls
              abbreviated.
            </figcaption>
          </figure>
          <p>
            An example set of transitions might be:
          </p>
          <dl>
            <dt>
              Caller transition:
            </dt>
            <dd>
              <ul>
                <li>new RTCPeerConnection(): {{RTCSignalingState/"stable"}}
                </li>
                <li>setLocalDescription(offer):
                {{RTCSignalingState/"have-local-offer"}}
                </li>
                <li>setRemoteDescription(pranswer):
                {{RTCSignalingState/"have-remote-pranswer"}}
                </li>
                <li>setRemoteDescription(answer):
                {{RTCSignalingState/"stable"}}
                </li>
              </ul>
            </dd>
            <dt>
              Callee transition:
            </dt>
            <dd>
              <ul>
                <li>new RTCPeerConnection(): {{RTCSignalingState/"stable"}}
                </li>
                <li>setRemoteDescription(offer):
                {{RTCSignalingState/"have-remote-offer"}}
                </li>
                <li>setLocalDescription(pranswer):
                {{RTCSignalingState/"have-local-pranswer"}}
                </li>
                <li>setLocalDescription(answer): {{RTCSignalingState/"stable"}}
                </li>
              </ul>
            </dd>
          </dl>
        </section>
        <section>
          <h4>
            <dfn>RTCIceGatheringState</dfn> Enum
          </h4>
          <div>
            <pre class="idl">enum RTCIceGatheringState {
  "new",
  "gathering",
  "complete"
};</pre>
            <table data-link-for="RTCIceGatheringState" data-dfn-for=
            "RTCIceGatheringState" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    Enumeration description
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td data-tests="RTCPeerConnection-iceGatheringState.html">
                    <dfn data-idl="">new</dfn>
                  </td>
                  <td>
                    Any of the {{RTCIceTransport}}s are in the
                    {{RTCIceGathererState/"new"}} gathering state and none of
                    the transports are in the
                    {{RTCIceGathererState/"gathering"}} state, or there are no
                    transports.
                  </td>
                </tr>
                <tr>
                  <td data-tests="RTCPeerConnection-iceGatheringState.html">
                    <dfn data-idl="">gathering</dfn>
                  </td>
                  <td>
                    Any of the {{RTCIceTransport}}s are in the
                    {{RTCIceGathererState/"gathering"}} state.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-iceGatheringState.html,protocol/candidate-exchange.https.html">
                    <dfn data-idl="">complete</dfn>
                  </td>
                  <td>
                    At least one {{RTCIceTransport}} exists, and all
                    {{RTCIceTransport}}s are in the
                    {{RTCIceGathererState/"complete"}} gathering state.
                  </td>
                </tr>
              </tbody>
            </table>
            <p>
              The set of transports considered is the one
              presently referenced by the PeerConnection's
              [= set of transceivers =] and the PeerConnection's
              <dfn data-dfn-for="RTCPeerConnection">[[\SctpTransport]]</dfn>
              internal slot if not <code>null</code>.
           </p>
          </div>
        </section>
        <section>
          <h4>
            <dfn>RTCPeerConnectionState</dfn> Enum
          </h4>
          <div>
            <pre class="idl">enum RTCPeerConnectionState {
  "closed",
  "failed",
  "disconnected",
  "new",
  "connecting",
  "connected"
};</pre>
            <table data-link-for="RTCPeerConnectionState" data-dfn-for=
            "RTCPeerConnectionState" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    Enumeration description
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-connectionState.https.html">
                    <dfn data-idl="">closed</dfn>
                  </td>
                  <td>
                    The {{RTCPeerConnection}} object's {{RTCPeerConnection/[[IsClosed]]}}
                    slot is <code>true</code>.
                  </td>
                </tr>
                <tr>
                  <td data-tests="protocol/dtls-fingerprint-validation.html">
                    <dfn data-idl="">failed</dfn>
                  </td>
                  <td>
                    The previous state doesn't apply and any
                    {{RTCIceTransport}}s are in the
                    {{RTCIceTransportState/"failed"}} state or any
                    {{RTCDtlsTransport}}s are in the
                    {{RTCDtlsTransportState/"failed"}} state.
                  </td>
                </tr>
                <tr>
                  <td data-tests="">
                    <dfn data-idl="">disconnected</dfn>
                  </td>
                  <td>
                    None of the previous states apply and any
                    {{RTCIceTransport}}s are in the
                    {{RTCIceTransportState/"disconnected"}} state.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-connectionState.https.html">
                    <dfn data-idl="">new</dfn>
                  </td>
                  <td>
                    None of the previous states apply and all
                    {{RTCIceTransport}}s are in the
                    {{RTCIceTransportState/"new"}} or
                    {{RTCIceTransportState/"closed"}} state, and all
                    {{RTCDtlsTransport}}s are in the
                    {{RTCDtlsTransportState/"new"}} or
                    {{RTCDtlsTransportState/"closed"}} state, or there are no
                    transports.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-connectionState.https.html">
                    <dfn data-idl="">connecting</dfn>
                  </td>
                  <td>
                    None of the previous states apply and any
                    {{RTCIceTransport}} is in the {{RTCIceTransportState/"new"}}
                    or {{RTCIceTransportState/"checking"}} state or any
                    {{RTCDtlsTransport}} is in the {{RTCDtlsTransportState/"new"}}
                    or {{RTCDtlsTransportState/"connecting"}} state.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-connectionState.https.html">
                    <dfn data-idl="">connected</dfn>
                  </td>
                  <td>
                    None of the previous states apply and all
                    {{RTCIceTransport}}s are in the
                    {{RTCIceTransportState/"connected"}},
                    {{RTCIceTransportState/"completed"}} or
                    {{RTCIceTransportState/"closed"}} state, and all
                    {{RTCDtlsTransport}}s are in the
                    {{RTCDtlsTransportState/"connected"}} or
                    {{RTCDtlsTransportState/"closed"}} state.
                  </td>
                </tr>
              </tbody>
            </table>
             <p>
              The set of transports considered is the one
              presently referenced by the PeerConnection's
              [= set of transceivers =] and the PeerConnection's
              <dfn data-dfn-for="RTCPeerConnection">[[\SctpTransport]]</dfn>
              internal slot if not <code>null</code>.
            </p>
         </div>
        </section>
        <section>
          <h4>
            <dfn>RTCIceConnectionState</dfn> Enum
          </h4>
          <div>
            <pre class="idl">enum RTCIceConnectionState {
  "closed",
  "failed",
  "disconnected",
  "new",
  "checking",
  "completed",
  "connected"
};</pre>
            <table data-link-for="RTCIceConnectionState" data-dfn-for=
            "RTCIceConnectionState" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    Enumeration description
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-iceConnectionState.https.html">
                    <dfn data-idl="">closed</dfn>
                  </td>
                  <td>
                    The {{RTCPeerConnection}} object's {{RTCPeerConnection/[[IsClosed]]}}
                    slot is <code>true</code>.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-iceConnectionState-disconnected.https.html,protocol/ice-state.https.html">
                    <dfn data-idl="">failed</dfn>
                  </td>
                  <td>
                    The previous state doesn't apply and any
                    {{RTCIceTransport}}s are in the
                    {{RTCIceTransportState/"failed"}} state.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-iceConnectionState-disconnected.https.html,protocol/ice-state.https.html">
                    <dfn data-idl="">disconnected</dfn>
                  </td>
                  <td>
                    None of the previous states apply and any
                    {{RTCIceTransport}}s are in the
                    {{RTCIceTransportState/"disconnected"}} state.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-iceConnectionState.https.html,no-media-call.html">
                    <dfn data-idl="">new</dfn>
                  </td>
                  <td>
                    None of the previous states apply and all
                    {{RTCIceTransport}}s are in the
                    {{RTCIceTransportState/"new"}} or
                    {{RTCIceTransportState/"closed"}} state, or there are no
                    transports.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-iceConnectionState.https.html,no-media-call.html">
                    <dfn data-idl="">checking</dfn>
                  </td>
                  <td>
                    None of the previous states apply and any
                    {{RTCIceTransport}}s are in the
                    {{RTCIceTransportState/"new"}} or
                    {{RTCIceTransportState/"checking"}} state.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-iceConnectionState.https.html">
                    <dfn data-idl="">completed</dfn>
                  </td>
                  <td>
                    None of the previous states apply and all
                    {{RTCIceTransport}}s are in the
                    {{RTCIceTransportState/"completed"}} or
                    {{RTCIceTransportState/"closed"}} state.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-iceConnectionState.https.html,protocol/ice-state.https.html,RTCIceConnectionState-candidate-pair.https.html">
                    <dfn data-idl="">connected</dfn>
                  </td>
                  <td>
                    None of the previous states apply and all
                    {{RTCIceTransport}}s are in the
                    {{RTCIceTransportState/"connected"}},
                    {{RTCIceTransportState/"completed"}} or
                    {{RTCIceTransportState/"closed"}} state.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The set of transports considered is the one
            presently referenced by the PeerConnection's
            [= set of transceivers =] and the PeerConnection's
              <dfn data-dfn-for="RTCPeerConnection">[[\SctpTransport]]</dfn>
              internal slot if not <code>null</code>.
          </p>
          <p>
            Note that if an {{RTCIceTransport}} is discarded as a result of
            signaling (e.g. RTCP mux or bundling), or created as a result of
            signaling (e.g. adding a new [= media description =]), the state
            may advance directly from one state to another.
          </p>
        </section>
      </section>
      <section>
        <h3>
          RTCPeerConnection Interface
        </h3>
        <p>
          The [[!RFC8829]] specification, as a whole, describes the details of how
          the {{RTCPeerConnection}} operates. References to specific
          subsections of [[!RFC8829]] are provided as appropriate.
        </p>
        <section>
          <h4>
            Operation
          </h4>
          <p>
            Calling <code>new
            {{RTCPeerConnection}}(<var>configuration</var>)</code> creates an
            {{RTCPeerConnection}} object.
          </p>
          <p>
            <var>configuration</var>.{{RTCConfiguration/iceServers}} contains
            information used to find and access the servers used by ICE. The
            application can supply multiple servers of each type, and any TURN
            server MAY also be used as a STUN server for the purposes of
            gathering server reflexive candidates.
          </p>
          <p>
            An {{RTCPeerConnection}} object has a <dfn>signaling state</dfn>, a
            <dfn>connection state</dfn>, an <dfn>ICE gathering state</dfn>, and
            an <dfn>ICE connection state</dfn>. These are initialized when the
            object is created.
          </p>
          <p data-link-for="RTCPeerConnection">
            The ICE protocol implementation of an {{RTCPeerConnection}} is
            represented by an <dfn>ICE agent</dfn> [[RFC5245]]. Certain
            {{RTCPeerConnection}} methods involve interactions with the [= ICE
            Agent =], namely {{addIceCandidate}}, {{setConfiguration}},
            {{setLocalDescription}}, {{setRemoteDescription}} and {{close}}.
            These interactions are described in the relevant sections in this
            document and in [[!RFC8829]]. The [= ICE Agent =] also provides
            indications to the user agent when the state of its internal
            representation of an {{RTCIceTransport}} changes, as described in
            <a href="#rtcicetransport"></a>.
          </p>
          <p>
            The task source for the tasks listed in this section is the [=
            networking task source =].
          </p>
          <p class="note" data-link-for="RTCPeerConnection">
            The state of the SDP negotiation is represented by the [= signaling
            state =] and the internal variables
            {{RTCPeerConnection/[[CurrentLocalDescription]]}},
            {{RTCPeerConnection/[[CurrentRemoteDescription]]}},
            {{RTCPeerConnection/[[PendingLocalDescription]]}} and
            {{RTCPeerConnection/[[PendingRemoteDescription]]}}. These are only set inside the
            {{setLocalDescription}} and {{setRemoteDescription}} operations,
            and modified by the {{addIceCandidate}} operation and the [=
            surface a candidate =] procedure. In each case, all the
            modifications to all the five variables are completed before the
            procedures fire any events or invoke any callbacks, so the
            modifications are made visible at a single point in time.
          </p>
          <p>
            As one of the <a>unloading document cleanup steps</a>, run the
            following steps:
          </p>
          <ol>
            <li class="untestable">
              <p>
                Let <var>window</var> be <var>document</var>'s [=relevant global object=].
              </p>
            </li>
            <li>
              <p>
                For each {{RTCPeerConnection}} object <var>connection</var>
                whose [=relevant global object=] is <var>window</var>, [= close the connection
                =] with <var>connection</var> and the value <code>true</code>.
              </p>
            </li>
          </ol>
          <section>
            <h4>
              Constructor
            </h4>
            <p>
              When the <dfn id=
              "dom-peerconnection">RTCPeerConnection.constructor()</dfn> is
              invoked, the user agent MUST run the following steps:
            </p>
            <ol>
              <li class="untestable">
                <p>
                  If any of the steps enumerated below fails for a reason not
                  specified here, [= exception/throw =] an {{UnknownError}}
                  with the {{DOMException/message}} attribute set to an
                  appropriate description.
                </p>
              </li>
              <li class="no-test-needed">
                <p>
                  Let <var>connection</var> be a newly created
                  {{RTCPeerConnection}} object.
                </p>
              </li>
              <li>
                <p>
                  Let <var>connection</var> have a
                  <dfn data-dfn-for="RTCPeerConnection">[[\DocumentOrigin]]</dfn> internal slot, initialized to
                  the [= relevant settings object =]'s
                  [=environment settings object/origin=].
                </p>
              </li>
              <li class="no-test-needed">Let <var>configuration</var> be the
              method's first argument.
              </li>
              <li data-tests="RTCCertificate.html">
                <p id="certificate-validation">
                  If the {{RTCConfiguration/certificates}} value in
                  <var>configuration</var> is non-empty, run the following
                  steps for each <var>certificate</var> in certificates:
                </p>
                <ol>
                  <li>
                    <p>
                      If the value of
                      <var>certificate</var>.{{RTCCertificate/expires}} is less
                      than the current time, [= exception/throw =] an
                      {{InvalidAccessError}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>certificate</var>.{{RTCCertificate/[[Origin]]}} is not
                      <a data-cite="html">same origin</a> with
                      <var>connection</var>.{{RTCPeerConnection/[[DocumentOrigin]]}}, [=
                      exception/throw =] an {{InvalidAccessError}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      Store <var>certificate</var>.
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <p>
                  Else, generate one or more new {{RTCCertificate}} instances
                  with this {{RTCPeerConnection}} instance and store them. This
                  MAY happen asynchronously and the value of
                  {{RTCConfiguration/certificates}} remains
                  <code>undefined</code> for the subsequent steps. As noted in
                  Section 4.3.2.3 of [[RFC8826]], WebRTC utilizes
                  self-signed rather than Public Key Infrastructure (PKI)
                  certificates, so that the expiration check is to ensure that
                  keys are not used indefinitely and additional certificate
                  checks are unnecessary.
                </p>
              </li>
              <li>
                <p>
                  Initialize <var>connection</var>'s [= ICE Agent =].
                </p>
              </li>
              <li data-tests="RTCConfiguration-iceTransportPolicy.html">
                <p>
                  If the value of
                  <var>configuration</var>.{{RTCConfiguration/iceTransportPolicy}}
                  is <code>undefined</code>, set it to
                  {{RTCIceTransportPolicy/"all"}}.
                </p>
              </li>
              <li data-tests="RTCConfiguration-bundlePolicy.html">
                <p>
                  If the value of
                  <var>configuration</var>.{{RTCConfiguration/bundlePolicy}} is
                  <code>undefined</code>, set it to
                  {{RTCBundlePolicy/"balanced"}}.
                </p>
              </li>
              <li data-tests="RTCConfiguration-rtcpMuxPolicy.html">
                <p>
                  If the value of
                  <var>configuration</var>.{{RTCConfiguration/rtcpMuxPolicy}}
                  is <code>undefined</code>, set it to
                  {{RTCRtcpMuxPolicy/"require"}}.
                </p>
              </li>
              <li data-tests=
              "RTCConfiguration-iceServers.html,RTCConfiguration-iceCandidatePoolSize.html,RTCConfiguration-bundlePolicy.html,RTCConfiguration-iceTransportPolicy.html,RTCConfiguration-rtcpMuxPolicy.html">
                <p>
                  Let <var>connection</var> have a
                  <dfn data-dfn-for="RTCPeerConnection">[[\Configuration]]</dfn> internal slot. [= Set the
                  configuration =] specified by <var>configuration</var>.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-addTrack.https.html">
                <p>
                  Let <var>connection</var> have an <dfn data-dfn-for="RTCPeerConnection">[[\IsClosed]]</dfn>
                  internal slot, initialized to <code>false</code>.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                <p>
                  Let <var>connection</var> have a
                  <dfn data-dfn-for="RTCPeerConnection">[[\NegotiationNeeded]]</dfn> internal slot, initialized
                  to <code>false</code>.
                </p>
              </li>
              <li data-tests="RTCSctpTransport-constructor.html">
                <p>
                  Let <var>connection</var> have an
                  <dfn data-dfn-for="RTCPeerConnection">[[\SctpTransport]]</dfn> internal slot, initialized to
                  <code>null</code>.
                </p>
              </li>
              <li>
                <p>
                  Let <var>connection</var> have an <dfn data-dfn-for="RTCPeerConnection">[[\Operations]]</dfn>
                  internal slot, representing an [= operations chain =],
                  initialized to an empty list.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-constructor.html">
                <p>
                  Let <var>connection</var> have a
                  <dfn data-dfn-for="RTCPeerConnection">[[\UpdateNegotiationNeededFlagOnEmptyChain]]</dfn>
                  internal slot, initialized to <code>false</code>.
                </p>
              </li>
              <li data-tests=
              "RTCPeerConnection-setLocalDescription-parameterless.https.html">
                <p>
                  Let <var>connection</var> have an
                  <dfn data-dfn-for="RTCPeerConnection">[[\LastCreatedOffer]]</dfn> internal slot, initialized
                  to <code>""</code>.
                </p>
              </li>
              <li data-tests=
              "RTCPeerConnection-setLocalDescription-parameterless.https.html">
                <p>
                  Let <var>connection</var> have an
                  <dfn data-dfn-for="RTCPeerConnection">[[\LastCreatedAnswer]]</dfn> internal slot, initialized
                  to <code>""</code>.
                </p>
              </li>
              <li data-tests=
                "RTCPeerConnection-addIceCandidate-timing.https.html,protocol/candidate-exchange.https.html">
                <p>
                  Let <var>connection</var> have an
                  <dfn data-dfn-for="RTCPeerConnection">[[\EarlyCandidates]]</dfn> internal slot, initialized to
                  an empty list.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-constructor.html">
                <p>
                  Set <var>connection</var>'s [= signaling state =] to
                  {{RTCSignalingState/"stable"}}.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-constructor.html">
                <p>
                  Set <var>connection</var>'s [= ICE connection state =] to
                  {{RTCIceConnectionState/"new"}}.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-constructor.html">
                <p>
                  Set <var>connection</var>'s [= ICE gathering state =] to
                  {{RTCIceGatheringState/"new"}}.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-constructor.html">
                <p>
                  Set <var>connection</var>'s [= connection state =] to
                  {{RTCPeerConnectionState/"new"}}.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-constructor.html">
                <p>
                  Let <var>connection</var> have a
                  <dfn data-dfn-for="RTCPeerConnection">[[\PendingLocalDescription]]</dfn> internal slot,
                  initialized to <code>null</code>.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-constructor.html">
                <p>
                  Let <var>connection</var> have a
                  <dfn data-dfn-for="RTCPeerConnection">[[\CurrentLocalDescription]]</dfn> internal slot,
                  initialized to <code>null</code>.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-constructor.html">
                <p>
                  Let <var>connection</var> have a
                  <dfn data-dfn-for="RTCPeerConnection">[[\PendingRemoteDescription]]</dfn> internal slot,
                  initialized to <code>null</code>.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-constructor.html">
                <p>
                  Let <var>connection</var> have a
                  <dfn data-dfn-for="RTCPeerConnection">[[\CurrentRemoteDescription]]</dfn> internal slot,
                  initialized to <code>null</code>.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-constructor.html">
                <p>
                  Let <var>connection</var> have a
                  <dfn data-dfn-for="RTCPeerConnection">[[\LocalIceCredentialsToReplace]]</dfn> internal slot,
                  initialized to an empty set.
                </p>
              </li>
              <li class="no-test-needed">
                <p>
                  Return <var>connection</var>.
                </p>
              </li>
            </ol>
          </section>
          <section>
            <h4>
              Chain an asynchronous operation
            </h4>
            <p>
              An {{RTCPeerConnection}} object has an <dfn>operations
              chain</dfn>, {{RTCPeerConnection/[[Operations]]}}, which ensures that only one
              asynchronous operation in the chain executes concurrently. If
              subsequent calls are made while the returned promise of a
              previous call is still not [= settled =], they are added to the
              chain and executed when all the previous calls have finished
              executing and their promises have [= settled =].
            </p>
            <p data-tests="RTCPeerConnection-createOffer.html">
              To <dfn data-lt="chain|chaining">chain an operation</dfn> to an
              {{RTCPeerConnection}} object's [= operations chain =], run the
              following steps:
            </p>
            <ol>
              <li class="no-test-needed">
                <p>
                  Let <var>connection</var> be the {{RTCPeerConnection}}
                  object.
                </p>
              </li>
              <li data-tests=
              "RTCPeerConnection-createAnswer.html,RTCPeerConnection-createOffer.html">
                <p>
                  If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                  <code>true</code>, return a promise [= rejected =] with a
                  newly [= exception/created =] {{InvalidStateError}}.
                </p>
              </li>
              <li class="no-test-needed">
                <p>
                  Let <var>operation</var> be the operation to be chained.
                </p>
              </li>
              <li class="no-test-needed">
                <p>
                  Let <var>p</var> be a new promise.
                </p>
              </li>
              <li class="no-test-needed">
                <p>
                  Append <var>operation</var> to {{RTCPeerConnection/[[Operations]]}}.
                </p>
              </li>
              <li>
                <p>
                  If the length of {{RTCPeerConnection/[[Operations]]}} is exactly 1, execute
                  <var>operation</var>.
                </p>
              </li>
              <li>
                <p>
                  Upon [= fulfillment =] or [= rejection =] of the promise
                  returned by the <var>operation</var>, run the following
                  steps:
                </p>
                <ol>
                  <li>
                    <p>
                      If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                      <code>true</code>, abort these steps.
                    </p>
                  </li>
                  <li>
                    <p>
                      If the promise returned by <var>operation</var> was [=
                      fulfilled =] with a value, [= fulfill =] <var>p</var>
                      with that value.
                    </p>
                  </li>
                  <li>
                    <p>
                      If the promise returned by <var>operation</var> was [=
                      rejected =] with a value, [= reject =] <var>p</var> with
                      that value.
                    </p>
                  </li>
                  <li>
                    <p>
                      Upon [= fulfillment =] or [= rejection =] of
                      <var>p</var>, execute the following steps:
                    </p>
                    <ol>
                      <li>
                        <p>
                          If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                          <code>true</code>, abort these steps.
                        </p>
                      </li>
                      <li>
                        <p>
                          Remove the first element of {{RTCPeerConnection/[[Operations]]}}.
                        </p>
                      </li>
                      <li>
                        <p>
                          If {{RTCPeerConnection/[[Operations]]}} is non-empty, execute the
                          operation represented by the first element of
                          {{RTCPeerConnection/[[Operations]]}}, and abort these steps.
                        </p>
                      </li>
                      <li>
                        <p>
                          If
                          <var>connection</var>.{{RTCPeerConnection/[[UpdateNegotiationNeededFlagOnEmptyChain]]}}
                          is <code>false</code>, abort these steps.
                        </p>
                      </li>
                      <li>
                        <p>
                          Set
                          <var>connection</var>.{{RTCPeerConnection/[[UpdateNegotiationNeededFlagOnEmptyChain]]}}
                          to <code>false</code>.
                        </p>
                      </li>
                      <li>
                        <p>
                          <a>Update the negotiation-needed flag</a> for
                          <var>connection</var>.
                        </p>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li class="no-test-needed">
                <p>
                  Return <var>p</var>.
                </p>
              </li>
            </ol>
          </section>
          <section>
            <h4>
              Update the connection state
            </h4>
            <p>
              An {{RTCPeerConnection}} object has an aggregated [= connection
              state =]. Whenever the state of an {{RTCDtlsTransport}} changes
              or when the {{RTCPeerConnection/[[IsClosed]]}} slot turns <code>true</code>,
              the user agent MUST update the connection state by queueing a
              task that runs the following steps:
            </p>
            <ol data-tests="RTCPeerConnection-connectionState.https.html">
              <li class="no-test-needed">
                <p>
                  Let <var>connection</var> be this {{RTCPeerConnection}}
                  object.
                </p>
              </li>
              <li>
                <p>
                  Let <var>newState</var> be the value of deriving a new state
                  value as described by the {{RTCPeerConnectionState}} enum.
                </p>
              </li>
              <li>
                <p>
                  If <var>connection</var>'s [= connection state =] is equal to
                  <var>newState</var>, abort these steps.
                </p>
              </li>
              <li>
                <p>
                  Let <var>connection</var>'s [= connection state =] be
                  <var>newState</var>.
                </p>
              </li>
              <li>
                <p>
                  [= Fire an event =] named {{RTCPeerConnection/connectionstatechange}} at
                  <var>connection</var>.
                </p>
              </li>
            </ol>
          </section>
          <section>
            <h4>
              Update the ICE gathering state
            </h4>
            <p>
              To <dfn id="update-ice-gathering-state">update the [= ICE
              gathering state =]</dfn> of an {{RTCPeerConnection}} instance
              <var>connection</var>, the user agent MUST queue a task that runs
              the following steps:
            </p>
            <ol>
              <li>
                <p>
                  If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                  <code>true</code>, abort these steps.
                </p>
              </li>
              <li>
                <p>
                  Let <var>newState</var> be the value of deriving a new state
                  value as described by the {{RTCIceGatheringState}} enum.
                </p>
              </li>
              <li>
                <p>
                  If <var>connection</var>'s [= ICE gathering state =] is equal
                  to <var>newState</var>, abort these steps.
                </p>
              </li>
              <li>
                <p>
                  Set <var>connection</var>'s [= ICE gathering state =] to
                  <var>newState</var>.
                </p>
              </li>
              <li data-tests="protocol/candidate-exchange.https.html">
                <p>
                  [= Fire an event =] named {{RTCPeerConnection/icegatheringstatechange}} at
                  <var>connection</var>.
                </p>
              </li>
              <li data-tests="RTCPeerConnection-iceGatheringState.html">
                <p>
                  If <var>newState</var> is
                  {{RTCIceGatheringState/"complete"}}, [= fire an event =]
                  named {{RTCPeerConnection/icecandidate}} using the
                  {{RTCPeerConnectionIceEvent}} interface with the candidate
                  attribute set to <code>null</code> at <var>connection</var>.
                </p>
                <div class="note">
                  The null candidate event is fired to ensure legacy
                  compatibility. New code should monitor the gathering state of
                  {{RTCIceTransport}} and/or {{RTCPeerConnection}}.
                </div>
              </li>
            </ol>
          </section>
          <section>
            <h4>
              Set the session description
            </h4>
            <p>
              To <dfn id="set-local-description" data-lt=
              "set local session description|setting the local session description">
              set a local session description</dfn> <var>description</var> on
              an {{RTCPeerConnection}} object <var>connection</var>, [=
              set a session description | set the session description =]
              <var>description</var> on <var>connection</var> with the additional
              value <code>false</code>.
            </p>
            <p>
              To <dfn id="set-remote-description" data-lt=
              "set remote session description|setting the remote session description">
              set a remote session description</dfn> <var>description</var>
              on an {{RTCPeerConnection}} object <var>connection</var>, [=
              set a session description | set the session description =]
              <var>description</var> on <var>connection</var> with the additional
              value <code>true</code>.
            </p>
            <p>
              To <dfn id="set-description" data-lt=
              "set the session description|setting a session description">set
              a session description</dfn> <var>description</var> on an
              {{RTCPeerConnection}} object <var>connection</var>, given a
              <var>remote</var> boolean, run the following steps:
            </p>
            <ol>
              <li class="no-test-needed">
                <p>
                  Let <var>p</var> be a new promise.
                </p>
              </li>
              <li data-tests=
              "RTCPeerConnection-setLocalDescription-rollback.html,RTCPeerConnection-setRemoteDescription-rollback.html">
                <p>
                  If <var>description</var>.{{RTCSessionDescriptionInit/type}} is
                  {{RTCSdpType/"rollback"}} and <var>connection</var>'s [=
                  signaling state =] is either {{RTCSignalingState/"stable"}},
                  {{RTCSignalingState/"have-local-pranswer"}}, or
                  {{RTCSignalingState/"have-remote-pranswer"}}, then [= reject
                  =] <var>p</var> with a newly [= exception/created =]
                  {{InvalidStateError}} and abort these steps.
                </p>
              </li>
              <li>
                <p>
                  Let <var>jsepSetOfTransceivers</var> be a shallow copy of
                  <var>connection</var>'s [= set of transceivers =].
                </p>
              </li>
              <li>
                <p data-tests="">
                  In parallel, start the process to apply
                  <var>description</var> as described in <span data-jsep=
                  "processing-a-local-desc processing-a-remote-desc">[[!RFC8829]]</span>,
                  with these additional restrictions:
                </p>
                <ol>
                  <li>
                    <p>
                      Use <var>jsepSetOfTransceivers</var> as the source of
                      truth with regard to what "RtpTransceivers" exist, and
                      their {{RTCRtpTransceiver/[[JsepMid]]}} internal slot as their "mid
                      property".
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>remote</var> is <code>true</code>, validate
                      back-to-back offers as if answers were applied in
                      between, by running the check for subsequent offers as if
                      it were in stable state.
                    </p>
                  </li>
                  <li>
                    <p>
                      If applying <var>description</var> leads to modifying a
                      transceiver <var>transceiver</var>, and
                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SendEncodings]]}}
                      is non-empty, and not equal to the encodings that would
                      result from processing <var>description</var>, the
                      process of applying <var>description</var> fails. This
                      specification does not allow remotely initiated RID
                      renegotiation.
                    </p>
                  </li>
                  <li>
                    <p>
                      If the process to apply <var>description</var> fails for
                      any reason, then the user agent MUST queue a task that
                      runs the following steps:
                    </p>
                    <ol>
                      <li>
                        <p>
                          If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                          <code>true</code>, then abort these steps.
                        </p>
                      </li>
                      <li data-tests=
                      "RTCPeerConnection-setLocalDescription-answer.html,RTCPeerConnection-setLocalDescription-pranswer.html,RTCPeerConnection-setRemoteDescription-answer.html,RTCPeerConnection-setRemoteDescription-offer.html,RTCPeerConnection-setRemoteDescription-pranswer.html">
                        <p>
                          If
                          <var>description</var>.{{RTCSessionDescriptionInit/type}}
                          is invalid for the current [= signaling state =] of
                          <var>connection</var> as described in
                          <span data-jsep="processing-a-local-desc processing-a-remote-desc">
                          [[!RFC8829]]</span>, then [= reject =] <var>p</var> with
                          a newly [= exception/created =] {{InvalidStateError}}
                          and abort these steps.
                        </p>
                      </li>
                      <li data-tests=
                      "RTCPeerConnection-setRemoteDescription-offer.html,RTCPeerConnection-setRemoteDescription.html,protocol/missing-fields.html">
                        <p>
                          If the content of <var>description</var> is not valid
                          SDP syntax, then [= reject =] <var>p</var> with an
                          {{RTCError}} (with {{RTCError/errorDetail}} set to
                          {{RTCErrorDetailType/"sdp-syntax-error"}} and the
                          {{RTCError/sdpLineNumber}} attribute set to the line
                          number in the SDP where the syntax error was
                          detected) and abort these steps.
                        </p>
                      </li>
                      <li data-tests="RTCConfiguration-rtcpMuxPolicy.html">
                        <p>
                          If <var>remote</var> is <code>true</code>, the
                          <var>connection</var>'s {{RTCRtcpMuxPolicy}} is
                          {{RTCRtcpMuxPolicy/require}} and the description does
                          not use RTCP mux, then [= reject =] <var>p</var> with
                          a newly [= exception/created =]
                          {{InvalidAccessError}} and abort these steps.
                        </p>
                      </li>
                      <li>
                        <p>
                          If the description attempted to renegotiate RIDs, as
                          described above, then [= reject =] <var>p</var> with
                          a newly [= exception/created =]
                          {{InvalidAccessError}} and abort these steps.
                        </p>
                      </li>
                      <li>
                        <p>
                          If the content of <var>description</var> is invalid,
                          then [= reject =] <var>p</var> with a newly [=
                          exception/created =] {{InvalidAccessError}} and abort
                          these steps.
                        </p>
                      </li>
                      <li>
                        <p>
                          For all other errors, [= reject =] <var>p</var> with
                          a newly [= exception/created =] {{OperationError}}.
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <p>
                      If <var>description</var> is applied successfully, the
                      user agent MUST queue a task that runs the following
                      steps:
                    </p>
                    <ol>
                      <li>
                        <p>
                          If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                          <code>true</code>, then abort these steps.
                        </p>
                      </li>
                      <li>
                        <p>
                          If <var>remote</var> is <code>true</code> and
                          <var>description</var> is of type
                          {{RTCSdpType/"offer"}}, then if any
                          {{RTCPeerConnection/addTrack()}} methods succeeded
                          during the process to apply <var>description</var>,
                          abort these steps and start the process over as if
                          they had succeeded prior, to include the extra
                          transceiver(s) in the process.
                        </p>
                      </li>
                      <li>
                        <p>
                          If <var>description</var> is of type
                          {{RTCSdpType/"offer"}} and the [= signaling state =]
                          of <var>connection</var> is
                          {{RTCSignalingState/"stable"}} then for each
                          <var>transceiver</var> in <var>connection</var>'s [=
                          set of transceivers =], run the following steps:
                        </p>
                        <ol>
                          <li>
                            <p>
                              Set
                              <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[LastStableStateSenderTransport]]}}
                              to
                              <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SenderTransport]]}}.
                            </p>
                          </li>
                          <li>
                            <p>
                              Set
                              <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[LastStableStateReceiverTransport]]}}
                              to
                              <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[ReceiverTransport]]}}.
                            </p>
                          </li>
                          <li>
                            <p>
                              Set
                              <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[LastStableStateAssociatedRemoteMediaStreams]]}}
                              to
                              <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[AssociatedRemoteMediaStreams]]}}.
                            </p>
                          </li>
                          <li>
                            <p>
                              Set
                              <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[LastStableStateReceiveCodecs]]}}
                              to
                              <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[ReceiveCodecs]]}}.
                            </p>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <p>
                          If <var>remote</var> is <code>false</code>, then run
                          one of the following steps:
                        </p>
                        <ol>
                          <!-- A) transition stable to haveLocalOffer -->
                          <li data-tests=
                          "RTCPeerConnection-setLocalDescription-offer.html,RTCPeerConnection-setLocalDescription.html">
                            <p>
                              If <var>description</var> is of type
                              {{RTCSdpType/"offer"}}, set
                              <var>connection</var>.{{RTCPeerConnection/[[PendingLocalDescription]]}}
                              to a new {{RTCSessionDescription}} object
                              constructed from <var>description</var>, set
                              <var>connection</var>'s [= signaling state =] to
                              {{RTCSignalingState/"have-local-offer"}}, and [=
                              release early candidates =].
                            </p>
                          </li>
                          <!-- C) transition haveRemoteOffer or haveLocalProvAnswer to
                      stable -->
                          <li data-tests=
                          "RTCPeerConnection-setLocalDescription-answer.html">
                            <p>
                              If <var>description</var> is of type
                              {{RTCSdpType/"answer"}}, then this completes an
                              offer answer negotiation. Set
                              <var>connection</var>.{{RTCPeerConnection/[[CurrentLocalDescription]]}}
                              to a new {{RTCSessionDescription}} object
                              constructed from <var>description</var>, and set
                              <var>connection</var>.{{RTCPeerConnection/[[CurrentRemoteDescription]]}}
                              to
                              <var>connection</var>.{{RTCPeerConnection/[[PendingRemoteDescription]]}}.
                              Set both
                              <var>connection</var>.{{RTCPeerConnection/[[PendingRemoteDescription]]}}
                              and
                              <var>connection</var>.{{RTCPeerConnection/[[PendingLocalDescription]]}}
                              to <code>null</code>. Set both
                              <var>connection</var>.{{RTCPeerConnection/[[LastCreatedOffer]]}}
                              and
                              <var>connection</var>.{{RTCPeerConnection/[[LastCreatedAnswer]]}}
                              to <code>""</code>, set <var>connection</var>'s
                              [= signaling state =] to
                              {{RTCSignalingState/"stable"}}, and [= release
                              early candidates =]. Finally, if none of the ICE
                              credentials in
                              <var>connection</var>.{{RTCPeerConnection/[[LocalIceCredentialsToReplace]]}}
                              are present in <var>description</var>, then set
                              <var>connection</var>.{{RTCPeerConnection/[[LocalIceCredentialsToReplace]]}}
                              to an empty set.
                            </p>
                          </li>
                          <!-- G) transition haveRemoteOffer to haveLocalProvAnswer -->
                          <li data-tests=
                          "RTCPeerConnection-setLocalDescription-pranswer.html">
                            <p>
                              If <var>description</var> is of type
                              {{RTCSdpType/"pranswer"}}, then set
                              <var>connection</var>.{{RTCPeerConnection/[[PendingLocalDescription]]}}
                              to a new {{RTCSessionDescription}} object
                              constructed from <var>description</var>, set
                              <var>connection</var>'s [= signaling state =] to
                              {{RTCSignalingState/"have-local-pranswer"}}, and
                              [= release early candidates =].
                            </p>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <p>
                          Otherwise, (if <var>remote</var> is
                          <code>true</code>) run one of the following steps:
                        </p>
                        <ol>
                          <!-- D) transition stable to haveRemoteOffer -->
                          <li data-tests=
                          "RTCPeerConnection-setRemoteDescription-offer.html">
                            <p>
                              If <var>description</var> is of type
                              {{RTCSdpType/"offer"}}, set
                              <var>connection</var>.{{RTCPeerConnection/[[PendingRemoteDescription]]}}
                              attribute to a new {{RTCSessionDescription}}
                              object constructed from <var>description</var>,
                              and set <var>connection</var>'s [= signaling
                              state =] to
                              {{RTCSignalingState/"have-remote-offer"}}.
                            </p>
                          </li>
                          <!-- F) transition haveRemoteOffer or haveLocalProvAnswer to
                      stable -->
                          <li data-tests=
                          "RTCPeerConnection-setRemoteDescription-answer.html">
                            <p>
                              If <var>description</var> is of type
                              {{RTCSdpType/"answer"}}, then this completes an
                              offer answer negotiation. Set
                              <var>connection</var>.{{RTCPeerConnection/[[CurrentRemoteDescription]]}}
                              to a new {{RTCSessionDescription}} object
                              constructed from <var>description</var>, and set
                              <var>connection</var>.{{RTCPeerConnection/[[CurrentLocalDescription]]}}
                              to
                              <var>connection</var>.{{RTCPeerConnection/[[PendingLocalDescription]]}}.
                              Set both
                              <var>connection</var>.{{RTCPeerConnection/[[PendingRemoteDescription]]}}
                              and
                              <var>connection</var>.{{RTCPeerConnection/[[PendingLocalDescription]]}}
                              to <code>null</code>. Set both
                              <var>connection</var>.{{RTCPeerConnection/[[LastCreatedOffer]]}}
                              and
                              <var>connection</var>.{{RTCPeerConnection/[[LastCreatedAnswer]]}}
                              to <code>""</code>, and set
                              <var>connection</var>'s [= signaling state =] to
                              {{RTCSignalingState/"stable"}}. Finally, if none
                              of the ICE credentials in
                              <var>connection</var>.{{RTCPeerConnection/[[LocalIceCredentialsToReplace]]}}
                              are present in the newly set
                              <var>connection</var>.{{RTCPeerConnection/[[CurrentLocalDescription]]}},
                              then set
                              <var>connection</var>.{{RTCPeerConnection/[[LocalIceCredentialsToReplace]]}}
                              to an empty set.
                            </p>
                          </li>
                          <!-- H) transition haveRemoteOffer to haveLocalProvAnswer -->
                          <li data-tests=
                          "RTCPeerConnection-setRemoteDescription-pranswer.html">
                            <p>
                              If <var>description</var> is of type
                              {{RTCSdpType/"pranswer"}}, then set
                              <var>connection</var>.{{RTCPeerConnection/[[PendingRemoteDescription]]}}
                              to a new {{RTCSessionDescription}} object
                              constructed from <var>description</var> and set
                              <var>connection</var>'s [= signaling state =] to
                              {{RTCSignalingState/"have-remote-pranswer"}}.
                            </p>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <p>
                          If <var>description</var> is of type
                          {{RTCSdpType/"answer"}}, and it initiates the closure
                          of an existing SCTP association, as defined in
                          [[RFC8841]], Sections 10.3 and 10.4, set the value
                          of <var>connection</var>.{{RTCPeerConnection/[[SctpTransport]]}} to
                          <code>null</code>.
                        </p>
                      </li>
                      <li>
                        <p>
                          Let <var>trackEventInits</var>,
                          <var>muteTracks</var>, <var>addList</var>,
                          <var>removeList</var> and <var>errorList</var> be
                          empty lists.
                        </p>
                      </li>
                      <li>
                        <p>
                          If <var>description</var> is of type
                          {{RTCSdpType/"answer"}} or {{RTCSdpType/"pranswer"}},
                          then run the following steps:
                        </p>
                        <ol>
                          <li data-tests=
                          "RTCPeerConnection-createDataChannel.html,RTCSctpTransport-constructor.html">
                            <p>
                              If <var>description</var> initiates the
                              establishment of a new SCTP association, as
                              defined in [[RFC8841]], Sections 10.3 and 10.4,
                              [= create an RTCSctpTransport =] with an initial
                              state of {{RTCSctpTransportState/"connecting"}}
                              and assign the result to the
                              {{RTCPeerConnection/[[SctpTransport]]}} slot. Otherwise, if an
                              SCTP association is established, but the
                              <code class="sdp">max-message-size</code> SDP
                              attribute is updated, [= update the data max
                              message size =] of
                              <var>connection</var>.{{RTCPeerConnection/[[SctpTransport]]}}.
                            </p>
                          </li>
                          <li>
                            <p data-tests=
                            "RTCPeerConnection-createDataChannel.html">
                              If <var>description</var> negotiates the DTLS
                              role of the SCTP transport, then for each
                              {{RTCDataChannel}}, <var>channel</var>, with a
                              <code>null</code> {{RTCDataChannel/id}}, run the
                              following step:
                            </p>
                            <ol>
                              <li>Give <var>channel</var> a new ID generated
                              according to [[RFC8832]]. If no
                              available ID could be generated, set
                              <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} to
                              {{RTCDataChannelState/"closed"}}, and add
                              <var>channnel</var> to <var>errorList</var>.
                              </li>
                            </ol>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <p>
                          If <var>description</var> is not of type
                          {{RTCSdpType/"rollback"}}, then run the following
                          steps:
                        </p>
                        <ol>
                          <li>
                            <p>
                              If <var>remote</var> is <code>false</code>, then
                              run the following steps for each [= media
                              description =] in <var>description</var>:
                            </p>
                            <ol>
                              <li>
                                <p>
                                  If the [= media description =] was not yet [=
                                  associated =] with an {{RTCRtpTransceiver}}
                                  object then run the following steps:
                                </p>
                                <ol>
                                  <li data-tests=
                                  "RTCPeerConnection-setDescription-transceiver.html,RTCPeerConnection-transceivers.https.html">
                                    <p>
                                      Let <var>transceiver</var> be the
                                      {{RTCRtpTransceiver}} used to create the
                                      [= media description =].
                                    </p>
                                  </li>
                                  <li data-tests=
                                  "RTCPeerConnection-setDescription-transceiver.html,RTCPeerConnection-transceivers.https.html,RTCRtpTransceiver.https.html">
                                    <p>
                                      Set
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Mid]]}} to
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[JsepMid]]}}.
                                    </p>
                                  </li>
                                  <li data-tests="RTCRtpTransceiver-stop.html">
                                    <p>
                                      If
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopped]]}}
                                      is <code>true</code>, abort these sub
                                      steps.
                                    </p>
                                  </li>
                                  <li data-tests=
                                  "RTCRtpSender-transport.https.html">
                                    <p>
                                      If the [= media description =] is
                                      indicated as using an existing [= media
                                      transport =] according to [[RFC8843]],
                                      let <var>transport</var> be the
                                      {{RTCDtlsTransport}} object representing
                                      the RTP/RTCP component of that transport.
                                    </p>
                                  </li>
                                  <li data-tests=
                                  "RTCRtpSender-transport.https.html">
                                    <p>
                                      Otherwise, let <var>transport</var> be a
                                      newly created {{RTCDtlsTransport}} object
                                      with a new underlying
                                      {{RTCIceTransport}}.
                                    </p>
                                  </li>
                                  <li data-tests=
                                  "RTCRtpSender-transport.https.html">
                                    <p>
                                      Set
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SenderTransport]]}}
                                      to <var>transport</var>.
                                    </p>
                                  </li>
                                  <li>
                                    <p>
                                      Set
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[ReceiverTransport]]}}
                                      to <var>transport</var>.
                                    </p>
                                  </li>
                                </ol>
                              </li>
                              <li>
                                <p>
                                  Let <var>transceiver</var> be the
                                  {{RTCRtpTransceiver}} [= associated =] with
                                  the [= media description =].
                                </p>
                              </li>
                              <li data-tests="RTCRtpTransceiver.https.html">
                                <p>
                                  If <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopped]]}}
                                  is <code>true</code>, abort these sub steps.
                                </p>
                              </li>
                              <li>
                                <p>
                                  Let <var>direction</var> be an
                                  {{RTCRtpTransceiverDirection}} value
                                  representing the direction from the [= media
                                  description =].
                                </p>
                              </li>
                              <li>
                                <p>
                                  If <var>direction</var> is
                                  {{RTCRtpTransceiverDirection/"sendrecv"}} or
                                  {{RTCRtpTransceiverDirection/"recvonly"}},
                                  set
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Receptive]]}}
                                  to <code>true</code>, otherwise set it to
                                  <code>false</code>.
                                </p>
                              </li>
                              <li>
                                <p>
                                  Set
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[ReceiveCodecs]]}}
                                  to the codecs that <var>description</var>
                                  negotiates for receiving and which the user
                                  agent is currently prepared to receive.
                                </p>
                                <p class='note'>
                                  If the <var>direction</var> is
                                  {{RTCRtpTransceiverDirection/"sendonly"}} or
                                  {{RTCRtpTransceiverDirection/"inactive"}},
                                  the receiver is not prepared to receive
                                  anything, and the list will be empty.
                                </p>
                              </li>
                              <li>
                                <p>
                                  If <var>description</var> is of type
                                  {{RTCSdpType/"answer"}} or
                                  {{RTCSdpType/"pranswer"}}, then run the
                                  following steps:
                                </p>
                                <ol>
                                  <li>
                                    <p>
                                      Set
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SendCodecs]]}}
                                      to the codecs that <var>description</var>
                                      negotiates for sending and which the user
                                      agent is currently capable of sending,
                                      and set
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[LastReturnedParameters]]}}
                                      to <code>null</code>.
                                    </p>
                                  </li>
                                  <li>
                                    <p>
                                      If <var>direction</var> is
                                      {{RTCRtpTransceiverDirection/"sendonly"}}
                                      or
                                      {{RTCRtpTransceiverDirection/"inactive"}},
                                      and
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[FiredDirection]]}}
                                      is either
                                      {{RTCRtpTransceiverDirection/"sendrecv"}}
                                      or
                                      {{RTCRtpTransceiverDirection/"recvonly"}},
                                      then run the following steps:
                                    </p>
                                    <ol>
                                      <li>
                                        <p>
                                          [= Set the associated remote streams
                                          =] given
                                          <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}},
                                          an empty list, another empty list,
                                          and <var>removeList</var>.
                                        </p>
                                      </li>
                                      <li data-tests=
                                      "RTCRtpTransceiver.https.html">
                                        <p>
                                          [= process the removal of a remote
                                          track =] for the [= media description
                                          =], given <var>transceiver</var> and
                                          <var>muteTracks</var>.
                                        </p>
                                      </li>
                                    </ol>
                                  </li>
                                  <li data-tests=
                                  "RTCPeerConnection-transceivers.https.html">
                                    <p>
                                      Set
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[CurrentDirection]]}}
                                      and
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[FiredDirection]]}}
                                      to <var>direction</var>.
                                    </p>
                                  </li>
                                </ol>
                              </li>
                            </ol>
                          </li>
                          <li>
                            <p>
                              Otherwise, (if <var>remote</var> is
                              <code>true</code>) run the following steps for
                              each [= media description =] in
                              <var>description</var>:
                            </p>
                            <ol>
                              <li>
                                <p>
                                  If the <var>description</var> is of type
                                  {{RTCSdpType/"offer"}} and contains a request
                                  to receive simulcast, use the order of the
                                  rid values specified in the simulcast
                                  attribute to create an
                                  {{RTCRtpEncodingParameters}} dictionary for
                                  each of the simulcast layers, populating the
                                  {{RTCRtpCodingParameters/rid}} member
                                  according to the corresponding rid value, and
                                  let <var>sendEncodings</var> be the list
                                  containing the created dictionaries.
                                  Otherwise, let <var>sendEncodings</var> be an
                                  empty list.
                                </p>
                              </li>
                              <li>Let <var>supportedEncodings</var> be the
                              maximum number of encodings that the
                              implementation can support. If the length of
                              <var>sendEncodings</var> is greater than
                              <var>supportedEncodings</var>, truncate
                              <var>sendEncodings</var> so that its length is
                              <var>supportedEncodings</var>.
                              </li>
                              <li>If <var>sendEncodings</var> is non-empty, set
                              each encoding's
                              {{RTCRtpEncodingParameters/scaleResolutionDownBy}}
                              to <code>2^(length of <var>sendEncodings</var> -
                              encoding index - 1)</code>.
                              </li>
                              <li>
                                <p>
                                  As described by <span data-jsep=
                                  "applying-a-remote-desc">[[!RFC8829]]</span>,
                                  attempt to find an existing
                                  {{RTCRtpTransceiver}} object,
                                  <var>transceiver</var>, to represent the [=
                                  media description =].
                                </p>
                              </li>
                              <li>
                                <p>
                                  If a suitable transceiver was found
                                  (<var>transceiver</var> is set) and
                                  <var>sendEncodings</var> is non-empty, set
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SendEncodings]]}}
                                  to <var>sendEncodings</var>, and set
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[LastReturnedParameters]]}}
                                  to <code>null</code>.
                                </p>
                              </li>
                              <li>
                                <p>
                                  If no suitable transceiver was found
                                  (<var>transceiver</var> is unset), run the
                                  following steps:
                                </p>
                                <ol>
                                  <li data-tests=
                                  "RTCPeerConnection-setDescription-transceiver.html,RTCPeerConnection-transceivers.https.html,RTCRtpParameters-encodings.html">
                                    <p>
                                      [= Create an RTCRtpSender =],
                                      <var>sender</var>, from the [= media
                                      description =] using
                                      <var>sendEncodings</var>.
                                    </p>
                                  </li>
                                  <li data-tests=
                                  "RTCPeerConnection-setDescription-transceiver.html,RTCPeerConnection-transceivers.https.html">
                                    <p>
                                      [= Create an RTCRtpReceiver =],
                                      <var>receiver</var>, from the [= media
                                      description =].
                                    </p>
                                  </li>
                                  <li data-tests=
                                  "RTCPeerConnection-setDescription-transceiver.html,RTCPeerConnection-transceivers.https.html">
                                    <p>
                                      [= Create an RTCRtpTransceiver =] with
                                      <var>sender</var>, <var>receiver</var>
                                      and an {{RTCRtpTransceiverDirection}}
                                      value of
                                      {{RTCRtpTransceiverDirection/"recvonly"}},
                                      and let <var>transceiver</var> be the
                                      result.
                                    </p>
                                  </li>
                                  <li data-tests=
                                  "RTCPeerConnection-setDescription-transceiver.html">
                                    <p>
                                      Add <var>transceiver</var> to the
                                      <var>connection</var>'s [= set of
                                      transceivers =].
                                    </p>
                                  </li>
                                </ol>
                              </li>
                              <li>
                                <p>
                                  If <var>description</var> is of type
                                  {{RTCSdpType/"answer"}} or
                                  {{RTCSdpType/"pranswer"}}, and
                                  <var>transceiver</var>.
                                  {{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SendEncodings]]}}
                                  .length is greater than <code>1</code>, then
                                  run the following steps:
                                </p>
                                <ol>
                                  <li>
                                    <p>
                                      If <var>description</var> indicates that
                                      simulcast is not supported or desired,
                                      then remove all dictionaries in
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SendEncodings]]}}
                                      except the first one and abort these sub
                                      steps.
                                    </p>
                                  </li>
                                  <li>
                                    <p>
                                      If <var>description</var> rejects any of
                                      the offered layers, then remove the
                                      dictionaries that correspond to rejected
                                      layers from
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SendEncodings]]}}.
                                    </p>
                                  </li>
                                  <li>
                                    <p>
                                      Update the paused status as indicated by
                                      [[RFC8853]] of each simulcast
                                      layer by setting the
                                      {{RTCRtpEncodingParameters/active}}
                                      member on the corresponding dictionaries
                                      in
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SendEncodings]]}}
                                      to <code>true</code> for unpaused or to
                                      <code>false</code> for paused.
                                    </p>
                                  </li>
                                </ol>
                              </li>
                              <li data-tests=
                              "RTCPeerConnection-setDescription-transceiver.html,RTCRtpTransceiver.https.html">
                                <p>
                                  Set <var>transceiver</var>.{{RTCRtpTransceiver/[[Mid]]}} to
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[JsepMid]]}}.
                                </p>
                              </li>
                              <li>
                                <p>
                                  Let <var>direction</var> be an
                                  {{RTCRtpTransceiverDirection}} value
                                  representing the direction from the [= media
                                  description =], but with the send and receive
                                  directions reversed to represent this peer's
                                  point of view. If the [= media description =]
                                  is rejected, set <var>direction</var> to
                                  {{RTCRtpTransceiverDirection/"inactive"}}.
                                </p>
                              </li>
                              <li data-tests=
                              "RTCPeerConnection-ontrack.https.html,RTCTrackEvent-fire.html">
                                <p>
                                  If <var>direction</var> is
                                  {{RTCRtpTransceiverDirection/"sendrecv"}} or
                                  {{RTCRtpTransceiverDirection/"recvonly"}},
                                  let <var>msids</var> be a list of the MSIDs
                                  that the media description indicates
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[ReceiverTrack]]}}
                                  is to be associated with. Otherwise, let
                                  <var>msids</var> be an empty list.
                                </p>
                                <div class="note">
                                  <var>msids</var> will be an empty list here
                                  if [= media description =] is rejected.
                                </div>
                              </li>
                              <li data-tests=
                              "RTCPeerConnection-ontrack.https.html,RTCPeerConnection-setRemoteDescription-tracks.https.html,RTCTrackEvent-fire.html">
                                <p>
                                  [= Process remote tracks =] with
                                  <var>transceiver</var>, <var>direction</var>,
                                  <var>msids</var>, <var>addList</var>,
                                  <var>removeList</var>, and
                                  <var>trackEventInits</var>.
                                </p>
                              </li>
                              <li>
                                <p>
                                  Set
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[ReceiveCodecs]]}}
                                  to the codecs that <var>description</var>
                                  negotiates for receiving and which the user
                                  agent is currently prepared to receive.
                                </p>
                              </li>
                              <li>
                                <p>
                                  If <var>description</var> is of type
                                  {{RTCSdpType/"answer"}} or
                                  {{RTCSdpType/"pranswer"}}, then run the
                                  following steps:
                                </p>
                                <ol>
                                  <li>
                                    <p>
                                      Set
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SendCodecs]]}}
                                      to the codecs that <var>description</var>
                                      negotiates for sending and which the user
                                      agent is currently capable of sending.
                                    </p>
                                  </li>
                                  <li>
                                    <p>
                                      Set
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[CurrentDirection]]}}
                                      and
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}}s
                                      to <var>direction</var>.
                                    </p>
                                  </li>
                                  <li>
                                    <p>
                                      Let <var>transport</var> be the
                                      {{RTCDtlsTransport}} object representing
                                      the RTP/RTCP component of the [= media
                                      transport =] used by
                                      <var>transceiver</var>'s [= associated =]
                                      [= media description =], according to
                                      [[RFC8843]].
                                    </p>
                                  </li>
                                  <li>
                                    <p>
                                      Set
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SenderTransport]]}}
                                      to <var>transport</var>.
                                    </p>
                                  </li>
                                  <li>
                                    <p>
                                      Set
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[ReceiverTransport]]}}
                                      to <var>transport</var>.
                                    </p>
                                  </li>
                                  <li>
                                    <p>
                                      Set the {{RTCIceTransport/[[IceRole]]}} of
                                      <var>transport</var> according to the
                                      rules of [[RFC8445]].
                                    </p>
                                    <div class='note'>
                                      The rules of [[RFC8445]] that apply here
                                      are:
                                      <ul>
                                        <li>If {{RTCIceTransport/[[IceRole]]}} is not
                                        {{RTCIceRole/unknown}}, do not modify
                                        {{RTCIceTransport/[[IceRole]]}}.
                                        </li>
                                        <li>If <var>description</var> is a
                                        local offer, set it to
                                        {{RTCIceRole/controlling}}.
                                        </li>
                                        <li>If <var>description</var> is a
                                        remote offer, and contains
                                          <code class="sdp">a=ice-lite</code>,
                                          set {{RTCIceTransport/[[IceRole]]}} to
                                          {{RTCIceRole/controlling}}.
                                        </li>
                                        <li>If <var>description</var> is a
                                        remote offer, and does not contain
                                        <code class="sdp">a=ice-lite</code>,
                                        set {{RTCIceTransport/[[IceRole]]}} to
                                        {{RTCIceRole/controlled}}.
                                        </li>
                                      </ul>This ensures that
                                      {{RTCIceTransport/[[IceRole]]}} always has a value
                                      after the first offer is processed.
                                    </div>
                                  </li>
                                </ol>
                              </li>
                              <li>
                                <p>
                                  If the [= media description =] is rejected,
                                  and
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopped]]}} is
                                  <code>false</code>, then [= stop the
                                  RTCRtpTransceiver =] <var>transceiver</var>.
                                </p>
                              </li>
                            </ol>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <p>
                          Otherwise, (if <var>description</var> is of type
                          {{RTCSdpType/"rollback"}}) run the following steps:
                        </p>
                        <ol>
                          <li>
                            <p>
                              Let <var>pendingDescription</var> be either
                              <var>connection</var>.{{RTCPeerConnection/[[PendingLocalDescription]]}}
                              or
                              <var>connection</var>.{{RTCPeerConnection/[[PendingRemoteDescription]]}},
                              whichever one is not <code>null</code>.
                            </p>
                          </li>
                          <li>
                            <p>
                              For each <var>transceiver</var> in the
                              <var>connection</var>'s [= set of transceivers =]
                              run the following steps:
                            </p>
                            <ol>
                              <li>
                                <p>
                                  If <var>transceiver</var> was not [=
                                  associated =] with a [= media description =]
                                  prior to <var>pendingDescription</var> being set,
                                  disassociate it and set both
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[JsepMid]]}}
                                  and <var>transceiver</var>.{{RTCRtpTransceiver/[[Mid]]}} to
                                  <code>null</code>.
                                </p>
                              </li>
                              <li>
                                <p>
                                  Set
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SenderTransport]]}}
                                  to
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[LastStableStateSenderTransport]]}}.
                                </p>
                              </li>
                              <li>
                                <p>
                                  Set
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[ReceiverTransport]]}}
                                  to
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[LastStableStateReceiverTransport]]}}.
                                </p>
                              </li>
                              <li>
                                <p>
                                  Set
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[ReceiveCodecs]]}}
                                  to
                                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[LastStableStateReceiveCodecs]]}}.
                                </p>
                              </li>
                              <li>
                                <p>
                                  If the <a>signaling state</a> of
                                  <var>connection</var> is
                                  {{RTCSignalingState/"have-remote-offer"}},
                                  run the following sub steps:
                                </p>
                                <ol>
                                  <li>
                                    <p>
                                      Let <var>msids</var> be a list of the
                                      <code class="gum">id</code>s of all
                                      {{MediaStream}} objects in
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[LastStableStateAssociatedRemoteMediaStreams]]}},
                                      or an empty list if there are none.
                                    </p>
                                  </li>
                                  <li data-tests=
                                  "RTCPeerConnection-ontrack.https.html,RTCPeerConnection-setRemoteDescription-tracks.https.html,RTCTrackEvent-fire.html">
                                    <p>
                                      <a>Process remote tracks</a> with
                                      <var>transceiver</var>,
                                      <var>transceiver</var>.{{RTCRtpTransceiver/[[CurrentDirection]]}},
                                      <var>msids</var>, <var>addList</var>,
                                      <var>removeList</var>, and
                                      <var>trackEventInits</var>.
                                    </p>
                                  </li>
                                </ol>
                              </li>
                              <li data-tests=
                              "RTCPeerConnection-setDescription-transceiver.html">
                                <p>
                                  If <var>transceiver</var> was created when
                                  <var>pendingDescription</var> was set, and a
                                  track has never been attached to it via
                                  {{RTCPeerConnection/addTrack()}}, then [=
                                  stop the RTCRtpTransceiver =]
                                  <var>transceiver</var>, and remove it from
                                  <var>connection</var>'s [= set of
                                  transceivers =].
                                </p>
                              </li>
                            </ol>
                          </li>
                          <li>
                            <p>
                              Set
                              <var>connection</var>.{{RTCPeerConnection/[[PendingLocalDescription]]}}
                              and
                              <var>connection</var>.{{RTCPeerConnection/[[PendingRemoteDescription]]}}
                              to <code>null</code>, and set
                              <var>connection</var>'s [= signaling state =] to
                              {{RTCSignalingState/"stable"}}.
                            </p>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <p>
                          If <var>description</var> is of type
                          {{RTCSdpType/"answer"}}, then run the following
                          steps:
                        </p>
                        <ol>
                          <li>
                            <p>
                              For each <var>transceiver</var> in the
                              <var>connection</var>'s [= set of transceivers =]
                              run the following steps:
                            </p>
                            <ol>
                              <li>
                                <p>
                                  If <var>transceiver</var> is
                                  {{RTCRtpTransceiver/stopped}}, [= associated
                                  =] with an m= section and the associated m=
                                  section is rejected in
                                  <var>connection</var>.{{RTCPeerConnection/[[CurrentLocalDescription]]}}
                                  or
                                  <var>connection</var>.{{RTCPeerConnection/[[CurrentRemoteDescription]]}},
                                  remove the <var>transceiver</var> from the
                                  <var>connection</var>'s [= set of
                                  transceivers =].
                                </p>
                              </li>
                            </ol>
                          </li>
                        </ol>
                      </li>
                      <li data-tests=
                      "RTCPeerConnection-onnegotiationneeded.html">
                        <p>
                          If <var>connection</var>'s [= signaling state =] is
                          now {{RTCSignalingState/"stable"}}, run the following
                          steps:
                        </p>
                        <ol>
                          <li>
                            <p class="needs-test">
                              For any <var>transceiver</var> that was removed
                              from the [= set of transceivers =] in a previous
                              step, if any of its transports
                              (<var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.{{RTCRtpSender/[[SenderTransport]]}}
                              or
                              <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.{{RTCRtpReceiver/[[ReceiverTransport]]}})
                              are still not closed and they're no longer
                              referenced by a non-stopped transceiver, close
                              the {{RTCDtlsTransport}}s and their associated
                              {{RTCIceTransport}}s. This results in events
                              firing on these objects in a queued task.
                            </p>
                          </li>
                          <li data-tests=
                          "RTCPeerConnection-onnegotiationneeded.html">
                            <p>
                              [= Clear the negotiation-needed flag =] and [=
                              update the negotiation-needed flag =].
                            </p>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <p>
                          If <var>connection</var>'s [= signaling state =]
                          changed above, [= fire an event =] named
                          {{RTCPeerConnection/signalingstatechange}} at <var>connection</var>.
                        </p>
                      </li>
                      <li>
                        <p>
                          For each <var>channel</var> in <var>errorList</var>,
                          [= fire an event =] named {{RTCDataChannel/error}}
                          using the {{RTCErrorEvent}} interface with the
                          {{RTCError/errorDetail}} attribute set to
                          {{RTCErrorDetailType/"data-channel-failure"}} at
                          <var>channel</var>.
                        </p>
                      </li>
                      <li id="remote-mute" data-tests=
                      "RTCPeerConnection-remote-track-mute.https.html">
                        <p>
                          For each <var>track</var> in <var>muteTracks</var>,
                          [= set the muted state =] of <var>track</var> to the
                          value <code>true</code>.
                        </p>
                      </li>
                      <li data-tests=
                      "RTCPeerConnection-setRemoteDescription-tracks.https.html">
                        <p>
                          For each <var>stream</var> and <var>track</var> pair
                          in <var>removeList</var>, [= remove the track =]
                          <var>track</var> from <var>stream</var>.
                        </p>
                      </li>
                      <li>
                        <p>
                          For each <var>stream</var> and <var>track</var> pair
                          in <var>addList</var>, [= add the track =]
                          <var>track</var> to <var>stream</var>.
                        </p>
                      </li>
                      <li data-tests=
                      "RTCPeerConnection-ontrack.https.html,RTCPeerConnection-setRemoteDescription-tracks.https.html,RTCTrackEvent-fire.html">
                        <p>
                          For each entry <var>entry</var> in
                          <var>trackEventInits</var>, [= fire an event =] named
                          {{RTCPeerConnection/track}} using the {{RTCTrackEvent}} interface with
                          its {{RTCTrackEvent/receiver}} attribute initialized
                          to <var>entry</var>.{{RTCTrackEventInit/receiver}},
                          its {{RTCTrackEvent/track}} attribute initialized to
                          <var>entry</var>.{{RTCTrackEventInit/track}}, its
                          {{RTCTrackEvent/streams}} attribute initialized to
                          <var>entry</var>.{{RTCTrackEventInit/streams}} and
                          its {{RTCTrackEvent/transceiver}} attribute
                          initialized to
                          <var>entry</var>.{{RTCTrackEventInit/transceiver}} at
                          the <var>connection</var> object.
                        </p>
                      </li>
                      <li data-tests=
                      "RTCPeerConnection-setLocalDescription.html">
                        <p>
                          [= Resolve =] <var>p</var> with
                          <code>undefined</code>.
                        </p>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li class="no-test-needed">
                <p>
                  Return <var>p</var>.
                </p>
              </li>
            </ol>
          </section>
          <section>
            <h4>
              Set the configuration
            </h4>
            <p>
              To <dfn data-lt="set the configuration" id=
              "set-pc-configuration">set a configuration</dfn>, run the
              following steps:
            </p>
            <ol>
              <li class="no-test-needed">
                <p>
                  Let <var>configuration</var> be the {{RTCConfiguration}}
                  dictionary to be processed.
                </p>
              </li>
              <li class="no-test-needed">
                <p>
                  Let <var>connection</var> be the target {{RTCPeerConnection}}
                  object.
                </p>
              </li>
              <li data-tests="RTCCertificate.html">
                <p id="setconfig-certificate">
                  If <var>configuration</var>.{{RTCConfiguration/certificates}}
                  is set, run the following steps:
                </p>
                <ol>
                  <li>
                    <p>
                      If the length of
                      <var>configuration</var>.{{RTCConfiguration/certificates}}
                      is different from the length of
                      <var>connection</var>.{{RTCPeerConnection/[[Configuration]]}}.{{RTCConfiguration/certificates}},
                      [= exception/throw =] an {{InvalidModificationError}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      Let <var>index</var> be initialized to 0.
                    </p>
                  </li>
                  <li>
                    <p>
                      Let <var>size</var> be initialized to the length of
                      <var>configuration</var>.{{RTCConfiguration/certificates}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      While <var>index</var> is less than <var>size</var>, run
                      the following steps:
                    </p>
                    <ol>
                      <li>
                        <p>
                          If the ECMAScript object represented by the value of
                          <var>configuration</var>.{{RTCConfiguration/certificates}}
                          at <var>index</var> is not the same as the ECMAScript
                          object represented by the value of
                          <var>connection</var>.{{RTCPeerConnection/[[Configuration]]}}.{{RTCConfiguration/certificates}}
                          at <var>index</var>, [= exception/throw =] an
                          {{InvalidModificationError}}.
                        </p>
                      </li>
                      <li>
                        <p>
                          Increment <var>index</var> by 1.
                        </p>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>
                <p id="config-bundle" data-tests=
                "RTCConfiguration-bundlePolicy.html">
                  If the value of
                  <var>configuration</var>.{{RTCConfiguration/bundlePolicy}} is
                  set and its value differs from the <var>connection</var>'s
                  bundle policy, [= exception/throw =] an
                  {{InvalidModificationError}}.
                </p>
              </li>
              <li>
                <p id="config-rtcpmux" data-tests=
                "RTCConfiguration-rtcpMuxPolicy.html">
                  If the value of
                  <var>configuration</var>.{{RTCConfiguration/rtcpMuxPolicy}}
                  is set and its value differs from the <var>connection</var>'s
                  rtcpMux policy, [= exception/throw =] an
                  {{InvalidModificationError}}.
                </p>
              </li>
              <li>
                <p id="config-icepool" data-tests=
                "RTCConfiguration-iceCandidatePoolSize.html">
                  If the value of
                  <var>configuration</var>.{{RTCConfiguration/iceCandidatePoolSize}}
                  is set and its value differs from the <var>connection</var>'s
                  previously set {{RTCConfiguration/iceCandidatePoolSize}}, and
                  {{RTCPeerConnection/setLocalDescription}} has already been
                  called, [= exception/throw =] an
                  {{InvalidModificationError}}.
                </p>
              </li>
              <li data-tests="RTCConfiguration-iceTransportPolicy.html">
                <p id="config-icetransportpolicy">
                  Set the [= ICE Agent =]'s <dfn id=
                  "ice-transports-setting">ICE transports setting</dfn> to the
                  value of
                  <var>configuration</var>.{{RTCConfiguration/iceTransportPolicy}}.
                  As defined in <span data-jsep=
                  "setconfiguration">[[!RFC8829]]</span>, if the new [= ICE
                  transports setting =] changes the existing setting, no action
                  will be taken until the next gathering phase. If a script
                  wants this to happen immediately, it should do an ICE
                  restart.
                </p>
              </li>
              <li data-tests="RTCConfiguration-iceCandidatePoolSize.html">
                <p>
                  Set the [= ICE Agent =]'s prefetched <dfn>ICE candidate pool
                  size</dfn> as defined in <span data-jsep=
                  "ice-candidate-pool pc-constructor">[[!RFC8829]]</span> to the
                  value of
                  <var>configuration</var>.{{RTCConfiguration/iceCandidatePoolSize}}.
                  If the new [= ICE candidate pool size =] changes the existing
                  setting, this may result in immediate gathering of new pooled
                  candidates, or discarding of existing pooled candidates, as
                  defined in <span data-jsep=
                  "setconfiguration">[[!RFC8829]]</span>.
                </p>
              </li>
              <li>
                <p>
                  Let <var>validatedServers</var> be an empty list.
                </p>
              </li>
              <li data-tests="RTCConfiguration-iceServers.html">
                <p id="config-iceservers">
                  If <var>configuration</var>.{{RTCConfiguration/iceServers}}
                  is defined, then run the following steps for each element:
                </p>
                <ol>
                  <li>
                    <p>
                      Let <var>server</var> be the current list element.
                    </p>
                  </li>
                  <li>
                    <p>
                      Let <var>urls</var> be
                      <var>server</var>.{{RTCIceServer/urls}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>urls</var> is a string, set <var>urls</var> to a
                      list consisting of just that string.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>urls</var> is empty, [= exception/throw =] a
                      {{SyntaxError}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      For each <var>url</var> in <var>urls</var> run the
                      following steps:
                    </p>
                    <ol>
                      <li>
                        <p>
                          Parse the <var>url</var> using the generic URI syntax
                          defined in [[!RFC3986]] and obtain the <var>scheme
                          name</var>. If the parsing based on the syntax
                          defined in [[!RFC3986]] fails, [= exception/throw =]
                          a {{SyntaxError}}. If the <var>scheme name</var> is
                          not implemented by the browser [= exception/throw =]
                          a {{NotSupportedError}}. If <var>scheme name</var> is
                          <code class="scheme">turn</code> or <code class=
                          "scheme">turns</code>, and parsing the <var>url</var>
                          using the syntax defined in [[!RFC7065]] fails, [=
                          exception/throw =] a {{SyntaxError}}. If <var>scheme
                          name</var> is <code class="scheme">stun</code> or
                          <code class="scheme">stuns</code>, and parsing the
                          <var>url</var> using the syntax defined in
                          [[!RFC7064]] fails, [= exception/throw =] a
                          {{SyntaxError}}.
                        </p>
                      </li>
                      <li>
                        <p>
                          If <var>scheme name</var> is <code class=
                          "scheme">turn</code> or <code class=
                          "scheme">turns</code>, and either of
                          <var>server</var>.{{RTCIceServer/username}} or
                          <var>server</var>.{{RTCIceServer/credential}} are
                          omitted, then [= exception/throw =] an
                          {{InvalidAccessError}}.
                        </p>
                      </li>
                      <li>
                        <p>
                          If <var>scheme name</var> is <code class=
                          "scheme">turn</code> or <code class=
                          "scheme">turns</code>, and
                          <var>server</var>.{{RTCIceServer/credentialType}} is
                          {{RTCIceCredentialType/"password"}}, and
                          <var>server</var>.{{RTCIceServer/credential}} is not
                          a <span class="idlMemberType">DOMString</span>, then
                          [= exception/throw =] an {{InvalidAccessError}}.
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <p>
                      Append <var>server</var> to <var>validatedServers</var>.
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <p>
                  Set the [= ICE Agent =]'s <dfn id="ice-servers-list">ICE
                  servers list</dfn> to <var>validatedServers</var>.
                </p>
                <p>
                  As defined in <span data-jsep=
                  "setconfiguration">[[!RFC8829]]</span>, if a new list of servers
                  replaces the [= ICE Agent =]'s existing ICE servers list, no
                  action will be taken until the next gathering phase. If a
                  script wants this to happen immediately, it should do an ICE
                  restart. However, if the [= ICE candidate pool size | ICE
                  candidate pool =] has a nonzero size, any existing pooled
                  candidates will be discarded, and new candidates will be
                  gathered from the new servers.
                </p>
              </li>
              <li data-tests=
              "RTCConfiguration-iceServers.html,RTCConfiguration-iceCandidatePoolSize.html,RTCConfiguration-bundlePolicy.html,RTCConfiguration-iceTransportPolicy.html,RTCConfiguration-rtcpMuxPolicy.html">
                <p>
                  Store <var>configuration</var> in the
                  {{RTCPeerConnection/[[Configuration]]}} internal slot.
                </p>
              </li>
            </ol>
          </section>
        </section>
        <section>
          <h3>
            Interface Definition
          </h3>
          <p>
            The <dfn>RTCPeerConnection</dfn> interface presented in this
            section is extended by several partial interfaces throughout this
            specification. Notably, the [= RTP Media API =] section, which adds
            the APIs to send and receive {{MediaStreamTrack}} objects.
          </p>
          <div>
            <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCPeerConnection : EventTarget  {
  constructor(optional RTCConfiguration configuration = {});
  Promise&lt;RTCSessionDescriptionInit&gt; createOffer(optional RTCOfferOptions options = {});
  Promise&lt;RTCSessionDescriptionInit&gt; createAnswer(optional RTCAnswerOptions options = {});
  Promise&lt;undefined&gt; setLocalDescription(optional RTCLocalSessionDescriptionInit description = {});
  readonly attribute RTCSessionDescription? localDescription;
  readonly attribute RTCSessionDescription? currentLocalDescription;
  readonly attribute RTCSessionDescription? pendingLocalDescription;
  Promise&lt;undefined&gt; setRemoteDescription(RTCSessionDescriptionInit description);
  readonly attribute RTCSessionDescription? remoteDescription;
  readonly attribute RTCSessionDescription? currentRemoteDescription;
  readonly attribute RTCSessionDescription? pendingRemoteDescription;
  Promise&lt;undefined&gt; addIceCandidate(optional RTCIceCandidateInit candidate = {});
  readonly attribute RTCSignalingState signalingState;
  readonly attribute RTCIceGatheringState iceGatheringState;
  readonly attribute RTCIceConnectionState iceConnectionState;
  readonly attribute RTCPeerConnectionState connectionState;
  readonly attribute boolean? canTrickleIceCandidates;
  undefined restartIce();
  RTCConfiguration getConfiguration();
  undefined setConfiguration(optional RTCConfiguration configuration = {});
  undefined close();
  attribute EventHandler onnegotiationneeded;
  attribute EventHandler onicecandidate;
  attribute EventHandler onicecandidateerror;
  attribute EventHandler onsignalingstatechange;
  attribute EventHandler oniceconnectionstatechange;
  attribute EventHandler onicegatheringstatechange;
  attribute EventHandler onconnectionstatechange;

  // Legacy Interface Extensions
  // Supporting the methods in this section is optional.
  // If these methods are supported
  // they must be implemented as defined
  // in section "Legacy Interface Extensions"
  Promise&lt;undefined&gt; createOffer(RTCSessionDescriptionCallback successCallback,
                            RTCPeerConnectionErrorCallback failureCallback,
                            optional RTCOfferOptions options = {});
  Promise&lt;undefined&gt; setLocalDescription(RTCLocalSessionDescriptionInit description,
                                    VoidFunction successCallback,
                                    RTCPeerConnectionErrorCallback failureCallback);
  Promise&lt;undefined&gt; createAnswer(RTCSessionDescriptionCallback successCallback,
                             RTCPeerConnectionErrorCallback failureCallback);
  Promise&lt;undefined&gt; setRemoteDescription(RTCSessionDescriptionInit description,
                                     VoidFunction successCallback,
                                     RTCPeerConnectionErrorCallback failureCallback);
  Promise&lt;undefined&gt; addIceCandidate(RTCIceCandidateInit candidate,
                                VoidFunction successCallback,
                                RTCPeerConnectionErrorCallback failureCallback);
};</pre>
            <section>
              <h2>
                Attributes
              </h2>
              <dl data-link-for="RTCPeerConnection" data-dfn-for=
              "RTCPeerConnection" class="attributes">
                <dt>
                  <dfn id=
                  "dom-peerconnection-localdescription">localDescription</dfn>
                  of type <span class=
                  "idlAttrType">{{RTCSessionDescription}}</span>, readonly,
                  nullable
                </dt>
                <dd>
                  <p data-tests="RTCPeerConnection-setLocalDescription.html">
                    The {{localDescription}} attribute MUST return
                    {{RTCPeerConnection/[[PendingLocalDescription]]}} if it is not
                    <code>null</code> and otherwise it MUST return
                    {{RTCPeerConnection/[[CurrentLocalDescription]]}}.
                  </p>
                  <p>
                    Note that
                    {{RTCPeerConnection/[[CurrentLocalDescription]]}}.{{RTCSessionDescription/sdp}}
                    and
                    {{RTCPeerConnection/[[PendingLocalDescription]]}}.{{RTCSessionDescription/sdp}}
                    need not be string-wise identical to the
                    {{RTCSessionDescriptionInit/sdp}} value passed to the
                    corresponding {{setLocalDescription}} call (i.e. SDP may be
                    parsed and reformatted, and ICE candidates may be added).
                  </p>
                </dd>
                <dt>
                  <dfn id=
                  "dom-peerconnection-currentlocaldesc">currentLocalDescription</dfn>
                  of type <span class=
                  "idlAttrType">{{RTCSessionDescription}}</span>, readonly,
                  nullable
                </dt>
                <dd>
                  <p data-tests="RTCPeerConnection-setLocalDescription.html">
                    The {{currentLocalDescription}} attribute MUST return
                    {{RTCPeerConnection/[[CurrentLocalDescription]]}}.
                  </p>
                  <p>
                    It represents the local description that was successfully
                    negotiated the last time the {{RTCPeerConnection}}
                    transitioned into the stable state plus any local
                    candidates that have been generated by the [= ICE Agent =]
                    since the offer or answer was created.
                  </p>
                </dd>
                <dt>
                  <dfn id=
                  "dom-peerconnection-pendinglocaldesc">pendingLocalDescription</dfn>
                  of type <span class=
                  "idlAttrType">{{RTCSessionDescription}}</span>, readonly,
                  nullable
                </dt>
                <dd>
                  <p data-tests="RTCPeerConnection-setLocalDescription.html">
                    The {{pendingLocalDescription}} attribute MUST return
                    {{RTCPeerConnection/[[PendingLocalDescription]]}}.
                  </p>
                  <p>
                    It represents a local description that is in the process of
                    being negotiated plus any local candidates that have been
                    generated by the [= ICE Agent =] since the offer or answer
                    was created. If the {{RTCPeerConnection}} is in the stable
                    state, the value is <code>null</code>.
                  </p>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-setRemoteDescription-answer.html,RTCPeerConnection-setRemoteDescription-offer.html">
                  <dfn id=
                  "dom-peerconnection-remotedescription">remoteDescription</dfn>
                  of type <span class=
                  "idlAttrType">{{RTCSessionDescription}}</span>, readonly,
                  nullable
                </dt>
                <dd>
                  <p data-tests="RTCPeerConnection-setRemoteDescription.html">
                    The {{remoteDescription}} attribute MUST return
                    {{RTCPeerConnection/[[PendingRemoteDescription]]}} if it is not
                    <code>null</code> and otherwise it MUST return
                    {{RTCPeerConnection/[[CurrentRemoteDescription]]}}.
                  </p>
                  <p>
                    Note that
                    {{RTCPeerConnection/[[CurrentRemoteDescription]]}}.{{RTCSessionDescription/sdp}}
                    and
                    {{RTCPeerConnection/[[PendingRemoteDescription]]}}.{{RTCSessionDescription/sdp}}
                    need not be string-wise identical to the
                    {{RTCSessionDescriptionInit/sdp}} value passed to the
                    corresponding {{setRemoteDescription}} call (i.e. SDP may be
                    parsed and reformatted, and ICE candidates may be added).
                  </p>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-setLocalDescription-answer.html,RTCPeerConnection-setRemoteDescription-answer.html,RTCPeerConnection-setRemoteDescription-offer.html">
                  <dfn id=
                  "dom-peerconnection-currentremotedesc">currentRemoteDescription</dfn>
                  of type <span class=
                  "idlAttrType">{{RTCSessionDescription}}</span>, readonly,
                  nullable
                </dt>
                <dd>
                  <p data-tests="RTCPeerConnection-setRemoteDescription.html">
                    The {{currentRemoteDescription}} attribute MUST return
                    {{RTCPeerConnection/[[CurrentRemoteDescription]]}}.
                  </p>
                  <p>
                    It represents the last remote description that was
                    successfully negotiated the last time the
                    {{RTCPeerConnection}} transitioned into the stable state
                    plus any remote candidates that have been supplied via
                    {{RTCPeerConnection/addIceCandidate()}} since the offer or
                    answer was created.
                  </p>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-setLocalDescription-answer.html,RTCPeerConnection-setRemoteDescription-answer.html,RTCPeerConnection-setRemoteDescription-offer.html">
                  <dfn id=
                  "dom-peerconnection-pendingremotedesc">pendingRemoteDescription</dfn>
                  of type <span class=
                  "idlAttrType">{{RTCSessionDescription}}</span>, readonly,
                  nullable
                </dt>
                <dd>
                  <p data-tests="RTCPeerConnection-setRemoteDescription.html">
                    The {{pendingRemoteDescription}} attribute MUST return
                    {{RTCPeerConnection/[[PendingRemoteDescription]]}}.
                  </p>
                  <p>
                    It represents a remote description that is in the process
                    of being negotiated, complete with any remote candidates
                    that have been supplied via
                    {{RTCPeerConnection/addIceCandidate()}} since the offer or
                    answer was created. If the {{RTCPeerConnection}} is in the
                    stable state, the value is <code>null</code>.
                  </p>
                </dd>
                <dt>
                  <dfn id=
                  "dom-peerconnection-signaling-state">signalingState</dfn> of
                  type <span class="idlAttrType">{{RTCSignalingState}}</span>,
                  readonly
                </dt>
                <dd>
                  <p data-tests=
                  "RTCPeerConnection-setLocalDescription-answer.html">
                    The {{signalingState}} attribute MUST return the
                    {{RTCPeerConnection/RTCPeerConnection}} object's [=
                    signaling state =].
                  </p>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-iceGatheringState.html,protocol/candidate-exchange.https.html">
                  <dfn id=
                  "dom-peerconnection-ice-gathering-state">iceGatheringState</dfn>
                  of type <span class=
                  "idlAttrType">{{RTCIceGatheringState}}</span>, readonly
                </dt>
                <dd>
                  <p>
                    The {{iceGatheringState}} attribute MUST return the [= ICE
                    gathering state =] of the {{RTCPeerConnection}} instance.
                  </p>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-iceConnectionState.https.html,no-media-call.html,RTCPeerConnection-iceConnectionState-disconnected.https.html,protocol/ice-state.https.html">
                  <dfn id=
                  "dom-peerconnection-ice-connection-state">iceConnectionState</dfn>
                  of type <span class=
                  "idlAttrType">{{RTCIceConnectionState}}</span>, readonly
                </dt>
                <dd>
                  <p>
                    The {{iceConnectionState}} attribute MUST return the [= ICE
                    connection state =] of the {{RTCPeerConnection}} instance.
                  </p>
                </dd>
                <dt data-tests="RTCPeerConnection-connectionState.https.html">
                  <dfn id=
                  "dom-peerconnection-connection-state">connectionState</dfn>
                  of type <span class=
                  "idlAttrType">{{RTCPeerConnectionState}}</span>, readonly
                </dt>
                <dd>
                  <p>
                    The {{connectionState}} attribute MUST return the [=
                    connection state =] of the {{RTCPeerConnection}} instance.
                  </p>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-canTrickleIceCandidates.html, RTCPeerConnection-constructor.html">
                  <dfn data-idl="">canTrickleIceCandidates</dfn> of type
                  <span class="idlAttrType">boolean</span>, readonly, nullable
                </dt>
                <dd>
                  <p>
                    The {{canTrickleIceCandidates}} attribute indicates whether
                    the remote peer is able to accept trickled ICE candidates
                    [[RFC8838]]. The value is determined based on whether a
                    remote description indicates support for trickle ICE, as
                    defined in <span data-jsep="cantrickle">[[!RFC8829]]</span>.
                    Prior to the completion of
                    {{RTCPeerConnection/setRemoteDescription}}, this value is
                    <code>null</code>.
                  </p>
                </dd>
                <dt data-tests="RTCPeerConnection-onnegotiationneeded.html">
                  <dfn data-idl="">onnegotiationneeded</dfn> of type
                  <span class="idlAttrType">EventHandler</span>
                </dt>
                <dd>
                  The event type of this event handler is
                  {{RTCPeerConnection/negotiationneeded}}.
                </dd>
                <dt data-tests="promises-call.html">
                  <dfn data-idl="">onicecandidate</dfn> of type <span class=
                  "idlAttrType">EventHandler</span>
                </dt>
                <dd>
                  The event type of this event handler is {{RTCPeerConnection/icecandidate}}.
                </dd>
                <dt data-tests=
                "RTCPeerConnection-onicecandidateerror.https.html">
                  <dfn data-idl="">onicecandidateerror</dfn> of type
                  <span class="idlAttrType">EventHandler</span>
                </dt>
                <dd>
                  The event type of this event handler is
                  {{RTCPeerConnection/icecandidateerror}}.
                </dd>
                <dt data-tests=
                "RTCPeerConnection-createOffer.html,RTCPeerConnection-onsignalingstatechanged.https.html">
                  <dfn data-idl="">onsignalingstatechange</dfn> of type
                  <span class="idlAttrType">EventHandler</span>
                </dt>
                <dd>
                  The event type of this event handler is
                  {{RTCPeerConnection/signalingstatechange}}.
                </dd>
                <dt data-tests=
                "RTCPeerConnection-connectionState.https.html,RTCPeerConnection-iceConnectionState.https.html,no-media-call.html,RTCPeerConnection-iceConnectionState-disconnected.https.html,protocol/ice-state.https.html">
                  <dfn data-idl="">oniceconnectionstatechange</dfn> of type
                  <span class="idlAttrType">EventHandler</span>
                </dt>
                <dd>
                  The event type of this event handler is
                  {{RTCPeerConnection/iceconnectionstatechange}}
                </dd>
                <dt data-tests=
                "RTCPeerConnection-iceGatheringState.html,protocol/candidate-exchange.https.html">
                  <dfn data-idl="">onicegatheringstatechange</dfn> of type
                  <span class="idlAttrType">EventHandler</span>
                </dt>
                <dd>
                  The event type of this event handler is
                  {{RTCPeerConnection/icegatheringstatechange}}.
                </dd>
                <dt data-tests=
                "RTCPeerConnection-iceConnectionState.https.html">
                  <dfn data-idl="">onconnectionstatechange</dfn> of type
                  <span class="idlAttrType">EventHandler</span>
                </dt>
                <dd>
                  The event type of this event handler is
                  {{RTCPeerConnection/connectionstatechange}}.
                </dd>
              </dl>
            </section>
            <section>
              <h2>
                Methods
              </h2>
              <dl data-link-for="RTCPeerConnection" data-dfn-for=
              "RTCPeerConnection" class="methods">
                <dt data-tests=
                "RTCPeerConnection-createOffer.html,promises-call.html">
                  <dfn data-idl="">createOffer</dfn>
                </dt>
                <dd>
                  <p>
                    The {{createOffer}} method generates a blob of SDP that
                    contains an RFC 3264 offer with the supported
                    configurations for the session, including descriptions of
                    the local {{MediaStreamTrack}}s attached to this
                    {{RTCPeerConnection}}, the codec/RTP/RTCP capabilities
                    supported by this implementation, and parameters of the [=
                    ICE agent =] and the DTLS connection. The
                    <var>options</var> parameter may be supplied to provide
                    additional control over the offer generated.
                  </p>
                  <p>
                    If a system has limited resources (e.g. a finite number of
                    decoders), {{createOffer}} needs to return an offer that
                    reflects the current state of the system, so that
                    {{setLocalDescription}} will succeed when it attempts to
                    acquire those resources. The session descriptions MUST
                    remain usable by {{setLocalDescription}} without causing an
                    error until at least the end of the [= fulfillment =]
                    callback of the returned promise.
                  </p>
                  <p data-tests=
                  "RTCRtpTransceiver-stop.html,protocol/jsep-initial-offer.https.html">
                    Creating the SDP MUST follow the appropriate process for
                    generating an offer described in [[!RFC8829]], except the user
                    agent MUST treat a {{RTCRtpTransceiver/stopping}}
                    transceiver as {{RTCRtpTransceiver/stopped}} for the
                    purposes of RFC8829 in this case.
                  </p>
                  <p>
                    As an offer, the generated SDP will contain the full set of
                    codec/RTP/RTCP capabilities supported or preferred by the
                    session (as opposed to an answer, which will include only a
                    specific negotiated subset to use). In the event
                    {{createOffer}} is called after the session is established,
                    {{createOffer}} will generate an offer that is compatible
                    with the current session, incorporating any changes that
                    have been made to the session since the last complete
                    offer-answer exchange, such as addition or removal of
                    tracks. If no changes have been made, the offer will
                    include the capabilities of the current local description
                    as well as any additional capabilities that could be
                    negotiated in an updated offer.
                  </p>
                  <p>
                    The generated SDP will also contain the [= ICE agent =]'s
                    {{RTCIceParameters/usernameFragment}},
                    {{RTCIceParameters/password}} and ICE options (as defined
                    in [[RFC5245]], Section 14) and may also contain any local
                    candidates that have been gathered by the agent.
                  </p>
                  <p>
                    The {{RTCConfiguration/certificates}} value in
                    <var>configuration</var> for the {{RTCPeerConnection}}
                    provides the certificates configured by the application for
                    the {{RTCPeerConnection}}. These certificates, along with
                    any default certificates are used to produce a set of
                    certificate fingerprints. These certificate fingerprints
                    are used in the construction of SDP.
                  </p>
                  <p class="fingerprint">
                    The process of generating an SDP exposes a subset of the
                    media capabilities of the underlying system, which provides
                    generally persistent cross-origin information on the
                    device. It thus increases the fingerprinting surface of the
                    application. In privacy-sensitive contexts, browsers can
                    consider mitigations such as generating SDP matching only a
                    common subset of the capabilities.
                  </p>
                  <p>
                    When the method is called, the user agent MUST run the
                    following steps:
                  </p>
                  <ol>
                    <li class="no-test-needed">
                      <p>
                        Let <var>connection</var> be the {{RTCPeerConnection}}
                        object on which the method was invoked.
                      </p>
                    </li>
                    <li data-tests="RTCPeerConnection-createOffer.html">
                      <p>
                        If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                        <code>true</code>, return a promise [= rejected =] with
                        a newly [= exception/created =] {{InvalidStateError}}.
                      </p>
                    </li>
                    <li>
                      <p>
                        Return the result of [= chaining =] the result of [=
                        creating an offer =] with <var>connection</var> to
                        <var>connection</var>'s [= operations chain =].
                      </p>
                    </li>
                  </ol>
                  <p>
                    To <dfn data-lt="creating an offer">create an offer</dfn>
                    given <var>connection</var> run the following steps:
                  </p>
                  <ol>
                    <li data-tests=
                    "RTCPeerConnection-createOffer.html,RTCPeerConnection-setRemoteDescription-offer.html">
                      <p>
                        If <var>connection</var>'s [= signaling state =] is
                        neither {{RTCSignalingState/"stable"}} nor
                        {{RTCSignalingState/"have-local-offer"}}, return a
                        promise [= rejected =] with a newly [=
                        exception/created =] {{InvalidStateError}}.
                      </p>
                    </li>
                    <li class="no-test-needed">
                      <p>
                        Let <var>p</var> be a new promise.
                      </p>
                    </li>
                    <li>
                      <p>
                        In parallel, begin the [= in-parallel steps to create
                        an offer =] given <var>connection</var> and
                        <var>p</var>.
                      </p>
                    </li>
                    <li class="no-test-needed">
                      <p>
                        Return <var>p</var>.
                      </p>
                    </li>
                  </ol>
                  <p>
                    The <dfn>in-parallel steps to create an offer</dfn> given
                    <var>connection</var> and a promise <var>p</var> are as
                    follows:
                  </p>
                  <ol>
                    <li>
                      <p>
                        If <var>connection</var> was not constructed with a set
                        of certificates, and one has not yet been generated,
                        wait for it to be generated.
                      </p>
                    </li>
                    <li class="untestable">
                      <p>
                        Inspect the <dfn>offerer's system state</dfn> to
                        determine the currently available resources as
                        necessary for generating the offer, as described in
                        <span data-jsep="createoffer">[[!RFC8829]]</span>.
                      </p>
                    </li>
                    <li class="untestable">
                      <p>
                        If this inspection failed for any reason, [= reject =]
                        <var>p</var> with a newly [= exception/created =]
                        {{OperationError}} and abort these steps.
                      </p>
                    </li>
                    <li>
                      <p>
                        Queue a task that runs the [= final steps to create an
                        offer =] given <var>connection</var> and <var>p</var>.
                      </p>
                    </li>
                  </ol>
                  <p>
                    The <dfn>final steps to create an offer</dfn> given
                    <var>connection</var> and a promise <var>p</var> are as
                    follows:
                  </p>
                  <ol>
                    <li>
                      <p>
                        If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                        <code>true</code>, then abort these steps.
                      </p>
                    </li>
                    <li data-tests="RTCPeerConnection-createOffer.html">
                      <p>
                        If <var>connection</var> was modified in such a way
                        that additional inspection of the [= offerer's system
                        state =] is necessary, then in parallel begin the [=
                        in-parallel steps to create an offer =] again, given
                        <var>connection</var> and <var>p</var>, and abort these
                        steps.
                      </p>
                      <div class="note">
                        This may be necessary if, for example, {{createOffer}}
                        was called when only an audio {{RTCRtpTransceiver}} was
                        added to <var>connection</var>, but while performing
                        the [= in-parallel steps to create an offer =], a video
                        {{RTCRtpTransceiver}} was added, requiring additional
                        inspection of video system resources.
                      </div>
                    </li>
                    <li>
                      <p class="untestable">
                        Given the information that was obtained from previous
                        inspection, the current state of <var>connection</var>
                        and its {{RTCRtpTransceiver}}s, generate an SDP offer,
                        <var>sdpString</var>, as described in <span data-jsep=
                        "create-offer">[[!RFC8829]]</span>.
                      </p>
                      <ol>
                        <li data-tests="RTCRtpSender-transport.https.html">
                          <p>
                            As described in [[RFC8843]] (Section 7), if
                            bundling is used (see {{RTCBundlePolicy}}) an
                            offerer tagged m= section must be selected in order
                            to negotiate a BUNDLE group. The user agent MUST
                            choose the m= section that corresponds to the first
                            non-stopped transceiver in the [= set of
                            transceivers =] as the offerer tagged m= section.
                            This allows the remote endpoint to predict which
                            transceiver is the offerer tagged m= section
                            without having to parse the SDP.
                          </p>
                        </li>
                        <li>
                          <p>
                            The <i>codec preferences</i> of a [= media
                            description =]'s [= associated =] transceiver is
                            said to be the value of the
                            {{RTCRtpTransceiver}}.{{RTCRtpTransceiver/[[PreferredCodecs]]}}
                            with the following filtering applied (or said not
                            to be set if {{RTCRtpTransceiver/[[PreferredCodecs]]}} is empty):
                          </p>
                          <ol>
                            <li>
                              <p>
                                If the {{RTCRtpTransceiver/direction}} is
                                {{RTCRtpTransceiverDirection/"sendrecv"}},
                                exclude any codecs not included in the
                                intersection of
                                {{RTCRtpSender}}.{{RTCRtpSender/getCapabilities}}(kind).{{RTCRtpCapabilities/codecs}}
                                and
                                {{RTCRtpReceiver}}.{{RTCRtpReceiver/getCapabilities}}(kind).{{RTCRtpCapabilities/codecs}}.
                              </p>
                            </li>
                            <li>
                              <p>
                                If the {{RTCRtpTransceiver/direction}} is
                                {{RTCRtpTransceiverDirection/"sendonly"}},
                                exclude any codecs not included in
                                {{RTCRtpSender}}.{{RTCRtpSender/getCapabilities}}(kind).{{RTCRtpCapabilities/codecs}}.
                              </p>
                            </li>
                            <li>
                              <p>
                                If the {{RTCRtpTransceiver/direction}} is
                                {{RTCRtpTransceiverDirection/"recvonly"}},
                                exclude any codecs not included in
                                {{RTCRtpReceiver}}.{{RTCRtpReceiver/getCapabilities}}(kind).{{RTCRtpCapabilities/codecs}}.
                              </p>
                            </li>
                          </ol>
                          <p>
                            The filtering MUST NOT change the order of the
                            codec preferences.
                          </p>
                        </li>
                        <li>
                          <p>
                            If the length of the {{RTCRtpSender/[[SendEncodings]]}} slot
                            of the {{RTCRtpSender}} is larger than 1, then for
                            each encoding given in {{RTCRtpSender/[[SendEncodings]]}} of
                            the {{RTCRtpSender}}, add an <code class=
                            "sdp">a=rid send</code> line to the corresponding
                            media section, and add an <code class=
                            "sdp">a=simulcast:send</code> line giving the RIDs
                            in the same order as given in the
                            {{RTCRtpSendParameters/encodings}} field. No RID
                            restrictions are set.
                          </p>
                          <p class="note">
                            [[RFC8853]] section 5.2 specifies that the
                            order of RIDs in the a=simulcast line suggests a
                            proposed order of preference. If the browser
                            decides not to transmit all encodings, one should
                            expect it to stop sending the last encoding in the
                            list first.
                          </p>
                        </li>
                      </ol>
                    </li>
                    <li data-tests="RTCPeerConnection-createOffer.html">
                      <p>
                        Let <var>offer</var> be a newly created
                        {{RTCSessionDescriptionInit}} dictionary with its
                        {{RTCSessionDescriptionInit/type}} member initialized
                        to the string {{RTCSdpType/"offer"}} and its
                        {{RTCSessionDescriptionInit/sdp}} member initialized to
                        <var>sdpString</var>.
                      </p>
                    </li>
                    <li>
                      <p>
                        Set the {{RTCPeerConnection/[[LastCreatedOffer]]}} internal slot to
                        <var>sdpString</var>.
                      </p>
                    </li>
                    <li>
                      <p>
                        [= Resolve =] <var>p</var> with <var>offer</var>.
                      </p>
                    </li>
                  </ol>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-createAnswer.html,promises-call.html">
                  <dfn data-idl="">createAnswer</dfn>
                </dt>
                <dd>
                  <p>
                    The {{createAnswer}} method generates an [[!SDP]] answer
                    with the supported configuration for the session that is
                    compatible with the parameters in the remote configuration.
                    Like {{createOffer}}, the returned blob of SDP contains
                    descriptions of the local {{MediaStreamTrack}}s attached to
                    this {{RTCPeerConnection}}, the codec/RTP/RTCP options
                    negotiated for this session, and any candidates that have
                    been gathered by the [= ICE Agent =]. The
                    <var>options</var> parameter may be supplied to provide
                    additional control over the generated answer.
                  </p>
                  <p>
                    Like {{createOffer}}, the returned description SHOULD
                    reflect the current state of the system. The session
                    descriptions MUST remain usable by {{setLocalDescription}}
                    without causing an error until at least the end of the [=
                    fulfillment =] callback of the returned promise.
                  </p>
                  <p>
                    As an answer, the generated SDP will contain a specific
                    codec/RTP/RTCP configuration that, along with the
                    corresponding offer, specifies how the media plane should
                    be established. The generation of the SDP MUST follow the
                    appropriate process for generating an answer described in
                    [[!RFC8829]].
                  </p>
                  <p>
                    The generated SDP will also contain the [= ICE agent =]'s
                    {{RTCIceParameters/usernameFragment}},
                    {{RTCIceParameters/password}} and ICE options (as defined
                    in [[RFC5245]], Section 14) and may also contain any local
                    candidates that have been gathered by the agent.
                  </p>
                  <p>
                    The {{RTCConfiguration/certificates}} value in
                    <var>configuration</var> for the {{RTCPeerConnection}}
                    provides the certificates configured by the application for
                    the {{RTCPeerConnection}}. These certificates, along with
                    any default certificates are used to produce a set of
                    certificate fingerprints. These certificate fingerprints
                    are used in the construction of SDP.
                  </p>
                  <p data-tests=
                  "RTCPeerConnection-setLocalDescription-pranswer.html,RTCPeerConnection-setRemoteDescription-pranswer.html">
                    An answer can be marked as provisional, as described in
                    <span data-jsep=
                    "use-of-provisional-answer">[[!RFC8829]]</span>, by setting
                    the {{RTCSessionDescriptionInit/type}} to
                    {{RTCSdpType/"pranswer"}}.
                  </p>
                  <p>
                    When the method is called, the user agent MUST run the
                    following steps:
                  </p>
                  <ol>
                    <li class="no-test-needed">
                      <p>
                        Let <var>connection</var> be the {{RTCPeerConnection}}
                        object on which the method was invoked.
                      </p>
                    </li>
                    <li data-tests="RTCPeerConnection-createAnswer.html">
                      <p>
                        If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                        <code>true</code>, return a promise [= rejected =] with
                        a newly [= exception/created =] {{InvalidStateError}}.
                      </p>
                    </li>
                    <li>
                      <p>
                        Return the result of [= chaining =] the result of [=
                        creating an answer =] with <var>connection</var> to
                        <var>connection</var>'s [= operations chain =].
                      </p>
                    </li>
                  </ol>
                  <p>
                    To <dfn data-lt="creating an answer">create an answer</dfn>
                    given <var>connection</var> run the following steps:
                  </p>
                  <ol>
                    <li data-tests=
                    "RTCPeerConnection-createAnswer.html, RTCPeerConnection-setLocalDescription-answer.html, RTCPeerConnection-setLocalDescription-pranswer.html">
                      <p>
                        If <var>connection</var>'s [= signaling state =] is
                        neither {{RTCSignalingState/"have-remote-offer"}} nor
                        {{RTCSignalingState/"have-local-pranswer"}}, return a
                        promise [= rejected =] with a newly [=
                        exception/created =] {{InvalidStateError}}.
                      </p>
                    </li>
                    <li class="no-test-needed">
                      <p>
                        Let <var>p</var> be a new promise.
                      </p>
                    </li>
                    <li>
                      <p>
                        In parallel, begin the [= in-parallel steps to create
                        an answer =] given <var>connection</var> and
                        <var>p</var>.
                      </p>
                    </li>
                    <li class="no-test-needed">
                      <p>
                        Return <var>p</var>.
                      </p>
                    </li>
                  </ol>
                  <p>
                    The <dfn>in-parallel steps to create an answer</dfn> given
                    <var>connection</var> and a promise <var>p</var> are as
                    follows:
                  </p>
                  <ol>
                    <li>
                      <p>
                        If <var>connection</var> was not constructed with a set
                        of certificates, and one has not yet been generated,
                        wait for it to be generated.
                      </p>
                    </li>
                    <li class="untestable">
                      <p>
                        Inspect the <dfn>answerer's system state</dfn> to
                        determine the currently available resources as
                        necessary for generating the answer, as described in
                        <span data-jsep="createanswer">[[!RFC8829]]</span>.
                      </p>
                    </li>
                    <li class="untestable">
                      <p>
                        If this inspection failed for any reason, [= reject =]
                        <var>p</var> with a newly [= exception/created =]
                        {{OperationError}} and abort these steps.
                      </p>
                    </li>
                    <li>
                      <p>
                        Queue a task that runs the [= final steps to create an
                        answer =] given <var>p</var>.
                      </p>
                    </li>
                  </ol>
                  <p>
                    The <dfn>final steps to create an answer</dfn> given a
                    promise <var>p</var> are as follows:
                  </p>
                  <ol>
                    <li>
                      <p>
                        If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                        <code>true</code>, then abort these steps.
                      </p>
                    </li>
                    <li>
                      <p>
                        If <var>connection</var> was modified in such a way
                        that additional inspection of the [= answerer's system
                        state =] is necessary, then in parallel begin the [=
                        in-parallel steps to create an answer =] again given
                        <var>connection</var> and <var>p</var>, and abort these
                        steps.
                      </p>
                      <div class="note">
                        This may be necessary if, for example, {{createAnswer}}
                        was called when an {{RTCRtpTransceiver}}'s direction
                        was {{RTCRtpTransceiverDirection/"recvonly"}}, but
                        while performing the [= in-parallel steps to create an
                        answer =], the direction was changed to
                        {{RTCRtpTransceiverDirection/"sendrecv"}}, requiring
                        additional inspection of video encoding resources.
                      </div>
                    </li>
                    <li>
                      <p>
                        Given the information that was obtained from previous
                        inspection and the current state of
                        <var>connection</var> and its {{RTCRtpTransceiver}}s,
                        generate an SDP answer, <var>sdpString</var>, as
                        described in <span data-jsep=
                        "generating-an-answer">[[!RFC8829]]</span>.
                      </p>
                      <ol>
                        <li>
                          <p>
                            The <i>codec preferences</i> of an m= section's
                            associated transceiver is said to be the value of
                            the
                            {{RTCRtpTransceiver}}.{{RTCRtpTransceiver/[[PreferredCodecs]]}}
                            with the following filtering applied (or said not
                            to be set if {{RTCRtpTransceiver/[[PreferredCodecs]]}} is empty):
                          </p>
                          <ol>
                            <li>
                              <p>
                                If the {{RTCRtpTransceiver/direction}} is
                                {{RTCRtpTransceiverDirection/"sendrecv"}},
                                exclude any codecs not included in the
                                intersection of
                                {{RTCRtpSender}}.{{RTCRtpSender/getCapabilities}}(kind).{{RTCRtpCapabilities/codecs}}
                                and
                                {{RTCRtpReceiver}}.{{RTCRtpReceiver/getCapabilities}}(kind).{{RTCRtpCapabilities/codecs}}.
                              </p>
                            </li>
                            <li>
                              <p>
                                If the {{RTCRtpTransceiver/direction}} is
                                {{RTCRtpTransceiverDirection/"sendonly"}},
                                exclude any codecs not included in
                                {{RTCRtpSender}}.{{RTCRtpSender/getCapabilities}}(kind).{{RTCRtpCapabilities/codecs}}.
                              </p>
                            </li>
                            <li>
                              <p>
                                If the {{RTCRtpTransceiver/direction}} is
                                {{RTCRtpTransceiverDirection/"recvonly"}},
                                exclude any codecs not included in
                                {{RTCRtpReceiver}}.{{RTCRtpReceiver/getCapabilities}}(kind).{{RTCRtpCapabilities/codecs}}.
                              </p>
                            </li>
                          </ol>
                          <p>
                            The filtering MUST NOT change the order of the
                            codec preferences.
                          </p>
                        </li>
                        <li>
                          <p>
                            If the length of the {{RTCRtpSender/[[SendEncodings]]}} slot
                            of the {{RTCRtpSender}} is larger than 1, then for
                            each encoding given in {{RTCRtpSender/[[SendEncodings]]}} of
                            the {{RTCRtpSender}}, add an <code class=
                            "sdp">a=rid send</code> line to the corresponding
                            media section, and add an <code class=
                            "sdp">a=simulcast:send</code> line giving the RIDs
                            in the same order as given in the
                            {{RTCRtpSendParameters/encodings}} field. No RID
                            restrictions are set.
                          </p>
                        </li>
                      </ol>
                    </li>
                    <li data-tests="RTCPeerConnection-createAnswer.html">
                      <p>
                        Let <var>answer</var> be a newly created
                        {{RTCSessionDescriptionInit}} dictionary with its
                        {{RTCSessionDescriptionInit/type}} member initialized
                        to the string {{RTCSdpType/"answer"}} and its
                        {{RTCSessionDescriptionInit/sdp}} member initialized to
                        <var>sdpString</var>.
                      </p>
                    </li>
                    <li>
                      <p>
                        Set the {{RTCPeerConnection/[[LastCreatedAnswer]]}} internal slot to
                        <var>sdpString</var>.
                      </p>
                    </li>
                    <li>
                      <p>
                        [= Resolve =] <var>p</var> with <var>answer</var>.
                      </p>
                    </li>
                  </ol>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-setDescription-transceiver.html,RTCPeerConnection-setLocalDescription-answer.html,RTCPeerConnection-setLocalDescription-offer.html,promises-call.html,RTCPeerConnection-setLocalDescription-parameterless.https.html">
                  <dfn id=
                  "dom-peerconnection-setlocaldescription">setLocalDescription</dfn>
                </dt>
                <dd>
                  <p>
                    The {{setLocalDescription}} method instructs the
                    {{RTCPeerConnection}} to apply the supplied
                    {{RTCLocalSessionDescriptionInit}} as the local
                    description.
                  </p>
                  <p>
                    This API changes the local media state. In order to
                    successfully handle scenarios where the application wants
                    to offer to change from one media format to a different,
                    incompatible format, the {{RTCPeerConnection}} MUST be able
                    to simultaneously support use of both the current and
                    pending local descriptions (e.g. support codecs that exist
                    in both descriptions) until a final answer is received, at
                    which point the {{RTCPeerConnection}} can fully adopt the
                    pending local description, or rollback to the current
                    description if the remote side rejected the change.
                  </p>
                  <p>
                    Passing in a description is optional. If left out, then
                    {{setLocalDescription}} will implicitly [= create an offer
                    =] or [= create an answer =], as needed. As noted in
                    <span data-jsep="modifying-sdp">[[!RFC8829]]</span>, if a
                    description with SDP is passed in, that SDP is not allowed
                    to have changed from when it was returned from either
                    {{createOffer}} or {{createAnswer}}.
                  </p>
                  <p>
                    When the method is invoked, the user agent MUST run the
                    following steps:
                  </p>
                  <ol>
                    <li class="no-test-needed">
                      <p>
                        Let <var>description</var> be the method's first
                        argument.
                      </p>
                    </li>
                    <li class="no-test-needed">
                      <p>
                        Let <var>connection</var> be the {{RTCPeerConnection}}
                        object on which the method was invoked.
                      </p>
                    </li>
                    <li class="no-test-needed">
                      <p>
                        Let <var>sdp</var> be
                        <var>description</var>.{{RTCSessionDescriptionInit/sdp}}.
                      </p>
                    </li>
                    <li>
                      <p data-tests="">
                        Return the result of [= chaining =] the following steps
                        to <var>connection</var>'s [= operations chain =]:
                      </p>
                      <ol>
                        <li data-tests=
                        "RTCPeerConnection-setLocalDescription-offer.html,RTCPeerConnection-setLocalDescription-answer.html,RTCPeerConnection-setLocalDescription-parameterless.https.html">
                          <p>
                            Let <var>type</var> be
                            <var>description</var>.{{RTCSessionDescriptionInit/type}}
                            if present, or {{RTCSdpType/"offer"}} if not
                            present and <var>connection</var>'s [= signaling
                            state =] is either {{RTCSignalingState/"stable"}},
                            {{RTCSignalingState/"have-local-offer"}}, or
                            {{RTCSignalingState/"have-remote-pranswer"}};
                            otherwise {{RTCSdpType/"answer"}}.
                          </p>
                        </li>
                        <li data-tests=
                        "RTCPeerConnection-setLocalDescription-offer.html">
                          <p>
                            If <var>type</var> is {{RTCSdpType/"offer"}}, and
                            <var>sdp</var> is not the empty string and not
                            equal to
                            <var>connection</var>.{{RTCPeerConnection/[[LastCreatedOffer]]}},
                            then return a promise [= rejected =] with a newly
                            [= exception/created =]
                            {{InvalidModificationError}} and abort these steps.
                          </p>
                        </li>
                        <li data-tests=
                        "RTCPeerConnection-setLocalDescription-answer.html">
                          <p>
                            If <var>type</var> is {{RTCSdpType/"answer"}} or
                            {{RTCSdpType/"pranswer"}}, and <var>sdp</var> is
                            not the empty string and not equal to
                            <var>connection</var>.{{RTCPeerConnection/[[LastCreatedAnswer]]}},
                            then return a promise [= rejected =] with a newly
                            [= exception/created =]
                            {{InvalidModificationError}} and abort these steps.
                          </p>
                        </li>
                        <li>
                          <p>
                            If <var>sdp</var> is the empty string, and
                            <var>type</var> is {{RTCSdpType/"offer"}}, then run
                            the following sub steps:
                          </p>
                          <ol>
                            <li data-tests=
                            "RTCPeerConnection-setLocalDescription-offer.html">
                              <p>
                                Set <var>sdp</var> to the value of
                                <var>connection</var>.{{RTCPeerConnection/[[LastCreatedOffer]]}}.
                              </p>
                            </li>
                            <li data-tests=
                            "RTCPeerConnection-setLocalDescription-parameterless.https.html">
                              <p>
                                If <var>sdp</var> is the empty string, or if it
                                no longer accurately represents the [=
                                offerer's system state =] of
                                <var>connection</var>, then let <var>p</var> be
                                the result of [= creating an offer =] with
                                <var>connection</var>, and return the result of
                                [= promise/reacting =] to <var>p</var> with a
                                fulfillment step that [= set a local
                                session description | sets the local
                                session description =] indicated by its first
                                argument.
                              </p>
                            </li>
                          </ol>
                        </li>
                        <li>
                          <p>
                            If <var>sdp</var> is the empty string, and
                            <var>type</var> is {{RTCSdpType/"answer"}} or
                            {{RTCSdpType/"pranswer"}}, then run the following
                            sub steps:
                          </p>
                          <ol>
                            <li data-tests=
                            "RTCPeerConnection-setLocalDescription-offer.html">
                              <p>
                                Set <var>sdp</var> to the value of
                                <var>connection</var>.{{RTCPeerConnection/[[LastCreatedAnswer]]}}.
                              </p>
                            </li>
                            <li data-tests=
                            "RTCPeerConnection-setLocalDescription-parameterless.https.html">
                              <p>
                                If <var>sdp</var> is the empty string, or if it
                                no longer accurately represents the [=
                                answerer's system state =] of
                                <var>connection</var>, then let <var>p</var> be
                                the result of [= creating an answer =] with
                                <var>connection</var>, and return the result of
                                [= promise/reacting =] to <var>p</var> with the
                                following fulfillment steps:
                              </p>
                              <ol>
                                <li>
                                  <p>
                                    Let <var>answer</var> be the first argument
                                    to these fulfillment steps.
                                  </p>
                                </li>
                                <li>
                                  <p>
                                    Return the result of [= setting the local
                                    session description =] indicated by
                                    <code class="param">{<var>type</var>,
                                    <var>answer</var>.{{RTCSessionDescriptionInit/sdp}}}</code>.
                                  </p>
                                </li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li data-tests=
                        "RTCPeerConnection-setLocalDescription-offer.html,RTCPeerConnection-setLocalDescription-answer.html">
                          <p>
                            Return the result of [= setting the local
                            session description =] indicated by <code class=
                            "param">{<var>type</var>, <var>sdp</var>}</code>.
                          </p>
                        </li>
                      </ol>
                    </li>
                  </ol>
                  <div class="note">
                    <p>
                      As noted in <span data-jsep=
                      "applying-a-local-desc">[[!RFC8829]]</span>, calling this
                      method may trigger the ICE candidate gathering process by
                      the [= ICE Agent =].
                    </p>
                  </div>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-setDescription-transceiver.html,RTCPeerConnection-setLocalDescription-answer.html,promises-call.html,simplecall-no-ssrcs.https.html,simplecall.https.html">
                  <dfn id=
                  "dom-peerconnection-setremotedescription">setRemoteDescription</dfn>
                </dt>
                <dd>
                  <p>
                    The {{setRemoteDescription}} method instructs the
                    {{RTCPeerConnection}} to apply the supplied
                    {{RTCSessionDescriptionInit}} as the remote offer or
                    answer. This API changes the local media state.
                  </p>
                  <p>
                    When the method is invoked, the user agent MUST run the
                    following steps:
                  </p>
                  <ol>
                    <li class="no-test-needed">
                      <p>
                        Let <var>description</var> be the method's first
                        argument.
                      </p>
                    </li>
                    <li class="no-test-needed">
                      <p>
                        Let <var>connection</var> be the {{RTCPeerConnection}}
                        object on which the method was invoked.
                      </p>
                    </li>
                    <li>
                      <p data-tests="">
                        Return the result of [= chaining =] the following steps
                        to <var>connection</var>'s [= operations chain =]:
                      </p>
                      <ol>
                        <li data-tests=
                        "RTCPeerConnection-setRemoteDescription-offer.html">
                          <p>
                            If
                            <var>description</var>.{{RTCSessionDescriptionInit/type}}
                            is {{RTCSdpType/"offer"}} and is invalid for the
                            current [= signaling state =] of
                            <var>connection</var> as described in
                            <span data-jsep=
                            "processing-a-local-desc processing-a-remote-desc">[[!RFC8829]]</span>,
                            then run the following sub steps:
                          </p>
                          <ol>
                            <li>
                              <p>
                                Let <var>p</var> be the result of [= setting
                                the local session description =] indicated by
                                <code class="param">{type:
                                {{RTCSdpType/"rollback"}}}</code>.
                              </p>
                            </li>
                            <li>
                              <p>
                                Return the result of [= promise/reacting =] to
                                <var>p</var> with a fulfillment step that [=
                                set a remote session description | sets the
                                remote session description =]
                                <var>description</var>, and abort these steps.
                              </p>
                            </li>
                          </ol>
                        </li>
                        <li data-tests=
                        "RTCPeerConnection-setRemoteDescription-offer.html,RTCPeerConnection-setRemoteDescription-answer.html">
                          <p>
                            Return the result of [= setting the remote
                            session description =] <var>description</var>.
                          </p>
                        </li>
                      </ol>
                    </li>
                  </ol>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-addIceCandidate.html,promises-call.html,RTCPeerConnection-addIceCandidate-timing.https.html">
                  <dfn id=
                  "dom-peerconnection-addicecandidate">addIceCandidate</dfn>
                </dt>
                <dd>
                  <p>
                    The {{addIceCandidate}} method provides a remote candidate
                    to the [= ICE Agent =]. This method can also be used to
                    indicate the end of remote candidates when called with an
                    empty string for the {{RTCIceCandidate/candidate}} member.
                    The only members of the argument used by this method are
                    {{RTCIceCandidate/candidate}}, {{RTCIceCandidate/sdpMid}},
                    {{RTCIceCandidate/sdpMLineIndex}}, and
                    {{RTCIceCandidate/usernameFragment}}; the rest are ignored.
                    When the method is invoked, the user agent MUST run the
                    following steps:
                  </p>
                  <ol>
                    <li class="no-test-needed">
                      <p>
                        Let <var>candidate</var> be the method's argument.
                      </p>
                    </li>
                    <li class="no-test-needed">
                      <p>
                        Let <var>connection</var> be the {{RTCPeerConnection}}
                        object on which the method was invoked.
                      </p>
                    </li>
                    <li data-tests="RTCPeerConnection-addIceCandidate.html">
                      <p>
                        If <var>candidate</var>.{{RTCIceCandidate/candidate}}
                        is not an empty string and both
                        <var>candidate</var>.{{RTCIceCandidate/sdpMid}} and
                        <var>candidate</var>.{{RTCIceCandidate/sdpMLineIndex}}
                        are <code>null</code>, return a promise [= rejected =]
                        with a newly [= exception/created =] {{TypeError}}.
                      </p>
                    </li>
                    <li>
                      <p>
                        Return the result of [= chaining =] the following steps
                        to <var>connection</var>'s [= operations chain =]:
                      </p>
                      <ol>
                        <li data-tests=
                        "RTCPeerConnection-addIceCandidate.html">
                          <p>
                            If {{RTCPeerConnection/remoteDescription}} is
                            <code>null</code> return a promise [= rejected =]
                            with a newly [= exception/created =]
                            {{InvalidStateError}}.
                          </p>
                        </li>
                        <li>
                          <p>
                            If <var>candidate</var>.{{RTCIceCandidate/sdpMid}}
                            is not <code>null</code>, run the following steps:
                          </p>
                          <ol>
                            <li data-tests=
                            "RTCPeerConnection-addIceCandidate.html">
                              <p>
                                If
                                <var>candidate</var>.{{RTCIceCandidate/sdpMid}}
                                is not equal to the mid of any media
                                description in
                                {{RTCPeerConnection/remoteDescription}}, return
                                a promise [= rejected =] with a newly [=
                                exception/created =] {{OperationError}}.
                              </p>
                            </li>
                          </ol>
                        </li>
                        <li data-tests=
                        "RTCPeerConnection-addIceCandidate.html">
                          <p>
                            Else, if
                            <var>candidate</var>.{{RTCIceCandidate/sdpMLineIndex}}
                            is not <code>null</code>, run the following steps:
                          </p>
                          <ol>
                            <li>
                              <p>
                                If
                                <var>candidate</var>.{{RTCIceCandidate/sdpMLineIndex}}
                                is equal to or larger than the number of media
                                descriptions in
                                {{RTCPeerConnection/remoteDescription}}, return
                                a promise [= rejected =] with a newly [=
                                exception/created =] {{OperationError}}.
                              </p>
                            </li>
                          </ol>
                        </li>
                        <li data-tests="">
                          <p>
                            If either
                            <var>candidate</var>.{{RTCIceCandidate/sdpMid}} or
                            <var>candidate</var>.{{RTCIceCandidate/sdpMLineIndex}}
                            indicate a media description in
                            {{RTCPeerConnection/remoteDescription}} whose
                            associated transceiver is {{RTCRtpTransceiver/
                            stopped}}, return a promise [= resolved =] with
                            <code>undefined</code>.
                          </p>
                        </li>
                        <li data-tests=
                        "RTCPeerConnection-addIceCandidate.html">
                          <p>
                            If
                            <var>candidate</var>.{{RTCIceCandidate/usernameFragment}}
                            is not <code>null</code>, and is not equal to any
                            username fragment present in the corresponding [=
                            media description =] of an applied remote
                            description, return a promise [= rejected =] with a
                            newly [= exception/created =] {{OperationError}}.
                          </p>
                        </li>
                        <li class="no-test-needed">
                          <p>
                            Let <var>p</var> be a new promise.
                          </p>
                        </li>
                        <li>
                          <p data-tests="">
                            In parallel, if the candidate is not [=
                            administratively prohibited =], add the ICE
                            candidate <var>candidate</var> as described in
                            <span data-jsep="addicecandidate">[[!RFC8829]]</span>.
                            Use
                            <var>candidate</var>.{{RTCIceCandidate/usernameFragment}}
                            to identify the ICE [= generation =]; if
                            {{RTCIceCandidate/usernameFragment}} is
                            <code>null</code>, process the <var>candidate</var>
                            for the most recent ICE [= generation =].
                            </p>
                            <p>If
                            <var>candidate</var>.{{RTCIceCandidate/candidate}}
                            is an empty string, process <var>candidate</var> as
                            an end-of-candidates indication for the
                            corresponding [= media description =] and ICE
                            candidate [= generation =]. If both
                            <var>candidate</var>.{{RTCIceCandidate/sdpMid}} and
                            <var>candidate</var>.{{RTCIceCandidate/sdpMLineIndex}}
                            are <code>null</code>, then this end-of-candidates
                            indication applies to all [=
                            media description =]s.
                          </p>
                          <ol>
                            <li>
                              <p>
                                If <var>candidate</var> could not be
                                successfully added the user agent MUST queue a
                                task that runs the following steps:
                              </p>
                              <ol>
                                <li>
                                  <p>
                                    If
                                    <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}}
                                    is <code>true</code>, then abort these
                                    steps.
                                  </p>
                                </li>
                                <li>
                                  <p>
                                    [= Reject =] <var>p</var> with a newly [=
                                    exception/created =] {{OperationError}} and
                                    abort these steps.
                                  </p>
                                </li>
                              </ol>
                            </li>
                            <li data-tests=
                            "RTCPeerConnection-addIceCandidate.html">
                              <p>
                                If <var>candidate</var> is applied
                                successfully, or if the candidate was [=
                                administratively prohibited =] the user agent
                                MUST queue a task that runs the following
                                steps:
                              </p>
                              <ol>
                                <li>
                                  <p>
                                    If
                                    <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}}
                                    is <code>true</code>, then abort these
                                    steps.
                                  </p>
                                </li>
                                <li>
                                  <p>
                                    If
                                    <var>connection</var>.{{RTCPeerConnection/[[PendingRemoteDescription]]}}
                                    is not <code>null</code>, and represents
                                    the ICE [= generation =] for which
                                    <var>candidate</var> was processed, add
                                    <var>candidate</var> to
                                    <var>connection</var>.{{RTCPeerConnection/[[PendingRemoteDescription]]}}.sdp.
                                  </p>
                                </li>
                                <li>
                                  <p>
                                    If
                                    <var>connection</var>.{{RTCPeerConnection/[[CurrentRemoteDescription]]}}
                                    is not <code>null</code>, and represents
                                    the ICE [= generation =] for which
                                    <var>candidate</var> was processed, add
                                    <var>candidate</var> to
                                    <var>connection</var>.{{RTCPeerConnection/[[CurrentRemoteDescription]]}}.sdp.
                                  </p>
                                </li>
                                <li>
                                  <p>
                                    [= Resolve =] <var>p</var> with
                                    <code>undefined</code>.
                                  </p>
                                </li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="no-test-needed">
                          <p>
                            Return <var>p</var>.
                          </p>
                        </li>
                      </ol>
                    </li>
                  </ol>
                  <p>
                    A candidate is <dfn>administratively prohibited</dfn> if
                    the UA has decided not to allow connection attempts to this
                    address.
                  </p>
                  <p>
                    For privacy reasons, there is no indication to the
                    developer about whether or not an address/port is blocked;
                    it behaves exactly as if there was no response from the
                    address.
                  </p>
                  <p>
                    The UA MUST prohibit connections to addresses on the
                    [[!Fetch]] [= block bad port =] list, and MAY choose to
                    prohibit connections to other addresses.
                  </p>
                  <p>
                    If the {{RTCConfiguration/iceTransportPolicy}} member of
                    the {{RTCConfiguration}} is
                    {{RTCIceTransportPolicy/relay}}, candidates requiring
                    external resolution, such as mDNS candidates and DNS
                    candidates, MUST be prohibited.
                  </p>
                  <p class="note">
                    Due to WebIDL processing,
                    {{RTCPeerConnection/addIceCandidate}}(<code>null</code>) is
                    interpreted as a call with the default dictionary present,
                    which, in the above algorithm, indicates end-of-candidates
                    for all media descriptions and ICE candidate generation.
                    This is by design for legacy reasons.
                  </p>
                </dd>
                <dt data-tests="RTCPeerConnection-restartIce.https.html">
                  <dfn data-idl="">restartIce</dfn>
                </dt>
                <dd>
                  <p>
                    The {{restartIce}} method tells the {{RTCPeerConnection}}
                    that ICE should be restarted. Subsequent calls to
                    {{createOffer}} will create descriptions that will restart
                    ICE, as described in section 9.1.1.1 of [[RFC5245]].
                  </p>
                  <p>
                    When this method is invoked, the user agent MUST run the
                    following steps:
                  </p>
                  <ol>
                    <li class="no-test-needed">
                      <p>
                        Let <var>connection</var> be the {{RTCPeerConnection}}
                        on which the method was invoked.
                      </p>
                    </li>
                    <li data-tests="RTCPeerConnection-restartIce.https.html">
                      <p>
                        Empty
                        <var>connection</var>.{{RTCPeerConnection/[[LocalIceCredentialsToReplace]]}},
                        and populate it with all ICE credentials (ice-ufrag and
                        ice-pwd as defined in section 15.4 of [[RFC5245]]) found
                        in
                        <var>connection</var>.{{RTCPeerConnection/[[CurrentLocalDescription]]}},
                        as well as all ICE credentials found in
                        <var>connection</var>.{{RTCPeerConnection/[[PendingLocalDescription]]}}.
                      </p>
                    </li>
                    <li data-tests=
                    "RTCPeerConnection-restartIce.https.html,RTCPeerConnection-restartIce-onnegotiationneeded.https.html">
                      <p>
                        [= Update the negotiation-needed flag =] for
                        <var>connection</var>.
                      </p>
                    </li>
                  </ol>
                </dd>
                <dt>
                  <dfn data-idl="">getConfiguration</dfn>
                </dt>
                <dd>
                  <p>
                    Returns an {{RTCConfiguration}} object representing the
                    current configuration of this {{RTCPeerConnection}} object.
                  </p>
                  <p data-tests=
                  "RTCConfiguration-iceServers.html,RTCConfiguration-iceCandidatePoolSize.html,RTCConfiguration-bundlePolicy.html,RTCConfiguration-iceTransportPolicy.html,RTCConfiguration-rtcpMuxPolicy.html">
                    When this method is called, the user agent MUST return the
                    {{RTCConfiguration}} object stored in the
                    {{RTCPeerConnection/[[Configuration]]}} internal slot.
                  </p>
                </dd>
                <dt>
                  <dfn data-idl="">setConfiguration</dfn>
                </dt>
                <dd>
                  <p data-tests="">
                    The {{setConfiguration}} method updates the configuration
                    of this {{RTCPeerConnection}} object. This includes
                    changing the configuration of the [= ICE Agent =]. As noted
                    in <span data-jsep="ice-gather-overview">[[!RFC8829]]</span>,
                    when the ICE configuration changes in a way that requires a
                    new gathering phase, an ICE restart is required.
                  </p>
                  <p>
                    When the {{setConfiguration}} method is invoked, the user
                    agent MUST run the following steps:
                  </p>
                  <ol>
                    <li class="no-test-needed">
                      <p>
                        Let <var>connection</var> be the {{RTCPeerConnection}}
                        on which the method was invoked.
                      </p>
                    </li>
                    <li>
                      <p>
                        If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                        <code>true</code>, [= exception/throw =] an
                        {{InvalidStateError}}.
                      </p>
                    </li>
                    <li data-tests=
                    "RTCConfiguration-iceServers.html,RTCConfiguration-iceCandidatePoolSize.html,RTCConfiguration-bundlePolicy.html,RTCConfiguration-iceTransportPolicy.html,RTCConfiguration-rtcpMuxPolicy.html">
                      <p>
                        [= Set the configuration =] specified by
                        <var>configuration</var>.
                      </p>
                    </li>
                  </ol>
                </dd>
                <dt data-tests="RTCPeerConnection-transceivers.https.html">
                  <dfn data-idl="">close</dfn>
                </dt>
                <dd>
                  <p>
                    When the {{close}} method is invoked, the user agent MUST
                    run the following steps:
                  </p>
                  <ol>
                    <li class="no-test-needed">
                      <p>
                        Let <var>connection</var> be the {{RTCPeerConnection}}
                        object on which the method was invoked.
                      </p>
                    </li>
                    <li class="no-test-needed">[= close the connection =] with
                    <var>connection</var> and the value <code>false</code>.
                    </li>
                  </ol>
                  <p>
                    The <dfn>close the connection</dfn> algorithm given a
                    <var>connection</var> and a <var>disappear</var> boolean,
                    is as follows:
                  </p>
                  <ol>
                    <li class="untestable">
                      <p>
                        If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                        <code>true</code>, abort these steps.
                      </p>
                    </li>
                    <li>
                      <p>
                        Set <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} to
                        <code>true</code>.
                      </p>
                    </li>
                    <li data-tests=
                    "RTCPeerConnection-onsignalingstatechanged.https.html">
                      <p>
                        Set <var>connection</var>'s [= signaling state =] to
                        {{RTCSignalingState/"closed"}}. This does not fire any
                        event.
                      </p>
                    </li>
                    <li data-tests="RTCPeerConnection-transceivers.https.html">
                      <p>
                        Let <var>transceivers</var> be the result of executing
                        the {{CollectTransceivers}} algorithm. For every
                        {{RTCRtpTransceiver}} <var>transceiver</var> in
                        <var>transceivers</var>, run the following steps:
                      </p>
                      <ol>
                        <li>
                          <p>
                            If <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopped]]}} is
                            <code>true</code>, abort these sub steps.
                          </p>
                        </li>
                        <li>
                          <p>
                            [= Stop the RTCRtpTransceiver =] with
                            <var>transceiver</var> and <var>disappear</var>.
                          </p>
                        </li>
                      </ol>
                    </li>
                    <li>
                      <p>
                        Set the {{RTCDataChannel/[[ReadyState]]}} slot of each of
                        <var>connection</var>'s {{RTCDataChannel}}s to
                        {{RTCDataChannelState/"closed"}}.
                      </p>
                      <div class="note">
                        The {{RTCDataChannel}}s will be closed abruptly and the
                        closing procedure will not be invoked.
                      </div>
                    </li>
                    <li>
                      <p>
                        If <var>connection</var>.{{RTCPeerConnection/[[SctpTransport]]}} is
                        not <code>null</code>, tear down the underlying SCTP
                        association by sending an SCTP ABORT chunk and set the
                        {{RTCSctpTransport/[[SctpTransportState]]}} to
                        {{RTCSctpTransportState/"closed"}}.
                      </p>
                    </li>
                    <li>
                      <p>
                        Set the {{RTCDtlsTransport/[[DtlsTransportState]]}} slot of each of
                        <var>connection</var>'s {{RTCDtlsTransport}}s to
                        {{RTCDtlsTransportState/"closed"}}.
                      </p>
                    </li>
                    <li>
                      <p>
                        Destroy <var>connection</var>'s [= ICE Agent =],
                        abruptly ending any active ICE processing and releasing
                        any relevant resources (e.g. TURN permissions).
                      </p>
                    </li>
                    <li>
                      <p>
                        Set the {{RTCIceTransport/[[IceTransportState]]}} slot of each of
                        <var>connection</var>'s {{RTCIceTransport}}s to
                        {{RTCIceTransportState/"closed"}}.
                      </p>
                    </li>
                    <li>
                      <p>
                        Set <var>connection</var>'s [= ICE connection state =]
                        to {{RTCIceConnectionState/"closed"}}. This does not
                        fire any event.
                      </p>
                    </li>
                    <li>
                      <p>
                        Set <var>connection</var>'s [= connection state =] to
                        {{RTCPeerConnectionState/"closed"}}. This does not fire
                        any event.
                      </p>
                    </li>
                  </ol>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section>
          <h3>
            Legacy Interface Extensions
          </h3>
          <div class="note">
            The <a href="#dom-rtcpeerconnection-createoffer!overload-1">IDL
            definition of these methods are documented</a> in the main
            definition of the {{RTCPeerConnection}} interface since overloaded
            functions are not allowed to be defined in partial interfaces.
          </div>
          <p>
            Supporting the methods in this section is optional. However, if
            these methods are supported it is mandatory to implement according
            to what is specified here.
          </p>
          <div class="note">
            The <code>addStream</code> method that used to exist on
            {{RTCPeerConnection}} is easy to polyfill as:
            <pre>RTCPeerConnection.prototype.addStream = function(stream) {
  stream.getTracks().forEach((track) =&gt; this.addTrack(track, stream));
};</pre>
          </div>
          <section>
            <h4>
              Method extensions
            </h4>
            <div>
              <section>
                <h2>
                  Methods
                </h2>
                <dl data-link-for="RTCPeerConnection" data-dfn-for=
                "RTCPeerConnection" class="methods">
                  <dt data-tests=
                  "legacy/RTCPeerConnection-createOffer-offerToReceive.html">
                    <dfn data-lt="createOffer!overload-1" data-lt-nodefault=
                    "true">createOffer</dfn>
                  </dt>
                  <dd>
                    <p>
                      When the <code class="overload">createOffer</code> method
                      is called, the user agent MUST run the following steps:
                    </p>
                    <ol>
                      <li class="no-test-needed">
                        <p>
                          Let <var>successCallback</var> be the method's first
                          argument.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>failureCallback</var> be the callback
                          indicated by the method's second argument.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>options</var> be the callback indicated by
                          the method's third argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Run the steps specified by {{RTCPeerConnection}}'s
                          {{RTCPeerConnection/createOffer()}} method with
                          <var>options</var> as the sole argument, and let
                          <var>p</var> be the resulting promise.
                        </p>
                      </li>
                      <li>
                        <p>
                          Upon [= fulfillment =] of <var>p</var> with value
                          <var>offer</var>, invoke <var>successCallback</var>
                          with <var>offer</var> as the argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Upon [= rejection =] of <var>p</var> with reason
                          <var>r</var>, invoke <var>failureCallback</var> with
                          <var>r</var> as the argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Return a promise [= resolved =] with
                          <code>undefined</code>.
                        </p>
                      </li>
                    </ol>
                  </dd>
                  <dt>
                    <dfn data-lt="setLocalDescription!overload-1"
                    data-lt-nodefault="true">setLocalDescription</dfn>
                  </dt>
                  <dd>
                    <p>
                      When the <code class=
                      "overload">setLocalDescription</code> method is called,
                      the user agent MUST run the following steps:
                    </p>
                    <ol>
                      <li class="no-test-needed">
                        <p>
                          Let <var>description</var> be the method's first
                          argument.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>successCallback</var> be the callback
                          indicated by the method's second argument.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>failureCallback</var> be the callback
                          indicated by the method's third argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Run the steps specified by {{RTCPeerConnection}}'s
                          {{RTCPeerConnection/setLocalDescription}} method with
                          <var>description</var> as the sole argument, and let
                          <var>p</var> be the resulting promise.
                        </p>
                      </li>
                      <li>
                        <p>
                          Upon [= fulfillment =] of <var>p</var>, invoke
                          <var>successCallback</var> with
                          <code>undefined</code> as the argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Upon [= rejection =] of <var>p</var> with reason
                          <var>r</var>, invoke <var>failureCallback</var> with
                          <var>r</var> as the argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Return a promise [= resolved =] with
                          <code>undefined</code>.
                        </p>
                      </li>
                    </ol>
                  </dd>
                  <dt>
                    <dfn data-lt="createAnswer!overload-1" data-lt-nodefault=
                    "true">createAnswer</dfn>
                  </dt>
                  <dd>
                    <div class="note">
                      The legacy <code class="overload">createAnswer</code>
                      method does not take an {{RTCAnswerOptions}} parameter,
                      since no known legacy <code class=
                      "overload">createAnswer</code> implementation ever
                      supported it.
                    </div>
                    <p>
                      When the <code class="overload">createAnswer</code>
                      method is called, the user agent MUST run the following
                      steps:
                    </p>
                    <ol>
                      <li class="no-test-needed">
                        <p>
                          Let <var>successCallback</var> be the method's first
                          argument.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>failureCallback</var> be the callback
                          indicated by the method's second argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Run the steps specified by {{RTCPeerConnection}}'s
                          {{RTCPeerConnection/createAnswer()}} method with no
                          arguments, and let <var>p</var> be the resulting
                          promise.
                        </p>
                      </li>
                      <li>
                        <p>
                          Upon [= fulfillment =] of <var>p</var> with value
                          <var>answer</var>, invoke <var>successCallback</var>
                          with <var>answer</var> as the argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Upon [= rejection =] of <var>p</var> with reason
                          <var>r</var>, invoke <var>failureCallback</var> with
                          <var>r</var> as the argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Return a promise [= resolved =] with
                          <code>undefined</code>.
                        </p>
                      </li>
                    </ol>
                  </dd>
                  <dt>
                    <dfn data-lt="setRemoteDescription!overload-1"
                    data-lt-nodefault="true">setRemoteDescription</dfn>
                  </dt>
                  <dd>
                    <p>
                      When the <code class=
                      "overload">setRemoteDescription</code> method is called,
                      the user agent MUST run the following steps:
                    </p>
                    <ol>
                      <li class="no-test-needed">
                        <p>
                          Let <var>description</var> be the method's first
                          argument.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>successCallback</var> be the callback
                          indicated by the method's second argument.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>failureCallback</var> be the callback
                          indicated by the method's third argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Run the steps specified by {{RTCPeerConnection}}'s
                          {{RTCPeerConnection/setRemoteDescription}} method
                          with <var>description</var> as the sole argument, and
                          let <var>p</var> be the resulting promise.
                        </p>
                      </li>
                      <li>
                        <p>
                          Upon [= fulfillment =] of <var>p</var>, invoke
                          <var>successCallback</var> with
                          <code>undefined</code> as the argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Upon [= rejection =] of <var>p</var> with reason
                          <var>r</var>, invoke <var>failureCallback</var> with
                          <var>r</var> as the argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Return a promise [= resolved =] with
                          <code>undefined</code>.
                        </p>
                      </li>
                    </ol>
                  </dd>
                  <dt>
                    <dfn data-lt="addIceCandidate!overload-1"
                    data-lt-nodefault="true">addIceCandidate</dfn>
                  </dt>
                  <dd>
                    <p>
                      When the <code class="overload">addIceCandidate</code>
                      method is called, the user agent MUST run the following
                      steps:
                    </p>
                    <ol>
                      <li class="no-test-needed">
                        <p>
                          Let <var>candidate</var> be the method's first
                          argument.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>successCallback</var> be the callback
                          indicated by the method's second argument.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>failureCallback</var> be the callback
                          indicated by the method's third argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Run the steps specified by {{RTCPeerConnection}}'s
                          {{RTCPeerConnection/addIceCandidate()}} method with
                          <var>candidate</var> as the sole argument, and let
                          <var>p</var> be the resulting promise.
                        </p>
                      </li>
                      <li>
                        <p>
                          Upon [= fulfillment =] of <var>p</var>, invoke
                          <var>successCallback</var> with
                          <code>undefined</code> as the argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Upon [= rejection =] of <var>p</var> with reason
                          <var>r</var>, invoke <var>failureCallback</var> with
                          <var>r</var> as the argument.
                        </p>
                      </li>
                      <li>
                        <p>
                          Return a promise [= resolved =] with
                          <code>undefined</code>.
                        </p>
                      </li>
                    </ol>
                  </dd>
                </dl>
                <h4>
                  Callback Definitions
                </h4>
                <p>
                  These callbacks are only used on the legacy APIs.
                </p>
                <section>
                  <h4>
                    <dfn>RTCPeerConnectionErrorCallback</dfn>
                  </h4>
                  <div>
                    <pre class="idl">callback RTCPeerConnectionErrorCallback = undefined (DOMException error);</pre>
                    <section>
                      <h2>
                        Callback {{RTCPeerConnectionErrorCallback}} Parameters
                      </h2>
                      <dl data-link-for="RTCPeerConnectionErrorCallback"
                      data-dfn-for="RTCPeerConnectionErrorCallback" class=
                      "callback-members">
                        <dt>
                          <code class="param">error</code> of type
                          {{DOMException}}
                        </dt>
                        <dd>
                          An error object encapsulating information about what
                          went wrong.
                        </dd>
                      </dl>
                    </section>
                  </div>
                </section>
                <section>
                  <h4>
                    <dfn>RTCSessionDescriptionCallback</dfn>
                  </h4>
                  <div>
                    <pre class="idl">callback RTCSessionDescriptionCallback = undefined (RTCSessionDescriptionInit description);</pre>
                    <section>
                      <h2>
                        Callback {{RTCSessionDescriptionCallback}} Parameters
                      </h2>
                      <dl data-link-for="RTCSessionDescriptionCallback"
                      data-dfn-for="RTCSessionDescriptionCallback" class=
                      "callback-members">
                        <dt>
                          description of type <span class=
                          "idlMemberType">{{RTCSessionDescriptionInit}}</span>
                        </dt>
                        <dd>
                          The object containing the SDP [[!SDP]].
                        </dd>
                      </dl>
                    </section>
                  </div>
                </section>
              </section>
            </div>
          </section>
          <section>
            <h4>
              Legacy configuration extensions
            </h4>
            <p>
              This section describes a set of legacy extensions that may be
              used to influence how an offer is created, in addition to the
              media added to the {{RTCPeerConnection}}. Developers are
              encouraged to use the {{RTCRtpTransceiver}} API instead.
            </p>
            <p>
              When {{RTCPeerConnection/createOffer}} is called with any of the
              legacy options specified in this section, run the followings
              steps instead of the regular {{RTCPeerConnection/createOffer}}
              steps:
            </p>
            <ol>
              <li class="no-test-needed">
                <p>
                  Let <var>options</var> be the methods first argument.
                </p>
              </li>
              <li class="no-test-needed">
                <p>
                  Let <var>connection</var> be the current
                  {{RTCPeerConnection}} object.
                </p>
              </li>
              <li>
                <p>
                  For each <code>offerToReceive<var>&lt;Kind&gt;</var></code>
                  member in <var>options</var> with kind, <var>kind</var>, run
                  the following steps:
                </p>
                <ol>
                  <li>If the value of the dictionary member is false,
                    <ol>
                      <li data-tests=
                      "legacy/RTCPeerConnection-createOffer-offerToReceive.html,legacy/RTCRtpTransceiver-with-OfferToReceive-options.https.html">
                        <p>
                          For each non-stopped
                          {{RTCRtpTransceiverDirection/"sendrecv"}} transceiver
                          of [= transceiver kind =] <var>kind</var>, set
                          <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} to
                          {{RTCRtpTransceiverDirection/"sendonly"}}.
                        </p>
                      </li>
                      <li data-tests=
                      "legacy/RTCPeerConnection-createOffer-offerToReceive.html,legacy/RTCRtpTransceiver-with-OfferToReceive-options.https.html">
                        <p>
                          For each non-stopped
                          {{RTCRtpTransceiverDirection/"recvonly"}} transceiver
                          of [= transceiver kind =] <var>kind</var>, set
                          <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} to
                          {{RTCRtpTransceiverDirection/"inactive"}}.
                        </p>
                      </li>
                    </ol>
                    <p>
                      Continue with the next option, if any.
                    </p>
                  </li>
                  <li data-tests=
                  "legacy/RTCPeerConnection-createOffer-offerToReceive.html">
                    <p>
                      If <var>connection</var> has any non-stopped
                      {{RTCRtpTransceiverDirection/"sendrecv"}} or
                      {{RTCRtpTransceiverDirection/"recvonly"}} transceivers of
                      [= transceiver kind =] <var>kind</var>, continue with the
                      next option, if any.
                    </p>
                  </li>
                  <li data-tests="">
                    <p>
                      Let <var>transceiver</var> be the result of invoking the
                      equivalent of
                      <var>connection</var>.{{RTCPeerConnection/addTransceiver}}(<var>kind</var>),
                      except that this operation MUST NOT [= update the
                      negotiation-needed flag =].
                    </p>
                  </li>
                  <li class="untestable">
                    <p>
                      If <var>transceiver</var> is unset because the previous
                      operation threw an error, abort these steps.
                    </p>
                  </li>
                  <li data-tests=
                  "legacy/RTCPeerConnection-createOffer-offerToReceive.html,legacy/RTCRtpTransceiver-with-OfferToReceive-options.https.html">
                    <p>
                      Set <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} to
                      {{RTCRtpTransceiverDirection/"recvonly"}}.
                    </p>
                  </li>
                </ol>
              </li>
              <li data-tests=
              "legacy/RTCPeerConnection-createOffer-offerToReceive.html,legacy/RTCRtpTransceiver-with-OfferToReceive-options.https.html">
                <p>
                  Run the steps specified by {{RTCPeerConnection/createOffer}}
                  to create the offer.
                </p>
              </li>
            </ol>
            <div>
              <pre class="idl">partial dictionary RTCOfferOptions {
  boolean offerToReceiveAudio;
  boolean offerToReceiveVideo;
};
          </pre>
              <section>
                <h2>
                  Attributes
                </h2>
                <dl data-link-for="RTCOfferOptions" data-dfn-for=
                "RTCOfferOptions" class="dictionary-members">
                  <dt data-tests=
                  "legacy/RTCPeerConnection-createOffer-offerToReceive.html,legacy/RTCRtpTransceiver-with-OfferToReceive-options.https.html">
                    <dfn>offerToReceiveAudio</dfn> of type <span class=
                    "idlMemberType">boolean</span>
                  </dt>
                  <dd>
                    <p>
                      This setting provides additional control over the
                      directionality of audio. For example, it can be used to
                      ensure that audio can be received, regardless if audio is
                      sent or not.
                    </p>
                  </dd>
                  <dt data-tests=
                  "legacy/RTCPeerConnection-createOffer-offerToReceive.html,legacy/RTCRtpTransceiver-with-OfferToReceive-options.https.html">
                    <dfn>offerToReceiveVideo</dfn> of type <span class=
                    "idlMemberType">boolean</span>
                  </dt>
                  <dd>
                    <p>
                      This setting provides additional control over the
                      directionality of video. For example, it can be used to
                      ensure that video can be received, regardless if video is
                      sent or not.
                    </p>
                  </dd>
                </dl>
              </section>
            </div>
          </section>
        </section>
        <section class="untestable">
          <h2>
            Garbage collection
          </h2>
          <p>
            An {{RTCPeerConnection}} object MUST not be garbage collected as
            long as any event can cause an event handler to be triggered on the
            object. When the object's {{RTCPeerConnection/[[IsClosed]]}} internal slot is
            <code>true</code>, no such event handler can be triggered and it is
            therefore safe to garbage collect the object.
          </p>
          <p>
            All {{RTCDataChannel}} and {{MediaStreamTrack}} objects that are
            connected to an {{RTCPeerConnection}} have a strong reference to
            the {{RTCPeerConnection}} object.
          </p>
        </section>
      </section>
      <section>
        <h3>
          Error Handling
        </h3>
        <section>
          <h4>
            General Principles
          </h4>
          <p>
            All methods that return promises are governed by the standard error
            handling rules of promises. Methods that do not return promises may
            throw exceptions to indicate errors.
          </p>
        </section>
      </section>
      <section>
        <h3>
          Session Description Model
        </h3>
        <section>
          <h4>
            <dfn>RTCSdpType</dfn>
          </h4>
          <p>
            The {{RTCSdpType}} enum describes the type of an
            {{RTCSessionDescriptionInit}}, {{RTCLocalSessionDescriptionInit}},
            or {{RTCSessionDescription}} instance.
          </p>
          <div>
            <pre class="idl">enum RTCSdpType {
  "offer",
  "pranswer",
  "answer",
  "rollback"
};</pre>
            <table data-link-for="RTCSdpType" data-dfn-for="RTCSdpType" class=
            "simple">
              <thead>
                <tr>
                  <th colspan="2">
                    Enumeration description
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr data-tests=
                "RTCPeerConnection-setLocalDescription-offer.html">
                  <td>
                    <dfn data-idl="">offer</dfn>
                  </td>
                  <td>
                    <p>
                      An {{RTCSdpType}} of {{RTCSdpType/"offer"}} indicates
                      that a description MUST be treated as an [[!SDP]] offer.
                    </p>
                  </td>
                </tr>
                <tr data-tests=
                "RTCPeerConnection-setLocalDescription-pranswer.html">
                  <td>
                    <dfn data-idl="">pranswer</dfn>
                  </td>
                  <td>
                    <p>
                      An {{RTCSdpType}} of {{RTCSdpType/"pranswer"}} indicates
                      that a description MUST be treated as an [[!SDP]] answer,
                      but not a final answer. A description used as an SDP
                      pranswer may be applied as a response to an SDP offer, or
                      an update to a previously sent SDP pranswer.
                    </p>
                  </td>
                </tr>
                <tr data-tests=
                "RTCPeerConnection-setLocalDescription-answer.html">
                  <td>
                    <dfn data-idl="">answer</dfn>
                  </td>
                  <td>
                    <p>
                      An {{RTCSdpType}} of {{RTCSdpType/"answer"}} indicates
                      that a description MUST be treated as an [[!SDP]] final
                      answer, and the offer-answer exchange MUST be considered
                      complete. A description used as an SDP answer may be
                      applied as a response to an SDP offer or as an update to
                      a previously sent SDP pranswer.
                    </p>
                  </td>
                </tr>
                <tr data-tests=
                "RTCPeerConnection-setDescription-transceiver.html,RTCPeerConnection-setLocalDescription-rollback.html,RTCPeerConnection-setRemoteDescription-rollback.html">
                  <td>
                    <dfn data-idl="">rollback</dfn>
                  </td>
                  <td>
                    <p>
                      An {{RTCSdpType}} of {{RTCSdpType/"rollback"}} indicates
                      that a description MUST be treated as canceling the
                      current SDP negotiation and moving the SDP [[!SDP]] offer
                      back to what it was in the previous stable state. Note
                      the local or remote SDP descriptions in the previous
                      stable state could be <code>null</code> if there has not
                      yet been a successful offer-answer negotiation. An
                      {{RTCSdpType/"answer"}} or {{RTCSdpType/"pranswer"}}
                      cannot be rolled back.
                    </p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section>
          <h4>
            <dfn>RTCSessionDescription</dfn> Class
          </h4>
          <p>
            The {{RTCSessionDescription}} class is used by
            {{RTCPeerConnection}} to expose local and remote session
            descriptions.
          </p>
          <div>
            <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCSessionDescription {
  constructor(RTCSessionDescriptionInit descriptionInitDict);
  readonly attribute RTCSdpType type;
  readonly attribute DOMString sdp;
  [Default] object toJSON();
};</pre>
            <section>
              <h2>
                Constructors
              </h2>
              <dl data-link-for="RTCSessionDescription" data-dfn-for=
              "RTCSessionDescription" class="constructors">
                <dt>
                  <dfn>constructor()</dfn>
                </dt>
                <dd>
                  <p data-tests="">
                    The <dfn id="dom-sessiondescription"><code class=
                    "constructor">RTCSessionDescription()</code></dfn>
                    constructor takes a dictionary argument,
                    <var>description</var>, whose content is used to initialize
                    the new {{RTCSessionDescription}} object. This constructor
                    is deprecated; it exists for legacy compatibility reasons
                    only.
                  </p>
                </dd>
              </dl>
            </section>
            <section>
              <h2>
                Attributes
              </h2>
              <dl data-link-for="RTCSessionDescription" data-dfn-for=
              "RTCSessionDescription" class="attributes">
                <dt data-tests=
                "RTCPeerConnection-setLocalDescription-answer.html,RTCPeerConnection-setLocalDescription-offer.html,RTCPeerConnection-setLocalDescription-pranswer.html">
                  <dfn data-idl="">type</dfn> of type <span class=
                  "idlAttrType">{{RTCSdpType}}</span>, readonly
                </dt>
                <dd>
                  The type of this session description.
                </dd>
                <dt data-tests=
                "RTCPeerConnection-setLocalDescription-answer.html,RTCPeerConnection-setLocalDescription-offer.html,RTCPeerConnection-setLocalDescription-pranswer.html">
                  <dfn data-idl="">sdp</dfn> of type <span class=
                  "idlAttrType">DOMString</span>, readonly, defaulting to
                  <code>""</code>
                </dt>
                <dd>
                  The string representation of the SDP [[!SDP]].
                </dd>
              </dl>
            </section>
            <section>
              <h2>
                Methods
              </h2>
              <dl data-link-for="RTCSessionDescription" data-dfn-for=
              "RTCSessionDescription" class="methods">
                <dt>
                  <dfn>toJSON()</dfn>
                </dt>
                <dd data-tests="">
                  When called, run [[!WEBIDL]]'s [= default toJSON steps =].
                </dd>
              </dl>
            </section>
          </div>
          <div>
            <pre class="idl">dictionary RTCSessionDescriptionInit {
  required RTCSdpType type;
  DOMString sdp = "";
};</pre>
            <section>
              <h2>
                Dictionary <dfn>RTCSessionDescriptionInit</dfn> Members
              </h2>
              <dl data-link-for="RTCSessionDescriptionInit" data-dfn-for=
              "RTCSessionDescriptionInit" class="dictionary-members">
                <dt data-tests=
                "RTCPeerConnection-setRemoteDescription-answer.html,RTCPeerConnection-setRemoteDescription-offer.html,RTCPeerConnection-setRemoteDescription-pranswer.html">
                  <dfn data-idl="">type</dfn> of type <span class=
                  "idlMemberType">{{RTCSdpType}}</span>, required
                </dt>
                <dd>
                  The type of this session description.
                </dd>
                <dt data-tests=
                "RTCPeerConnection-setRemoteDescription-answer.html,RTCPeerConnection-setRemoteDescription-offer.html,RTCPeerConnection-setRemoteDescription-pranswer.html">
                  <dfn data-idl="">sdp</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd data-tests=
                "RTCPeerConnection-setLocalDescription-rollback.html">
                  The string representation of the SDP [[!SDP]]; if
                  {{RTCSessionDescriptionInit/type}} is {{RTCSdpType/"rollback"}},
                  this member is unused.
                </dd>
              </dl>
            </section>
          </div>
          <div>
            <pre class="idl">dictionary RTCLocalSessionDescriptionInit {
  RTCSdpType type;
  DOMString sdp = "";
};</pre>
            <section>
              <h2>
                Dictionary <dfn>RTCLocalSessionDescriptionInit</dfn> Members
              </h2>
              <dl data-link-for="RTCLocalSessionDescriptionInit" data-dfn-for=
              "RTCLocalSessionDescriptionInit" class="dictionary-members">
                <dt data-tests=
                "RTCPeerConnection-setLocalDescription-answer.html,RTCPeerConnection-setLocalDescription-offer.html,RTCPeerConnection-setLocalDescription-pranswer.html">
                  <dfn data-idl="">type</dfn> of type <span class=
                  "idlMemberType">{{RTCSdpType}}</span>
                </dt>
                <dd>
                  The type of this description. If not present, then
                  {{RTCPeerConnection/setLocalDescription}} will infer the type
                  based on the {{RTCPeerConnection}}'s [= signaling state =].
                </dd>
                <dt data-tests=
                "RTCPeerConnection-setLocalDescription-answer.html,RTCPeerConnection-setLocalDescription-offer.html,RTCPeerConnection-setLocalDescription-pranswer.html">
                  <dfn data-idl="">sdp</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd data-tests=
                "RTCPeerConnection-setLocalDescription-rollback.html">
                  The string representation of the SDP [[!SDP]]; if
                  {{RTCLocalSessionDescriptionInit/type}} is
                  {{RTCSdpType/"rollback"}}, this member is unused.
                </dd>
              </dl>
            </section>
          </div>
        </section>
      </section>
      <section>
        <h3>
          Session Negotiation Model
        </h3>
        <p>
          Many changes to state of an {{RTCPeerConnection}} will require
          communication with the remote side via the signaling channel, in
          order to have the desired effect. The app can be kept informed as to
          when it needs to do signaling, by listening to the
          {{RTCPeerConnection/negotiationneeded}} event. This event is fired
          according
          to the state of the connection's <dfn>negotiation-needed flag</dfn>,
          represented by a {{RTCPeerConnection/[[NegotiationNeeded]]}} internal slot.
        </p>
        <section class="informative">
          <h4>
            Setting Negotiation-Needed
          </h4>
          <p>
            If an operation is performed on an {{RTCPeerConnection}} that
            requires signaling, the connection will be marked as needing
            negotiation. Examples of such operations include adding or stopping
            an {{RTCRtpTransceiver}}, or adding the first {{ RTCDataChannel}}.
          </p>
          <p>
            Internal changes within the implementation can also result in the
            connection being marked as needing negotiation.
          </p>
          <p>
            Note that the exact procedures for [= update the negotiation-needed
            flag | updating the negotiation-needed flag =] are specified below.
          </p>
        </section>
        <section class="informative">
          <h4>
            Clearing Negotiation-Needed
          </h4>
          <p>
            The negotiation-needed flag is cleared when a session description
            of type {{RTCSdpType/"answer"}} [= set a session description | is
            set =] successfully, and the supplied description
            matches the state of the {{RTCRtpTransceiver}}s and
            {{RTCDataChannel}}s that currently exist on the
            {{RTCPeerConnection}}. Specifically, this means that all
            non-{{RTCRtpTransceiver/stopped}} transceivers have an [=
            associated =] section in the local description with matching
            properties, and, if any data channels have been created, a data
            section exists in the local description.
          </p>
          <p>
            Note that the exact procedures for [= update the negotiation-needed
            flag | updating the negotiation-needed flag =] are specified below.
          </p>
        </section>
        <section>
          <h4>
            Updating the Negotiation-Needed flag
          </h4>
          <p class="untestable">
            The process below occurs where referenced elsewhere in this
            document. It also may occur as a result of internal changes within
            the implementation that affect negotiation. If such changes occur,
            the user agent MUST [= update the negotiation-needed flag =].
          </p>
          <p data-tests="">
            To <dfn>update the negotiation-needed flag</dfn> for
            <var>connection</var>, run the following steps:
          </p>
          <ol>
            <li>
              <p>
                If the length of <var>connection</var>.{{RTCPeerConnection/[[Operations]]}}
                is not <code>0</code>, then set
                <var>connection</var>.{{RTCPeerConnection/[[UpdateNegotiationNeededFlagOnEmptyChain]]}}
                to <code>true</code>, and abort these steps.
              </p>
            </li>
            <li>
              <p>
                Queue a task to run the following steps:
              </p>
              <ol>
                <li class="untestable">
                  <p>
                    If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                    <code>true</code>, abort these steps.
                  </p>
                </li>
                <li>
                  <p>
                    If the length of
                    <var>connection</var>.{{RTCPeerConnection/[[Operations]]}} is not
                    <code>0</code>, then set
                    <var>connection</var>.{{RTCPeerConnection/[[UpdateNegotiationNeededFlagOnEmptyChain]]}}
                    to <code>true</code>, and abort these steps.
                  </p>
                </li>
                <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                  <p>
                    If <var>connection</var>'s [= signaling state =] is not
                    {{RTCSignalingState/"stable"}}, abort these steps.
                  </p>
                  <p class="note">
                    The negotiation-needed flag will be updated once the state
                    transitions to {{RTCSignalingState/"stable"}}, as part of
                    the steps for [= setting a session description =].
                  </p>
                </li>
                <li>
                  <p>
                    If the result of [= check if negotiation is needed |
                    checking if negotiation is needed =] is <code>false</code>,
                    <dfn>clear the negotiation-needed flag</dfn> by setting
                    <var>connection</var>.{{RTCPeerConnection/[[NegotiationNeeded]]}} to
                    <code>false</code>, and abort these steps.
                  </p>
                </li>
                <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                  <p>
                    If <var>connection</var>.{{RTCPeerConnection/[[NegotiationNeeded]]}} is
                    already <code>true</code>, abort these steps.
                  </p>
                </li>
                <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                  <p>
                    Set <var>connection</var>.{{RTCPeerConnection/[[NegotiationNeeded]]}} to
                    <code>true</code>.
                  </p>
                </li>
                <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                  <p>
                    [= Fire an event =] named {{RTCPeerConnection/negotiationneeded}} at
                    <var>connection</var>.
                  </p>
                </li>
              </ol>
              <div class="note">
                <p>
                  The task queueing prevents {{RTCPeerConnection/negotiationneeded}} from firing
                  prematurely, in the common situation where multiple
                  modifications to <var>connection</var> are being made at
                  once.
                </p>
                <p>
                  Additionally, we avoid racing with negotiation methods by
                  only firing {{RTCPeerConnection/negotiationneeded}} when the [= operations
                  chain =] is empty.
                </p>
              </div>
            </li>
          </ol>
          <p>
            To <dfn>check if negotiation is needed</dfn> for
            <var>connection</var>, perform the following checks:
          </p>
          <ol>
            <li class="untestable">
              <p>
                If any implementation-specific negotiation is required, as
                described at the start of this section, return
                <code>true</code>.
              </p>
            </li>
            <li>
              <p>
                If
                <var>connection</var>.{{RTCPeerConnection/[[LocalIceCredentialsToReplace]]}}
                is not empty, return <code>true</code>.
              </p>
            </li>
            <li>
              <p>
                Let <var>description</var> be
                <var>connection</var>.{{RTCPeerConnection/[[CurrentLocalDescription]]}}.
              </p>
            </li>
            <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
              <p>
                If <var>connection</var> has created any {{RTCDataChannel}}s,
                and no m= section in <var>description</var> has been negotiated
                yet for data, return <code>true</code>.
              </p>
            </li>
            <li>
              <p>
                For each <var>transceiver</var> in <var>connection</var>'s [=
                set of transceivers =], perform the following checks:
              </p>
              <ol>
                <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                  <p>
                    If <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopping]]}} is
                    <code>true</code> and
                    <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopped]]}} is
                    <code>false</code>, return <code>true</code>.
                  </p>
                </li>
                <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                  <p>
                    If <var>transceiver</var> isn't {{RTCRtpTransceiver/
                    stopped}} and isn't yet [= associated =] with an m= section
                    in <var>description</var>, return <code>true</code>.
                  </p>
                </li>
                <li>
                  <p>
                    If <var>transceiver</var> isn't {{RTCRtpTransceiver/
                    stopped}} and is [= associated =] with an m= section in
                    <var>description</var> then perform the following checks:
                  </p>
                  <ol>
                    <li>
                      <p>
                        If <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} is
                        {{RTCRtpTransceiverDirection/"sendrecv"}} or
                        {{RTCRtpTransceiverDirection/"sendonly"}}, and the [=
                        associated =] m= section in <var>description</var>
                        either doesn't contain a single <code class=
                        "sdp">a=msid</code> line, or the number of MSIDs from
                        the <code class="sdp">a=msid</code> lines in this
                        <code class="sdp">m=</code> section, or the MSID values
                        themselves, differ from what is in
                        <var>transceiver</var>.sender.{{RTCRtpSender/[[AssociatedMediaStreamIds]]}},
                        return <code>true</code>.
                      </p>
                    </li>
                    <li>
                      <p>
                        If <var>description</var> is of type
                        {{RTCSdpType/"offer"}}, and the direction of the [=
                        associated =] m= section in neither
                        <var>connection</var>.{{RTCPeerConnection/[[CurrentLocalDescription]]}}
                        nor
                        <var>connection</var>.{{RTCPeerConnection/[[CurrentRemoteDescription]]}}
                        matches <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}},
                        return <code>true</code>. In this step, when the
                        direction is compared with a direction found in
                        {{RTCPeerConnection/[[CurrentRemoteDescription]]}}, the description's
                        direction must be reversed to represent the peer's
                        point of view.
                      </p>
                    </li>
                    <li>
                      <p>
                        If <var>description</var> is of type
                        {{RTCSdpType/"answer"}}, and the direction of the [=
                        associated =] m= section in the <var>description</var>
                        does not match
                        <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}}
                        intersected with the offered direction (as described in
                        <span data-jsep="initial-answers">[[!RFC8829]]</span>),
                        return <code>true</code>.
                      </p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>
                    If <var>transceiver</var> is {{RTCRtpTransceiver/ stopped}}
                    and is [= associated =] with an m= section, but the
                    associated m= section is not yet rejected in
                    <var>connection</var>.{{RTCPeerConnection/[[CurrentLocalDescription]]}}
                    or
                    <var>connection</var>.{{RTCPeerConnection/[[CurrentRemoteDescription]]}},
                    return <code>true</code>.
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <p>
                If all the preceding checks were performed and
                <code>true</code> was not returned, nothing remains to be
                negotiated; return <code>false</code>.
              </p>
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h3>
          Interfaces for Interactive Connectivity Establishment
        </h3>
        <section>
          <h4>
            <dfn>RTCIceCandidate</dfn> Interface
          </h4>
          <p>
            This interface describes an ICE candidate, described in [[RFC5245]]
            Section 2. Other than {{RTCIceCandidateInit/candidate}},
            {{RTCIceCandidateInit/sdpMid}},
            {{RTCIceCandidateInit/sdpMLineIndex}}, and
            {{RTCIceCandidateInit/usernameFragment}}, the remaining attributes
            are derived from parsing the {{RTCIceCandidateInit/candidate}}
            member in <var>candidateInitDict</var>, if it is well formed.
          </p>
          <div>
            <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCIceCandidate {
  constructor(optional RTCIceCandidateInit candidateInitDict = {});
  readonly attribute DOMString candidate;
  readonly attribute DOMString? sdpMid;
  readonly attribute unsigned short? sdpMLineIndex;
  readonly attribute DOMString? foundation;
  readonly attribute RTCIceComponent? component;
  readonly attribute unsigned long? priority;
  readonly attribute DOMString? address;
  readonly attribute RTCIceProtocol? protocol;
  readonly attribute unsigned short? port;
  readonly attribute RTCIceCandidateType? type;
  readonly attribute RTCIceTcpCandidateType? tcpType;
  readonly attribute DOMString? relatedAddress;
  readonly attribute unsigned short? relatedPort;
  readonly attribute DOMString? usernameFragment;
  RTCIceCandidateInit toJSON();
};</pre>
            <section>
              <h2>
                Constructor
              </h2>
              <dl data-link-for="RTCIceCandidate" data-dfn-for=
              "RTCIceCandidate" class="constructors">
                <dt>
                  <dfn>constructor()</dfn>
                </dt>
                <dd>
                  <p>
                    The <dfn><code class=
                    "constructor">RTCIceCandidate()</code></dfn> constructor
                    takes a dictionary argument, <var>candidateInitDict</var>,
                    whose content is used to initialize the new
                    {{RTCIceCandidate}} object.
                  </p>
                  <p>
                    When invoked, run the following steps:
                  </p>
                  <ol>
                    <li data-tests="RTCIceCandidate-constructor.html">If both
                    the {{RTCIceCandidateInit/sdpMid}} and
                    {{RTCIceCandidateInit/sdpMLineIndex}} members of
                    <var>candidateInitDict</var> are <code>null</code>, [=
                    exception/throw =] a {{TypeError}}.
                    </li>
                    <li data-tests="RTCIceCandidate-constructor.html">
                      <p>
                        Return the result of [= creating an RTCIceCandidate =]
                        with <var>candidateInitDict</var>.
                      </p>
                    </li>
                  </ol>
                  <p>
                    To <dfn data-lt="creating an RTCIceCandidate">create an
                    RTCIceCandidate</dfn> with a <var>candidateInitDict</var>
                    dictionary, run the following steps:
                  </p>
                  <ol>
                    <li>Let <var>iceCandidate</var> be a newly created
                    {{RTCIceCandidate}} object.
                    </li>
                    <li>Create internal slots for the following attributes of
                    <var>iceCandidate</var>, initilized to <code>null</code>:
                    {{foundation}}, {{component}}, {{priority}}, {{address}},
                    {{protocol}}, {{port}}, {{type}}, {{tcpType}},
                    {{relatedAddress}}, and {{relatedPort}}.
                    </li>
                    <li>Create internal slots for the following attributes of
                    <var>iceCandidate</var>, initilized to their namesakes in
                    <var>candidateInitDict</var>: {{candidate}}, {{sdpMid}},
                    {{sdpMLineIndex}}, {{usernameFragment}}.
                    </li>
                    <li>Let <var>candidate</var> be the
                    {{RTCIceCandidateInit/candidate}} dictionary member of
                    <var>candidateInitDict</var>. If <var>candidate</var> is
                    not an empty string, run the following steps:
                      <ol data-tests="RTCIceCandidate-constructor.html">
                        <li>Parse <var>candidate</var> using the [=
                        candidate-attribute =] grammar.
                        </li>
                        <li>If parsing of [= candidate-attribute =] has failed,
                        abort these steps.
                        </li>
                        <li>If any field in the parse result represents an
                        invalid value for the corresponding attribute in <var>
                          iceCandidate</var>, abort these steps.
                        </li>
                        <li>Set the corresponding internal slots in
                        <var>iceCandidate</var> to the field values of the
                        parsed result.
                        </li>
                      </ol>
                    </li>
                    <li class="no-test-needed">Return <var>iceCandidate</var>.
                    </li>
                  </ol>
                  <div class="note">
                    <p>
                      The constructor for {{RTCIceCandidate}} only does basic
                      parsing and type checking for the dictionary members in
                      <var>candidateInitDict</var>. Detailed validation on the
                      well-formedness of {{RTCIceCandidateInit/candidate}},
                      {{RTCIceCandidateInit/sdpMid}},
                      {{RTCIceCandidateInit/sdpMLineIndex}},
                      {{RTCIceCandidateInit/usernameFragment}} with the
                      corresponding session description is done when passing
                      the {{RTCIceCandidate}} object to
                      {{RTCPeerConnection/addIceCandidate()}}.
                    </p>
                    <p>
                      To maintain backward compatibility, any error on parsing
                      the <var>candidate</var> attribute is ignored. In such
                      case, the {{candidate}} attribute holds the raw
                      {{RTCIceCandidateInit/candidate}} string given in
                      <var>candidateInitDict</var>, but derivative attributes
                      such as {{foundation}}, {{priority}}, etc are set to
                      <code>null</code>.
                    </p>
                  </div>
                </dd>
              </dl>
            </section>
            <section>
              <h2>
                Attributes
              </h2>
              <p>
                Most attributes below are defined in section 15.1 of [[RFC5245]].
              </p>
              <dl data-link-for="RTCIceCandidate" data-dfn-for=
              "RTCIceCandidate" class="attributes">
                <dt data-tests="">
                  <dfn data-idl="">candidate</dfn> of type <span class=
                  "idlAttrType">DOMString</span>, readonly
                </dt>
                <dd>
                  This carries the [= candidate-attribute =] as defined in
                  section 15.1 of [[RFC5245]]. If this {{RTCIceCandidate}}
                  represents an end-of-candidates indication or a peer
                  reflexive remote candidate, {{candidate}} is an empty string.
                </dd>
                <dt data-tests="">
                  <dfn data-idl="">sdpMid</dfn> of type <span class=
                  "idlAttrType">DOMString</span>, readonly, nullable
                </dt>
                <dd>
                  If not <code>null</code>, this contains the <dfn>media stream
                  "identification-tag"</dfn> defined in [[!RFC5888]] for the
                  media component this candidate is associated with.
                </dd>
                <dt data-tests="">
                  <dfn data-idl="">sdpMLineIndex</dfn> of type <span class=
                  "idlAttrType">unsigned short</span>, readonly, nullable
                </dt>
                <dd>
                  If not <code>null</code>, this indicates the index (starting
                  at zero) of the [= media description =] in the SDP this
                  candidate is associated with.
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">foundation</dfn> of type <span class=
                  "idlAttrType">DOMString</span>, readonly, nullable
                </dt>
                <dd>
                  A unique identifier that allows ICE to correlate candidates
                  that appear on multiple {{RTCIceTransport}}s.
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">component</dfn> of type <span class=
                  "idlAttrType">{{RTCIceComponent}}</span>, readonly, nullable
                </dt>
                <dd>
                  The assigned network component of the candidate
                  ({{RTCIceComponent/"rtp"}} or {{RTCIceComponent/"rtcp"}}).
                  This corresponds to the <code class="ice">component-id</code>
                  field in [= candidate-attribute =], decoded to the string
                  representation as defined in {{RTCIceComponent}}.
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">priority</dfn> of type <span class=
                  "idlAttrType">unsigned long</span>, readonly, nullable
                </dt>
                <dd>
                  The assigned priority of the candidate.
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">address</dfn> of type <span class=
                  "idlAttrType">DOMString</span>, readonly, nullable
                </dt>
                <dd>
                  <p>
                    The address of the candidate, allowing for IPv4 addresses,
                    IPv6 addresses, and fully qualified domain names (FQDNs).
                    This corresponds to the <code class=
                    "ice">connection-address</code> field in [=
                    candidate-attribute =].
                  </p>
                  <p>
                    Remote candidates may be exposed, for instance via
                    {{RTCIceTransport/[[SelectedCandidatePair]]}}.{{RTCIceCandidatePair/remote}}.
                    By default, the user agent MUST leave the
                    {{RTCIceCandidate/address}} attribute as <code>null</code>
                    for any exposed remote candidate. Once a
                    {{RTCPeerConnection}} instance learns on an address by the
                    web application using
                    {{RTCPeerConnection/addIceCandidate}}, the user agent can
                    expose the {{address}} attribute value in any
                    {{RTCIceCandidate}} of the {{RTCPeerConnection}} instance
                    representing a remote candidate with that newly learnt
                    address.
                  </p>
                  <div class="note">
                    <p>
                      The addresses exposed in candidates gathered via ICE and
                      made visibile to the application in {{RTCIceCandidate}}
                      instances can reveal more information about the device
                      and the user (e.g. location, local network topology) than
                      the user might have expected in a non-WebRTC enabled
                      browser.
                    </p>
                    <p>
                      These addresses are always exposed to the application,
                      and potentially exposed to the communicating party, and
                      can be exposed without any specific user consent (e.g.
                      for peer connections used with data channels, or to
                      receive media only).
                    </p>
                    <p class="fingerprint">
                      These addresses can also be used as temporary or
                      persistent cross-origin states, and thus contribute to
                      the fingerprinting surface of the device.
                    </p>
                    <p>
                      Applications can avoid exposing addresses to the
                      communicating party, either temporarily or permanently,
                      by forcing the [= ICE Agent =] to report only relay
                      candidates via the
                      {{RTCConfiguration/iceTransportPolicy}} member of
                      {{RTCConfiguration}}.
                    </p>
                    <p>
                      To limit the addresses exposed to the application itself,
                      browsers can offer their users different policies
                      regarding sharing local addresses, as defined in
                      [[RFC8828]].
                    </p>
                  </div>
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">protocol</dfn> of type <span class=
                  "idlAttrType">{{RTCIceProtocol}}</span>, readonly, nullable
                </dt>
                <dd>
                  The protocol of the candidate
                  ({{RTCIceProtocol/"udp"}}/{{RTCIceProtocol/"tcp"}}). This
                  corresponds to the <code class="ice">transport</code> field
                  in [= candidate-attribute =].
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">port</dfn> of type <span class=
                  "idlAttrType">unsigned short</span>, readonly, nullable
                </dt>
                <dd>
                  The port of the candidate.
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">type</dfn> of type <span class=
                  "idlAttrType">{{RTCIceCandidateType}}</span>, readonly,
                  nullable
                </dt>
                <dd>
                  The type of the candidate. This corresponds to the
                  <code class="ice">candidate-types</code> field in [=
                  candidate-attribute =].
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">tcpType</dfn> of type <span class=
                  "idlAttrType">{{RTCIceTcpCandidateType}}</span>, readonly,
                  nullable
                </dt>
                <dd>
                  If {{protocol}} is {{RTCIceProtocol/"tcp"}}, {{tcpType}}
                  represents the type of TCP candidate. Otherwise, {{tcpType}}
                  is <code>null</code>. This corresponds to the <code class=
                  "ice">tcp-type</code> field in [= candidate-attribute =].
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn>relatedAddress</dfn> of type <span class=
                  "idlAttrType">DOMString</span>, readonly, nullable
                </dt>
                <dd>
                  For a candidate that is derived from another, such as a relay
                  or reflexive candidate, the {{relatedAddress}} is the IP
                  address of the candidate that it is derived from. For host
                  candidates, the {{relatedAddress}} is <code>null</code>. This
                  corresponds to the <code class="ice">rel-address</code> field
                  in [= candidate-attribute =].
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn>relatedPort</dfn> of type <span class=
                  "idlAttrType">unsigned short</span>, readonly, nullable
                </dt>
                <dd>
                  For a candidate that is derived from another, such as a relay
                  or reflexive candidate, the {{relatedPort}} is the port of
                  the candidate that it is derived from. For host candidates,
                  the {{relatedPort}} is <code>null</code>. This corresponds to
                  the <code class="ice">rel-port</code> field in [=
                  candidate-attribute =].
                </dd>
                <dt data-tests="">
                  <dfn>usernameFragment</dfn> of type <span class=
                  "idlAttrType">DOMString</span>, readonly, nullable
                </dt>
                <dd>
                  This carries the <code class="ice">ufrag</code> as defined in
                  section 15.4 of [[RFC5245]].
                </dd>
              </dl>
            </section>
            <section>
              <h2>
                Methods
              </h2>
              <dl data-link-for="RTCIceCandidate" data-dfn-for=
              "RTCIceCandidate" class="methods">
                <dt>
                  <dfn data-idl="">toJSON()</dfn>
                </dt>
                <dd>
                  To invoke the {{toJSON()}} operation of the
                  {{RTCIceCandidate}} interface, run the following steps:
                  <ol>
                    <li class="no-test-needed">Let <var>json</var> be a new
                    {{RTCIceCandidateInit}} dictionary.
                    </li>
                    <li data-tests="">For each attribute identifier
                    <var>attr</var> in «{{candidate}}, {{sdpMid}},
                    {{sdpMLineIndex}}, {{usernameFragment}}»:
                      <ol>
                        <li>Let <var>value</var> be the result of getting the
                        underlying value of the attribute identified by
                        <var>attr</var>, given this {{RTCIceCandidate}} object.
                        </li>
                        <li>Set <code><var>json</var>[<var>attr</var>]</code>
                        to <var>value</var>.
                        </li>
                      </ol>
                    </li>
                    <li class="no-test-needed">Return <var>json</var>.
                    </li>
                  </ol>
                </dd>
              </dl>
            </section>
          </div>
          <div>
            <pre class="idl">dictionary RTCIceCandidateInit {
  DOMString candidate = "";
  DOMString? sdpMid = null;
  unsigned short? sdpMLineIndex = null;
  DOMString? usernameFragment = null;
};</pre>
            <section>
              <h2>
                Dictionary <dfn>RTCIceCandidateInit</dfn> Members
              </h2>
              <dl data-link-for="RTCIceCandidateInit" data-dfn-for=
              "RTCIceCandidateInit" class="dictionary-members">
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">candidate</dfn> of type <span class=
                  "idlMemberType">DOMString</span>, defaulting to
                  <code>""</code>
                </dt>
                <dd>
                  This carries the [= candidate-attribute =] as defined in
                  section 15.1 of [[RFC5245]]. If this represents an
                  end-of-candidates indication, {{candidate}} is an empty
                  string.
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">sdpMid</dfn> of type <span class=
                  "idlMemberType">DOMString</span>, nullable, defaulting to
                  <code>null</code>
                </dt>
                <dd>
                  If not <code>null</code>, this contains the [= media stream
                  "identification-tag" =] defined in [[!RFC5888]] for the media
                  component this candidate is associated with.
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">sdpMLineIndex</dfn> of type <span class=
                  "idlMemberType">unsigned short</span>, nullable, defaulting
                  to <code>null</code>
                </dt>
                <dd>
                  If not <code>null</code>, this indicates the index (starting
                  at zero) of the [= media description =] in the SDP this
                  candidate is associated with.
                </dd>
                <dt data-tests="RTCIceCandidate-constructor.html">
                  <dfn data-idl="">usernameFragment</dfn> of type <span class=
                  "idlMemberType">DOMString</span>, nullable, defaulting to
                  <code>null</code>
                </dt>
                <dd>
                  If not <code>null</code>, this carries the <code class=
                  "ice">ufrag</code> as defined in section 15.4 of [[RFC5245]].
                </dd>
              </dl>
            </section>
          </div>
          <section>
            <h4>
              <dfn><code class="ice">candidate-attribute</code></dfn> Grammar
            </h4>
            <p>
              The [= candidate-attribute =] grammar is used to parse the
              {{RTCIceCandidateInit/candidate}} member of
              <var>candidateInitDict</var> in the {{RTCIceCandidate()}}
              constructor.
            </p>
            <p>
              The primary grammar for [= candidate-attribute =] is defined in
              section 15.1 of [[RFC5245]]. In addition, the browser MUST support
              the grammar extension for ICE TCP as defined in section 4.5 of
              [[!RFC6544]].
            </p>
            <p class="untestable">
              The browser MAY support other grammar extensions for [=
              candidate-attribute =] as defined in other RFCs.
            </p>
          </section>
          <section>
            <h4>
              <dfn>RTCIceProtocol</dfn> Enum
            </h4>
            <p>
              The {{RTCIceProtocol}} represents the protocol of the ICE
              candidate.
            </p>
            <div>
              <pre class="idl">enum RTCIceProtocol {
  "udp",
  "tcp"
};</pre>
              <table data-link-for="RTCIceProtocol" data-dfn-for=
              "RTCIceProtocol" class="simple">
                <thead>
                  <tr>
                    <th colspan="2">
                      Enumeration description
                    </th>
                  </tr>
                </thead>
                <tbody>
                  <tr data-tests="RTCIceCandidate-constructor.html">
                    <td>
                      <dfn data-idl="">udp</dfn>
                    </td>
                    <td>
                      A UDP candidate, as described in [[RFC5245]].
                    </td>
                  </tr>
                  <tr data-tests="">
                    <td>
                      <dfn data-idl="">tcp</dfn>
                    </td>
                    <td>
                      A TCP candidate, as described in [[!RFC6544]].
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section>
            <h4>
              <dfn>RTCIceTcpCandidateType</dfn> Enum
            </h4>
            <p>
              The {{RTCIceTcpCandidateType}} represents the type of the ICE TCP
              candidate, as defined in [[!RFC6544]].
            </p>
            <div>
              <pre class="idl">enum RTCIceTcpCandidateType {
  "active",
  "passive",
  "so"
};</pre>
              <table data-link-for="RTCIceTcpCandidateType" data-dfn-for=
              "RTCIceTcpCandidateType" class="simple">
                <thead>
                  <tr>
                    <th colspan="2">
                      Enumeration description
                    </th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td data-tests="">
                      <dfn data-idl="">active</dfn>
                    </td>
                    <td>
                      An {{RTCIceTcpCandidateType/"active"}} TCP candidate is
                      one for which the transport will attempt to open an
                      outbound connection but will not receive incoming
                      connection requests.
                    </td>
                  </tr>
                  <tr>
                    <td data-tests="">
                      <dfn data-idl="">passive</dfn>
                    </td>
                    <td>
                      A {{RTCIceTcpCandidateType/"passive"}} TCP candidate is
                      one for which the transport will receive incoming
                      connection attempts but not attempt a connection.
                    </td>
                  </tr>
                  <tr>
                    <td data-tests="">
                      <dfn data-idl="">so</dfn>
                    </td>
                    <td>
                      An {{RTCIceTcpCandidateType/"so"}} candidate is one for
                      which the transport will attempt to open a connection
                      simultaneously with its peer.
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p class="note">
              The user agent will typically only gather
              {{RTCIceTcpCandidateType/active}} ICE TCP candidates.
            </p>
          </section>
          <section>
            <h4>
              <dfn>RTCIceCandidateType</dfn> Enum
            </h4>
            <p>
              The {{RTCIceCandidateType}} represents the type of the ICE
              candidate, as defined in [[RFC5245]] section 15.1.
            </p>
            <div>
              <pre class="idl">enum RTCIceCandidateType {
  "host",
  "srflx",
  "prflx",
  "relay"
};</pre>
              <table data-link-for="RTCIceCandidateType" data-dfn-for=
              "RTCIceCandidateType" class="simple">
                <thead>
                  <tr>
                    <th colspan="2">
                      Enumeration description
                    </th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td data-tests="protocol/candidate-exchange.https.html">
                      <dfn data-idl="">host</dfn>
                    </td>
                    <td>
                      A host candidate, as defined in Section 4.1.1.1 of
                      [[RFC5245]].
                    </td>
                  </tr>
                  <tr>
                    <td data-tests="">
                      <dfn data-idl="">srflx</dfn>
                    </td>
                    <td>
                      A server reflexive candidate, as defined in Section
                      4.1.1.2 of [[RFC5245]].
                    </td>
                  </tr>
                  <tr>
                    <td data-tests="protocol/candidate-exchange.https.html">
                      <dfn data-idl="">prflx</dfn>
                    </td>
                    <td>
                      A peer reflexive candidate, as defined in Section 4.1.1.2
                      of [[RFC5245]].
                    </td>
                  </tr>
                  <tr>
                    <td data-tests="">
                      <dfn data-idl="">relay</dfn>
                    </td>
                    <td>
                      A relay candidate, as defined in Section 7.1.3.2.1 of
                      [[RFC5245]].
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
        <section>
          <h4>
            <dfn>RTCPeerConnectionIceEvent</dfn>
          </h4>
          <p>
            The {{RTCPeerConnection/icecandidate}} event of the
            {{RTCPeerConnection}} uses the {{RTCPeerConnectionIceEvent}}
            interface.
          </p>
          <p data-tests="RTCPeerConnectionIceEvent-constructor.html">
            When firing an {{RTCPeerConnectionIceEvent}} event that contains an
            {{RTCIceCandidate}} object, it MUST include values for both
            {{RTCIceCandidate/sdpMid}} and {{RTCIceCandidate/sdpMLineIndex}}.
            If the {{RTCIceCandidate}} is of type
            {{RTCIceCandidateType/"srflx"}} or type
            {{RTCIceCandidateType/"relay"}}, the
            {{RTCPeerConnectionIceEvent/url}} property of the event MUST be set
            to the URL of the ICE server from which the candidate was obtained.
          </p>
          <div class="note">
            The {{RTCPeerConnection/icecandidate}} event is used for three different types of
            indications:
            <ul>
              <li>
                <p>
                  A candidate has been gathered. The
                  {{RTCPeerConnectionIceEvent/candidate}} member of the event
                  will be populated normally. It should be signaled to the
                  remote peer and passed into
                  {{RTCPeerConnection/addIceCandidate}}.
                </p>
              </li>
              <li>
                <p>
                  An {{RTCIceTransport}} has finished gathering a [= generation
                  =] of candidates, and is providing an end-of-candidates
                  indication as defined by Section 8.2 of [[RFC8838]]. This
                  is indicated by
                  {{RTCPeerConnectionIceEvent/candidate}}.{{RTCIceCandidate/candidate}}
                  being set to an empty string. The
                  {{RTCPeerConnectionIceEvent/candidate}} object should be
                  signaled to the remote peer and passed into
                  {{RTCPeerConnection/addIceCandidate}} like a typical ICE
                  candidate, in order to provide the end-of-candidates
                  indication to the remote peer.
                </p>
              </li>
              <li>
                <p>
                  All {{RTCIceTransport}}s have finished gathering candidates,
                  and the {{RTCPeerConnection}}'s {{RTCIceGatheringState}} has
                  transitioned to {{RTCIceGatheringState/"complete"}}. This is
                  indicated by the {{RTCPeerConnectionIceEvent/candidate}}
                  member of the event being set to <code>null</code>. This only
                  exists for backwards compatibility, and this event does not
                  need to be signaled to the remote peer. It's equivalent to an
                  {{RTCPeerConnection/icegatheringstatechange}} event with the
                  {{RTCIceGatheringState/"complete"}} state.
                </p>
              </li>
            </ul>
          </div>
          <div>
            <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCPeerConnectionIceEvent : Event {
  constructor(DOMString type, optional RTCPeerConnectionIceEventInit eventInitDict = {});
  readonly attribute RTCIceCandidate? candidate;
  readonly attribute DOMString? url;
};</pre>
            <section>
              <h2>
                Constructors
              </h2>
              <dl data-link-for="RTCPeerConnectionIceEvent" data-dfn-for=
              "RTCPeerConnectionIceEvent" class="constructors">
                <dt data-tests="RTCPeerConnectionIceEvent-constructor.html">
                  <dfn>RTCPeerConnectionIceEvent.constructor()</dfn>
                </dt>
                <dd></dd>
              </dl>
            </section>
            <section>
              <h2>
                Attributes
              </h2>
              <dl data-link-for="RTCPeerConnectionIceEvent" data-dfn-for=
              "RTCPeerConnectionIceEvent" class="attributes">
                <dt data-tests="RTCPeerConnectionIceEvent-constructor.html">
                  <dfn data-idl="">candidate</dfn> of type <span class=
                  "idlAttrType">{{RTCIceCandidate}}</span>, readonly, nullable
                </dt>
                <dd>
                  <p>
                    The {{candidate}} attribute is the {{RTCIceCandidate}}
                    object with the new ICE candidate that caused the event.
                  </p>
                  <p>
                    This attribute is set to <code>null</code> when an event is
                    generated to indicate the end of candidate gathering.
                  </p>
                  <p class="note">
                    Even where there are multiple media components, only one
                    event containing a <code>null</code> candidate is fired.
                  </p>
                </dd>
                <dt data-tests="RTCPeerConnectionIceEvent-constructor.html">
                  <dfn data-idl="">url</dfn> of type <span class=
                  "idlAttrType">DOMString</span>, readonly, nullable
                </dt>
                <dd>
                  <p>
                    The {{url}} attribute is the STUN or TURN URL that
                    identifies the STUN or TURN server used to gather this
                    candidate. If the candidate was not gathered from a STUN or
                    TURN server, this parameter will be set to
                    <code>null</code>.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
          <div>
            <pre class="idl">dictionary RTCPeerConnectionIceEventInit : EventInit {
  RTCIceCandidate? candidate;
  DOMString? url;
};</pre>
            <section>
              <h2>
                Dictionary <dfn>RTCPeerConnectionIceEventInit</dfn> Members
              </h2>
              <dl data-link-for="RTCPeerConnectionIceEventInit" data-dfn-for=
              "RTCPeerConnectionIceEventInit" class="dictionary-members">
                <dt data-tests="RTCPeerConnectionIceEvent-constructor.html">
                  <dfn data-idl="">candidate</dfn> of type <span class=
                  "idlMemberType">{{RTCIceCandidate}}</span>, nullable
                </dt>
                <dd>
                  <p>
                    See the {{RTCPeerConnectionIceEvent/candidate}} attribute
                    of the {{RTCPeerConnectionIceEvent}} interface.
                  </p>
                </dd>
                <dt data-tests="RTCPeerConnectionIceEvent-constructor.html">
                  <dfn data-idl="">url</dfn> of type <span class=
                  "idlMemberType">DOMString</span>, nullable
                </dt>
                <dd>
                  The {{url}} attribute is the STUN or TURN URL that identifies
                  the STUN or TURN server used to gather this candidate.
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section>
          <h4>
            <dfn>RTCPeerConnectionIceErrorEvent</dfn>
          </h4>
          <p>
            The {{RTCPeerConnection/icecandidateerror}} event of the
            {{RTCPeerConnection}} uses the {{RTCPeerConnectionIceErrorEvent}}
            interface.
          </p>
          <div>
            <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCPeerConnectionIceErrorEvent : Event {
  constructor(DOMString type, RTCPeerConnectionIceErrorEventInit eventInitDict);
  readonly attribute DOMString? address;
  readonly attribute unsigned short? port;
  readonly attribute DOMString url;
  readonly attribute unsigned short errorCode;
  readonly attribute USVString errorText;
};</pre>
            <section>
              <h2>
                Constructors
              </h2>
              <dl data-link-for="RTCPeerConnectionIceErrorEvent" data-dfn-for=
              "RTCPeerConnectionIceErrorEvent" class="constructors">
                <dt data-tests="RTCPeerConnectionIceErrorEvent.html">
                  <dfn>RTCPeerConnectionIceErrorEvent.constructor()</dfn>
                </dt>
                <dd></dd>
              </dl>
            </section>
            <section>
              <h2>
                Attributes
              </h2>
              <dl data-link-for="RTCPeerConnectionIceErrorEvent" data-dfn-for=
              "RTCPeerConnectionIceErrorEvent" class="attributes">
                <dt data-tests=
                "RTCPeerConnection-onicecandidateerror.https.html">
                  <dfn data-idl="">address</dfn> of type <span class=
                  "idlAttrType">DOMString</span>, readonly, nullable
                </dt>
                <dd>
                  <p>
                    The {{address}} attribute is the local IP address used to
                    communicate with the STUN or TURN server.
                  </p>
                  <p>
                    On a multihomed system, multiple interfaces may be used to
                    contact the server, and this attribute allows the
                    application to figure out on which one the failure
                    occurred.
                  </p>
                  <p>
                    If the local IP address value is not already exposed as
                    part of a local candidate, the {{address}} attribute will
                    be set to <code>null</code>.
                  </p>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-onicecandidateerror.https.html">
                  <dfn data-idl="">port</dfn> of type <span class=
                  "idlAttrType">unsigned short</span>, readonly, nullable
                </dt>
                <dd>
                  <p>
                    The {{port}} attribute is the port used to communicate with
                    the STUN or TURN server.
                  </p>
                  <p>
                    If the {{address}} attribute is <code>null</code>, the
                    {{port}} attribute is also set to <code>null</code>.
                  </p>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-onicecandidateerror.https.html">
                  <dfn data-idl="">url</dfn> of type <span class=
                  "idlAttrType">DOMString</span>, readonly
                </dt>
                <dd>
                  <p>
                    The {{url}} attribute is the STUN or TURN URL that
                    identifies the STUN or TURN server for which the failure
                    occurred.
                  </p>
                </dd>
                <dt data-tests=
                "RTCPeerConnection-onicecandidateerror.https.html">
                  <dfn data-idl="">errorCode</dfn> of type <span class=
                  "idlAttrType">unsigned short</span>, readonly
                </dt>
                <dd>
                  <p>
                    The {{errorCode}} attribute is the numeric STUN error code
                    returned by the STUN or TURN server [[STUN-PARAMETERS]].
                  </p>
                  <p data-tests="">
                    If no host candidate can reach the server, {{errorCode}}
                    will be set to the value 701 which is outside the STUN
                    error code range. This error is only fired once per server
                    URL while in the {{RTCIceGatheringState}} of
                    {{RTCIceGatheringState/"gathering"}}.
                  </p>
                </dd>
                <dt data-tests="">
                  <dfn data-idl="">errorText</dfn> of type <span class=
                  "idlAttrType">USVString</span>, readonly
                </dt>
                <dd>
                  <p>
                    The {{errorText}} attribute is the STUN reason text
                    returned by the STUN or TURN server [[STUN-PARAMETERS]].
                  </p>
                  <p>
                    If the server could not be reached, {{errorText}} will be
                    set to an implementation-specific value providing details
                    about the error.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
          <div>
            <pre class="idl">dictionary RTCPeerConnectionIceErrorEventInit : EventInit {
  DOMString? address;
  unsigned short? port;
  DOMString url;
  required unsigned short errorCode;
  USVString errorText;
};</pre>
            <section>
              <h2>
                Dictionary <dfn>RTCPeerConnectionIceErrorEventInit</dfn>
                Members
              </h2>
              <dl data-link-for="RTCPeerConnectionIceErrorEventInit"
              data-dfn-for="RTCPeerConnectionIceErrorEventInit" class=
              "dictionary-members">
                <dt data-tests="">
                  <dfn data-idl="">address</dfn> of type <span class=
                  "idlMemberType">DOMString</span>, nullable
                </dt>
                <dd>
                  <p>
                    The local address used to communicate with the STUN or TURN
                    server, or <code>null</code>.
                  </p>
                </dd>
                <dt data-tests="">
                  <dfn data-idl="">port</dfn> of type <span class=
                  "idlMemberType">unsigned short</span>, nullable
                </dt>
                <dd>
                  <p>
                    The local port used to communicate with the STUN or TURN
                    server, or <code>null</code>.
                  </p>
                </dd>
                <dt data-tests="">
                  <dfn data-idl="">url</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd>
                  <p>
                    The STUN or TURN URL that identifies the STUN or TURN
                    server for which the failure occurred.
                  </p>
                </dd>
                <dt data-tests="">
                  <dfn data-idl="">errorCode</dfn> of type <span class=
                  "idlMemberType">unsigned short</span>, required
                </dt>
                <dd>
                  <p>
                    The numeric STUN error code returned by the STUN or TURN
                    server.
                  </p>
                </dd>
                <dt data-tests="">
                  <dfn data-idl="">errorText</dfn> of type <span class=
                  "idlMemberType">USVString</span>
                </dt>
                <dd>
                  <p>
                    The STUN reason text returned by the STUN or TURN server.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
      </section>
      <section>
        <h2 id="sec.cert-mgmt">
          Certificate Management
        </h2>
        <p>
          The certificates that {{RTCPeerConnection}} instances use to
          authenticate with peers use the {{RTCCertificate}} interface. These
          objects can be explicitly generated by applications using the
          {{RTCPeerConnection/generateCertificate}} method and can be provided
          in the {{RTCConfiguration}} when constructing a new
          {{RTCPeerConnection}} instance.
        </p>
        <p>
          The explicit certificate management functions provided here are
          optional. If an application does not provide the
          {{RTCConfiguration/certificates}} configuration option when
          constructing an {{RTCPeerConnection}} a new set of certificates MUST
          be generated by the <a>user agent</a>. That set MUST include an ECDSA
          certificate with a private key on the P-256 curve and a signature
          with a SHA-256 hash.
        </p>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js" data-cite=
          "WebCryptoAPI">partial interface RTCPeerConnection {
  static Promise&lt;RTCCertificate&gt;
      generateCertificate(AlgorithmIdentifier keygenAlgorithm);
};</pre>
          <section>
            <h2>
              Methods
            </h2>
            <dl data-link-for="RTCPeerConnection" data-dfn-for=
            "RTCPeerConnection" class="methods">
              <dt data-tests="RTCPeerConnection-generateCertificate.html">
                <dfn data-idl="">generateCertificate</dfn>, static
              </dt>
              <dd>
                <p>
                  The {{generateCertificate}} function causes the <a>user
                  agent</a> to create an X.509 certificate [[!X509V3]] and
                  corresponding private key. A handle to information is
                  provided in the form of the {{RTCCertificate}} interface. The
                  returned {{RTCCertificate}} can be used to control the
                  certificate that is offered in the DTLS sessions established
                  by {{RTCPeerConnection}}.
                </p>
                <p>
                  The <var>keygenAlgorithm</var> argument is used to control
                  how the private key associated with the certificate is
                  generated. The <var>keygenAlgorithm</var> argument uses the
                  WebCrypto [[!WebCryptoAPI]] <a data-cite=
                  "!WebCryptoAPI#dfn-AlgorithmIdentifier">AlgorithmIdentifier</a>
                  type.
                </p>
                <p data-tests="RTCPeerConnection-generateCertificate.html">
                  The following values MUST be supported by a <a>user
                  agent</a>: <code>{ name: "<a data-cite=
                  "!WebCryptoAPI#rsassa-pkcs1">RSASSA-PKCS1-v1_5</a>",
                  modulusLength: 2048, publicExponent: new Uint8Array([1, 0,
                  1]), hash: "SHA-256" }</code>, and <code>{ name:
                  "<a data-cite="!WebCryptoAPI#ecdsa">ECDSA</a>", namedCurve:
                  "<a data-cite="!WebCryptoAPI#dfn-NamedCurve">P-256</a>"
                  }</code>.
                </p>
                <p class="note">
                  It is expected that a <a>user agent</a> will have a small or
                  even fixed set of values that it will accept.
                </p>
                <p>
                  The certificate produced by this process also contains a
                  signature. The validity of this signature is only relevant
                  for compatibility reasons. Only the public key and the
                  resulting certificate fingerprint are used by
                  {{RTCPeerConnection}}, but it is more likely that a
                  certificate will be accepted if the certificate is well
                  formed. The browser selects the algorithm used to sign the
                  certificate; a browser SHOULD select SHA-256 [[!FIPS-180-4]]
                  if a hash algorithm is needed.
                </p>
                <p>
                  The resulting certificate MUST NOT include information that
                  can be linked to a user or <a>user agent</a>. Randomized
                  values for distinguished name and serial number SHOULD be
                  used.
                </p>
                <p>
                  When the method is called, the user agent MUST run the
                  following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>keygenAlgorithm</var> be the first argument to
                      {{generateCertificate}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      Let <var>expires</var> be a {{DOMTimeStamp}} value of
                      2592000000.
                    </p>
                    <div class="note">
                      <p>
                        This means the certificate will by default expire in 30
                        days from the time of the {{generateCertificate}} call.
                      </p>
                    </div>
                  </li>
                  <li>
                    <p>
                      If <var>keygenAlgorithm</var> is an object, run the
                      following steps:
                    </p>
                    <ol>
                      <li>
                        <p>
                          Let <var>certificateExpiration</var> be the result of
                          <a data-cite=
                          "webidl#dfn-convert-ecmascript-to-idl-value">converting</a>
                          the ECMAScript object represented by
                          <var>keygenAlgorithm</var> to an
                          {{RTCCertificateExpiration}} dictionary.
                        </p>
                      </li>
                      <li data-tests=
                      "RTCPeerConnection-generateCertificate.html">
                        <p>
                          If the conversion fails with an <var>error</var>,
                          return a promise that is [= rejected =] with
                          <var>error</var>.
                        </p>
                      </li>
                      <li>
                        <p>
                          If
                          <var>certificateExpiration</var>.{{RTCCertificateExpiration/expires}}
                          is not <code>undefined</code>, set <var>expires</var>
                          to
                          <var>certificateExpiration</var>.{{RTCCertificateExpiration/expires}}.
                        </p>
                      </li>
                      <li>
                        <p>
                          If <var>expires</var> is greater than 31536000000,
                          set <var>expires</var> to 31536000000.
                        </p>
                        <div class="note">
                          <p>
                            This means the certificate cannot be valid for
                            longer than 365 days from the time of the
                            {{generateCertificate}} call.
                          </p>
                        </div>
                        <p>
                          A <a>user agent</a> MAY further cap the value of
                          <var>expires</var>.
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <p>
                      Let <var>normalizedKeygenAlgorithm</var> be the result of
                      <a data-cite=
                      "!WebCryptoAPI#dfn-normalize-an-algorithm">normalizing an
                      algorithm</a> with an operation name of <code class=
                      "ext"><a data-cite=
                      "WebCryptoAPI#SubtleCrypto-method-generateKey">generateKey</a></code>
                      and a <a data-cite=
                      "!WebCryptoAPI#dfn-supportedAlgorithms">supportedAlgorithms</a>
                      value specific to production of certificates for
                      {{RTCPeerConnection}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      If the above normalization step fails with an
                      <var>error</var>, return a promise that is [= rejected =]
                      with <var>error</var>.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-generateCertificate.html">
                    <p>
                      If the <var>normalizedKeygenAlgorithm</var> parameter
                      identifies an algorithm that the <a>user agent</a> cannot
                      or will not use to generate a certificate for
                      {{RTCPeerConnection}}, return a promise that is [=
                      rejected =] with a {{DOMException}} of type
                      {{NotSupportedError}}. In particular,
                      <var>normalizedKeygenAlgorithm</var> MUST be an
                      asymmetric algorithm that can be used to produce a
                      signature used to authenticate DTLS connections.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>p</var> be a new promise.
                    </p>
                  </li>
                  <li>
                    <p>
                      Run the following steps in parallel:
                    </p>
                    <ol>
                      <li>
                        <p>
                          Perform the generate key operation specified by
                          <var>normalizedKeygenAlgorithm</var> using
                          <var>keygenAlgorithm</var>.
                        </p>
                      </li>
                      <li>
                        <p>
                          Let <var>generatedKeyingMaterial</var> and
                          <var>generatedKeyCertificate</var> be the private
                          keying material and certificate generated by the
                          above step.
                        </p>
                      </li>
                      <li>
                        <p>
                          Let <var>certificate</var> be a new
                          {{RTCCertificate}} object.
                        </p>
                      </li>
                      <li>
                        <p>
                          Set <var>certificate</var>.[[\Expires]] to the
                          current time plus <var>expires</var> value.
                        </p>
                      </li>
                      <li>
                        <p>
                          Set <var>certificate</var>.{{RTCCertificate/[[Origin]]}} to the
                          [= relevant settings object =]'s
                          [=environment settings object/origin=].
                        </p>
                      </li>
                      <li>
                        <p>
                          Store the <var>generatedKeyingMaterial</var> in a
                          secure module, and let <var>handle</var> be a
                          reference identifier to it.
                        </p>
                      </li>
                      <li>
                        <p>
                          Set <var>certificate</var>.{{RTCCertificate/[[KeyingMaterialHandle]]}}
                          to <var>handle</var>.
                        </p>
                      </li>
                      <li>
                        <p>
                          Set <var>certificate</var>.{{RTCCertificate/[[Certificate]]}} to
                          <var>generatedCertificate</var>.
                        </p>
                      </li>
                      <li>
                        <p>
                          Resolve <var>p</var> with <var>certificate</var>.
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Return <var>p</var>.
                    </p>
                  </li>
                </ol>
              </dd>
            </dl>
          </section>
        </div>
        <section>
          <h2>
            <dfn>RTCCertificateExpiration</dfn> Dictionary
          </h2>
          <p>
            {{RTCCertificateExpiration}} is used to set an expiration date on
            certificates generated by
            {{RTCPeerConnection/generateCertificate}}.
          </p>
          <pre class="idl">dictionary RTCCertificateExpiration {
  [EnforceRange] DOMTimeStamp expires;
};</pre>
          <dl data-link-for="RTCCertificateExpiration" data-dfn-for=
          "RTCCertificateExpiration" class="methods">
            <dt data-tests=
            "RTCPeerConnection-generateCertificate.html,RTCCertificate.html">
              <dfn>expires</dfn>, of type {{DOMTimeStamp}}
            </dt>
            <dd>
              <p>
                An optional {{expires}} attribute MAY be added to the
                definition of the algorithm that is passed to
                {{RTCPeerConnection/generateCertificate}}. If this parameter is
                present it indicates the maximum time that the
                {{RTCCertificate}} is valid for relative to the current time.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>RTCCertificate</dfn> Interface
          </h2>
          <p>
            The {{RTCCertificate}} interface represents a certificate used to
            authenticate WebRTC communications. In addition to the visible
            properties, internal slots contain a handle to the generated
            private keying materal (<dfn data-dfn-for="RTCCertificate">[[\KeyingMaterialHandle]]</dfn>), a
            certificate (<dfn data-dfn-for="RTCCertificate">[[\Certificate]]</dfn>) that
            {{RTCPeerConnection}} uses to authenticate with a peer, and the
            origin (<dfn data-dfn-for="RTCCertificate">[[\Origin]]</dfn>) that created the object.
          </p>
          <div>
            <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window, Serializable]
interface RTCCertificate {
  readonly attribute DOMTimeStamp expires;
  sequence&lt;RTCDtlsFingerprint&gt; getFingerprints();
};</pre>
            <section>
              <h2>
                Attributes
              </h2>
              <dl data-link-for="RTCCertificate" data-dfn-for="RTCCertificate"
              class="attributes">
                <dt data-tests="RTCCertificate.html">
                  <dfn data-idl="">expires</dfn> of type <span class=
                  "idlAttrType">DOMTimeStamp</span>, readonly
                </dt>
                <dd>
                  <p>
                    The <var>expires</var> attribute indicates the date and
                    time in milliseconds relative to 1970-01-01T00:00:00Z after
                    which the certificate will be considered invalid by the
                    browser. After this time, attempts to construct an
                    {{RTCPeerConnection}} using this certificate fail.
                  </p>
                  <p>
                    Note that this value might not be reflected in a
                    <code class="ext">notAfter</code> parameter in the
                    certificate itself.
                  </p>
                </dd>
              </dl>
            </section>
            <section>
              <h2>
                Methods
              </h2>
              <dl data-link-for="RTCCertificate" data-dfn-for="RTCCertificate"
              class="methods">
                <dt data-tests="RTCCertificate.html">
                  <dfn data-idl="">getFingerprints</dfn>
                </dt>
                <dd>
                  <p>
                    Returns the list of certificate fingerprints, one of which
                    is computed with the digest algorithm used in the
                    certificate signature.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
          <p>
            For the purposes of this API, the {{RTCCertificate/[[Certificate]]}} slot
            contains unstructured binary data. No mechanism is provided for
            applications to access the {{RTCCertificate/[[KeyingMaterialHandle]]}}
            internal slot or the keying material it references. Implementations
            MUST support applications storing and retrieving {{RTCCertificate}}
            objects from persistent storage, in a manner that also preserves
            the keying material referenced by {{RTCCertificate/[[KeyingMaterialHandle]]}}.
            Implementations SHOULD store the sensitive keying material in a
            secure module safe from same-process memory attacks. This allows
            the private key to be stored and used, but not easily read using a
            memory attack.
          </p>
          <p id="serializable-certificate" data-tests=
          "RTCCertificate-postMessage.html">
            {{RTCCertificate}} objects are [= serializable objects =]
            [[!HTML]]. Their [= serialization steps =], given <var>value</var>
            and <var>serialized</var>, are:
          </p>
          <ol>
            <li>Set <var>serialized</var>.[[\Expires]] to the value of
            <var>value</var>.{{RTCCertificate/expires}} attribute.
            </li>
            <li>Set <var>serialized</var>.[[\Certificate]] to a copy of the
            unstructured binary data in
            <var>value</var>.{{RTCCertificate/[[Certificate]]}}.
            </li>
            <li>Set <var>serialized</var>.[[\Origin]] to a copy of the
            unstructured binary data in <var>value</var>.{{RTCCertificate/[[Origin]]}}.
            </li>
            <li>Set <var>serialized</var>.[[\KeyingMaterialHandle]] to a
            serialization of the handle in
            <var>value</var>.{{RTCCertificate/[[KeyingMaterialHandle]]}} (not the private
            keying material itself).
            </li>
          </ol>
          <p>
            Their <a>deserialization steps</a>, given <var>serialized</var> and
            <var>value</var>, are:
          </p>
          <ol>
            <li>Initialize <var>value</var>.{{RTCCertificate/expires}}
            attribute to contain <var>serialized</var>.[[\Expires]].
            </li>
            <li>Set <var>value</var>.{{RTCCertificate/[[Certificate]]}} to a copy of <var>
              serialized</var>.[[\Certificate]]
            </li>
            <li>Set <var>value</var>.{{RTCCertificate/[[Origin]]}} to a copy of
            <var>serialized</var>.[[\Origin]]
            </li>
            <li>Set <var>value</var>.{{RTCCertificate/[[KeyingMaterialHandle]]}} to the
            private keying material handle resulting from deserializing
            <var>serialized</var>.[[\KeyingMaterialHandle]]
            </li>
          </ol>
          <p class="note">
            Supporting structured cloning in this manner allows
            {{RTCCertificate}} instances to be persisted to stores. It also
            allows instances to be passed to other origins using APIs like
            {{MessagePort/postMessage(message, options)}} [[html]]. However, the object cannot
            be used by any other origin than the one that originally created
            it.
          </p>
        </section>
      </section>
    </section>
    <section>
      <h2>
        RTP Media API
      </h2>
      <p>
        The <dfn>RTP media API</dfn> lets a web application send and receive
        {{MediaStreamTrack}}s over a peer-to-peer connection. Tracks, when
        added to an {{RTCPeerConnection}}, result in signaling; when this
        signaling is forwarded to a remote peer, it causes corresponding tracks
        to be created on the remote side.
      </p>
      <p class="note">
        There is not an exact 1:1 correspondence between tracks sent by one
        {{RTCPeerConnection}} and received by the other. For one, IDs of tracks
        sent have no mapping to the IDs of tracks received. Also,
        {{RTCRtpSender/replaceTrack}} changes the track sent by an
        {{RTCRtpSender}} without creating a new track on the receiver side; the
        corresponding {{RTCRtpReceiver}} will only have a single track,
        potentially representing multiple sources of media stitched together.
        Both {{RTCPeerConnection/addTransceiver}} and
        {{RTCRtpSender/replaceTrack}} can be used to cause the same track to be
        sent multiple times, which will be observed on the receiver side as
        multiple receivers each with its own separate track. Thus it's more
        accurate to think of a 1:1 relationship between an {{RTCRtpSender}} on
        one side and an {{RTCRtpReceiver}}'s track on the other side, matching
        senders and receivers using the {{RTCRtpTransceiver}}'s
        {{RTCRtpTransceiver/mid}} if necessary.
      </p>
      <p>
        When sending media, the sender may need to rescale or resample the
        media to meet various requirements including the envelope negotiated by
        SDP.
      </p>
      <p>
        Following the rules in <span data-jsep="imageattr">[[!RFC8829]]</span>,
        the video MAY be downscaled in order to fit the SDP constraints. The
        media MUST NOT be upscaled to create fake data that did not occur in
        the input source, the media MUST NOT be cropped except as needed to
        satisfy constraints on pixel counts, and the aspect ratio MUST NOT be
        changed.
      </p>
      <p class="note">
        The WebRTC Working Group is seeking implementation feedback on the need
        and timeline for a more complex handling of this situation. Some
        possible designs have been discussed in <a href=
        "https://github.com/w3c/webrtc-pc/issues/1283">GitHub issue 1283</a>.
      </p>
      <p>
        When video is rescaled, for example for certain combinations of width
        or height and {{RTCRtpEncodingParameters/ scaleResolutionDownBy}}
        values, situations when the resulting width or height is not an integer
        may occur. In such situations the user agent MUST use <a href=
        "https://tc39.github.io/ecma262/#eqn-floor">the integer part of the
        result</a>. What to transmit if the integer part of the scaled width or
        height is zero is implementation-specific.
      </p>
      <p>
        The actual encoding and transmission of {{MediaStreamTrack}}s is
        managed through objects called {{RTCRtpSender}}s. Similarly, the
        reception and decoding of {{MediaStreamTrack}}s is managed through
        objects called {{RTCRtpReceiver}}s. Each {{RTCRtpSender}} is associated
        with at most one track, and each track to be received is associated
        with exactly one {{RTCRtpReceiver}}.
      </p>
      <p>
        The encoding and transmission of each {{MediaStreamTrack}} SHOULD be
        made such that its characteristics (<code class="gum">width</code>,
        <code class="gum">height</code> and <code class="gum">frameRate</code>
        for video tracks; <code class=
        "gum">sampleSize</code>, <code class="gum">sampleRate</code> and
        <code class="gum">channelCount</code> for audio tracks) are to a
        reasonable degree retained by the track created on the remote side.
        There are situations when this does not apply, there may for example be
        resource constraints at either endpoint or in the network or there may
        be {{RTCRtpSender}} settings applied that instruct the implementation
        to act differently.
      </p>
      <p>
        An {{RTCPeerConnection}} object contains a <dfn id="transceivers-set"
        data-lt="set of transceivers">set of {{RTCRtpTransceiver}}s</dfn>,
        representing the paired senders and receivers with some shared state.
        <span data-tests="RTCPeerConnection-getTransceivers.html">This set is
        initialized to the empty set when the {{RTCPeerConnection}} object is
        created.</span> {{RTCRtpSender}}s and {{RTCRtpReceiver}}s are always
        created at the same time as an {{RTCRtpTransceiver}}, which they will
        remain attached to for their lifetime. {{RTCRtpTransceiver}}s are
        created implicitly when the application attaches a {{MediaStreamTrack}}
        to an {{RTCPeerConnection}} via the {{RTCPeerConnection/addTrack()}}
        method, or explicitly when the application uses the
        {{RTCPeerConnection/addTransceiver}} method. They are also created when
        a remote description is applied that includes a new media description.
        Additionally, when a remote description is applied that indicates the
        remote endpoint has media to send, the relevant {{MediaStreamTrack}}
        and {{RTCRtpReceiver}} are surfaced to the application via the
        {{RTCPeerConnection/track}} event.
      </p>
      <p>
        In order for an {{RTCRtpTransceiver}} to send and/or receive media with
        another endpoint this must be negotiated with SDP such that both
        endpoints have an {{RTCRtpTransceiver}} object that is [= associated =]
        with the same [= media description =].
      </p>
      <p>
        When creating an offer, enough media descriptions will be generated to
        cover all transceivers on that end. When this offer is set as the local
        description, any disassociated transceivers get associated with media
        descriptions in the offer.
      </p>
      <p>
        When an offer is set as the remote description, any media descriptions
        in it not yet associated with a transceiver get associated with a new
        or existing transceiver. In this case, only disassociated transceivers
        that were created via the {{RTCPeerConnection/addTrack()}} method may
        be associated. Disassociated transceivers created via the
        {{RTCPeerConnection/addTransceiver()}} method, however, won't get
        associated even if media descriptions are available in the remote
        offer. Instead, new transceivers will be created and associated if
        there aren't enough {{RTCPeerConnection/addTrack()}}-created
        transceivers. This sets {{RTCPeerConnection/addTrack()}}-created and
        {{RTCPeerConnection/addTransceiver()}}-created transceivers apart in a
        critical way that is not observable from inspecting their attributes.
      </p>
      <p>
        When creating an answer, only media descriptions that were
        present in the offer may be listed in the answer. As a consequence, any
        transceivers that were not associated when setting the remote offer
        remain disassociated after setting the local answer. This can be
        remedied by the answerer creating a follow-up offer, initiating another
        offer/answer exchange, or in the case of using
        {{RTCPeerConnection/addTrack()}}-created transceivers, making sure that
        enough media descriptions are offered in the initial exchange.
      </p>
      <section>
        <h3>
          RTCPeerConnection Interface Extensions
        </h3>
        <p>
          The RTP media API extends the {{RTCPeerConnection}} interface as
          described below.
        </p>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">
          partial interface RTCPeerConnection {
  sequence&lt;RTCRtpSender&gt; getSenders();
  sequence&lt;RTCRtpReceiver&gt; getReceivers();
  sequence&lt;RTCRtpTransceiver&gt; getTransceivers();
  RTCRtpSender addTrack(MediaStreamTrack track, MediaStream... streams);
  undefined removeTrack(RTCRtpSender sender);
  RTCRtpTransceiver addTransceiver((MediaStreamTrack or DOMString) trackOrKind,
                                   optional RTCRtpTransceiverInit init = {});
  attribute EventHandler ontrack;
};</pre>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCPeerConnection" data-dfn-for=
            "RTCPeerConnection" class="attributes">
              <dt data-tests=
              "RTCPeerConnection-ontrack.https.html,RTCPeerConnection-transceivers.https.html">
                <dfn data-idl="">ontrack</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd>
                <p>
                  The event type of this event handler is {{RTCPeerConnection/track}}.
                </p>
              </dd>
            </dl>
          </section>
          <section>
            <h2>
              Methods
            </h2>
            <dl data-link-for="RTCPeerConnection" data-dfn-for=
            "RTCPeerConnection" class="methods">
              <dt data-tests=
              "RTCRtpTransceiver.https.html,RTCPeerConnection-getTransceivers.html,RTCPeerConnection-transceivers.https.html">
                <dfn id="dom-peerconnection-getsenders">getSenders</dfn>
              </dt>
              <dd>
                <p>
                  Returns a sequence of {{RTCRtpSender}} objects representing
                  the RTP senders that belong to non-stopped
                  {{RTCRtpTransceiver}} objects currently attached to this
                  {{RTCPeerConnection}} object.
                </p>
                <p class="no-test-needed">
                  When the {{getSenders}} method is invoked, the user agent
                  MUST return the result of executing the {{CollectSenders}}
                  algorithm.
                </p>
                <p>
                  We define the <dfn>CollectSenders</dfn> algorithm as follows:
                </p>
                <ol>
                  <li data-tests="RTCPeerConnection-getTransceivers.html">Let
                  <var>transceivers</var> be the result of executing the
                  {{CollectTransceivers}} algorithm.
                  </li>
                  <li data-tests="RTCRtpTransceiver.https.html">Let
                  <var>senders</var> be a new empty sequence.
                  </li>
                  <li>For each <var>transceiver</var> in
                  <var>transceivers</var>,
                    <ol>
                      <li data-tests="RTCRtpTransceiver.https.html">If
                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopped]]}} is
                      <code>false</code>, add
                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}} to
                      <var>senders</var>.
                      </li>
                    </ol>
                  </li>
                  <li data-tests="RTCRtpTransceiver.https.html">Return
                  <var>senders</var>.
                  </li>
                </ol>
              </dd>
              <dt data-tests=
              "RTCRtpTransceiver.https.html,RTCPeerConnection-addTransceiver.https.html,RTCPeerConnection-getTransceivers.html,RTCPeerConnection-transceivers.https.html">
                <dfn id="dom-peerconnection-getreceivers">getReceivers</dfn>
              </dt>
              <dd>
                <p>
                  Returns a sequence of {{RTCRtpReceiver}} objects representing
                  the RTP receivers that belong to non-stopped
                  {{RTCRtpTransceiver}} objects currently attached to this
                  {{RTCPeerConnection}} object.
                </p>
                <p>
                  When the {{getReceivers}} method is invoked, the user agent
                  MUST run the following steps:
                </p>
                <ol>
                  <li data-tests="RTCRtpTransceiver.https.html">Let
                  <var>transceivers</var> be the result of executing the
                  {{CollectTransceivers}} algorithm.
                  </li>
                  <li data-tests="RTCRtpTransceiver.https.html">Let
                  <var>receivers</var> be a new empty sequence.
                  </li>
                  <li data-tests="RTCRtpTransceiver.https.html">For each <var>
                    transceiver</var> in <var>transceivers</var>,
                    <ol>
                      <li>If <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopped]]}} is
                      <code>false</code>, add
                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}} to
                      <var>receivers</var>.
                      </li>
                    </ol>
                  </li>
                  <li class="RTCRtpTransceiver.https.html">Return
                  <var>receivers</var>.
                  </li>
                </ol>
              </dd>
              <dt data-tests=
              "RTCRtpTransceiver.https.html,RTCPeerConnection-getTransceivers.html,RTCPeerConnection-transceivers.https.html">
                <dfn id=
                "dom-peerconnection-gettranseceivers">getTransceivers</dfn>
              </dt>
              <dd>
                <p>
                  Returns a sequence of {{RTCRtpTransceiver}} objects
                  representing the RTP transceivers that are currently attached
                  to this {{RTCPeerConnection}} object.
                </p>
                <p data-tests="RTCRtpTransceiver.https.html">
                  The {{getTransceivers}} method MUST return the result of
                  executing the {{CollectTransceivers}} algorithm.
                </p>
                <p>
                  We define the <dfn>CollectTransceivers</dfn> algorithm as
                  follows:
                </p>
                <ol>
                  <li class="RTCRtpTransceiver.https.html">Let
                  <var>transceivers</var> be a new sequence consisting of all
                  {{RTCRtpTransceiver}} objects in this {{RTCPeerConnection}}
                  object's [= set of transceivers =], in insertion order.
                  </li>
                  <li class="no-test-needed">Return <var>transceivers</var>.
                  </li>
                </ol>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-add-track-no-deadlock.https.html">
                <dfn data-idl="">addTrack</dfn>
              </dt>
              <dd>
                <p>
                  Adds a new track to the {{RTCPeerConnection}}, and indicates
                  that it is contained in the specified {{MediaStream}}s.
                </p>
                <p>
                  When the {{addTrack}} method is invoked, the user agent MUST
                  run the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>connection</var> be the {{RTCPeerConnection}}
                      object on which this method was invoked.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>track</var> be the {{MediaStreamTrack}} object
                      indicated by the method's first argument.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>kind</var> be <var>track.kind</var>.
                    </p>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-setRemoteDescription-tracks.https.html">
                    <p>
                      Let <var>streams</var> be a list of {{MediaStream}}
                      objects constructed from the method's remaining
                      arguments, or an empty list if the method was called with
                      a single argument.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-addTrack.https.html">
                    <p>
                      If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                      <code>true</code>, [= exception/throw =] an
                      {{InvalidStateError}}.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-addTrack.https.html">
                    <p>
                      Let <var>senders</var> be the result of executing the
                      {{CollectSenders}} algorithm. If an {{RTCRtpSender}} for
                      <var>track</var> already exists in <var>senders</var>, [=
                      exception/throw =] an {{InvalidAccessError}}.
                    </p>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-addTrack.https.html,RTCPeerConnection-transceivers.https.html">
                    <p>
                      The steps below describe how to determine if an existing
                      sender can be reused. Doing so will cause future calls to
                      {{RTCPeerConnection/createOffer}} and
                      {{RTCPeerConnection/createAnswer}} to mark the
                      corresponding [= media description =] as <code class=
                      "sdp">sendrecv</code> or <code class=
                      "sdp">sendonly</code> and add the MSID of the sender's
                      streams, as defined in <span data-jsep=
                      "subsequent-offers subsequent-answers">[[!RFC8829]]</span>.
                    </p>
                    <p>
                      If any {{RTCRtpSender}} object in <var>senders</var>
                      matches all the following criteria, let <var>sender</var>
                      be that object, or <code>null</code> otherwise:
                    </p>
                    <ul>
                      <li>
                        <p>
                          The sender's track is null.
                        </p>
                      </li>
                      <li>
                        <p>
                          The <a>transceiver kind</a> of the
                          {{RTCRtpTransceiver}}, associated with the sender,
                          matches <var>kind</var>.
                        </p>
                      </li>
                      <li>
                        <p>
                          The {{RTCRtpTransceiver/[[Stopping]]}} slot of the
                          {{RTCRtpTransceiver}} associated with the sender is
                          <code>false</code>.
                        </p>
                      </li>
                      <li>
                        <p>
                          The sender has never been used to send. More
                          precisely, the {{RTCRtpTransceiver/[[CurrentDirection]]}} slot of
                          the {{RTCRtpTransceiver}} associated with the sender
                          has never had a value of
                          {{RTCRtpTransceiverDirection/"sendrecv"}} or
                          {{RTCRtpTransceiverDirection/"sendonly"}}.
                        </p>
                      </li>
                    </ul>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-addTrack.https.html,RTCPeerConnection-setRemoteDescription-tracks.https.html,RTCPeerConnection-transceivers.https.html">
                    <p>
                      If <var>sender</var> is not <code>null</code>, run the
                      following steps to use that sender:
                    </p>
                    <ol>
                      <li>
                        <p>
                          Set <var>sender</var>.{{RTCRtpSender/[[SenderTrack]]}} to
                          <var>track</var>.
                        </p>
                      </li>
                      <li>
                        <p>
                          Set
                          <var>sender</var>.{{RTCRtpSender/[[AssociatedMediaStreamIds]]}}
                          to an empty set.
                        </p>
                      </li>
                      <li>
                        <p>
                          For each <var>stream</var> in <var>streams</var>, add
                          <var>stream.id</var> to
                          {{RTCRtpSender/[[AssociatedMediaStreamIds]]}} if it's not
                          already there.
                        </p>
                      </li>
                      <li>
                        <p>
                          Let <var>transceiver</var> be the
                          {{RTCRtpTransceiver}} associated with
                          <var>sender</var>.
                        </p>
                      </li>
                      <li>
                        <p>
                          If <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} is
                          {{RTCRtpTransceiverDirection/"recvonly"}}, set
                          <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} to
                          {{RTCRtpTransceiverDirection/"sendrecv"}}.
                        </p>
                      </li>
                      <li>
                        <p>
                          If <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} is
                          {{RTCRtpTransceiverDirection/"inactive"}}, set
                          <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} to
                          {{RTCRtpTransceiverDirection/"sendonly"}}.
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-addTrack.https.html,RTCPeerConnection-transceivers.https.html">
                    <p>
                      If <var>sender</var> is <code>null</code>, run the
                      following steps:
                    </p>
                    <ol>
                      <li>
                        <p>
                          <a>Create an RTCRtpSender</a> with <var>track</var>,
                          <var>kind</var> and <var>streams</var>, and let
                          <var>sender</var> be the result.
                        </p>
                      </li>
                      <li>
                        <p>
                          <a>Create an RTCRtpReceiver</a> with <var>kind</var>,
                          and let <var>receiver</var> be the result.
                        </p>
                      </li>
                      <li>
                        <p>
                          <a>Create an RTCRtpTransceiver</a> with
                          <var>sender</var>, <var>receiver</var> and an
                          {{RTCRtpTransceiverDirection}} value of
                          {{RTCRtpTransceiverDirection/"sendrecv"}}, and let
                          <var>transceiver</var> be the result.
                        </p>
                      </li>
                      <li>
                        <p>
                          Add <var>transceiver</var> to <var>connection</var>'s
                          [= set of transceivers =].
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <p>
                      A track could have contents that are inaccessible to the
                      application. This can be due to anything that would make
                      a track <a data-cite="!fetch#concept-cors-check">CORS
                      cross-origin</a>. These tracks can be supplied to the
                      {{RTCPeerConnection/addTrack()}} method, and have an
                      {{RTCRtpSender}} created for them, but content MUST NOT
                      be transmitted. Silence (audio), black frames (video) or
                      equivalently absent content is sent in place of track
                      content.
                    </p>
                    <p>
                      Note that this property can change over time.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                    <p>
                      [= Update the negotiation-needed flag =] for
                      <var>connection</var>.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Return <var>sender</var>.
                    </p>
                  </li>
                </ol>
              </dd>
              <dt data-tests="RTCPeerConnection-removeTrack.https.html">
                <dfn data-idl="">removeTrack</dfn>
              </dt>
              <dd>
                <p>
                  Stops sending media from <var>sender</var>. The
                  {{RTCRtpSender}} will still appear in {{getSenders}}. Doing
                  so will cause future calls to {{createOffer}} to mark the [=
                  media description =] for the corresponding transceiver as
                  {{RTCRtpTransceiverDirection/"recvonly"}} or
                  {{RTCRtpTransceiverDirection/"inactive"}}, as defined in
                  <span data-jsep="subsequent-offers">[[!RFC8829]]</span>.
                  <!-- onended -->
                </p>
                <p>
                  When the other peer stops sending a track in this manner, the
                  track is removed from any remote {{MediaStream}}s that were
                  initially revealed in the {{RTCPeerConnection/track}}
                  event, and if the {{MediaStreamTrack}} is not already muted,
                  a <code class=fixme>mute</code> event is fired at the
                  track.
                </p>
                <div class="note">
                  The same effect as {{removeTrack()}} can be achieved by
                  setting the
                  {{RTCRtpTransceiver}}.{{RTCRtpTransceiver/direction}}
                  attribute of the corresponding transceiver and invoking
                  {{RTCRtpSender}}.{{RTCRtpSender/replaceTrack}}(null) on the
                  sender. One minor difference is that
                  {{RTCRtpSender/replaceTrack()}} is asynchronous and
                  {{removeTrack()}} is synchronous.
                </div>
                <p>
                  When the {{removeTrack}} method is invoked, the user agent
                  MUST run the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>sender</var> be the argument to {{removeTrack}}.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>connection</var> be the {{RTCPeerConnection}}
                      object on which the method was invoked.
                    </p>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-removeTrack.https.html,RTCRtpTransceiver.https.html">
                    <p>
                      If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                      <code>true</code>, [= exception/throw =] an
                      {{InvalidStateError}}.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-removeTrack.https.html">
                    <p>
                      If <var>sender</var> was not created by
                      <var>connection</var>, [= exception/throw =] an
                      {{InvalidAccessError}}.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-removeTrack.https.html">
                    <p>
                      Let <var>senders</var> be the result of executing the
                      {{CollectSenders}} algorithm.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>sender</var> is not in <var>senders</var> (which
                      indicates its transceiver was stopped or removed due to
                      [= setting a session description =] of
                      {{RTCSessionDescriptionInit/type}}
                      {{RTCSdpType/"rollback"}}), then abort these steps.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>sender</var>.{{RTCRtpSender/[[SenderTrack]]}} is null,
                      abort these steps.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-removeTrack.https.html">
                    <p>
                      Set <var>sender</var>.{{RTCRtpSender/[[SenderTrack]]}} to null.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>transceiver</var> be the {{RTCRtpTransceiver}}
                      object corresponding to <var>sender</var>.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-removeTrack.https.html">
                    <p>
                      If <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} is
                      {{RTCRtpTransceiverDirection/"sendrecv"}}, set
                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} to
                      {{RTCRtpTransceiverDirection/"recvonly"}}.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-removeTrack.https.html">
                    <p>
                      If <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} is
                      {{RTCRtpTransceiverDirection/"sendonly"}}, set
                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} to
                      {{RTCRtpTransceiverDirection/"inactive"}}.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                    <p>
                      [= Update the negotiation-needed flag =] for
                      <var>connection</var>.
                    </p>
                  </li>
                </ol>
              </dd>
              <dt data-tests="RTCRtpTransceiver.https.html">
                <dfn data-idl="">addTransceiver</dfn>
              </dt>
              <dd>
                <p>
                  Create a new {{RTCRtpTransceiver}} and add it to the [= set
                  of transceivers =].
                </p>
                <p>
                  Adding a transceiver will cause future calls to
                  {{createOffer}} to add a [= media description =] for the
                  corresponding transceiver, as defined in <span data-jsep=
                  "subsequent-offers">[[!RFC8829]]</span>.
                </p>
                <p data-tests="RTCPeerConnection-addTransceiver.https.html">
                  The initial value of {{RTCRtpTransceiver/mid}} is null.
                  [= Setting a session description =] may later change it to a
                  non-null value.
                </p>
                <p data-tests="protocol/simulcast-offer.html">
                  The {{RTCRtpTransceiverInit/sendEncodings}} argument can be
                  used to specify the number of offered simulcast encodings,
                  and optionally their RIDs and encoding parameters.
                </p>
                <p>
                  When this method is invoked, the user agent MUST run the
                  following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>init</var> be the second argument.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>streams</var> be
                      <var>init</var>.{{RTCRtpTransceiverInit/streams}}.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>sendEncodings</var> be
                      <var>init</var>.{{RTCRtpTransceiverInit/sendEncodings}}.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>direction</var> be
                      <var>init</var>.{{RTCRtpTransceiverInit/direction}}.
                    </p>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-addTransceiver.https.html,RTCPeerConnection-transceivers.https.html,RTCRtpTransceiver.https.html">
                    <p>
                      If the first argument is a string, let it be
                      <var>kind</var> and run the following steps:
                    </p>
                    <ol>
                      <li>
                        <p>
                          If <var>kind</var> is not a legal
                          {{MediaStreamTrack}} <code class="ext">kind</code>,
                          [= exception/throw =] a {{TypeError}}.
                        </p>
                      </li>
                      <li>
                        <p>
                          Let <var>track</var> be <code>null</code>.
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-addTransceiver.https.html,RTCPeerConnection-transceivers.https.html,RTCRtpTransceiver.https.html">
                    <p>
                      If the first argument is a {{MediaStreamTrack}}, let it
                      be <var>track</var> and let <var>kind</var> be
                      <var>track.kind</var>.
                    </p>
                  </li>
                  <li data-tests="RTCRtpTransceiver.https.html">
                    <p>
                      If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                      <code>true</code>, [= exception/throw =] an
                      {{InvalidStateError}}.
                    </p>
                  </li>
                  <li>Validate <var>sendEncodings</var> by running the
                  following steps:
                    <ol>
                      <li data-tests=
                      "RTCPeerConnection-addTransceiver.https.html">
                        <p>
                          Verify that each {{RTCRtpCodingParameters/rid}} value
                          in <var>sendEncodings</var> conforms to the grammar
                          specified in Section 10 of [[RFC8851]]. If one of
                          the RIDs does not meet these requirements, [=
                          exception/throw =] a {{TypeError}}.
                        </p>
                      </li>
                      <li>
                        <p>
                          If any {{RTCRtpEncodingParameters}} dictionary in
                          <var>sendEncodings</var> contains a <a>read-only
                          parameter</a> other than
                          {{RTCRtpCodingParameters/rid}}, [= exception/throw =]
                          an {{InvalidAccessError}}.
                        </p>
                      </li>
                      <li data-tests="RTCRtpParameters-encodings.html">
                        <p>
                          Verify that the value of each
                          {{RTCRtpEncodingParameters/scaleResolutionDownBy}}
                          member in <var>sendEncodings</var> that is defined
                          is greater than or equal to 1.0. If one of the
                          {{RTCRtpEncodingParameters/scaleResolutionDownBy}}
                          values does not meet this requirement, [=
                          exception/throw =] a {{RangeError}}.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>maxN</var> be the maximum number of total
                          simultaneous encodings the user agent may support for
                          this <var>kind</var>, at minimum <code>1</code>.This
                          should be an optimistic number since the codec to be
                          used is not known yet.
                        </p>
                      </li>
                      <li>
                        <p>
                          If <var>sendEncodings</var> contains any encoding
                          whose
                          {{RTCRtpEncodingParameters/scaleResolutionDownBy}}
                          attribute is defined, set any undefined
                          {{RTCRtpEncodingParameters/scaleResolutionDownBy}} of
                          the other encodings to 1.0.
                        </p>
                      </li>
                      <li>
                        <p>
                          If the number of {{RTCRtpEncodingParameters}} stored
                          in <var>sendEncodings</var> exceeds <var>maxN</var>,
                          then trim <var>sendEncodings</var> from the tail
                          until its length is <var>maxN</var>.
                        </p>
                      </li>
                      <li>If the
                      {{RTCRtpEncodingParameters/scaleResolutionDownBy}}
                      attribues of <var>sendEncodings</var> are still
                      undefined, initialize each encoding's
                      {{RTCRtpEncodingParameters/scaleResolutionDownBy}} to
                      <code>2^(length of <var>sendEncodings</var> - encoding
                      index - 1)</code>. This results in smaller-to-larger
                      resolutions where the last encoding has no scaling
                      applied to it, e.g. 4:2:1 if the length is 3.
                      </li>
                      <li>
                        <p>
                          If the number of {{RTCRtpEncodingParameters}} now
                          stored in <var>sendEncodings</var> is <code>1</code>,
                          then remove any {{RTCRtpCodingParameters/rid}} member
                          from the lone entry.
                        </p>
                        <div class="note">
                          Providing a single, default
                          {{RTCRtpEncodingParameters}} in
                          <var>sendEncodings</var> allows the application to
                          subsequently set encoding parameters using
                          {{RTCRtpSender/setParameters}}, even when simulcast
                          isn't used.
                        </div>
                      </li>
                    </ol>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-addTransceiver.https.html,RTCRtpParameters-encodings.html,RTCRtpTransceiver.https.html">
                    <p>
                      <a>Create an RTCRtpSender</a> with <var>track</var>,
                      <var>kind</var>, <var>streams</var> and
                      <var>sendEncodings</var> and let <var>sender</var> be the
                      result.
                    </p>
                    <p>
                      If <var>sendEncodings</var> is set, then subsequent calls
                      to {{createOffer}} will be configured to send multiple
                      RTP encodings as defined in <span data-jsep=
                      "subsequent-offers initial-offers">[[!RFC8829]]</span>. When
                      {{RTCPeerConnection/setRemoteDescription}} is called with
                      a corresponding remote description that is able to
                      receive multiple RTP encodings as defined in
                      <span data-jsep="simulcast">[[!RFC8829]]</span>, the
                      {{RTCRtpSender}} may send multiple RTP encodings and the
                      parameters retrieved via the transceiver's
                      {{RTCRtpTransceiver/sender}}.{{RTCRtpSender/getParameters()}}
                      will reflect the encodings negotiated.
                    </p>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-addTransceiver.https.html,RTCRtpTransceiver.https.html">
                    <p>
                      <a>Create an RTCRtpReceiver</a> with <var>kind</var> and
                      let <var>receiver</var> be the result.
                    </p>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-addTransceiver.https.html,RTCRtpTransceiver.https.html">
                    <p>
                      <a>Create an RTCRtpTransceiver</a> with
                      <var>sender</var>, <var>receiver</var> and
                      <var>direction</var>, and let <var>transceiver</var> be
                      the result.
                    </p>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-addTransceiver.https.html,RTCRtpTransceiver.https.html">
                    <p>
                      Add <var>transceiver</var> to <var>connection</var>'s [=
                      set of transceivers =].
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                    <p>
                      [= Update the negotiation-needed flag =] for
                      <var>connection</var>.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Return <var>transceiver</var>.
                    </p>
                  </li>
                </ol>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">dictionary RTCRtpTransceiverInit {
  RTCRtpTransceiverDirection direction = "sendrecv";
  sequence&lt;MediaStream&gt; streams = [];
  sequence&lt;RTCRtpEncodingParameters&gt; sendEncodings = [];
};</pre>
          <section>
            <h2>
              Dictionary <dfn>RTCRtpTransceiverInit</dfn> Members
            </h2>
            <dl data-link-for="RTCRtpTransceiverInit" data-dfn-for=
            "RTCRtpTransceiverInit" class="dictionary-members">
              <dt data-tests=
              "RTCPeerConnection-addTransceiver.https.html, RTCRtpTransceiver-direction.html">
                <dfn data-idl="">direction</dfn> of type <span class=
                "idlMemberType">{{RTCRtpTransceiverDirection}}</span>,
                defaulting to {{RTCRtpTransceiverDirection/"sendrecv"}}
              </dt>
              <dd>
                The direction of the {{RTCRtpTransceiver}}.
              </dd>
              <dt>
                <dfn data-idl="">streams</dfn> of type <span class=
                "idlMemberType">sequence&lt;{{MediaStream}}&gt;</span>
              </dt>
              <dd>
                <p>
                  When the remote PeerConnection's track event fires
                  corresponding to the {{RTCRtpReceiver}} being added, these
                  are the streams that will be put in the event.
                </p>
              </dd>
              <dt data-tests="RTCRtpParameters-encodings.html">
                <dfn data-idl="">sendEncodings</dfn> of type <span class=
                "idlMemberType">sequence&lt;{{RTCRtpEncodingParameters}}&gt;</span>
              </dt>
              <dd>
                <p>
                  A sequence containing parameters for sending RTP encodings of
                  media.
                </p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">enum RTCRtpTransceiverDirection {
  "sendrecv",
  "sendonly",
  "recvonly",
  "inactive",
  "stopped"
};</pre>
          <table class="simple">
            <thead>
              <tr>
                <th colspan="2">
                  <dfn>RTCRtpTransceiverDirection</dfn> Enumeration description
                </th>
              </tr>
            </thead>
            <tbody data-link-for="RTCRtpTransceiverDirection" data-dfn-for=
            "RTCRtpTransceiverDirection">
              <tr>
                <td data-tests="RTCPeerConnection-transceivers.https.html">
                  <dfn data-idl="">sendrecv</dfn>
                </td>
                <td>
                  The {{RTCRtpTransceiver}}'s {{RTCRtpSender}}
                  <var>sender</var> will offer to send RTP, and will send RTP
                  if the remote peer accepts and
                  <var>sender</var>.{{RTCRtpSender/getParameters()}}.{{RTCRtpSendParameters/encodings}}[<var>i</var>].{{RTCRtpEncodingParameters/active}}
                  is <code>true</code> for any value of <var>i</var>. The
                  {{RTCRtpTransceiver}}'s {{RTCRtpReceiver}} will offer to
                  receive RTP, and will receive RTP if the remote peer accepts.
                </td>
              </tr>
              <tr>
                <td data-tests="RTCPeerConnection-transceivers.https.html">
                  <dfn data-idl="">sendonly</dfn>
                </td>
                <td>
                  The {{RTCRtpTransceiver}}'s {{RTCRtpSender}}
                  <var>sender</var> will offer to send RTP, and will send RTP
                  if the remote peer accepts and
                  <var>sender</var>.{{RTCRtpSender/getParameters()}}.{{RTCRtpSendParameters/encodings}}[<var>i</var>].{{RTCRtpEncodingParameters/active}}
                  is <code>true</code> for any value of <var>i</var>. The
                  {{RTCRtpTransceiver}}'s {{RTCRtpReceiver}} will not offer to
                  receive RTP, and will not receive RTP.
                </td>
              </tr>
              <tr>
                <td data-tests="RTCPeerConnection-transceivers.https.html">
                  <dfn data-idl="">recvonly</dfn>
                </td>
                <td>
                  The {{RTCRtpTransceiver}}'s {{RTCRtpSender}} will not offer
                  to send RTP, and will not send RTP. The
                  {{RTCRtpTransceiver}}'s {{RTCRtpReceiver}} will offer to
                  receive RTP, and will receive RTP if the remote peer accepts.
                </td>
              </tr>
              <tr>
                <td data-tests="RTCPeerConnection-transceivers.https.html">
                  <dfn data-idl="">inactive</dfn>
                </td>
                <td>
                  The {{RTCRtpTransceiver}}'s {{RTCRtpSender}} will not offer
                  to send RTP, and will not send RTP. The
                  {{RTCRtpTransceiver}}'s {{RTCRtpReceiver}} will not offer to
                  receive RTP, and will not receive RTP.
                </td>
              </tr>
              <tr>
                <td data-tests="RTCPeerConnection-transceivers.https.html">
                  <dfn data-idl="">stopped</dfn>
                </td>
                <td>
                  The {{RTCRtpTransceiver}} will neither send nor receive RTP.
                  It will generate a zero port in the offer. In answers, its
                  {{RTCRtpSender}} will not offer to send RTP, and its
                  {{RTCRtpReceiver}} will not offer to receive RTP. This is a
                  terminal state.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <section>
          <h4>
            Processing Remote MediaStreamTracks
          </h4>
          <p>
            An application can reject incoming media descriptions by setting
            the transceiver's direction to either
            {{RTCRtpTransceiverDirection/"inactive"}} to turn off both
            directions temporarily, or to
            {{RTCRtpTransceiverDirection/"sendonly"}} to reject only the
            incoming side. To permanently reject an m-line in a manner that
            makes it available for reuse, the application would need to call
            {{RTCRtpTransceiver}}.{{RTCRtpTransceiver/stop()}} and subsequently
            initiate negotiation from its end.
          </p>
          <p>
            To <dfn id="process-remote-tracks">process remote tracks</dfn>
            given an {{RTCRtpTransceiver}} <var>transceiver</var>,
            <var>direction</var>, <var>msids</var>, <var>addList</var>,
            <var>removeList</var>, and <var>trackEventInits</var>, run the
            following steps:
          </p>
          <ol data-tests="RTCPeerConnection-transceivers.https.html">
            <li data-tests=
            "RTCPeerConnection-ontrack.https.html,RTCPeerConnection-setRemoteDescription-tracks.https.html,RTCTrackEvent-fire.html">
              <p>
                <a>Set the associated remote streams</a> with
                <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}, <var>msids</var>,
                <var>addList</var>, and <var>removeList</var>.
              </p>
            </li>
            <li data-tests=
            "RTCPeerConnection-ontrack.https.html,RTCPeerConnection-setRemoteDescription-tracks.https.html,RTCPeerConnection-transceivers.https.html">
              <p>
                If <var>direction</var> is
                {{RTCRtpTransceiverDirection/"sendrecv"}} or
                {{RTCRtpTransceiverDirection/"recvonly"}} and
                <var>transceiver</var>.{{RTCRtpTransceiver/[[FiredDirection]]}} is neither
                {{RTCRtpTransceiverDirection/"sendrecv"}} nor
                {{RTCRtpTransceiverDirection/"recvonly"}}, or the previous step
                increased the length of <var>addList</var>, <a>process the
                addition of a remote track</a> with <var>transceiver</var> and
                <var>trackEventInits</var>.
              </p>
            </li>
            <li>
              <p>
                If <var>direction</var> is
                {{RTCRtpTransceiverDirection/"sendonly"}} or
                {{RTCRtpTransceiverDirection/"inactive"}}, set
                <var>transceiver</var>.{{RTCRtpTransceiver/[[Receptive]]}} to
                <code>false</code>.
              </p>
            </li>
            <li data-tests="RTCPeerConnection-remote-track-mute.https.html">
              <p>
                If <var>direction</var> is
                {{RTCRtpTransceiverDirection/"sendonly"}} or
                {{RTCRtpTransceiverDirection/"inactive"}}, and
                <var>transceiver</var>.{{RTCRtpTransceiver/[[FiredDirection]]}} is either
                {{RTCRtpTransceiverDirection/"sendrecv"}} or
                {{RTCRtpTransceiverDirection/"recvonly"}}, <a>process the
                removal of a remote track</a> for the <a>media description</a>,
                with <var>transceiver</var> and <var>muteTracks</var>.
              </p>
            </li>
            <li>
              <p>
                Set <var>transceiver</var>.{{RTCRtpTransceiver/[[FiredDirection]]}} to
                <var>direction</var>.
              </p>
            </li>
          </ol>
          <p>
            To <dfn id="process-remote-track-addition">process the addition of
            a remote track</dfn> given an {{RTCRtpTransceiver}}
            <var>transceiver</var> and <var>trackEventInits</var>, run the
            following steps:
          </p>
          <ol data-tests="RTCPeerConnection-transceivers.https.html">
            <li>
              <p>
                Let <var>receiver</var> be
                <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.
              </p>
            </li>
            <li>
              <p>
                Let <var>track</var> be
                <var>receiver</var>.{{RTCRtpReceiver/[[ReceiverTrack]]}}.
              </p>
            </li>
            <li>
              <p>
                Let <var>streams</var> be
                <var>receiver</var>.{{RTCRtpReceiver/[[AssociatedRemoteMediaStreams]]}}.
              </p>
            </li>
            <li>
              <p>
                Create a new {{RTCTrackEventInit}} dictionary with
                <var>receiver</var>, <var>track</var>, <var>streams</var> and
                <var>transceiver</var> as members and add it to
                <var>trackEventInits</var>.
              </p>
            </li>
          </ol>
          <p>
            To <dfn id="process-remote-track-removal">process the removal of a
            remote track</dfn> with an {{RTCRtpTransceiver}}
            <var>transceiver</var> and <var>muteTracks</var>, run the following
            steps:
          </p>
          <ol data-tests="RTCPeerConnection-remote-track-mute.https.html">
            <li>
              <p>
                Let <var>receiver</var> be
                <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.
              </p>
            </li>
            <li>
              <p>
                Let <var>track</var> be
                <var>receiver</var>.{{RTCRtpReceiver/[[ReceiverTrack]]}}.
              </p>
            </li>
            <li data-tests="RTCRtpTransceiver.https.html">
              <p>
                If <var>track.muted</var> is <code>false</code>, add
                <var>track</var> to <var>muteTracks</var>.
              </p>
            </li>
          </ol>
          <p>
            To <dfn id="set-associated-remote-streams">set the associated
            remote streams</dfn> given {{RTCRtpReceiver}} <var>receiver</var>,
            <var>msids</var>, <var>addList</var>, and <var>removeList</var>,
            run the following steps:
          </p>
          <ol>
            <li class="no-test-needed">
              <p>
                Let <var>connection</var> be the {{RTCPeerConnection}} object
                associated with <var>receiver</var>.
              </p>
            </li>
            <li data-tests=
            "RTCPeerConnection-ontrack.https.html,protocol/msid-parse.html">
              <p>
                For each MSID in <var>msids</var>, unless a {{MediaStream}}
                object has previously been created with that <code class=
                "gum">id</code> for this <var>connection</var>, create a
                {{MediaStream}} object with that <code class="gum">id</code>.
              </p>
            </li>
            <li class="no-test-needed">
              <p>
                Let <var>streams</var> be a list of the {{MediaStream}} objects
                created for this <var>connection</var> with the <code class=
                "gum">id</code>s corresponding to <var>msids</var>.
              </p>
            </li>
            <li class="no-test-needed">
              <p>
                Let <var>track</var> be
                <var>receiver</var>.{{RTCRtpReceiver/[[ReceiverTrack]]}}.
              </p>
            </li>
            <li>
              <p>
                For each <var>stream</var> in
                <var>receiver</var>.{{RTCRtpReceiver/[[AssociatedRemoteMediaStreams]]}}
                that is not present in <var>streams</var>, add
                <var>stream</var> and <var>track</var> as a pair to
                <var>removeList</var>.
              </p>
            </li>
            <li data-tests=
            "RTCPeerConnection-ontrack.https.html,RTCPeerConnection-setRemoteDescription-nomsid.html,protocol/msid-parse.html">
              <p>
                For each <var>stream</var> in <var>streams</var> that is not
                present in
                <var>receiver</var>.{{RTCRtpReceiver/[[AssociatedRemoteMediaStreams]]}},
                add <var>stream</var> and <var>track</var> as a pair to
                <var>addList</var>.
              </p>
            </li>
            <li data-tests=
            "RTCPeerConnection-ontrack.https.html,RTCPeerConnection-setRemoteDescription-nomsid.html,protocol/msid-parse.html">
              <p>
                Set
                <var>receiver</var>.{{RTCRtpReceiver/[[AssociatedRemoteMediaStreams]]}} to
                <var>streams</var>.
              </p>
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h3>
          <dfn>RTCRtpSender</dfn> Interface
        </h3>
        <p>
          The {{RTCRtpSender}} interface allows an application to control how a
          given {{MediaStreamTrack}} is encoded and transmitted to a remote
          peer. When {{RTCRtpSender/setParameters}} is called on an
          {{RTCRtpSender}} object, the encoding is changed appropriately.
        </p>
        <p>
          To <dfn>create an RTCRtpSender</dfn> with a {{MediaStreamTrack}},
          <var>track</var>, a string, <var>kind</var>, a list of
          {{MediaStream}} objects, <var>streams</var>, and optionally a list of
          {{RTCRtpEncodingParameters}} objects, <var>sendEncodings</var>, run
          the following steps:
        </p>
        <ol>
          <li class="no-test-needed">
            <p>
              Let <var>sender</var> be a new {{RTCRtpSender}} object.
            </p>
          </li>
          <li data-tests="RTCPeerConnection-addTransceiver.https.html">
            <p>
              Let <var>sender</var> have a <dfn data-dfn-for="RTCRtpSender">[[\SenderTrack]]</dfn> internal
              slot initialized to <var>track</var>.
            </p>
          </li>
          <li data-tests="RTCRtpSender-transport.https.html">
            <p>
              Let <var>sender</var> have a <dfn data-dfn-for="RTCRtpSender">[[\SenderTransport]]</dfn>
              internal slot initialized to <code>null</code>.
            </p>
          </li>
          <li>
            <p>
              Let <var>sender</var> have a
              <dfn data-dfn-for="RTCRtpSender">[[\LastStableStateSenderTransport]]</dfn> internal slot
              initialized to <code>null</code>.
            </p>
          </li>
          <li data-tests="RTCDTMFSender-insertDTMF.https.html">
            <p>
              Let <var>sender</var> have a <dfn data-dfn-for="RTCRtpSender">[[\Dtmf]]</dfn> internal slot
              initialized to <code>null</code>.
            </p>
          </li>
          <li data-tests="RTCDTMFSender-insertDTMF.https.html">
            <p>
              If <var>kind</var> is <code>"audio"</code> then <a>create an
              RTCDTMFSender</a> <var>dtmf</var> and set the {{RTCRtpSender/[[Dtmf]]}}
              internal slot to <var>dtmf</var>.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Let <var>sender</var> have an
              <dfn data-dfn-for="RTCRtpSender">[[\AssociatedMediaStreamIds]]</dfn> internal slot,
              representing a list of Ids of {{MediaStream}} objects that this
              sender is to be associated with. The
              {{RTCRtpSender/[[AssociatedMediaStreamIds]]}} slot is used when
              <var>sender</var> is represented in SDP as described in
              <span data-jsep="initial-offers">[[!RFC8829]]</span>.
            </p>
          </li>
          <li>
            <p>
              Set <var>sender</var>.{{RTCRtpSender/[[AssociatedMediaStreamIds]]}} to an
              empty set.
            </p>
          </li>
          <li>
            <p>
              For each <var>stream</var> in <var>streams</var>, add
              <var>stream.id</var> to {{RTCRtpSender/[[AssociatedMediaStreamIds]]}} if
              it's not already there.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Let <var>sender</var> have a <dfn data-dfn-for="RTCRtpSender">[[\SendEncodings]]</dfn>
              internal slot, representing a list of
              {{RTCRtpEncodingParameters}} dictionaries.
            </p>
          </li>
          <li data-tests=
          "RTCPeerConnection-transceivers.https.html,protocol/simulcast-offer.html">
            <p>
              If <var>sendEncodings</var> is given as input to this algorithm,
              and is non-empty, set the {{RTCRtpSender/[[SendEncodings]]}} slot to
              <var>sendEncodings</var>. Otherwise, set it to a list containing
              a single {{RTCRtpEncodingParameters}} with
              {{RTCRtpEncodingParameters/active}} set to <code>true</code>.
            </p>
          </li>
          <li>
            <p>
              Let <var>sender</var> have a <dfn data-dfn-for="RTCRtpSender">[[\SendCodecs]]</dfn> internal
              slot, representing a list of {{RTCRtpCodecParameters}}
              dictionaries, and initialized to an empty list.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Let <var>sender</var> have a
              <dfn data-dfn-for="RTCRtpSender">[[\LastReturnedParameters]]</dfn> internal slot, which will
              be used to match {{RTCRtpSender/getParameters}} and
              {{RTCRtpSender/setParameters}} transactions.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Return <var>sender</var>.
            </p>
          </li>
        </ol>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCRtpSender {
  readonly attribute MediaStreamTrack? track;
  readonly attribute RTCDtlsTransport? transport;
  static RTCRtpCapabilities? getCapabilities(DOMString kind);
  Promise&lt;undefined&gt; setParameters(RTCRtpSendParameters parameters);
  RTCRtpSendParameters getParameters();
  Promise&lt;undefined&gt; replaceTrack(MediaStreamTrack? withTrack);
  undefined setStreams(MediaStream... streams);
  Promise&lt;RTCStatsReport&gt; getStats();
};</pre>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCRtpSender" data-dfn-for="RTCRtpSender" class=
            "attributes">
              <dt>
                <dfn data-idl="">track</dfn> of type <span class=
                "idlAttrType">{{MediaStreamTrack}}</span>, readonly, nullable
              </dt>
              <dd>
                <p>
                  The {{track}} attribute is the track that is associated with
                  this {{RTCRtpSender}} object. If {{track}} is ended, or if
                  the track's output is disabled, i.e. the track is disabled
                  and/or muted, the {{RTCRtpSender}} MUST send black frames
                  (video) and MUST NOT send (audio). In the case of video, the
                  {{RTCRtpSender}} SHOULD send one black frame per second. If
                  {{track}} is <code>null</code> then the {{RTCRtpSender}} does
                  not send. On getting, the attribute MUST return the value of
                  the {{RTCRtpSender/[[SenderTrack]]}} slot.
                </p>
              </dd>
              <dt data-tests=
              "RTCDtlsTransport-state.html,RTCRtpSender-transport.https.html">
                <dfn data-idl="">transport</dfn> of type <span class=
                "idlAttrType">{{RTCDtlsTransport}}</span>, readonly, nullable
              </dt>
              <dd>
                <p>
                  The {{transport}} attribute is the transport over which media
                  from {{track}} is sent in the form of RTP packets. Prior to
                  construction of the {{RTCDtlsTransport}} object, the
                  {{transport}} attribute will be null. When bundling is used,
                  multiple {{RTCRtpSender}} objects will share one
                  {{transport}} and will all send RTP and RTCP over the same
                  transport.
                </p>
                <p>
                  On getting, the attribute MUST return the value of the
                  {{RTCRtpSender/[[SenderTransport]]}} slot.
                </p>
              </dd>
            </dl>
          </section>
          <section>
            <h2>
              Methods
            </h2>
            <dl data-link-for="RTCRtpSender" data-dfn-for="RTCRtpSender" class=
            "methods">
              <dt data-tests="RTCRtpSender-getCapabilities.html">
                <dfn data-idl="">getCapabilities</dfn>, static
              </dt>
              <dd>
                <p data-tests="RTCRtpSender-getCapabilities.html">
                  The {{getCapabilities()}} method returns the most optimistic
                  view of the capabilities of the system for sending media of
                  the given kind. It does not reserve any resources, ports, or
                  other state but is meant to provide a way to discover the
                  types of capabilities of the browser including which codecs
                  may be supported. User agents MUST support <var>kind</var>
                  values of <code>"audio"</code> and <code>"video"</code>. If
                  the system has no capabilities corresponding to the value of
                  the <var>kind</var> argument, {{getCapabilities}} returns
                  <code>null</code>.
                </p>
                <p class="fingerprint">
                  These capabilities provide generally persistent cross-origin
                  information on the device and thus increases the
                  fingerprinting surface of the application. In
                  privacy-sensitive contexts, browsers can consider mitigations
                  such as reporting only a common subset of the capabilities.
                </p>
                <div class="note">
                  <p>
                    The codec capabilities returned affect the
                    {{RTCRtpTransceiver/setCodecPreferences()}} algorithm and
                    what inputs it throws {{InvalidModificationError}} on,
                    and should also be consistent with information revealed by
                    {{RTCPeerConnection/createOffer()}} and {{RTCPeerConnection/createAnswer()}} about codecs
                    negotiated for sending, to ensure any
                    privacy mitigations are effective.
                  </p>
                </div>
              </dd>
              <dt data-tests=
              "RTCRtpParameters-codecs.html,RTCRtpSender-setParameters.html">
                <dfn data-idl="">setParameters</dfn>
              </dt>
              <dd>
                <p>
                  The {{setParameters}} method updates how {{track}} is encoded
                  and transmitted to a remote peer.
                </p>
                <p>
                  When the {{setParameters}} method is called, the user agent
                  MUST run the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">Let <var>parameters</var> be the
                  method's first argument.
                  </li>
                  <li class="no-test-needed">Let <var>sender</var> be the
                  {{RTCRtpSender}} object on which {{setParameters}} is
                  invoked.
                  </li>
                  <li class="no-test-needed">Let <var>transceiver</var> be the
                  {{RTCRtpTransceiver}} object associated with
                  <var>sender</var> (i.e. <var>sender</var> is
                  <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}).
                  </li>
                  <li data-tests=
                  "RTCRtpSender-setParameters.html,RTCRtpTransceiver.https.html">
                  If <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopped]]}} is
                  <code>true</code>, return a promise [= rejected =] with a
                  newly [= exception/created =] {{InvalidStateError}}.
                  </li>
                  <li data-tests="RTCRtpParameters-transactionId.html">If <var>
                    sender</var>.{{RTCRtpSender/[[LastReturnedParameters]]}} is
                    <code>null</code>, return a promise [= rejected =] with a
                    newly [= exception/created =] {{InvalidStateError}}.
                  </li>
                  <li>Validate <var>parameters</var> by running the following
                  steps:
                    <ol>
                      <li class="no-test-needed">Let <var>encodings</var> be
                      <var>parameters</var>.{{RTCRtpSendParameters/encodings}}.
                      </li>
                      <li class="no-test-needed">Let <var>codecs</var> be <var>
                        parameters</var>.{{RTCRtpParameters/codecs}}.
                      </li>
                      <li class="no-test-needed">Let <var>N</var> be the number
                      of {{RTCRtpEncodingParameters}} stored in
                      <var>sender</var>.{{RTCRtpSender/[[SendEncodings]]}}.
                      </li>
                      <li>If any of the following conditions are met, return a
                      promise [= rejected =] with a newly [= exception/created
                      =] {{InvalidModificationError}}:
                        <ol>
                          <li data-tests="RTCRtpParameters-encodings.html">
                            <code><var>encodings</var>.length</code> is
                            different from <var>N</var>.
                          </li>
                          <li>
                            <var>encodings</var> has been re-ordered.
                          </li>
                          <li data-tests=
                          "RTCRtpParameters-codecs.html,RTCRtpParameters-encodings.html,RTCRtpParameters-headerExtensions.html,RTCRtpParameters-rtcp.html,RTCRtpParameters-transactionId.html">
                          Any parameter in <var>parameters</var> is marked as a
                          <dfn>Read-only parameter</dfn> (such as RID) and has
                          a value that is different from the corresponding
                          parameter value in
                          <var>sender</var>.{{RTCRtpSender/[[LastReturnedParameters]]}}.
                          Note that this also applies to
                          <var>transactionId</var>.
                          </li>
                        </ol>
                      </li>
                      <li data-tests="RTCRtpParameters-encodings.html">
                        <p>
                          Verify that each encoding in <var>encodings</var> has
                          a {{RTCRtpEncodingParameters/scaleResolutionDownBy}}
                          member whose value is greater than or equal to 1.0. If one of the
                          {{RTCRtpEncodingParameters/scaleResolutionDownBy}}
                          values does not meet this requirement, return a
                          promise [= rejected =] with a newly [=
                          exception/created =] {{RangeError}}.
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li class="no-test-needed">Let <var>p</var> be a new promise.
                  </li>
                  <li>In parallel, configure the media stack to use
                  <var>parameters</var> to transmit
                  <var>sender</var>.{{RTCRtpSender/[[SenderTrack]]}}.
                    <ol>
                      <li>If the media stack is successfully configured with
                      <var>parameters</var>, queue a task to run the following
                      steps:
                        <ol>
                          <li data-tests=
                          "RTCRtpParameters-codecs.html,RTCRtpParameters-encodings.html, RTCRtpParameters-headerExtensions.html,RTCRtpParameters-rtcp.html, RTCRtpParameters-transactionId.html">
                          Set
                          <var>sender</var>.{{RTCRtpSender/[[LastReturnedParameters]]}}
                          to <code>null</code>.
                          </li>
                          <li>Set <var>sender</var>.{{RTCRtpSender/[[SendEncodings]]}}
                          to
                          <var>parameters</var>.{{RTCRtpSendParameters/encodings}}.
                          </li>
                          <li>[= Resolve =] <var>p</var> with
                          <code>undefined</code>.
                          </li>
                        </ol>
                      </li>
                      <li>If any error occurred while configuring the media
                      stack, queue a task to run the following steps:
                        <ol>
                          <li>If an error occurred due to hardware resources
                          not being available, [= reject =] <var>p</var> with a
                          newly created {{RTCError}} whose
                          {{RTCError/errorDetail}} is set to
                          {{RTCErrorDetailType/"hardware-encoder-not-available"}}
                          and abort these steps.
                          </li>
                          <li>If an error occurred due to a hardware encoder
                          not supporting <var>parameters</var>, [= reject =]
                          <var>p</var> with a newly created {{RTCError}} whose
                          {{RTCError/errorDetail}} is set to
                          {{RTCErrorDetailType/"hardware-encoder-error"}} and
                          abort these steps.
                          </li>
                          <li>For all other errors, [= reject =] <var>p</var>
                          with a newly [= exception/created =]
                          {{OperationError}}.
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                  <li class="no-test-needed">Return <var>p</var>.
                  </li>
                </ol>
                <p>
                  {{setParameters}} does not cause SDP renegotiation and can
                  only be used to change what the media stack is sending or
                  receiving within the envelope negotiated by Offer/Answer. The
                  attributes in the {{RTCRtpSendParameters}} dictionary are
                  designed to not enable this, so attributes like
                  {{RTCRtcpParameters/cname}} that cannot be changed are
                  read-only. Other things, like bitrate, are controlled using
                  limits such as {{RTCRtpEncodingParameters/maxBitrate}}, where
                  the user agent needs to ensure it does not exceed the maximum
                  bitrate specified by {{RTCRtpEncodingParameters/maxBitrate}},
                  while at the same time making sure it satisfies constraints
                  on bitrate specified in other places such as the SDP.
                </p>
              </dd>
              <dt data-tests=
              "RTCRtpParameters-codecs.html,protocol/video-codecs.https.html">
                <dfn data-idl="">getParameters</dfn>
              </dt>
              <dd>
                <p>
                  The {{getParameters()}} method returns the {{RTCRtpSender}}
                  object's current parameters for how {{track}} is encoded and
                  transmitted to a remote {{RTCRtpReceiver}}.
                </p>
                <p>
                  When {{getParameters}} is called, the user agent MUST run the
                  following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>sender</var> be the {{RTCRtpSender}} object on
                      which the getter was invoked.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>sender</var>.{{RTCRtpSender/[[LastReturnedParameters]]}}
                      is not <code>null</code>, return
                      <var>sender</var>.{{RTCRtpSender/[[LastReturnedParameters]]}}, and
                      abort these steps.
                    </p>
                  </li>
                  <li>
                    <p>
                      Let <var>result</var> be a new {{RTCRtpSendParameters}}
                      dictionary constructed as follows:
                    </p>
                    <ul>
                      <li data-tests=
                      "RTCRtpParameters-codecs.html,RTCRtpParameters-encodings.html,RTCRtpParameters-transactionId.html">
                      {{RTCRtpSendParameters/transactionId}} is set to a new
                      unique identifier.
                      </li>
                      <li data-tests="RTCRtpParameters-encodings.html">
                      {{RTCRtpSendParameters/encodings}} is set to the value of
                      the {{RTCRtpSender/[[SendEncodings]]}} internal slot.
                      </li>
                      <li data-tests="RTCRtpParameters-headerExtensions.html">
                      The {{RTCRtpParameters/headerExtensions}} sequence is
                      populated based on the header extensions that have been
                      negotiated for sending.
                      </li>
                      <li data-tests=
                      "RTCRtpParameters-codecs.html,protocol/video-codecs.https.html">
                      {{RTCRtpParameters/codecs}} is set to the value of the
                      {{RTCRtpSender/[[SendCodecs]]}} internal slot.
                      </li>
                      <li data-tests="RTCRtpParameters-encodings.html">
                      {{RTCRtpParameters/rtcp}}.{{RTCRtcpParameters/cname}} is
                      set to the CNAME of the associated {{RTCPeerConnection}}.
                      {{RTCRtpParameters/rtcp}}.{{RTCRtcpParameters/reducedSize}}
                      is set to <code>true</code> if reduced-size RTCP has been
                      negotiated for sending, and <code>false</code> otherwise.
                      </li>
                    </ul>
                  </li>
                  <li>
                    <p>
                      Set <var>sender</var>.{{RTCRtpSender/[[LastReturnedParameters]]}}
                      to <var>result</var>.
                    </p>
                  </li>
                  <li>
                    <p>
                      Queue a task that sets
                      <var>sender</var>.{{RTCRtpSender/[[LastReturnedParameters]]}} to
                      <code>null</code>.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Return <var>result</var>.
                    </p>
                  </li>
                </ol>
                <p>
                  {{getParameters}} may be used with {{setParameters}} to
                  change the parameters in the following way:
                </p>
                <pre class="example highlight">
async function updateParameters() {
  try {
    const params = sender.getParameters();
    // ... make changes to parameters
    params.encodings[0].active = false;
    await sender.setParameters(params);
  } catch (err) {
    console.error(err);
  }
}
              </pre>
                <p>
                  After a completed call to {{setParameters}}, subsequent calls
                  to {{getParameters}} will return the modified set of
                  parameters.
                </p>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-setRemoteDescription-replaceTrack.https.html,RTCRtpSender-replaceTrack.https.html">
                <dfn data-idl="">replaceTrack</dfn>
              </dt>
              <dd>
                <p>
                  Attempts to replace the {{RTCRtpSender}}'s current {{track}}
                  with another track provided (or with a <code>null</code>
                  track), without renegotiation.
                </p>
                <p>
                  When the {{replaceTrack}} method is invoked, the user agent
                  MUST run the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>sender</var> be the {{RTCRtpSender}} object on
                      which {{replaceTrack}} is invoked.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>transceiver</var> be the {{RTCRtpTransceiver}}
                      object associated with <var>sender</var>.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>connection</var> be the {{RTCPeerConnection}}
                      object associated with <var>sender</var>.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>withTrack</var> be the argument to this method.
                    </p>
                  </li>
                  <li data-tests="RTCRtpSender-replaceTrack.https.html">
                    <p>
                      If <var>withTrack</var> is non-null and
                      <code><var>withTrack</var>.kind</code> differs from the
                      <a>transceiver kind</a> of <var>transceiver</var>, return
                      a promise [= rejected =] with a newly [=
                      exception/created =] {{TypeError}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      Return the result of [= chaining =] the following steps
                      to <var>connection</var>'s [= operations chain =]:
                    </p>
                    <ol>
                      <li data-tests=
                      "RTCPeerConnection-setRemoteDescription-replaceTrack.https.html,RTCRtpSender-replaceTrack.https.html,RTCRtpTransceiver.https.html">
                        <p>
                          If <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopped]]}} is
                          <code>true</code>, return a promise [= rejected =]
                          with a newly [= exception/created =]
                          {{InvalidStateError}}.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>p</var> be a new promise.
                        </p>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Let <var>sending</var> be <code>true</code> if
                          <var>transceiver</var>.{{RTCRtpTransceiver/[[CurrentDirection]]}}
                          is {{RTCRtpTransceiverDirection/"sendrecv"}} or
                          {{RTCRtpTransceiverDirection/"sendonly"}}, and
                          <code>false</code> otherwise.
                        </p>
                      </li>
                      <li>
                        <p>
                          Run the following steps in parallel:
                        </p>
                        <ol>
                          <li data-tests=
                          "RTCRtpSender-replaceTrack.https.html">
                            <p>
                              If <var>sending</var> is <code>true</code>, and
                              <var>withTrack</var> is <code>null</code>, have
                              the sender stop sending.
                            </p>
                          </li>
                          <li data-tests=
                          "RTCRtpSender-replaceTrack.https.html">
                            <p>
                              If <var>sending</var> is <code>true</code>, and
                              <var>withTrack</var> is not <code>null</code>,
                              determine if <var>withTrack</var> can be sent
                              immediately by the sender without violating the
                              sender's already-negotiated envelope, and if it
                              cannot, then [= reject =] <var>p</var> with a
                              newly [= exception/created =]
                              {{InvalidModificationError}}, and abort these
                              steps.
                            </p>
                          </li>
                          <li>
                            <p>
                              If <var>sending</var> is <code>true</code>, and
                              <var>withTrack</var> is not <code>null</code>,
                              have the sender switch seamlessly to transmitting
                              <var>withTrack</var> instead of the sender's
                              existing track.
                            </p>
                          </li>
                          <li>
                            <p data-tests=
                            "RTCPeerConnection-setRemoteDescription-replaceTrack.https.html,RTCRtpSender-replaceTrack.https.html">
                              Queue a task that runs the following steps:
                            </p>
                            <ol>
                              <li>
                                <p>
                                  If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}}
                                  is <code>true</code>, abort these steps.
                                </p>
                              </li>
                              <li data-tests=
                              "RTCPeerConnection-setRemoteDescription-replaceTrack.https.html">
                                <p>
                                  Set <var>sender</var>.{{RTCRtpSender/[[SenderTrack]]}}
                                  to <var>withTrack</var>.
                                </p>
                              </li>
                              <li>
                                <p>
                                  [= Resolve =] <var>p</var> with
                                  <code>undefined</code>.
                                </p>
                              </li>
                            </ol>
                          </li>
                        </ol>
                      </li>
                      <li class="no-test-needed">
                        <p>
                          Return <var>p</var>.
                        </p>
                      </li>
                    </ol>
                  </li>
                </ol>
                <div class="note">
                  <p>
                    Changing dimensions and/or frame rates might not require
                    negotiation. Cases that may require negotiation include:
                  </p>
                  <ol>
                    <li>Changing a resolution to a value outside of the
                    negotiated imageattr bounds, as described in [[RFC6236]].
                    </li>
                    <li>Changing a frame rate to a value that causes the block
                    rate for the codec to be exceeded.
                    </li>
                    <li>A video track differing in raw vs. pre-encoded format.
                    </li>
                    <li>An audio track having a different number of channels.
                    </li>
                    <li>Sources that also encode (typically hardware encoders)
                    might be unable to produce the negotiated codec; similarly,
                    software sources might not implement the codec that was
                    negotiated for an encoding source.
                    </li>
                  </ol>
                </div>
              </dd>
              <dt data-tests=
              "RTCRtpSender-setStreams.https.html,RTCPeerConnection-onnegotiationneeded.html">
                <dfn data-idl="">setStreams</dfn>
              </dt>
              <dd>
                <p>
                  Sets the {{MediaStream}}s to be associated with this sender's
                  track.
                </p>
                <p>
                  When the {{setStreams}} method is invoked, the user agent
                  MUST run the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>sender</var> be the {{RTCRtpSender}} object on
                      which this method was invoked.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>connection</var> be the {{RTCPeerConnection}}
                      object on which this method was invoked.
                    </p>
                  </li>
                  <li data-tests="RTCRtpSender-setStreams.https.html">
                    <p>
                      If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                      <code>true</code>, [= exception/throw =] an
                      {{InvalidStateError}}.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>streams</var> be a list of {{MediaStream}}
                      objects constructed from the method's arguments, or an
                      empty list if the method was called without arguments.
                    </p>
                  </li>
                  <li>
                    <p>
                      Set
                      <var>sender</var>.{{RTCRtpSender/[[AssociatedMediaStreamIds]]}} to
                      an empty set.
                    </p>
                  </li>
                  <li data-tests="RTCRtpSender-setStreams.https.html">
                    <p>
                      For each <var>stream</var> in <var>streams</var>, add
                      <var>stream.id</var> to
                      {{RTCRtpSender/[[AssociatedMediaStreamIds]]}} if it's not already
                      there.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                    <p>
                      [= Update the negotiation-needed flag =] for
                      <var>connection</var>.
                    </p>
                  </li>
                </ol>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-getStats.https.html,RTCRtpSender-getStats.https.html">
                <dfn data-idl="" id=
                "widl-RTCRtpSender-getStats-Promise-RTCStatsReport">getStats</dfn>
              </dt>
              <dd>
                <p>
                  Gathers stats for this sender only and reports the result
                  asynchronously.
                </p>
                <p>
                  When the {{getStats()}} method is invoked, the user agent
                  MUST run the following steps:
                </p>
                <ol data-tests="RTCRtpSender-getStats.https.html">
                  <li class="no-test-needed">
                    <p>
                      Let <var>selector</var> be the {{RTCRtpSender}} object on
                      which the method was invoked.
                    </p>
                  </li>
                  <li>
                    <p>
                      Let <var>p</var> be a new promise, and run the following
                      steps in parallel:
                    </p>
                    <ol>
                      <li>
                        <p>
                          Gather the stats indicated by <var>selector</var>
                          according to the [= stats selection algorithm =].
                        </p>
                      </li>
                      <li>
                        <p>
                          [= Resolve =] <var>p</var> with the resulting
                          {{RTCStatsReport}} object, containing the gathered
                          stats.
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Return <var>p</var>.
                    </p>
                  </li>
                </ol>
              </dd>
            </dl>
          </section>
        </div>
        <section id="rtcrtpparameters">
          <h3>
            <dfn>RTCRtpParameters</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCRtpParameters {
  required sequence&lt;RTCRtpHeaderExtensionParameters&gt; headerExtensions;
  required RTCRtcpParameters rtcp;
  required sequence&lt;RTCRtpCodecParameters&gt; codecs;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCRtpParameters}} Members
              </h2>
              <dl data-link-for="RTCRtpParameters" data-dfn-for=
              "RTCRtpParameters" class="dictionary-members">
                <dt data-tests="RTCRtpParameters-headerExtensions.html">
                  <dfn data-idl="">headerExtensions</dfn> of type <span class=
                  "idlMemberType">sequence&lt;{{RTCRtpHeaderExtensionParameters}}&gt;</span>,
                  required
                </dt>
                <dd>
                  <p>
                    A sequence containing parameters for RTP header extensions.
                    <a>Read-only parameter</a>.
                  </p>
                </dd>
                <dt data-tests="RTCRtpParameters-rtcp.html">
                  <dfn data-idl="">rtcp</dfn> of type <span class=
                  "idlMemberType">{{RTCRtcpParameters}}</span>, required
                </dt>
                <dd>
                  <p>
                    Parameters used for RTCP. <a>Read-only parameter</a>.
                  </p>
                </dd>
                <dt data-tests=
                "RTCRtpParameters-codecs.html,protocol/video-codecs.https.html">
                  <dfn data-idl="">codecs</dfn> of type <span class=
                  "idlMemberType">sequence&lt;{{RTCRtpCodecParameters}}&gt;</span>,
                  required
                </dt>
                <dd>
                  <p>
                    A sequence containing the media codecs that an
                    {{RTCRtpSender}} will choose from, as well as entries for
                    RTX, RED and FEC mechanisms. Corresponding to each media
                    codec where retransmission via RTX is enabled, there will
                    be an entry in {{codecs}} with a
                    {{RTCRtpCodecParameters/mimeType}} attribute indicating
                    retransmission via <code class="mime">audio/rtx</code> or
                    <code class="mime">video/rtx</code>, and an
                    {{RTCRtpCodecParameters/sdpFmtpLine}} attribute (providing
                    the "apt" and "rtx-time" parameters). <a>Read-only
                    parameter</a>.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section id="rtcsendrtpparameters">
          <h3>
            <dfn>RTCRtpSendParameters</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">
              dictionary RTCRtpSendParameters : RTCRtpParameters {
                required DOMString transactionId;
                required sequence&lt;RTCRtpEncodingParameters&gt; encodings;
              };
            </pre>
            <section>
              <h2>
                Dictionary {{RTCRtpSendParameters}} Members
              </h2>
              <dl data-link-for="RTCRtpSendParameters" data-dfn-for=
              "RTCRtpSendParameters" class="dictionary-members">
                <!-- test needs to be updated to check for required -->
                <dt data-tests="RTCRtpParameters-transactionId.html">
                  <dfn data-idl="">transactionId</dfn> of type <span class=
                  "idlMemberType">DOMString</span>, required
                </dt>
                <dd>
                  <p>
                    A unique identifier for the last set of parameters applied.
                    Ensures that {{RTCRtpSender/setParameters}} can only be
                    called based on a previous {{RTCRtpSender/getParameters}},
                    and that there are no intervening changes. [= Read-only
                    parameter =].
                  </p>
                </dd>
                <dt>
                  <dfn data-idl="">encodings</dfn> of type <span class=
                  "idlMemberType">sequence&lt;{{RTCRtpEncodingParameters}}&gt;</span>,
                  required
                </dt>
                <dd>
                  <p>
                    A sequence containing parameters for RTP encodings of
                    media.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section id="rtcreceivertpparameters">
          <h3>
            <dfn>RTCRtpReceiveParameters</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCRtpReceiveParameters : RTCRtpParameters {
};</pre>
          </div>
        </section>
        <section id="rtcrtpcodingparameters">
          <h3>
            <dfn>RTCRtpCodingParameters</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCRtpCodingParameters {
  DOMString rid;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCRtpCodingParameters}} Members
              </h2>
              <dl data-link-for="RTCRtpCodingParameters" data-dfn-for=
              "RTCRtpCodingParameters" class="dictionary-members">
                <dt data-tests="RTCRtpParameters-encodings.html">
                  <dfn data-idl="">rid</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd>
                  <p>
                    If set, this RTP encoding will be sent with the RID header
                    extension as defined by <span data-jsep=
                    "initial-offers">[[!RFC8829]]</span>. The RID is not
                    modifiable via {{RTCRtpSender/setParameters}}. It can only
                    be set or modified in {{RTCPeerConnection/addTransceiver}}
                    on the sending side. <a>Read-only parameter</a>.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section id="rtcrtpdecodingparameters">
          <h3>
            <dfn>RTCRtpDecodingParameters</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCRtpDecodingParameters : RTCRtpCodingParameters {};</pre>
          </div>
        </section>
        <section id="rtcrtpencodingparameters">
          <h3>
            <dfn>RTCRtpEncodingParameters</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCRtpEncodingParameters : RTCRtpCodingParameters {
  boolean active = true;
  unsigned long maxBitrate;
  double scaleResolutionDownBy;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCRtpEncodingParameters}} Members
              </h2>
              <dl data-link-for="RTCRtpEncodingParameters" data-dfn-for=
              "RTCRtpEncodingParameters" class="dictionary-members">
                <dt data-tests=
                "RTCPeerConnection-transceivers.https.html,RTCRtpParameters-encodings.html">
                  <dfn data-idl="">active</dfn> of type <span class=
                  "idlMemberType">boolean</span>, defaulting to
                  <code>true</code>
                </dt>
                <dd>
                  <p>
                    Indicates that this encoding is actively being sent.
                    Setting it to <code>false</code> causes this encoding to no
                    longer be sent. Setting it to <code>true</code> causes this
                    encoding to be sent. Since setting the value to
                    <code>false</code> does not cause the SSRC to be removed,
                    an RTCP BYE is not sent.
                  </p>
                </dd>
                <!-- Could add test to validate it does what it says it does with very low values and high values, and check stats-->
                <dt data-tests="RTCRtpParameters-encodings.html">
                  <dfn data-idl="">maxBitrate</dfn> of type <span class=
                  "idlMemberType">unsigned long</span>
                </dt>
                <dd>
                  <p>
                    When present, indicates the maximum bitrate that can be
                    used to send this encoding. The user agent is free to
                    allocate bandwidth between the encodings, as long as the
                    {{maxBitrate}} value is not exceeded. The encoding may also
                    be further constrained by other limits (such as
                    per-transport or per-session bandwidth limits) below the
                    maximum specified here. {{maxBitrate}} is computed the same
                    way as the Transport Independent Application Specific
                    Maximum (TIAS) bandwidth defined in [[RFC3890]] Section
                    6.2.2, which is the maximum bandwidth needed without
                    counting IP or other transport layers like TCP or UDP. The
                    unit of {{maxBitrate}} is bits per second.
                  </p>
                  <p class="note">
                    How the bitrate is achieved is media and encoding
                    dependent. For video, a frame will always be sent as fast
                    as possible, but frames may be dropped until bitrate is low
                    enough. Thus, even a bitrate of zero will allow sending one
                    frame. For audio, it might be necessary to stop playing if
                    the bitrate does not allow the chosen encoding enough
                    bandwidth to be sent.
                  </p>
                </dd>
                <!-- Could add test to validate it does what it says it does -->
                <dt data-tests="RTCRtpParameters-encodings.html">
                  <dfn data-idl="">scaleResolutionDownBy</dfn> of type
                  <span class="idlMemberType">double</span>
                </dt>
                <dd>
                  <p>
                    This member is only present if the sender's <code class=
                    "gum">kind</code> is <code>"video"</code>. The video's
                    resolution will be scaled down in each dimension by the
                    given value before sending. For example, if the value is
                    2.0, the video will be scaled down by a factor of 2 in each
                    dimension, resulting in sending a video of one quarter the
                    size. If the value is 1.0, the video will not be affected.
                    The value must be greater than or equal to 1.0. By default,
                    scaling is applied by a factor of two to the power of the
                    layer's number, in order of smaller to higher resolutions,
                    e.g. 4:2:1. If there is only one layer, the sender will by
                    default not apply any scaling, (i.e.
                    {{RTCRtpEncodingParameters/scaleResolutionDownBy}} will be
                    1.0).
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section id="rtcrtcpparameters">
          <h3>
            <dfn>RTCRtcpParameters</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCRtcpParameters {
  DOMString cname;
  boolean reducedSize;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCRtcpParameters}} Members
              </h2>
              <dl data-link-for="RTCRtcpParameters" data-dfn-for=
              "RTCRtcpParameters" class="dictionary-members">
                <dt data-tests=
                "RTCRtpParameters-encodings.html, RTCRtpParameters-rtcp.html,RTCRtpReceiver-getParameters.html">
                  <dfn data-idl="">cname</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd>
                  <p>
                    The Canonical Name (CNAME) used by RTCP (e.g. in SDES
                    messages). <a>Read-only parameter</a>.
                  </p>
                </dd>
                <dt data-tests=
                "RTCRtpParameters-encodings.html,RTCRtpParameters-rtcp.html,RTCRtpReceiver-getParameters.html">
                  <dfn data-idl="">reducedSize</dfn> of type <span class=
                  "idlMemberType">boolean</span>
                </dt>
                <dd>
                  <p>
                    Whether reduced size RTCP [[RFC5506]] is configured (if
                    true) or compound RTCP as specified in [[RFC3550]] (if
                    false). <a>Read-only parameter</a>.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section id="rtcrtpheaderextensionparameters">
          <h3>
            <dfn>RTCRtpHeaderExtensionParameters</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCRtpHeaderExtensionParameters {
  required DOMString uri;
  required unsigned short id;
  boolean encrypted = false;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCRtpHeaderExtensionParameters}} Members
              </h2>
              <dl data-link-for="RTCRtpHeaderExtensionParameters" data-dfn-for=
              "RTCRtpHeaderExtensionParameters" class="dictionary-members">
                <dt data-tests=
                "RTCRtpParameters-headerExtensions.html,RTCRtpReceiver-getParameters.html">
                  <dfn data-idl="">uri</dfn> of type <span class=
                  "idlMemberType">DOMString</span>, required
                </dt>
                <dd>
                  <p>
                    The URI of the RTP header extension, as defined in
                    [[RFC5285]]. <a>Read-only parameter</a>.
                  </p>
                </dd>
                <dt data-tests=
                "RTCRtpParameters-headerExtensions.html,RTCRtpReceiver-getParameters.html">
                  <dfn data-idl="">id</dfn> of type <span class=
                  "idlMemberType">unsigned short</span>, required
                </dt>
                <dd>
                  <p>
                    The value put in the RTP packet to identify the header
                    extension. <a>Read-only parameter</a>.
                  </p>
                </dd>
                <!-- Validate default value, but since read-only, what does it mean to have a default value? -->
                <dt data-tests=
                "RTCRtpParameters-headerExtensions.html,RTCRtpReceiver-getParameters.html">
                  <dfn data-idl="">encrypted</dfn> of type <span class=
                  "idlMemberType">boolean</span>
                </dt>
                <dd>
                  <p>
                    Whether the header extension is encrypted or not.
                    <a>Read-only parameter</a>.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
          <div class="note">
            <p>
              The {{RTCRtpHeaderExtensionParameters}} dictionary enables an
              application to determine whether a header extension is configured
              for use within an {{RTCRtpSender}} or {{RTCRtpReceiver}}. For an
              {{RTCRtpTransceiver}} <var>transceiver</var>, an application can
              determine the "direction" parameter (defined in Section 5 of
              [[RFC5285]]) of a header extension as follows without having to
              parse SDP:
            </p>
            <ol>
              <li>sendonly: The header extension is only included in
              <var>transceiver</var>.{{RTCRtpTransceiver/sender}}.{{RTCRtpSender/getParameters()}}.{{RTCRtpParameters/headerExtensions}}.
              </li>
              <li>recvonly: The header extension is only included in
              <var>transceiver</var>.{{RTCRtpTransceiver/receiver}}.{{RTCRtpReceiver/getParameters()}}.{{RTCRtpParameters/headerExtensions}}.
              </li>
              <li>sendrecv: The header extension is included in both
              <var>transceiver</var>.{{RTCRtpTransceiver/sender}}.{{RTCRtpSender/getParameters()}}.{{RTCRtpParameters/headerExtensions}}
              and
              <var>transceiver</var>.{{RTCRtpTransceiver/receiver}}.{{RTCRtpReceiver/getParameters()}}.{{RTCRtpParameters/headerExtensions}}.
              </li>
              <li>inactive: The header extension is included in neither
              <var>transceiver</var>.{{RTCRtpTransceiver/sender}}.{{RTCRtpSender/getParameters()}}.{{RTCRtpParameters/headerExtensions}}
              nor
              <var>transceiver</var>.{{RTCRtpTransceiver/receiver}}.{{RTCRtpReceiver/getParameters()}}.{{RTCRtpParameters/headerExtensions}}.
              </li>
            </ol>
          </div>
        </section>
        <section id="rtcrtpcodecparameters">
          <h3>
            <dfn>RTCRtpCodecParameters</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCRtpCodecParameters {
  required octet payloadType;
  required DOMString mimeType;
  required unsigned long clockRate;
  unsigned short channels;
  DOMString sdpFmtpLine;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCRtpCodecParameters}} Members
              </h2>
              <!-- Tests need to be refreshed, required payloadType/mimeType/clockRate for instance -->
              <dl data-link-for="RTCRtpCodecParameters" data-dfn-for=
              "RTCRtpCodecParameters" class="dictionary-members">
                <dt data-tests="RTCRtpParameters-codecs.html">
                  <dfn data-idl="">payloadType</dfn> of type <span class=
                  "idlMemberType">octet</span>, required
                </dt>
                <dd>
                  <p>
                    The RTP payload type used to identify this codec.
                    <a>Read-only parameter</a>.
                  </p>
                </dd>
                <dt data-tests=
                "RTCRtpParameters-codecs.html,protocol/video-codecs.https.html">
                  <dfn data-idl="">mimeType</dfn> of type <span class=
                  "idlMemberType">DOMString</span>, required
                </dt>
                <dd>
                  <p>
                    The codec MIME media type/subtype. Valid media types and
                    subtypes are listed in [[IANA-RTP-2]]. <a>Read-only
                    parameter</a>.
                  </p>
                </dd>
                <dt data-tests="RTCRtpParameters-codecs.html">
                  <dfn data-idl="">clockRate</dfn> of type <span class=
                  "idlMemberType">unsigned long</span>, required
                </dt>
                <dd>
                  <p>
                    The codec clock rate expressed in Hertz. <a>Read-only
                    parameter</a>.
                  </p>
                </dd>
                <dt data-tests="RTCRtpParameters-codecs.html">
                  <dfn data-idl="">channels</dfn> of type <span class=
                  "idlMemberType">unsigned short</span>
                </dt>
                <dd>
                  <p>
                    When present, indicates the number of channels (mono=1,
                    stereo=2). <a>Read-only parameter</a>.
                  </p>
                </dd>
                <dt data-tests="RTCRtpParameters-codecs.html">
                  <dfn data-idl="">sdpFmtpLine</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd>
                  <p>
                    The "format specific parameters" field from the
                    <code class="sdp">a=fmtp</code> line in the SDP
                    corresponding to the codec, if one exists, as defined by
                    <span data-jsep="parsing-a-desc">[[!RFC8829]]</span>. For an
                    {{RTCRtpSender}}, these parameters come from the remote
                    description, and for an {{RTCRtpReceiver}}, they come from
                    the local description. <a>Read-only parameter</a>.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section id="rtcrtpcapabilities">
          <h3>
            <dfn>RTCRtpCapabilities</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCRtpCapabilities {
  required sequence&lt;RTCRtpCodecCapability&gt; codecs;
  required sequence&lt;RTCRtpHeaderExtensionCapability&gt; headerExtensions;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCRtpCapabilities}} Members
              </h2>
              <dl data-link-for="RTCRtpCapabilities" data-dfn-for=
              "RTCRtpCapabilities" class="dictionary-members">
                <dt data-tests="RTCRtpReceiver-getCapabilities.html">
                  <dfn data-idl="">codecs</dfn> of type <span class=
                  "idlMemberType">sequence&lt;{{RTCRtpCodecCapability}}&gt;</span>,
                  required
                </dt>
                <dd>
                  <p class="needs-test">
                    Supported media codecs as well as entries for RTX, RED and
                    FEC mechanisms. There will only be a single entry in
                    {{codecs}} for retransmission via RTX, with
                    {{RTCRtpCodecCapability/sdpFmtpLine}} not present.
                  </p>
                </dd>
                <dt data-tests="RTCRtpReceiver-getCapabilities.html">
                  <dfn data-idl="">headerExtensions</dfn> of type <span class=
                  "idlMemberType">sequence&lt;{{RTCRtpHeaderExtensionCapability}}&gt;</span>,
                  required
                </dt>
                <dd>
                  <p>
                    Supported RTP header extensions.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section id="rtcrtpcodeccapability">
          <h3>
            <dfn>RTCRtpCodecCapability</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCRtpCodecCapability {
  required DOMString mimeType;
  required unsigned long clockRate;
  unsigned short channels;
  DOMString sdpFmtpLine;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCRtpCodecCapability}} Members
              </h2>
              <!-- Tests need to be refreshed, required mimeType/clockRate for instance -->
              <p>
                The {{RTCRtpCodecCapability}} dictionary provides information
                about codec capabilities. Only capability combinations that
                would utilize distinct payload types in a generated SDP offer
                are provided. For example:
              </p>
              <ol>
                <li>Two H.264/AVC codecs, one for each of two supported
                packetization-mode values.
                </li>
                <li>Two CN codecs with different clock rates.
                </li>
              </ol>
              <dl data-link-for="RTCRtpCodecCapability" data-dfn-for=
              "RTCRtpCodecCapability" class="dictionary-members">
                <dt data-tests="RTCRtpReceiver-getCapabilities.html">
                  <dfn data-idl="">mimeType</dfn> of type <span class=
                  "idlMemberType">DOMString</span>, required
                </dt>
                <dd>
                  <p>
                    The codec MIME media type/subtype. Valid media types and
                    subtypes are listed in [[IANA-RTP-2]].
                  </p>
                </dd>
                <dt data-tests="RTCRtpReceiver-getCapabilities.html">
                  <dfn data-idl="">clockRate</dfn> of type <span class=
                  "idlMemberType">unsigned long</span>, required
                </dt>
                <dd>
                  <p>
                    The codec clock rate expressed in Hertz.
                  </p>
                </dd>
                <dt data-tests="RTCRtpReceiver-getCapabilities.html">
                  <dfn data-idl="">channels</dfn> of type <span class=
                  "idlMemberType">unsigned short</span>
                </dt>
                <dd>
                  <p>
                    If present, indicates the maximum number of channels
                    (mono=1, stereo=2).
                  </p>
                </dd>
                <dt data-tests="RTCRtpReceiver-getCapabilities.html">
                  <dfn data-idl="">sdpFmtpLine</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd>
                  <p class="needs-test">
                    The "format specific parameters" field from the
                    <code class="sdp">a=fmtp</code> line in the SDP
                    corresponding to the codec, if one exists.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section id="rtcrtpheaderextensioncapability">
          <h3>
            <dfn>RTCRtpHeaderExtensionCapability</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCRtpHeaderExtensionCapability {
  DOMString uri;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCRtpHeaderExtensionCapability}} Members
              </h2>
              <dl data-link-for="RTCRtpHeaderExtensionCapability" data-dfn-for=
              "RTCRtpHeaderExtensionCapability" class="dictionary-members">
                <dt data-tests="RTCRtpReceiver-getCapabilities.html">
                  <dfn data-idl="">uri</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd>
                  <p>
                    The URI of the RTP header extension, as defined in
                    [[RFC5285]].
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
      </section>
      <section>
        <h3>
          <dfn>RTCRtpReceiver</dfn> Interface
        </h3>
        <p>
          The {{RTCRtpReceiver}} interface allows an application to inspect the
          receipt of a {{MediaStreamTrack}}.
        </p>
        <p>
          To <dfn>create an RTCRtpReceiver</dfn> with a string,
          <var>kind</var>, run the following steps:
        </p>
        <ol>
          <li class="no-test-needed">
            <p>
              Let <var>receiver</var> be a new {{RTCRtpReceiver}} object.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Let <var>track</var> be a new {{MediaStreamTrack}} object
              [[!GETUSERMEDIA]]. The source of <var>track</var> is a
              <dfn>remote source</dfn> provided by <var>receiver</var>. Note
              that the <var>track</var>.<code class="gum">id</code> is
              generated by the <a>user agent</a> and does not map to any track
              IDs on the remote side.
            </p>
          </li>
          <li data-tests=
          "RTCPeerConnection-addTransceiver.https.html,RTCPeerConnection-transceivers.https.html">
            <p>
              Initialize <var>track.kind</var> to <var>kind</var>.
            </p>
          </li>
          <li class="needs-test">
            <p>
              Initialize <var>track.label</var> to the result of concatenating
              the string <code>"remote "</code> with <var>kind</var>.
            </p>
          </li>
          <li data-tests="RTCPeerConnection-addTransceiver.https.html">
            <p>
              Initialize <var>track.readyState</var> to <code class=
              "gum">live</code>.
            </p>
          </li>
          <li data-tests=
          "RTCPeerConnection-addTransceiver.https.html,RTCPeerConnection-transceivers.https.html">
            <p>
              Initialize <var>track.muted</var> to <code>true</code>. See the
              <a href="#mediastreamtrack-network-use">MediaStreamTrack</a>
              section about how the <code class="gum">muted</code> attribute
              reflects if a {{MediaStreamTrack}} is receiving media data or
              not.
            </p>
          </li>
          <li data-tests="RTCPeerConnection-addTransceiver.https.html">
            <p>
              Let <var>receiver</var> have a <dfn data-dfn-for="RTCRtpReceiver">[[\ReceiverTrack]]</dfn>
              internal slot initialized to <var>track</var>.
            </p>
          </li>
          <li data-tests="RTCRtpSender-transport.https.html">
            <p>
              Let <var>receiver</var> have a <dfn data-dfn-for="RTCRtpReceiver">[[\ReceiverTransport]]</dfn>
              internal slot initialized to <code>null</code>.
            </p>
          </li>
          <li>
            <p>
              Let <var>receiver</var> have a
              <dfn data-dfn-for="RTCRtpReceiver">[[\LastStableStateReceiverTransport]]</dfn> internal slot
              initialized to <code>null</code>.
            </p>
          </li>
          <li>
            <p>
              Let <var>receiver</var> have an
              <dfn data-dfn-for="RTCRtpReceiver">[[\AssociatedRemoteMediaStreams]]</dfn> internal slot,
              representing a list of {{MediaStream}} objects that the
              {{MediaStreamTrack}} object of this receiver is associated with,
              and initialized to an empty list.
            </p>
          </li>
          <li>
            <p>
              Let <var>receiver</var> have a
              <dfn data-dfn-for="RTCRtpReceiver">[[\LastStableStateAssociatedRemoteMediaStreams]]</dfn>
              internal slot and initialize it to an empty list.
            </p>
          </li>
          <li>
            <p>
              Let <var>receiver</var> have a <dfn data-dfn-for="RTCRtpReceiver">[[\ReceiveCodecs]]</dfn>
              internal slot, representing a list of {{RTCRtpCodecParameters}}
              dictionaries, and initialized to an empty list.
            </p>
          </li>
          <li>
            <p>
              Let <var>receiver</var> have a
              <dfn data-dfn-for="RTCRtpReceiver">[[\LastStableStateReceiveCodecs]]</dfn> internal slot and
              initialize it to an empty list.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Return <var>receiver</var>.
            </p>
          </li>
        </ol>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCRtpReceiver {
  readonly attribute MediaStreamTrack track;
  readonly attribute RTCDtlsTransport? transport;
  static RTCRtpCapabilities? getCapabilities(DOMString kind);
  RTCRtpReceiveParameters getParameters();
  sequence&lt;RTCRtpContributingSource&gt; getContributingSources();
  sequence&lt;RTCRtpSynchronizationSource&gt; getSynchronizationSources();
  Promise&lt;RTCStatsReport&gt; getStats();
};</pre>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCRtpReceiver" data-dfn-for="RTCRtpReceiver"
            class="attributes">
              <dt>
                <dfn data-idl="" id="dom-rtpreceiver-track">track</dfn> of type
                <span class="idlAttrType">{{MediaStreamTrack}}</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{track}} attribute is the track that is associated with
                  this {{RTCRtpReceiver}} object <var>receiver</var>.
                </p>
                <p>
                  Note that {{track}}.<code class="gum">stop()</code> is final,
                  although clones are not affected. Since
                  <var>receiver</var>.{{track}}.<code class="gum">stop()</code>
                  does not implicitly stop <var>receiver</var>, Receiver
                  Reports continue to be sent. On getting, the attribute MUST
                  return the value of the {{RTCRtpReceiver/[[ReceiverTrack]]}} slot.
                </p>
              </dd>
              <dt>
                <dfn data-idl="">transport</dfn> of type <span class=
                "idlAttrType">{{RTCDtlsTransport}}</span>, readonly, nullable
              </dt>
              <dd>
                <p>
                  The {{transport}} attribute is the transport over which media
                  for the receiver's {{RTCRtpReceiver/track}} is received in
                  the form of RTP packets. Prior to construction of the
                  {{RTCDtlsTransport}} object, the {{transport}} attribute will
                  be <code>null</code>. When bundling is used, multiple
                  {{RTCRtpReceiver}} objects will share one {{transport}} and
                  will all receive RTP and RTCP over the same transport.
                </p>
                <p class="no-test-needed">
                  On getting, the attribute MUST return the value of the
                  {{RTCRtpReceiver/[[ReceiverTransport]]}} slot.
                </p>
              </dd>
            </dl>
          </section>
          <section>
            <h2>
              Methods
            </h2>
            <dl data-link-for="RTCRtpReceiver" data-dfn-for="RTCRtpReceiver"
            class="methods">
              <dt data-tests="RTCRtpReceiver-getCapabilities.html">
                <dfn data-idl="">getCapabilities</dfn>, static
              </dt>
              <dd>
                <p data-tests="RTCRtpReceiver-getCapabilities.html">
                  The {{getCapabilities()}} method returns the most optimistic
                  view of the capabilities of the system for receiving media of
                  the given kind. It does not reserve any resources, ports, or
                  other state but is meant to provide a way to discover the
                  types of capabilities of the browser including which codecs
                  may be supported. User agents MUST support <var>kind</var>
                  values of <code>"audio"</code> and <code>"video"</code>. If
                  the system has no capabilities corresponding to the value of
                  the <var>kind</var> argument, {{getCapabilities}} returns
                  <code>null</code>.
                </p>
                <p class="fingerprint">
                  These capabilities provide generally persistent cross-origin
                  information on the device and thus increases the
                  fingerprinting surface of the application. In
                  privacy-sensitive contexts, browsers can consider mitigations
                  such as reporting only a common subset of the capabilities.
                </p>
                <div class="note">
                  <p>
                    The codec capabilities returned affect the
                    {{RTCRtpTransceiver/setCodecPreferences()}} algorithm and
                    what inputs it throws {{InvalidModificationError}} on,
                    and should also be consistent with information revealed by
                    {{RTCPeerConnection/createOffer()}} and {{RTCPeerConnection/createAnswer()}} about codecs
                    negotiated for reception, to ensure any
                    privacy mitigations are effective.
                  </p>
                </div>
              </dd>
              <dt data-tests="RTCRtpReceiver-getParameters.html">
                <dfn data-idl="">getParameters</dfn>
              </dt>
              <dd>
                <p>
                  The {{getParameters()}} method returns the {{RTCRtpReceiver}}
                  object's current parameters for how {{track}} is decoded.
                </p>
                <p>
                  When {{getParameters}} is called, the
                  {{RTCRtpReceiveParameters}} dictionary is constructed as
                  follows:
                </p>
                <ul>
                  <li data-tests="RTCRtpReceiver-getParameters.html">The
                  {{RTCRtpParameters/headerExtensions}} sequence is populated
                  based on the header extensions that the receiver is currently
                  prepared to receive.
                  </li>
                  <li data-tests="RTCRtpReceiver-getParameters.html">
                    <p>
                      {{RTCRtpParameters/codecs}} is set to the value of the
                      {{RTCRtpReceiver/[[ReceiveCodecs]]}} internal slot.
                    </p>
                    <div class="note">
                      Both the local and remote description may affect this
                      list of codecs. For example, if three codecs are offered,
                      the receiver will be prepared to receive each of them and
                      will return them all from {{getParameters}}. But if the
                      remote endpoint only answers with two, the absent codec
                      will no longer be returned by {{getParameters}} as the
                      receiver no longer needs to be prepared to receive it.
                    </div>
                  </li>
                  <li data-tests="RTCRtpReceiver-getParameters.html">
                  {{RTCRtpParameters/rtcp}}.{{RTCRtcpParameters/reducedSize}}
                  is set to <code>true</code> if the receiver is currently
                  prepared to receive reduced-size RTCP packets, and
                  <code>false</code> otherwise.
                  {{RTCRtpParameters/rtcp}}.{{RTCRtcpParameters/cname}} is left
                  out.
                  </li>
                </ul>
              </dd>
              <dt data-tests=
              "RTCRtpReceiver-getContributingSources.https.html">
                <dfn data-idl="">getContributingSources</dfn>
              </dt>
              <dd>
                <p class="needs-test">
                  Returns an {{RTCRtpContributingSource}} for each unique CSRC
                  identifier received by this {{RTCRtpReceiver}} in the last 10
                  seconds, in descending {{RTCRtpContributingSource/timestamp}}
                  order.
                </p>
              </dd>
              <dt data-tests=
              "RTCRtpReceiver-getSynchronizationSources.https.html">
                <dfn data-idl="">getSynchronizationSources</dfn>
              </dt>
              <dd>
                <p class="needs-test">
                  Returns an {{RTCRtpSynchronizationSource}} for each unique
                  SSRC identifier received by this {{RTCRtpReceiver}} in the
                  last 10 seconds, in descending
                  {{RTCRtpContributingSource/timestamp}} order.
                </p>
              </dd>
              <dt data-tests="RTCRtpReceiver-getStats.https.html">
                <dfn data-idl="" id=
                "widl-RTCRtpReceiver-getStats-Promise-RTCStatsReport">getStats</dfn>
              </dt>
              <dd>
                <p>
                  Gathers stats for this receiver only and reports the result
                  asynchronously.
                </p>
                <p>
                  When the {{getStats()}} method is invoked, the user agent
                  MUST run the following steps:
                </p>
                <ol data-tests="RTCRtpReceiver-getStats.https.html">
                  <li class="no-test-needed">
                    <p>
                      Let <var>selector</var> be the {{RTCRtpReceiver}} object
                      on which the method was invoked.
                    </p>
                  </li>
                  <li>
                    <p>
                      Let <var>p</var> be a new promise, and run the following
                      steps in parallel:
                    </p>
                    <ol>
                      <li>
                        <p>
                          Gather the stats indicated by <var>selector</var>
                          according to the [= stats selection algorithm =].
                        </p>
                      </li>
                      <li>
                        <p>
                          [= Resolve =] <var>p</var> with the resulting
                          {{RTCStatsReport}} object, containing the gathered
                          stats.
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Return <var>p</var>.
                    </p>
                  </li>
                </ol>
              </dd>
            </dl>
          </section>
        </div>
        <p>
          The <dfn>RTCRtpContributingSource</dfn> and
          <dfn>RTCRtpSynchronizationSource</dfn> dictionaries contain
          information about a given contributing source (CSRC) or
          synchronization source (SSRC) respectively. When an audio or video
          frame from one or more RTP packets is delivered to the
          {{RTCRtpReceiver}}'s {{MediaStreamTrack}}, the user agent MUST queue
          a task to update the relevant information for the
          {{RTCRtpContributingSource}} and {{RTCRtpSynchronizationSource}}
          dictionaries based on the content of those packets. The information
          relevant to the {{RTCRtpSynchronizationSource}} dictionary
          corresponding to the SSRC identifier, is updated each time, and if an
          RTP packet contains CSRC identifiers, then the information relevant
          to the {{RTCRtpContributingSource}} dictionaries corresponding to
          those CSRC identifiers is also updated. The user agent MUST process
          RTP packets in order of ascending RTP timestamps. The user agent MUST
          keep information from RTP packets delivered to the
          {{RTCRtpReceiver}}'s {{MediaStreamTrack}} in the previous 10 seconds.
        </p>
        <div class="note">
          Even if the {{MediaStreamTrack}} is not attached to any sink for
          playout, {{RTCRtpReceiver/getSynchronizationSources}} and
          {{RTCRtpReceiver/getContributingSources}} returns up-to-date
          information as long as the track is not ended; sinks are not a
          prerequisite for decoding RTP packets.
        </div>
        <div class="note">
          As stated in the <a href="#conformance">conformance section</a>,
          requirements phrased as algorithms may be implemented in any manner
          so long as the end result is equivalent. So, an implementation does
          not need to literally queue a task for every frame, as long as the
          end result is that within a single event loop task execution, all
          returned {{RTCRtpSynchronizationSource}} and
          {{RTCRtpContributingSource}} dictionaries for a particular
          {{RTCRtpReceiver}} contain information from a single point in the RTP
          stream.
        </div>
        <div>
          <pre class="idl">dictionary RTCRtpContributingSource {
  required DOMHighResTimeStamp timestamp;
  required unsigned long source;
  double audioLevel;
  required unsigned long rtpTimestamp;
};</pre>
          <section>
            <h2>
              Dictionary RTCRtpContributingSource Members
            </h2>
            <dl data-link-for="RTCRtpContributingSource" data-dfn-for=
            "RTCRtpContributingSource" class="dictionary-members">
              <dt data-tests=
              "RTCRtpReceiver-getSynchronizationSources.https.html">
                <dfn data-idl="">timestamp</dfn> of type
                {{DOMHighResTimeStamp}}, required
              </dt>
              <dd>
                <p>
                  The {{timestamp}} indicating the most recent time a frame
                  from an RTP packet, originating from this source, was
                  delivered to the {{RTCRtpReceiver}}'s {{MediaStreamTrack}}.
                  The {{timestamp}} is defined as {{Performance.timeOrigin}} +
                  {{Performance.now()}} at that time.
                </p>
              </dd>
              <dt data-tests=
              "RTCRtpReceiver-getSynchronizationSources.https.html">
                <dfn data-idl="">source</dfn> of type <span class=
                "idlMemberType">unsigned long</span>, required
              </dt>
              <dd>
                <p>
                  The CSRC or SSRC identifier of the contributing or
                  synchronization source.
                </p>
              </dd>
              <dt data-tests=
              "RTCRtpReceiver-getSynchronizationSources.https.html">
                <dfn data-idl="">audioLevel</dfn> of type <span class=
                "idlMemberType">double</span>
              </dt>
              <dd>
                <p>
                  Only present for audio receivers. This is a value between
                  0..1 (linear), where 1.0 represents 0 dBov, 0 represents
                  silence, and 0.5 represents approximately 6 dBSPL change in
                  the sound pressure level from 0 dBov.
                </p>
                <p>
                  For CSRCs, this MUST be converted from the level value
                  defined in [[!RFC6465]] if the RFC 6465 header extension is
                  present, otherwise this member MUST be absent.
                </p>
                <p>
                  For SSRCs, this MUST be converted from the level value
                  defined in [[!RFC6464]]. If the RFC 6464 header extension is
                  not present in the received packets (such as if the other
                  endpoint is not a user agent or is a legacy endpoint), this
                  value SHOULD be absent.
                </p>
                <p>
                  Both RFCs define the level as an integral value from 0 to 127
                  representing the audio level in negative decibels relative to
                  the loudest signal that the system could possibly encode.
                  Thus, 0 represents the loudest signal the system could
                  possibly encode, and 127 represents silence.
                </p>
                <p>
                  To convert these values to the linear 0..1 range, a value of
                  127 is converted to 0, and all other values are converted
                  using the equation: <code class=
                  "math">10^(-rfc_level/20)</code>.
                </p>
              </dd>
              <dt data-tests=
              "RTCRtpReceiver-getSynchronizationSources.https.html">
                <dfn data-idl="">rtpTimestamp</dfn> of type <span class=
                "idlMemberType">unsigned long</span>, required
              </dt>
              <dd>
                <p>
                  The RTP timestamp, as defined in [[!RFC3550]] Section
                  5.1, of the media played out at <var>timestamp</var>.
                </p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">
            dictionary RTCRtpSynchronizationSource : RTCRtpContributingSource {};
          </pre>
          <p>The {{RTCRtpSynchronizationSource}} dictionary is expected to serve as an extension point for the specification to surface data only available in SSRCs.</p>
      </section>
      <section>
        <h3>
          <dfn>RTCRtpTransceiver</dfn> Interface
        </h3>
        <p>
          The {{RTCRtpTransceiver}} interface represents a combination of an
          {{RTCRtpSender}} and an {{RTCRtpReceiver}} that share a common [=
          media stream "identification-tag" =]. As defined in <span data-jsep=
          "rtptransceivers">[[!RFC8829]]</span>, an {{RTCRtpTransceiver}} is said
          to be <dfn>associated</dfn> with a [= media description =] if its
          "mid" property is non-null and matches a [= media stream
          "identification-tag" =] in the [= media description =]; otherwise it
          is said to be disassociated with that [= media description =].
        </p>
        <div class="note">
          <p>
            A {{RTCRtpTransceiver}} may become associated with a new pending
            description in RFC8829 while still being disassociated with the
            current description. This may happen in [= check if negotiation is
            needed =].
          </p>
        </div>
        <p>
          The <dfn>transceiver kind</dfn> of an {{RTCRtpTransceiver}} is
          defined by the kind of the associated {{RTCRtpReceiver}}'s
          {{MediaStreamTrack}} object.
        </p>
        <p>
          To <dfn>create an RTCRtpTransceiver</dfn> with an {{RTCRtpReceiver}}
          object, <var>receiver</var>, {{RTCRtpSender}} object,
          <var>sender</var>, and an {{RTCRtpTransceiverDirection}} value,
          <var>direction</var>, run the following steps:
        </p>
        <ol>
          <li class="no-test-needed">
            <p>
              Let <var>transceiver</var> be a new {{RTCRtpTransceiver}} object.
            </p>
          </li>
          <li data-tests="RTCPeerConnection-addTransceiver.https.html">
            <p>
              Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\Sender]]</dfn> internal
              slot, initialized to <var>sender</var>.
            </p>
          </li>
          <li data-tests="RTCPeerConnection-addTransceiver.https.html">
            <p>
              Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\Receiver]]</dfn>
              internal slot, initialized to <var>receiver</var>.
            </p>
          </li>
          <li data-tests=
          "RTCPeerConnection-addTransceiver.https.html,RTCPeerConnection-transceivers.https.html">
            <p>
              Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\Stopping]]</dfn>
              internal slot, initialized to <code>false</code>.
            </p>
          </li>
          <li data-tests=
          "RTCPeerConnection-addTransceiver.https.html,RTCPeerConnection-transceivers.https.html">
            <p>
              Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\Stopped]]</dfn>
              internal slot, initialized to <code>false</code>.
            </p>
          </li>
          <li data-tests=
          "RTCPeerConnection-addTransceiver.https.html,RTCPeerConnection-transceivers.https.html">
            <p>
              Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\Direction]]</dfn>
              internal slot, initialized to <var>direction</var>.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\Receptive]]</dfn>
              internal slot, initialized to <code>false</code>.
            </p>
          </li>
          <li data-tests=
          "RTCPeerConnection-addTransceiver.https.html,RTCPeerConnection-transceivers.https.html">
            <p>
              Let <var>transceiver</var> have a
              <dfn data-dfn-for="RTCRtpTransceiver">[[\CurrentDirection]]</dfn> internal slot, initialized to
              <code>null</code>.
            </p>
          </li>
          <li data-tests="RTCRtpTransceiver-direction.html">
            <p>
              Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\FiredDirection]]</dfn>
              internal slot, initialized to <code>null</code>.
            </p>
          </li>
          <li>
            <p>
              Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\PreferredCodecs]]</dfn>
              internal slot, initialized to an empty list.
            </p>
          </li>
          <li class="untestable">
            <p>
              Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\JsepMid]]</dfn>
              internal slot, initialized to <code>null</code>. This is the
              "RtpTransceiver mid property" defined in <span data-jsep=
              "initial-offers initial-answers">[[!RFC8829]]</span>, and is only
              modified there.
            </p>
          </li>
          <li data-tests="RTCRtpTransceiver.https.html">
            <p>
              Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\Mid]]</dfn> internal
              slot, initialized to <code>null</code>.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Return <var>transceiver</var>.
            </p>
          </li>
        </ol>
        <div class="note">
          Creating a transceiver does not create the underlying
          {{RTCDtlsTransport}} and {{RTCIceTransport}} objects. This will only
          occur as part of the process of [= set the session description |
          setting a session description =].
        </div>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCRtpTransceiver {
  readonly attribute DOMString? mid;
  [SameObject] readonly attribute RTCRtpSender sender;
  [SameObject] readonly attribute RTCRtpReceiver receiver;
  attribute RTCRtpTransceiverDirection direction;
  readonly attribute RTCRtpTransceiverDirection? currentDirection;
  undefined stop();
  undefined setCodecPreferences(sequence&lt;RTCRtpCodecCapability&gt; codecs);
};</pre>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCRtpTransceiver" data-dfn-for=
            "RTCRtpTransceiver" class="attributes">
              <dt data-tests=
              "RTCPeerConnection-setDescription-transceiver.html,RTCPeerConnection-transceivers.https.html,RTCRtpTransceiver.https.html">
                <dfn id="dom-rtptransceiver-mid">mid</dfn> of type <span class=
                "idlAttrType">DOMString</span>, readonly, nullable
              </dt>
              <dd>
                <p>
                  The {{mid}} attribute is the [= media stream
                  "identification-tag" =] negotiated and present in the local
                  and remote descriptions. On getting, the attribute MUST
                  return the value of the {{RTCRtpTransceiver/[[Mid]]}} slot.
                </p>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-transceivers.https.html,RTCRtpTransceiver.https.html">
                <dfn data-idl="">sender</dfn> of type <span class=
                "idlAttrType">{{RTCRtpSender}}</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{sender}} attribute exposes the {{RTCRtpSender}}
                  corresponding to the RTP media that may be sent with mid =
                  {{RTCRtpTransceiver/[[Mid]]}}. On getting, the attribute MUST return the
                  value of the {{RTCRtpTransceiver/[[Sender]]}} slot.
                </p>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-transceivers.https.html,RTCRtpTransceiver.https.html">
                <dfn data-idl="">receiver</dfn> of type <span class=
                "idlAttrType">{{RTCRtpReceiver}}</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{receiver}} attribute is the {{RTCRtpReceiver}}
                  corresponding to the RTP media that may be received with mid
                  = {{RTCRtpTransceiver/[[Mid]]}}. On getting the attribute MUST return the
                  value of the {{RTCRtpTransceiver/[[Receiver]]}} slot.
                </p>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-transceivers.https.html,RTCRtpTransceiver.https.html">
                <dfn data-idl="">direction</dfn> of type <span class=
                "idlAttrType">{{RTCRtpTransceiverDirection}}</span>
              </dt>
              <dd>
                <p>
                  As defined in <span data-jsep=
                  "transceiver-direction">[[!RFC8829]]</span>, the
                  <var>direction</var> attribute indicates the preferred
                  direction of this transceiver, which will be used in calls to
                  {{RTCPeerConnection/createOffer}} and
                  {{RTCPeerConnection/createAnswer}}. An update of
                  directionality does not take effect immediately. Instead,
                  future calls to {{RTCPeerConnection/createOffer}} and
                  {{RTCPeerConnection/createAnswer}} mark the corresponding [=
                  media description =] as <code class="sdp">sendrecv</code>,
                  <code class="sdp">sendonly</code>, <code class=
                  "sdp">recvonly</code> or <code class="sdp">inactive</code> as
                  defined in <span data-jsep=
                  "subsequent-offers subsequent-answers">[[!RFC8829]]</span>
                </p>
                <p>
                  On getting, the user agent MUST run the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>transceiver</var> be the {{RTCRtpTransceiver}}
                      object on which the getter is invoked.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopping]]}} is
                      <code>true</code>, return
                      {{RTCRtpTransceiverDirection/"stopped"}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      Otherwise, return the value of the {{RTCRtpTransceiver/[[Direction]]}}
                      slot.
                    </p>
                  </li>
                </ol>
                <p>
                  On setting, the user agent MUST run the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>transceiver</var> be the {{RTCRtpTransceiver}}
                      object on which the setter is invoked.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>connection</var> be the {{RTCPeerConnection}}
                      object associated with <var>transceiver</var>.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopping]]}} is
                      <code>true</code>, [= exception/throw =] an
                      {{InvalidStateError}}.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>newDirection</var> be the argument to the
                      setter.
                    </p>
                  </li>
                  <li class="needs-test">
                    <p>
                      If <var>newDirection</var> is equal to
                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}}, abort these
                      steps.
                    </p>
                  </li>
                  <li class="needs-test">
                    <p>
                      If <var>newDirection</var> is equal to
                      {{RTCRtpTransceiverDirection/"stopped"}}, [=
                      exception/throw =] a {{TypeError}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      Set <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} to
                      <var>newDirection</var>.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                    <p>
                      <a>Update the negotiation-needed flag</a> for
                      <var>connection</var>.
                    </p>
                  </li>
                </ol>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-transceivers.https.html,RTCRtpTransceiver-direction.html">
                <dfn data-idl="">currentDirection</dfn> of type <span class=
                "idlAttrType">{{RTCRtpTransceiverDirection}}</span>, readonly,
                nullable
              </dt>
              <dd>
                <p>
                  As defined in <span data-jsep=
                  "transceiver-current-direction">[[!RFC8829]]</span>, the
                  <var>currentDirection</var> attribute indicates the current
                  direction negotiated for this transceiver. The value of
                  <var>currentDirection</var> is independent of the value of
                  {{RTCRtpEncodingParameters}}.{{RTCRtpEncodingParameters/active}}
                  since one cannot be deduced from the other. If this
                  transceiver has never been represented in an offer/answer
                  exchange, the value is <code>null</code>. If the transceiver
                  is {{stopped}}, the value is
                  {{RTCRtpTransceiverDirection/"stopped"}}.
                </p>
                <p>
                  On getting, the user agent MUST run the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>transceiver</var> be the {{RTCRtpTransceiver}}
                      object on which the getter is invoked.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopped]]}} is
                      <code>true</code>, return
                      {{RTCRtpTransceiverDirection/"stopped"}}.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Otherwise, return the value of the
                      {{RTCRtpTransceiver/[[CurrentDirection]]}} slot.
                    </p>
                  </li>
                </ol>
              </dd>
            </dl>
          </section>
          <section>
            <h2>
              Methods
            </h2>
            <dl data-link-for="RTCRtpTransceiver" data-dfn-for=
            "RTCRtpTransceiver" class="methods">
              <dt data-tests="RTCRtpTransceiver-stop.html">
                <dfn data-idl="">stop</dfn>
              </dt>
              <dd>
                <p>
                  Irreversibly marks the transceiver as {{stopping}}, unless it
                  is already {{stopped}}. This will immediately cause the
                  transceiver's sender to no longer send, and its receiver to
                  no longer receive. Calling {{stop()}} also [= update the
                  negotiation-needed flag | updates the negotiation-needed flag
                  =] for the {{RTCRtpTransceiver}}'s associated
                  {{RTCPeerConnection}}.
                </p>
                <p>
                  A <dfn>stopping</dfn> transceiver will cause future calls to
                  {{RTCPeerConnection/createOffer}} to generate a zero port in
                  the [= media description =] for the corresponding
                  transceiver, as defined in <span data-jsep=
                  "transceiver-stop">[[!RFC8829]]</span> (The user agent MUST treat a
                  {{stopping}} transceiver as {{stopped}} for the purposes of
                  RFC8829 only in this case). However, to avoid problems with
                  [[RFC8843]], a transceiver that is {{stopping}}, but not
                  {{stopped}}, will not affect
                  {{RTCPeerConnection/createAnswer}}.
                </p>
                <p>
                  A <dfn>stopped</dfn> transceiver will cause future calls to
                  {{RTCPeerConnection/createOffer}} or
                  {{RTCPeerConnection/createAnswer}} to generate a zero port in
                  the [= media description =] for the corresponding
                  transceiver, as defined in <span data-jsep=
                  "transceiver-stop">[[!RFC8829]]</span>.
                </p>
                <p>
                  The transceiver will remain in the {{stopping}} state, unless
                  it becomes {{stopped}} by
                  {{RTCPeerConnection/setRemoteDescription}} processing a
                  rejected m-line in a remote offer or answer.
                </p>
                <p class="note">
                  A transceiver that is {{stopping}} but not {{stopped}} will
                  always need negotiation. In practice, this means that calling
                  {{stop()}} on a transceiver will cause the transceiver to
                  become {{stopped}} eventually, provided negotiation is
                  allowed to complete on both ends.
                </p>
                <p>
                  When the {{stop}} method is invoked, the user agent MUST run
                  the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>transceiver</var> be the {{RTCRtpTransceiver}}
                      object on which the method is invoked.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>connection</var> be the {{RTCPeerConnection}}
                      object associated with <var>transceiver</var>.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                      <code>true</code>, [= exception/throw =] an
                      {{InvalidStateError}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopping]]}} is
                      <code>true</code>, abort these steps.
                    </p>
                  </li>
                  <li>
                    <p>
                      [= Stop sending and receiving =] with
                      <var>transceiver</var>.
                    </p>
                  </li>
                  <li>
                    <p>
                      <a>Update the negotiation-needed flag</a> for
                      <var>connection</var>.
                    </p>
                  </li>
                </ol>
                <p>
                  The <dfn>stop sending and receiving</dfn> algorithm given a
                  <var>transceiver</var> and, optionally, a
                  <var>disappear</var> boolean defaulting to
                  <code>false</code>, is as follows:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>sender</var> be
                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Sender]]}}.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>receiver</var> be
                      <var>transceiver</var>.{{RTCRtpTransceiver/[[Receiver]]}}.
                    </p>
                  </li>
                  <li class="needs-test">
                    <p>
                      Stop sending media with <var>sender</var>.
                    </p>
                  </li>
                  <li>
                    <p>
                      Send an RTCP BYE for each RTP stream that was being sent
                      by <var>sender</var>, as specified in [[!RFC3550]].
                    </p>
                  </li>
                  <li>
                    <p>
                      Stop receiving media with <var>receiver</var>.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>disappear</var> is <code>false</code>, execute
                      the steps for
                      <var>receiver</var>.{{RTCRtpReceiver/[[ReceiverTrack]]}} to be
                      <a data-cite="!GETUSERMEDIA#track-ended">ended</a>. This
                      fires an event.
                    </p>
                  </li>
                  <li>
                    <p>
                      Set <var>transceiver</var>.{{RTCRtpTransceiver/[[Direction]]}} to
                      {{RTCRtpTransceiverDirection/"inactive"}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      Set <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopping]]}} to
                      <code>true</code>.
                    </p>
                  </li>
                </ol>
                <p>
                  The <dfn>stop the RTCRtpTransceiver</dfn> algorithm given a
                  <var>transceiver</var> and, optionally, a
                  <var>disappear</var> boolean defaulting to
                  <code>false</code>, is as follows:
                </p>
                <ol>
                  <li>
                    <p>
                      If <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopping]]}} is
                      <code>false</code>, [= stop sending and receiving =] with
                      <var>transceiver</var> and <var>disappear</var>.
                    </p>
                  </li>
                  <li>
                    <p>
                      Set <var>transceiver</var>.{{RTCRtpTransceiver/[[Stopped]]}} to
                      <code>true</code>.
                    </p>
                  </li>
                  <li>
                    <p>
                      Set <var>transceiver</var>.{{RTCRtpTransceiver/[[Receptive]]}} to
                      <code>false</code>.
                    </p>
                  </li>
                  <li>
                    <p>
                      Set <var>transceiver</var>.{{RTCRtpTransceiver/[[CurrentDirection]]}}
                      to <code>null</code>.
                    </p>
                  </li>
                </ol>
              </dd>
              <dt data-tests="RTCRtpTransceiver-setCodecPreferences.html">
                <dfn data-idl="">setCodecPreferences</dfn>
              </dt>
              <dd>
                <p>
                  The {{setCodecPreferences}} method overrides the default
                  codec preferences used by the <a>user agent</a>. When
                  generating a session description using either
                  {{RTCPeerConnection/createOffer}} or
                  {{RTCPeerConnection/createAnswer}}, the <a>user agent</a>
                  MUST use the indicated codecs, in the order specified in the
                  <var>codecs</var> argument, for the media section
                  corresponding to this {{RTCRtpTransceiver}}.
                </p>
                <p>
                  This method allows applications to disable the negotiation of
                  specific codecs (including RTX/RED/FEC). It also allows an
                  application to cause a remote peer to prefer the codec that
                  appears first in the list for sending.
                </p>
                <!-- 'until this method is called again' is not clear. Ditto for 'any default value' -->
                <p class="needs-test">
                  Codec preferences remain in effect for all calls to
                  {{RTCPeerConnection/createOffer}} and
                  {{RTCPeerConnection/createAnswer}} that include this
                  {{RTCRtpTransceiver}} until this method is called again.
                  Setting <var>codecs</var> to an empty sequence resets codec
                  preferences to any default value.
                </p>
                <p class="note">
                  Codecs have their payload types listed under each m= section
                  in the SDP, defining the mapping between payload types and
                  codecs. These payload types are referenced by the m=video or
                  m=audio lines in the order of preference, and codecs that are
                  not negotiated do not appear in this list as defined in
                  section 5.2.1 of [[!RFC8829]]. A previously negotiated codec
                  that is subsequently removed disappears from the m=video or
                  m=audio line, and while its codec payload type is not to be
                  reused in future offers or answers, its payload type may also
                  be removed from the mapping of payload types in the SDP.
                </p>
                <p>
                  The <var>codecs</var> sequence passed into
                  {{setCodecPreferences}} can only contain codecs that are
                  returned by
                  {{RTCRtpSender}}.{{RTCRtpSender/getCapabilities}}(<var>kind</var>)
                  or
                  {{RTCRtpReceiver}}.{{RTCRtpReceiver/getCapabilities}}(<var>kind</var>),
                  where <var>kind</var> is the kind of the
                  {{RTCRtpTransceiver}} on which the method is called.
                  Additionally, the {{RTCRtpCodecCapability}} dictionary
                  members cannot be modified. If <var>codecs</var> does not
                  fulfill these requirements, the user agent MUST [=
                  exception/throw =] an {{InvalidModificationError}}.
                </p>
                <p class="note">
                  Due to a recommendation in [[!SDP]], calls to
                  {{RTCPeerConnection/createAnswer}} SHOULD use only the common
                  subset of the codec preferences and the codecs that appear in
                  the offer. For example, if codec preferences are "C, B, A",
                  but only codecs "A, B" were offered, the answer should only
                  contain codecs "B, A". However, <span data-jsep=
                  "initial-answers">[[!RFC8829]]</span> allows adding codecs that
                  were not in the offer, so implementations can behave
                  differently.
                </p>
                <p>
                  When {{setCodecPreferences()}} is invoked, the <a>user
                  agent</a> MUST run the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>transceiver</var> be the {{RTCRtpTransceiver}}
                      object this method was invoked on.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>codecs</var> be the first argument.
                    </p>
                  </li>
                  <li data-tests="RTCRtpTransceiver-setCodecPreferences.html">
                    <p>
                      If <var>codecs</var> is an empty list, set
                      <var>transceiver</var>.{{RTCRtpTransceiver/[[PreferredCodecs]]}} to
                      <var>codecs</var> and abort these steps.
                    </p>
                  </li>
                  <li>
                    <p>
                      Remove any duplicate values in <var>codecs</var>. Start
                      at the back of the list such that the priority of the
                      codecs is maintained; the index of the first occurrence
                      of a codec within the list is the same before and after
                      this step.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>kind</var> be the <var>transceiver</var>'s [=
                      transceiver kind =].
                    </p>
                  </li>
                  <li data-tests="RTCRtpTransceiver-setCodecPreferences.html">
                    <p>
                      If the intersection between <var>codecs</var> and
                      {{RTCRtpSender}}.{{RTCRtpSender/getCapabilities}}(<var>kind</var>).{{RTCRtpParameters/codecs}}
                      or the intersection between <var>codecs</var> and
                      {{RTCRtpReceiver}}.{{RTCRtpReceiver/getCapabilities}}(<var>kind</var>).{{RTCRtpParameters/codecs}}
                      only contains RTX, RED or FEC codecs or is an empty set,
                      throw {{InvalidModificationError}}. This ensures that we
                      always have something to offer, regardless of
                      <var>transceiver</var>.{{RTCRtpTransceiver/direction}}.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>codecCapabilities</var> be the union of
                      {{RTCRtpSender}}.{{RTCRtpSender/getCapabilities}}(<var>kind</var>).{{RTCRtpParameters/codecs}}
                      and
                      {{RTCRtpReceiver}}.{{RTCRtpReceiver/getCapabilities}}(<var>kind</var>).{{RTCRtpParameters/codecs}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      For each <var>codec</var> in <var>codecs</var>,
                    </p>
                    <ol>
                      <li>If <var>codec</var> is not in
                      <var>codecCapabilities</var>, throw
                      {{InvalidModificationError}}.
                      </li>
                    </ol>
                  </li>
                  <li data-tests="RTCRtpTransceiver-setCodecPreferences.html">
                    <p>
                      Set <var>transceiver</var>.{{RTCRtpTransceiver/[[PreferredCodecs]]}} to
                      <var>codecs</var>.
                    </p>
                  </li>
                </ol>
                <p class="note">
                  If set, the offerer's codec preferences will decide the order
                  of the codecs in the offer. If the answerer does not have any
                  codec preferences then the same order will be used in the
                  answer. However, if the answerer also has codec preferences,
                  these preferences override the order in the answer. In this
                  case, the offerer's preferences would affect which codecs
                  were on offer but not the final order.
                </p>
              </dd>
            </dl>
          </section>
        </div>
        <section>
          <h3>
            Simulcast functionality
          </h3>
          <p data-test="simulcast/basic.https.html">
            Simulcast functionality is provided via the
            {{RTCPeerConnection/addTransceiver}} method of the
            {{RTCPeerConnection}} object and the {{RTCRtpSender/setParameters}}
            method of the {{RTCRtpSender}} object.
          </p>
          <p class="needs-test">
            The {{RTCPeerConnection/addTransceiver}} method establishes the
            <dfn>simulcast envelope</dfn> which includes the maximum number of
            simulcast streams that can be sent, as well as the ordering of the
            {{RTCRtpSendParameters/encodings}}. While characteristics of
            individual simulcast streams can be modified using the
            {{RTCRtpSender/setParameters}} method, the [= simulcast envelope =]
            cannot be changed. One of the implications of this model is that
            the {{RTCPeerConnection/addTrack()}} method cannot provide
            simulcast functionality since it does not take
            {{RTCRtpTransceiverInit/sendEncodings}} as an argument, and
            therefore cannot configure an {{RTCRtpTransceiver}} to send
            simulcast.
          </p>
          <p class="needs-test">
            Another implication is that the answerer cannot set the [=
            simulcast envelope =] directly. Upon calling the
            {{RTCPeerConnection/setRemoteDescription}} method of the
            {{RTCPeerConnection}} object, the [= simulcast envelope =] is
            configured on the {{RTCRtpTransceiver}} to contain the layers
            described by the specified session description. Once the
            envelope is determined, layers cannot be removed. They can be
            marked as inactive by setting the
            {{RTCRtpEncodingParameters/active}} member to <code>false</code>
            effectively disabling the layer.
          </p>
          <p data-tests="simulcast/getStats.https.html">
            While {{RTCRtpSender/setParameters}} cannot modify the [= simulcast
            envelope =], it is still possible to control the number of streams
            that are sent and the characteristics of those streams. Using
            {{RTCRtpSender/setParameters}}, simulcast streams can be made
            inactive by setting the {{RTCRtpEncodingParameters/active}} member
            to <code>false</code>, or can be reactivated by setting the
            {{RTCRtpEncodingParameters/active}} member to <code>true</code>.
            Using {{RTCRtpSender/setParameters}}, stream characteristics can be
            changed by modifying attributes such as
            {{RTCRtpEncodingParameters/maxBitrate}}.
          </p>
          <p class="note" data-tests="simulcast/getStats.https.html">
            Simulcast is frequently used to send multiple encodings to an SFU,
            which will then forward one of the simulcast streams to the end
            user. The user agent is therefore expected to allocate bandwidth
            between encodings in such a way that all simulcast streams are
            usable on their own; for instance, if two simulcast streams have
            the same {{RTCRtpEncodingParameters/maxBitrate}}, one would expect
            to see a similar bitrate on both streams. If bandwidth does not
            permit all simulcast streams to be sent in an usable form, the user
            agent is expected to stop sending some of the simulcast streams.
          </p>
          <p data-tests="simulcast/basic.https.html">
            As defined in <span data-jsep="simulcast">[[!RFC8829]]</span>, an
            offer from a user-agent will only contain a "send" description and
            no "recv" description on the <code class="sdp">a=simulcast</code>
            line. Alternatives and restrictions (described in
            [[RFC8853]]) are not supported.
          </p>
          <p class="needs-test">
            This specification does not define how to configure reception of
            multiple RTP encodings using {{RTCPeerConnection/createOffer}},
            {{RTCPeerConnection/createAnswer}} or
            {{RTCPeerConnection/addTransceiver}}. However when
            {{RTCPeerConnection/setRemoteDescription}} is called with a
            corresponding remote description that is able to send multiple RTP
            encodings as defined in [[!RFC8829]], and the browser supports
            receiving multiple RTP encodings, the {{RTCRtpReceiver}} may
            receive multiple RTP encodings and the parameters retrieved via the
            transceiver's
            {{RTCRtpTransceiver/receiver}}.{{RTCRtpReceiver/getParameters()}}
            will reflect the encodings negotiated.
          </p>
          <p class="note">
            An {{RTCRtpReceiver}} can receive multiple RTP streams in a
            scenario where a Selective Forwarding Unit (SFU) switches between
            simulcast streams it receives from user agents. If the SFU does not
            rewrite RTP headers so as to arrange the switched streams into a
            single RTP stream prior to forwarding, the {{RTCRtpReceiver}} will
            receive packets from distinct RTP streams, each with their own SSRC
            and sequence number space. While the SFU may only forward a single
            RTP stream at any given time, packets from multiple RTP streams can
            become intermingled at the receiver due to reordering. An
            {{RTCRtpReceiver}} equipped to receive multiple RTP streams will
            therefore need to be able to correctly order the received packets,
            recognize potential loss events and react to them. Correct
            operation in this scenario is non-trivial and therefore is optional
            for implementations of this specification.
          </p>
          <section class="informative" id="rtcrtpencodingspatialsim-example*">
            <h3>
              Encoding Parameter Examples
            </h3>
            <div>
              <p>
                Examples of simulcast scenarios implemented with encoding
                parameters:
              </p>
              <pre class="example highlight">

// Example of 3-layer spatial simulcast with all but the lowest resolution layer disabled
var encodings = [
  {rid: 'q', active: true, scaleResolutionDownBy: 4.0}
  {rid: 'h', active: false, scaleResolutionDownBy: 2.0},
  {rid: 'f', active: false},
];
        </pre>
            </div>
          </section>
        </section>
        <section class="informative">
          <h3>
            "Hold" functionality
          </h3>
          <p>
            Together, the {{RTCRtpTransceiver/direction}} attribute and the
            {{RTCRtpSender/replaceTrack}} method enable developers to implement
            "hold" scenarios.
          </p>
          <p>
            To send music to a peer and cease rendering received audio
            (music-on-hold):
          </p>
          <pre class="example highlight">
async function playMusicOnHold() {
  try {
    // Assume we have an audio transceiver and a music track named musicTrack
    await audio.sender.replaceTrack(musicTrack);
    // Mute received audio
    audio.receiver.track.enabled = false;
    // Set the direction to send-only (requires negotiation)
    audio.direction = 'sendonly';
  } catch (err) {
    console.error(err);
  }
}
        </pre>
          <p>
            To respond to a remote peer's "sendonly" offer:
          </p>
          <pre class="example highlight">
async function handleSendonlyOffer() {
  try {
    // Apply the sendonly offer first,
    // to ensure the receiver is ready for ICE candidates.
    await pc.setRemoteDescription(sendonlyOffer);
    // Stop sending audio
    await audio.sender.replaceTrack(null);
    // Align our direction to avoid further negotiation
    audio.direction = 'recvonly';
    // Call createAnswer and send a recvonly answer
    await doAnswer();
  } catch (err) {
    // handle signaling error
  }
}
        </pre>
          <p>
            To stop sending music and send audio captured from a microphone, as
            well to render received audio:
          </p>
          <pre class="example highlight">
async function stopOnHoldMusic() {
  // Assume we have an audio transceiver and a microphone track named micTrack
  await audio.sender.replaceTrack(micTrack);
  // Unmute received audio
  audio.receiver.track.enabled = true;
  // Set the direction to sendrecv (requires negotiation)
  audio.direction = 'sendrecv';
}
        </pre>
          <p>
            To respond to being taken off hold by a remote peer:
          </p>
          <pre class="example highlight">
async function onOffHold() {
  try {
    // Apply the sendrecv offer first, to ensure receiver is ready for ICE candidates.
    await pc.setRemoteDescription(sendrecvOffer);
    // Start sending audio
    await audio.sender.replaceTrack(micTrack);
    // Set the direction sendrecv (just in time for the answer)
    audio.direction = 'sendrecv';
    // Call createAnswer and send a sendrecv answer
    await doAnswer();
  } catch (err) {
    // handle signaling error
  }
}
        </pre>
        </section>
      </section>
      <section>
        <h3>
          <dfn>RTCDtlsTransport</dfn> Interface
        </h3>
        <p>
          The {{RTCDtlsTransport}} interface allows an application access to
          information about the Datagram Transport Layer Security (DTLS)
          transport over which RTP and RTCP packets are sent and received by
          {{RTCRtpSender}} and {{RTCRtpReceiver}} objects, as well other data
          such as SCTP packets sent and received by data channels. In
          particular, DTLS adds security to an underlying transport, and the
          {{RTCDtlsTransport}} interface allows access to information about the
          underlying transport and the security added. {{RTCDtlsTransport}}
          objects are constructed as a result of calls to
          {{RTCPeerConnection/setLocalDescription()}} and
          {{RTCPeerConnection/setRemoteDescription()}}. Each
          {{RTCDtlsTransport}} object represents the DTLS transport layer for
          the RTP or RTCP {{RTCIceTransport/component}} of a specific
          {{RTCRtpTransceiver}}, or a group of {{RTCRtpTransceiver}}s if such a
          group has been negotiated via [[RFC8843]].
        </p>
        <div class="note">
          A new DTLS association for an existing {{RTCRtpTransceiver}} will be
          represented by an existing {{RTCDtlsTransport}} object, whose
          {{RTCDtlsTransport/state}} will be updated accordingly, as opposed to
          being represented by a new object.
        </div>
        <p data-tests="RTCDtlsTransport-getRemoteCertificates.html">
          An {{RTCDtlsTransport}} has a <dfn data-dfn-for="RTCDtlsTransport">[[\DtlsTransportState]]</dfn>
          internal slot initialized to {{RTCDtlsTransportState/"new"}} and a
          <dfn data-dfn-for="RTCDtlsTransport">[[\RemoteCertificates]]</dfn> slot initialized to an empty list.
        </p>
        <p>
          When the underlying DTLS transport experiences an error, such as a
          certificate validation failure, or a fatal alert (see [[RFC5246]]
          section 7.2), the user agent MUST queue a task that runs the
          following steps:
        </p>
        <ol>
          <li class="no-test-needed">
            <p>
              Let <var>transport</var> be the {{RTCDtlsTransport}} object to
              receive the state update and error notification.
            </p>
          </li>
          <li>
            <p>
              If the state of <var>transport</var> is already
              {{RTCDtlsTransportState/"failed"}}, abort these steps.
            </p>
          </li>
          <li data-tests="protocol/dtls-fingerprint-validation.html">
            <p>
              Set <var>transport</var>.{{RTCDtlsTransport/[[DtlsTransportState]]}} to
              {{RTCDtlsTransportState/"failed"}}.
            </p>
          </li>
          <li>
            <p>
              [= Fire an event =] named {{RTCDtlsTransport/error}} using the
              {{RTCErrorEvent}} interface with its errorDetail attribute set to
              either {{RTCErrorDetailType/"dtls-failure"}} or
              {{RTCErrorDetailType/"fingerprint-failure"}}, as appropriate, and
              other fields set as described under the {{RTCErrorDetailType}}
              enum description, at <var>transport</var>.
            </p>
          </li>
          <li>
            <p>
              [= Fire an event =] named {{RTCDtlsTransport/statechange}} at
              <var>transport</var>.
            </p>
          </li>
        </ol>
        <p>
          When the underlying DTLS transport needs to update the state of the
          corresponding {{RTCDtlsTransport}} object for any other reason, the
          user agent MUST queue a task that runs the following steps:
        </p>
        <ol>
          <li class="no-test-needed">
            <p>
              Let <var>transport</var> be the {{RTCDtlsTransport}} object to
              receive the state update.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Let <var>newState</var> be the new state.
            </p>
          </li>
          <li data-tests="RTCDtlsTransport-getRemoteCertificates.html">
            <p>
              Set <var>transport</var>.{{RTCDtlsTransport/[[DtlsTransportState]]}} to
              <var>newState</var>.
            </p>
          </li>
          <li data-tests="RTCDtlsTransport-getRemoteCertificates.html">
            <p>
              If <var>newState</var> is {{RTCDtlsTransportState/connected}}
              then let <var>newRemoteCertificates</var> be the certificate
              chain in use by the remote side, with each certificate encoded in
              binary Distinguished Encoding Rules (DER) [[!X690]], and set
              <var>transport</var>.{{RTCDtlsTransport/[[RemoteCertificates]]}} to
              <var>newRemoteCertificates</var>.
            </p>
          </li>
          <li data-tests="RTCDtlsTransport-state.html">
            <p>
              [= Fire an event =] named {{RTCDtlsTransport/statechange}} at
              <var>transport</var>.
            </p>
          </li>
        </ol>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCDtlsTransport : EventTarget {
  [SameObject] readonly attribute RTCIceTransport iceTransport;
  readonly attribute RTCDtlsTransportState state;
  sequence&lt;ArrayBuffer&gt; getRemoteCertificates();
  attribute EventHandler onstatechange;
  attribute EventHandler onerror;
};</pre>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCDtlsTransport" data-dfn-for=
            "RTCDtlsTransport" class="attributes">
              <dt data-tests=
              "RTCIceTransport.html,RTCPeerConnection-connectionState.https.html,RTCPeerConnection-iceConnectionState.https.html,RTCPeerConnection-iceGatheringState.html">
                <dfn data-idl="">iceTransport</dfn> of type <span class=
                "idlAttrType">{{RTCIceTransport}}</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{iceTransport}} attribute is the underlying transport
                  that is used to send and receive packets. The underlying
                  transport may not be shared between multiple active
                  {{RTCDtlsTransport}} objects.
                </p>
              </dd>
              <dt data-tests=
              "RTCDtlsTransport-state.html,RTCPeerConnection-connectionState.https.html">
                <dfn data-idl="">state</dfn> of type <span class=
                "idlAttrType">{{RTCDtlsTransportState}}</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{state}} attribute MUST, on getting, return the value of
                  the {{RTCDtlsTransport/[[DtlsTransportState]]}} slot.
                </p>
              </dd>
              <dt data-tests="RTCDtlsTransport-state.html">
                <dfn data-idl="">onstatechange</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd>
                The event type of this event handler is
                {{RTCDtlsTransport/statechange}}.
              </dd>
              <dt data-tests="">
                <dfn data-idl="">onerror</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd>
                The event type of this event handler is {{RTCDtlsTransport/error}}.
              </dd>
            </dl>
          </section>
          <section>
            <h2>
              Methods
            </h2>
            <dl data-link-for="RTCDtlsTransport" data-dfn-for=
            "RTCDtlsTransport" class="methods">
              <dt data-tests="RTCDtlsTransport-getRemoteCertificates.html">
                <dfn data-idl="">getRemoteCertificates</dfn>
              </dt>
              <dd>
                <p>
                  Returns the value of {{RTCDtlsTransport/[[RemoteCertificates]]}}.
                </p>
              </dd>
            </dl>
          </section>
        </div>
        <h3>
          <dfn>RTCDtlsTransportState</dfn> Enum
        </h3>
        <div>
          <pre class="idl">enum RTCDtlsTransportState {
  "new",
  "connecting",
  "connected",
  "closed",
  "failed"
};</pre>
          <table data-link-for="RTCDtlsTransportState" data-dfn-for=
          "RTCDtlsTransportState" class="simple">
            <thead>
              <tr>
                <th colspan="2">
                  Enumeration description
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td data-tests="">
                  <dfn data-idl="">new</dfn>
                </td>
                <td>
                  DTLS has not started negotiating yet.
                </td>
              </tr>
              <tr>
                <td data-tests="">
                  <dfn data-idl="">connecting</dfn>
                </td>
                <td>
                  DTLS is in the process of negotiating a secure connection and
                  verifying the remote fingerprint.
                </td>
              </tr>
              <tr>
                <td data-tests=
                "RTCDtlsTransport-state.html,RTCPeerConnection-connectionState.https.html">
                  <dfn data-idl="">connected</dfn>
                </td>
                <td>
                  DTLS has completed negotiation of a secure connection and
                  verified the remote fingerprint.
                </td>
              </tr>
              <tr>
                <td data-tests="RTCDtlsTransport-state.html">
                  <dfn data-idl="">closed</dfn>
                </td>
                <td>
                  The transport has been closed intentionally as the result of
                  receipt of a close_notify alert, or calling
                  {{RTCPeerConnection/close()}}.
                </td>
              </tr>
              <tr>
                <td data-tests="protocol/dtls-fingerprint-validation.html">
                  <dfn data-idl="">failed</dfn>
                </td>
                <td>
                  The transport has failed as the result of an error (such as
                  receipt of an error alert or failure to validate the remote
                  fingerprint).
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <section id="rtcdtlsfingerprint">
          <h3>
            <dfn>RTCDtlsFingerprint</dfn> Dictionary
          </h3>
          <p data-tests="RTCCertificate.html">
            The {{RTCDtlsFingerprint}} dictionary includes the hash function
            algorithm and certificate fingerprint as described in [[!RFC4572]].
          </p>
          <div>
            <pre class="idl">dictionary RTCDtlsFingerprint {
  DOMString algorithm;
  DOMString value;
};</pre>
            <section>
              <h2>
                Dictionary RTCDtlsFingerprint Members
              </h2>
              <dl data-link-for="RTCDtlsFingerprint" data-dfn-for=
              "RTCDtlsFingerprint" class="dictionary-members">
                <dt data-tests="">
                  <dfn data-idl="">algorithm</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd>
                  <p>
                    One of the the hash function algorithms defined in the
                    'Hash function Textual Names' registry
                    [[!IANA-HASH-FUNCTION]].
                  </p>
                </dd>
                <dt data-tests="">
                  <dfn data-idl="">value</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd>
                  <p>
                    The value of the certificate fingerprint in lowercase hex
                    string as expressed utilizing the syntax of 'fingerprint'
                    in [[!RFC4572]] Section 5.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
      </section>
      <section id="rtcicetransport">
        <h3>
          <dfn>RTCIceTransport</dfn> Interface
        </h3>
        <p>
          The {{RTCIceTransport}} interface allows an application access to
          information about the ICE transport over which packets are sent and
          received. In particular, ICE manages peer-to-peer connections which
          involve state which the application may want to access.
          {{RTCIceTransport}} objects are constructed as a result of calls to
          {{RTCPeerConnection/setLocalDescription()}} and
          {{RTCPeerConnection/setRemoteDescription()}}. The underlying ICE
          state is managed by the <a>ICE agent</a>; as such, the state of an
          {{RTCIceTransport}} changes when the [= ICE Agent =] provides
          indications to the user agent as described below. Each
          {{RTCIceTransport}} object represents the ICE transport layer for the
          RTP or RTCP {{RTCIceTransport/component}} of a specific
          {{RTCRtpTransceiver}}, or a group of {{RTCRtpTransceiver}}s if such a
          group has been negotiated via [[RFC8843]].
        </p>
        <div class="note">
          An ICE restart for an existing {{RTCRtpTransceiver}} will be
          represented by an existing {{RTCIceTransport}} object, whose
          {{RTCIceTransport/state}} will be updated accordingly, as opposed to
          being represented by a new object.
        </div>
        <p>
          When the [= ICE Agent =] indicates that it began gathering a [=
          generation =] of candidates for an {{RTCIceTransport}}, the user
          agent MUST queue a task that runs the following steps:
        </p>
        <ol>
          <li class="no-test-needed">
            <p>
              Let <var>connection</var> be the {{RTCPeerConnection}} object
              associated with this [= ICE Agent =].
            </p>
          </li>
          <li>
            <p>
              If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
              <code>true</code>, abort these steps.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Let <var>transport</var> be the {{RTCIceTransport}} for which
              candidate gathering began.
            </p>
          </li>
          <li>
            <p>
              Set <var>transport</var>.{{RTCIceTransport/[[IceGathererState]]}} to
              {{RTCIceGathererState/gathering}}.
            </p>
          </li>
          <li>
            <p>
              [= Fire an event =] named {{RTCIceTransport/gatheringstatechange}} at
              <var>transport</var>.
            </p>
          </li>
          <li class="needs-test">
            <p>
              <a>Update the ICE gathering state</a> of <var>connection</var>.
            </p>
          </li>
        </ol>
        <p>
          When the [= ICE Agent =] is finished gathering a [= generation =] of
          candidates for an {{RTCIceTransport}}, and those candidates have been
          surfaced to the application, the user agent MUST queue a task that
          runs the following steps:
        </p>
        <ol>
          <li class="no-test-needed">
            <p>
              Let <var>connection</var> be the {{RTCPeerConnection}} object
              associated with this [= ICE Agent =].
            </p>
          </li>
          <li>
            <p>
              If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
              <code>true</code>, abort these steps.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Let <var>transport</var> be the {{RTCIceTransport}} for which
              candidate gathering finished.
            </p>
          </li>
          <li>
            <p>
              Let <var>newCandidate</var> be the result of [= creating an
              RTCIceCandidate =] with a new dictionary whose
              {{RTCIceCandidateInit/sdpMid}} and
              {{RTCIceCandidateInit/sdpMLineIndex}} are set to the values
              associated with this {{RTCIceTransport}},
              {{RTCIceCandidateInit/usernameFragment}} is set to the username
              fragment of the [= generation =] of candidates for which
              gathering finished, and {{RTCIceCandidateInit/candidate}} is set
              to an empty string.
            </p>
          </li>
          <li>
            <p>
              [= Fire an event =] named {{RTCPeerConnection/icecandidate}} using the
              {{RTCPeerConnectionIceEvent}} interface with the candidate
              attribute set to <var>newCandidate</var> at
              <var>connection</var>.
            </p>
          </li>
          <li>
            <p>
              If another [= generation =] of candidates is still being
              gathered, abort these steps.
            </p>
            <div class="note">
              This may occur if an ICE restart is initiated while the ICE agent
              is still gathering the previous [= generation =] of candidates.
            </div>
          </li>
          <li>
            <p>
              Set <var>transport</var>.{{RTCIceTransport/[[IceGathererState]]}} to
              {{RTCIceGathererState/complete}}.
            </p>
          </li>
          <li>
            <p>
              [= Fire an event =] named {{RTCIceTransport/gatheringstatechange}} at
              <var>transport</var>.
            </p>
          </li>
          <li>
            <p>
              <a>Update the ICE gathering state</a> of <var>connection</var>.
            </p>
          </li>
        </ol>
        <p>
          When the [= ICE Agent =] indicates that a new ICE candidate is
          available for an {{RTCIceTransport}}, either by taking one from the
          [= ICE candidate pool size | ICE candidate pool =] or gathering it
          from scratch, the user agent MUST queue a task that runs the
          following steps:
        </p>
        <ol>
          <li class="no-test-needed">
            <p>
              Let <var>candidate</var> be the available ICE candidate.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Let <var>connection</var> be the {{RTCPeerConnection}} object
              associated with this [= ICE Agent =].
            </p>
          </li>
          <li>
            <p>
              If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
              <code>true</code>, abort these steps.
            </p>
          </li>
          <li data-tests=
            "RTCPeerConnection-addIceCandidate-timing.https.html,protocol/candidate-exchange.https.html">
            <p>
              If either
              <var>connection</var>.{{RTCPeerConnection/[[PendingLocalDescription]]}} or
              <var>connection</var>.{{RTCPeerConnection/[[CurrentLocalDescription]]}} are not
              <code>null</code>, and represent the ICE [= generation =] for
              which <var>candidate</var> was gathered, [= surface the candidate
              =] with <var>candidate</var> and <var>connection</var>, and abort
              these steps.
            </p>
          </li>
          <li data-tests=
            "RTCPeerConnection-addIceCandidate-timing.https.html,protocol/candidate-exchange.https.html">
            <p>
              Otherwise, append <var>candidate</var> to
              <var>connection</var>.{{RTCPeerConnection/[[EarlyCandidates]]}}.
            </p>
          </li>
        </ol>
        <p>
          When the [= ICE Agent =] signals that the ICE role has changed due to
          an ICE binding request with a role collision per [[RFC8445]] section
          7.3.1.1, the UA will queue a task to set the value of
          {{RTCIceTransport/[[IceRole]]}} to the new value.
        </p>
        <p>
          To <dfn>release early candidates</dfn> of a <var>connection</var>,
          run the following steps:
        </p>
        <ol>
          <li data-tests=
            "RTCPeerConnection-addIceCandidate-timing.https.html,protocol/candidate-exchange.https.html">
            <p>
              For each candidate, <var>candidate</var>, in
              <var>connection</var>.{{RTCPeerConnection/[[EarlyCandidates]]}}, queue a task
              to [= surface the candidate =] with <var>candidate</var> and
              <var>connection</var>.
            </p>
          </li>
          <li>
            <p>
              Set <var>connection</var>.{{RTCPeerConnection/[[EarlyCandidates]]}} to an empty
              list.
            </p>
          </li>
        </ol>
        <p>
          To <dfn data-lt="surface the candidate">surface a candidate</dfn>
          with <var>candidate</var> and <var>connection</var>, run the
          following steps:
        </p>
        <ol>
          <li>
            <p>
              If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
              <code>true</code>, abort these steps.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Let <var>transport</var> be the {{RTCIceTransport}} for which
              <var>candidate</var> is being made available.
            </p>
          </li>
          <li data-tests=
            "RTCPeerConnection-candidate-in-sdp.https.html">
            <p>
              If <var>connection</var>.{{RTCPeerConnection/[[PendingLocalDescription]]}} is
              not <code>null</code>, and represents the ICE [= generation =]
              for which <var>candidate</var> was gathered, add
              <var>candidate</var> to
              <var>connection</var>.{{RTCPeerConnection/[[PendingLocalDescription]]}}.sdp.
            </p>
          </li>
          <li>
            <p>
              If <var>connection</var>.{{RTCPeerConnection/[[CurrentLocalDescription]]}} is
              not <code>null</code>, and represents the ICE [= generation =]
              for which <var>candidate</var> was gathered, add
              <var>candidate</var> to
              <var>connection</var>.{{RTCPeerConnection/[[CurrentLocalDescription]]}}.sdp.
            </p>
          </li>
          <li>
            <p>
              Let <var>newCandidate</var> be the result of [= creating an
              RTCIceCandidate =] with a new dictionary whose
              {{RTCIceCandidateInit/sdpMid}} and
              {{RTCIceCandidateInit/sdpMLineIndex}} are set to the values
              associated with this {{RTCIceTransport}},
              {{RTCIceCandidateInit/usernameFragment}} is set to the username
              fragment of the candidate, and {{RTCIceCandidateInit/candidate}}
              is set to a string encoded using the [= candidate-attribute =]
              grammar to represent <var>candidate</var>.
            </p>
          </li>
          <li>
            <p>
              Add <var>newCandidate</var> to <var>transport</var>'s set of
              local candidates.
            </p>
          </li>
          <li data-tests="protocol/candidate-exchange.https.html">
            <p>
              [= Fire an event =] named {{RTCPeerConnection/icecandidate}} using the
              {{RTCPeerConnectionIceEvent}} interface with the candidate
              attribute set to <var>newCandidate</var> at
              <var>connection</var>.
            </p>
          </li>
        </ol>
        <p>
          The {{RTCIceTransportState}} of an {{RTCIceTransport}} may change
          because a candidate pair with a usable connection was found and
          selected or it may change without the selected candidate pair
          changing. The selected pair and {{RTCIceTransportState}} are related
          and are handled in the same task.
        </p>
        <p>
          When the [= ICE Agent =] indicates that an {{RTCIceTransport}} has
          changed either the selected candidate pair, the
          {{RTCIceTransportState}} or both, the user agent MUST queue a task
          that runs the following steps:
        </p>
        <ol>
          <li class="no-test-needed">
            <p>
              Let <var>connection</var> be the {{RTCPeerConnection}} object
              associated with this [= ICE Agent =].
            </p>
          </li>
          <li>
            <p>
              If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
              <code>true</code>, abort these steps.
            </p>
          </li>
          <li class="no-test-needed">
            <p>
              Let <var>transport</var> be the {{RTCIceTransport}} whose state
              is changing.
            </p>
          </li>
          <li>
            <p>
              Let <var>selectedCandidatePairChanged</var> be
              <code>false</code>.
            </p>
          </li>
          <li>
            <p>
              Let <var>transportIceConnectionStateChanged</var> be
              <code>false</code>.
            </p>
          </li>
          <li>
            <p>
              Let <var>connectionIceConnectionStateChanged</var> be
              <code>false</code>.
            </p>
          </li>
          <li>
            <p>
              Let <var>connectionStateChanged</var> be <code>false</code>.
            </p>
          </li>
          <li>
            <p>
              If <var>transport</var>'s selected candidate pair was changed,
              run the following steps:
            </p>
            <ol>
              <li>
                <p>
                  Let <var>newCandidatePair</var> be a newly created
                  {{RTCIceCandidatePair}} representing the indicated pair if
                  one is selected, and <code>null</code> otherwise.
                </p>
              </li>
              <li data-tests="RTCIceTransport.html">
                <p>
                  Set <var>transport</var>.{{RTCIceTransport/[[SelectedCandidatePair]]}} to
                  <var>newCandidatePair</var>.
                </p>
              </li>
              <li>
                <p>
                  Set <var>selectedCandidatePairChanged</var> to
                  <code>true</code>.
                </p>
              </li>
            </ol>
          </li>
          <li>
            <p>
              If <var>transport</var>'s {{RTCIceTransportState}} was changed,
              run the following steps:
            </p>
            <ol>
              <li>
                <p>
                  Set <var>transport</var>.{{RTCIceTransport/[[IceTransportState]]}} to the
                  new indicated {{RTCIceTransportState}}.
                </p>
              </li>
              <li>
                <p>
                  Set <var>transportIceConnectionStateChanged</var> to
                  <code>true</code>.
                </p>
              </li>
              <li>
                <p>
                  Set <var>connection</var>'s [= ICE connection state =] to the
                  value of deriving a new state value as described by the
                  {{RTCIceConnectionState}} enum.
                </p>
              </li>
              <li>
                <p>
                  If the <a>ice connection state</a> changed in the previous
                  step, set <var>connectionIceConnectionStateChanged</var> to
                  <code>true</code>.
                </p>
              </li>
              <li>
                <p>
                  Set <var>connection</var>'s [= connection state =] to the
                  value of deriving a new state value as described by the
                  {{RTCPeerConnectionState}} enum.
                </p>
              </li>
              <li>
                <p>
                  If the [= connection state =] changed in the previous step,
                  set <var>connectionStateChanged</var> to <code>true</code>.
                </p>
              </li>
            </ol>
          </li>
          <li>
            <p>
              If <var>selectedCandidatePairChanged</var> is <code>true</code>,
              [= fire an event =] named {{RTCIceTransport/selectedcandidatepairchange}} at
              <var>transport</var>.
            </p>
          </li>
          <li>
            <p>
              If <var>transportIceConnectionStateChanged</var> is
              <code>true</code>, [= fire an event =] named {{RTCIceTransport/statechange}} at
              <var>transport</var>.
            </p>
          </li>
          <li data-tests=
          "RTCIceConnectionState-candidate-pair.https.html,RTCPeerConnection-getStats.https.html,RTCPeerConnection-iceConnectionState-disconnected.https.html,RTCPeerConnection-iceConnectionState.https.html,RTCPeerConnection-track-stats.https.html">
            <p>
              If <var>connectionIceConnectionStateChanged</var> is
              <code>true</code>, [= fire an event =] named
              {{RTCPeerConnection/iceconnectionstatechange}} at <var>connection</var>.
            </p>
          </li>
          <li>
            <p>
              If <var>connectionStateChanged</var> is <code>true</code>, [=
              fire an event =] named {{RTCPeerConnection/connectionstatechange}} at
              <var>connection</var>.
            </p>
          </li>
        </ol>
        <p>
          An {{RTCIceTransport}} object has the following internal slots:
        </p>
        <ul>
          <li>
            <dfn data-dfn-for="RTCIceTransport">[[\IceTransportState]]</dfn> initialized to
            {{RTCIceTransportState/"new"}}
          </li>
          <li>
            <dfn data-dfn-for="RTCIceTransport">[[\IceGathererState]]</dfn> initialized to
            {{RTCIceGatheringState/"new"}}
          </li>
          <li data-tests="RTCIceTransport.html">
            <dfn data-dfn-for="RTCIceTransport">[[\SelectedCandidatePair]]</dfn> initialized to
            <code>null</code>
          </li>
          <li>
            <dfn data-dfn-for="RTCIceTransport">[[\IceRole]]</dfn> initialized to {{RTCIceRole/"unknown"}}
          </li>
        </ul>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCIceTransport : EventTarget {
  readonly attribute RTCIceRole role;
  readonly attribute RTCIceComponent component;
  readonly attribute RTCIceTransportState state;
  readonly attribute RTCIceGathererState gatheringState;
  sequence&lt;RTCIceCandidate&gt; getLocalCandidates();
  sequence&lt;RTCIceCandidate&gt; getRemoteCandidates();
  RTCIceCandidatePair? getSelectedCandidatePair();
  RTCIceParameters? getLocalParameters();
  RTCIceParameters? getRemoteParameters();
  attribute EventHandler onstatechange;
  attribute EventHandler ongatheringstatechange;
  attribute EventHandler onselectedcandidatepairchange;
};</pre>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCIceTransport" data-dfn-for="RTCIceTransport"
            class="attributes">
              <dt>
                <dfn id="dom-icetransport-role">role</dfn> of type <span class=
                "idlAttrType">{{RTCIceRole}}</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{role}} attribute MUST, on getting, return the value of
                  the [[\IceRole]] internal slot.
                </p>
              </dd>
              <dt>
                <dfn id="dom-icetransport-component">component</dfn> of type
                <span class="idlAttrType">{{RTCIceComponent}}</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{component}} attribute MUST return the ICE component of
                  the transport. When RTCP mux is used, a single
                  {{RTCIceTransport}} transports both RTP and RTCP and
                  {{component}} is set to {{RTCIceComponent/"rtp"}}.
                </p>
              </dd>
              <dt>
                <dfn id="dom-icetransport-state">state</dfn> of type
                <span class="idlAttrType">{{RTCIceTransportState}}</span>,
                readonly
              </dt>
              <dd>
                <p>
                  The {{state}} attribute MUST, on getting, return the value of
                  the {{RTCIceTransport/[[IceTransportState]]}} slot.
                </p>
              </dd>
              <dt>
                <dfn id="dom-icetransport-gatheringstate" data-idl=
                "">gatheringState</dfn> of type <span class=
                "idlAttrType">{{RTCIceGathererState}}</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{gatheringState}} attribute MUST, on getting, return the
                  value of the {{RTCIceTransport/[[IceGathererState]]}} slot.
                </p>
              </dd>
              <dt>
                <dfn data-idl="">onstatechange</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd>
                This event handler, of event handler event type
                {{statechange}}, MUST be fired any time the {{RTCIceTransport}}
                {{RTCIceTransport/state}} changes.
              </dd>
              <dt>
                <dfn data-idl="">ongatheringstatechange</dfn> of type
                <span class="idlAttrType">EventHandler</span>
              </dt>
              <dd>
                This event handler, of event handler event type
                {{gatheringstatechange}}, MUST be fired any time the
                {{RTCIceTransport}} [= ICE gathering state =] changes.
              </dd>
              <dt>
                <dfn data-idl="">onselectedcandidatepairchange</dfn> of type
                <span class="idlAttrType">EventHandler</span>
              </dt>
              <dd>
                This event handler, of event handler event type
                {{RTCIceTransport/selectedcandidatepairchange}}, MUST be fired any time the
                {{RTCIceTransport}}'s selected candidate pair changes.
              </dd>
            </dl>
          </section>
          <section>
            <h2>
              Methods
            </h2>
            <dl data-link-for="RTCIceTransport" data-dfn-for="RTCIceTransport"
            class="methods">
              <dt data-tests="RTCIceTransport.html">
                <dfn data-idl="">getLocalCandidates</dfn>
              </dt>
              <dd>
                <p>
                  Returns a sequence describing the local ICE candidates
                  gathered for this {{RTCIceTransport}} and sent in
                  {{RTCPeerConnection/onicecandidate}}.
                </p>
              </dd>
              <dt data-tests="RTCIceTransport.html">
                <dfn data-idl="">getRemoteCandidates</dfn>
              </dt>
              <dd>
                <p>
                  Returns a sequence describing the remote ICE candidates
                  received by this {{RTCIceTransport}} via
                  {{RTCPeerConnection/addIceCandidate()}}.
                </p>
                <div class="note">
                  {{getRemoteCandidates}} will not expose peer reflexive
                  candidates since they are not received via
                  {{RTCPeerConnection/addIceCandidate()}}.
                </div>
              </dd>
              <dt data-tests="RTCIceTransport.html">
                <dfn data-idl="">getSelectedCandidatePair</dfn>
              </dt>
              <dd>
                <p>
                  Returns the selected candidate pair on which packets are
                  sent. This method MUST return the value of the
                  {{RTCIceTransport/[[SelectedCandidatePair]]}} slot. When
                  {{RTCIceTransport}}.{{RTCIceTransport/state}} is
                  {{RTCIceTransportState/"new"}} or
                  {{RTCIceTransportState/"closed"}}
                  {{getSelectedCandidatePair}} returns <code>null</code>.
                </p>
              </dd>
              <dt data-tests="RTCIceTransport.html">
                <dfn data-idl="">getLocalParameters</dfn>
              </dt>
              <dd>
                <p>
                  Returns the local ICE parameters received by this
                  {{RTCIceTransport}} via
                  {{RTCPeerConnection/setLocalDescription}}, or
                  <code>null</code> if the parameters have not yet been
                  received.
                </p>
              </dd>
              <dt data-tests="RTCIceTransport.html">
                <dfn data-idl="">getRemoteParameters</dfn>
              </dt>
              <dd>
                <p>
                  Returns the remote ICE parameters received by this
                  {{RTCIceTransport}} via
                  {{RTCPeerConnection/setRemoteDescription}} or
                  <code>null</code> if the parameters have not yet been
                  received.
                </p>
              </dd>
            </dl>
          </section>
        </div>
        <section id="rtciceparameters">
          <h3>
            <dfn>RTCIceParameters</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCIceParameters {
  DOMString usernameFragment;
  DOMString password;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCIceParameters}} Members
              </h2>
              <dl data-link-for="RTCIceParameters" data-dfn-for=
              "RTCIceParameters" class="dictionary-members">
                <dt>
                  <dfn data-idl="">usernameFragment</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd>
                  <p>
                    The ICE username fragment as defined in [[RFC5245]], Section
                    7.1.2.3.
                  </p>
                </dd>
                <dt>
                  <dfn data-idl="">password</dfn> of type <span class=
                  "idlMemberType">DOMString</span>
                </dt>
                <dd>
                  <p>
                    The ICE password as defined in [[RFC5245]], Section 7.1.2.3.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section id="rtcicecandidatepair">
          <h3>
            <dfn>RTCIceCandidatePair</dfn> Dictionary
          </h3>
          <div>
            <pre class="idl">dictionary RTCIceCandidatePair {
  RTCIceCandidate local;
  RTCIceCandidate remote;
};</pre>
            <section>
              <h2>
                Dictionary {{RTCIceCandidatePair}} Members
              </h2>
              <dl data-link-for="RTCIceCandidatePair" data-dfn-for=
              "RTCIceCandidatePair" class="dictionary-members">
                <dt>
                  <dfn data-idl="">local</dfn> of type <span class=
                  "idlMemberType">{{RTCIceCandidate}}</span>
                </dt>
                <dd>
                  <p>
                    The local ICE candidate.
                  </p>
                </dd>
                <dt>
                  <dfn data-idl="">remote</dfn> of type <span class=
                  "idlMemberType">{{RTCIceCandidate}}</span>
                </dt>
                <dd>
                  <p>
                    The remote ICE candidate.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section id="rtcicegathererstate">
          <h4>
            <dfn>RTCIceGathererState</dfn> Enum
          </h4>
          <div>
            <pre class="idl">enum RTCIceGathererState {
  "new",
  "gathering",
  "complete"
};</pre>
            <table data-link-for="RTCIceGathererState" data-dfn-for=
            "RTCIceGathererState" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    {{RTCIceGathererState}} Enumeration description
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <dfn data-idl="">new</dfn>
                  </td>
                  <td>
                    The {{RTCIceTransport}} was just created, and has not
                    started gathering candidates yet.
                  </td>
                </tr>
                <tr>
                  <td data-tests="RTCPeerConnection-iceGatheringState.html">
                    <dfn data-idl="">gathering</dfn>
                  </td>
                  <td>
                    The {{RTCIceTransport}} is in the process of gathering
                    candidates.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-iceGatheringState.html,protocol/candidate-exchange.https.html">
                    <dfn data-idl="">complete</dfn>
                  </td>
                  <td>
                    The {{RTCIceTransport}} has completed gathering and the
                    end-of-candidates indication for this transport has been
                    sent. It will not gather candidates again until an ICE
                    restart causes it to restart.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section id="rtcicetransportstate">
          <h3>
            <dfn>RTCIceTransportState</dfn> Enum
          </h3>
          <div>
            <pre class="idl">enum RTCIceTransportState {
  "new",
  "checking",
  "connected",
  "completed",
  "disconnected",
  "failed",
  "closed"
};</pre>
            <table data-link-for="RTCIceTransportState" data-dfn-for=
            "RTCIceTransportState" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    {{RTCIceTransportState}} Enumeration description
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <dfn data-idl="">new</dfn>
                  </td>
                  <td>
                    The {{RTCIceTransport}} is gathering candidates and/or
                    waiting for remote candidates to be supplied, and has not
                    yet started checking.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-iceConnectionState.https.html">
                    <dfn data-idl="">checking</dfn>
                  </td>
                  <td>
                    The {{RTCIceTransport}} has received at least one remote
                    candidate and is checking candidate pairs and has either
                    not yet found a connection or consent checks [[!RFC7675]]
                    have failed on all previously successful candidate pairs.
                    In addition to checking, it may also still be gathering.
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-connectionState.https.html, RTCPeerConnection-iceConnectionState.https.html">
                    <dfn data-idl="">connected</dfn>
                  </td>
                  <td>
                    The {{RTCIceTransport}} has found a usable connection, but
                    is still checking other candidate pairs to see if there is
                    a better connection. It may also still be gathering and/or
                    waiting for additional remote candidates. If consent checks
                    [[!RFC7675]] fail on the connection in use, and there are
                    no other successful candidate pairs available, then the
                    state transitions to {{RTCIceTransportState/"checking"}}
                    (if there are candidate pairs remaining to be checked) or
                    {{RTCIceTransportState/"disconnected"}} (if there are no
                    candidate pairs to check, but the peer is still gathering
                    and/or waiting for additional remote candidates).
                  </td>
                </tr>
                <tr>
                  <td data-tests=
                  "RTCPeerConnection-connectionState.https.html,RTCPeerConnection-iceConnectionState.https.html">
                    <dfn data-idl="">completed</dfn>
                  </td>
                  <td>
                    The {{RTCIceTransport}} has finished gathering, received an
                    indication that there are no more remote candidates,
                    finished checking all candidate pairs and found a
                    connection. If consent checks [[!RFC7675]] subsequently
                    fail on all successful candidate pairs, the state
                    transitions to {{RTCIceTransportState/"failed"}}.
                  </td>
                </tr>
                <tr>
                  <td>
                    <dfn data-idl="">disconnected</dfn>
                  </td>
                  <td>
                    The [= ICE Agent =] has determined that connectivity is
                    currently lost for this {{RTCIceTransport}}. This is a
                    transient state that may trigger intermittently (and
                    resolve itself without action) on a flaky network. The way
                    this state is determined is implementation dependent.
                    Examples include:
                    <ul>
                      <li>Losing the network interface for the connection in
                      use.
                      </li>
                      <li>Repeatedly failing to receive a response to STUN
                      requests.
                      </li>
                    </ul>Alternatively, the {{RTCIceTransport}} has finished
                    checking all existing candidates pairs and not found a
                    connection (or consent checks [[!RFC7675]] once successful,
                    have now failed), but it is still gathering and/or waiting
                    for additional remote candidates.
                  </td>
                </tr>
                <tr>
                  <td>
                    <dfn data-idl="">failed</dfn>
                  </td>
                  <td>
                    The {{RTCIceTransport}} has finished gathering, received an
                    indication that there are no more remote candidates,
                    finished checking all candidate pairs, and all pairs have
                    either failed connectivity checks or have lost consent.
                    This is a terminal state until ICE is restarted. Since an
                    ICE restart may cause connectivity to resume, entering the
                    {{RTCIceTransportState/"failed"}} state does not cause DTLS
                    transports, SCTP associations or the data channels that run
                    over them to close, or tracks to mute.
                  </td>
                </tr>
                <tr>
                  <td>
                    <dfn data-idl="">closed</dfn>
                  </td>
                  <td>
                    The {{RTCIceTransport}} has shut down and is no longer
                    responding to STUN requests.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="note">
            The most common transitions for a successful call will be new -&gt;
            checking -&gt; connected -&gt; completed, but under specific
            circumstances (only the last checked candidate succeeds, and
            gathering and the no-more candidates indication both occur prior to
            success), the state can transition directly from
            {{RTCIceTransportState/"checking"}} to
            {{RTCIceTransportState/"completed"}}.
          </p>
          <p>
            An ICE restart causes candidate gathering and connectivity checks to
            begin anew, causing a transition to
            {{RTCIceTransportState/"connected"}} if begun in the
            {{RTCIceTransportState/"completed"}} state. If begun in the
            transient {{RTCIceTransportState/"disconnected"}} state, it causes
            a transition to {{RTCIceTransportState/"checking"}}, effectively
            forgetting that connectivity was previously lost.
          </p>
          <p>
            The {{RTCIceTransportState/"failed"}} and
            {{RTCIceTransportState/"completed"}} states require an indication
            that there are no additional remote candidates. This can be
            indicated by calling {{RTCPeerConnection/addIceCandidate}} with a
            candidate value whose {{RTCIceCandidate/candidate}} property is set
            to an empty string or by
            {{RTCPeerConnection/canTrickleIceCandidates}} being set to
            <code>false</code>.
          </p>
          <p>
            Some example state transitions are:
          </p>
          <ul>
            <li>({{RTCIceTransport}} first created, as a result of
            {{RTCPeerConnection/setLocalDescription}} or
            {{RTCPeerConnection/setRemoteDescription}}):
            {{RTCIceTransportState/"new"}}
            </li>
            <li>({{RTCIceTransportState/"new"}}, remote candidates received):
            {{RTCIceTransportState/"checking"}}
            </li>
            <li>({{RTCIceTransportState/"checking"}}, found usable connection):
            {{RTCIceTransportState/"connected"}}
            </li>
            <li>({{RTCIceTransportState/"checking"}}, checks fail but gathering
            still in progress): {{RTCIceTransportState/"disconnected"}}
            </li>
            <li>({{RTCIceTransportState/"checking"}}, gave up):
            {{RTCIceTransportState/"failed"}}
            </li>
            <li>({{RTCIceTransportState/"disconnected"}}, new local
            candidates): {{RTCIceTransportState/"checking"}}
            </li>
            <li>({{RTCIceTransportState/"connected"}}, finished all checks):
            {{RTCIceTransportState/"completed"}}
            </li>
            <li>({{RTCIceTransportState/"completed"}}, lost connectivity):
            {{RTCIceTransportState/"disconnected"}}
            </li>
            <li>({{RTCIceTransportState/"disconnected"}} or
            {{RTCIceTransportState/"failed"}}, ICE restart occurs):
            {{RTCIceTransportState/"checking"}}
            </li>
            <li>({{RTCIceTransportState/"completed"}}, ICE restart occurs):
            {{RTCIceTransportState/"connected"}}
            </li>
            <li>{{RTCPeerConnection}}.{{RTCPeerConnection/close()}}:
            {{RTCIceTransportState/"closed"}}
            </li>
          </ul>
          <figure>
            <img alt="ICE transport state transition diagram" src=
            "images/icetransportstate.svg" width="600">
            <figcaption>
              Non-normative ICE transport state transition diagram
            </figcaption>
          </figure>
        </section>
        <section id="rtcicerole">
          <h3>
            <dfn>RTCIceRole</dfn> Enum
          </h3>
          <div>
            <pre class="idl">enum RTCIceRole {
  "unknown",
  "controlling",
  "controlled"
};</pre>
            <table data-link-for="RTCIceRole" data-dfn-for="RTCIceRole" class=
            "simple">
              <thead>
                <tr>
                  <th colspan="2">
                    {{RTCIceRole}} Enumeration description
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <dfn data-idl="">unknown</dfn>
                  </td>
                  <td>
                    An agent whose role as defined by [[RFC5245]], Section 3, has
                    not yet been determined.
                  </td>
                </tr>
                <tr>
                  <td>
                    <dfn data-idl="">controlling</dfn>
                  </td>
                  <td>
                    A controlling agent as defined by [[RFC5245]], Section 3.
                  </td>
                </tr>
                <tr>
                  <td>
                    <dfn data-idl="">controlled</dfn>
                  </td>
                  <td>
                    A controlled agent as defined by [[RFC5245]], Section 3.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section id="rtcicecomponent">
          <h3>
            <dfn>RTCIceComponent</dfn> Enum
          </h3>
          <div>
            <pre class="idl">enum RTCIceComponent {
  "rtp",
  "rtcp"
};</pre>
            <table data-link-for="RTCIceComponent" data-dfn-for=
            "RTCIceComponent" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    {{RTCIceComponent}} Enumeration description
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <dfn data-idl="">rtp</dfn>
                  </td>
                  <td>
                    The ICE Transport is used for RTP (or RTCP multiplexing),
                    as defined in [[RFC5245]], Section 4.1.1.1. Protocols
                    multiplexed with RTP (e.g. data channel) share its
                    component ID. This represents the <code class=
                    "ice">component-id</code> value <code>1</code> when encoded
                    in [= candidate-attribute =].
                  </td>
                </tr>
                <tr>
                  <td>
                    <dfn data-idl="">rtcp</dfn>
                  </td>
                  <td>
                    The ICE Transport is used for RTCP as defined by [[RFC5245]],
                    Section 4.1.1.1. This represents the <code class=
                    "ice">component-id</code> value <code>2</code> when encoded
                    in [= candidate-attribute =].
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
      </section>
      <section>
        <h3>
          <dfn>RTCTrackEvent</dfn>
        </h3>
        <p>
          The {{RTCPeerConnection/track}} event uses the {{RTCTrackEvent}} interface.
        </p>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCTrackEvent : Event {
  constructor(DOMString type, RTCTrackEventInit eventInitDict);
  readonly attribute RTCRtpReceiver receiver;
  readonly attribute MediaStreamTrack track;
  [SameObject] readonly attribute FrozenArray&lt;MediaStream&gt; streams;
  readonly attribute RTCRtpTransceiver transceiver;
};</pre>
          <section>
            <h2>
              Constructors
            </h2>
            <dl data-link-for="RTCTrackEvent" data-dfn-for="RTCTrackEvent"
            class="constructors">
              <dt data-tests="RTCTrackEvent-constructor.html">
                <dfn>RTCTrackEvent.constructor()</dfn>
              </dt>
              <dd></dd>
            </dl>
          </section>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCTrackEvent" data-dfn-for="RTCTrackEvent"
            class="attributes">
              <dt data-tests=
              "RTCPeerConnection-ontrack.https.html,RTCTrackEvent-constructor.html">
                <dfn id="dom-trackevent-receiver">receiver</dfn> of type
                <span class="idlAttrType">{{RTCRtpReceiver}}</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{receiver}} attribute represents the {{RTCRtpReceiver}}
                  object associated with the event.
                </p>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-ontrack.https.html,RTCTrackEvent-constructor.html">
                <dfn data-idl="">track</dfn> of type <span class=
                "idlAttrType">{{MediaStreamTrack}}</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{track}} attribute represents the {{MediaStreamTrack}}
                  object that is associated with the {{RTCRtpReceiver}}
                  identified by {{receiver}}.
                </p>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-ontrack.https.html,RTCTrackEvent-constructor.html">
                <dfn data-idl="">streams</dfn> of type <span class=
                "idlAttrType">FrozenArray&lt;{{MediaStream}}&gt;</span>,
                readonly
              </dt>
              <dd>
                <p>
                  The {{streams}} attribute returns an array of {{MediaStream}}
                  objects representing the {{MediaStream}}s that this event's
                  {{track}} is a part of.
                </p>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-ontrack.https.html,RTCTrackEvent-constructor.html">
                <dfn id="dom-trackevent-transceiver">transceiver</dfn> of type
                <span class="idlAttrType">{{RTCRtpTransceiver}}</span>,
                readonly
              </dt>
              <dd>
                <p>
                  The {{transceiver}} attribute represents the
                  {{RTCRtpTransceiver}} object associated with the event.
                </p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">dictionary RTCTrackEventInit : EventInit {
  required RTCRtpReceiver receiver;
  required MediaStreamTrack track;
  sequence&lt;MediaStream&gt; streams = [];
  required RTCRtpTransceiver transceiver;
};</pre>
          <section>
            <h2>
              Dictionary <dfn>RTCTrackEventInit</dfn> Members
            </h2>
            <dl data-link-for="RTCTrackEventInit" data-dfn-for=
            "RTCTrackEventInit" class="dictionary-members">
              <dt data-tests="RTCTrackEvent-constructor.html">
                <dfn data-idl="">receiver</dfn> of type <span class=
                "idlMemberType">{{RTCRtpReceiver}}</span>, required
              </dt>
              <dd>
                <p>
                  The {{receiver}} member represents the {{RTCRtpReceiver}}
                  object associated with the event.
                </p>
              </dd>
              <dt data-tests="RTCTrackEvent-constructor.html">
                <dfn data-idl="">track</dfn> of type <span class=
                "idlMemberType">{{MediaStreamTrack}}</span>, required
              </dt>
              <dd>
                <p>
                  The {{track}} member represents the {{MediaStreamTrack}}
                  object that is associated with the {{RTCRtpReceiver}}
                  identified by {{RTCTrackEventInit/receiver}}.
                </p>
              </dd>
              <dt data-tests="RTCTrackEvent-constructor.html">
                <dfn data-idl="">streams</dfn> of type <span class=
                "idlMemberType">sequence&lt;{{MediaStream}}&gt;</span>,
                defaulting to <code>[]</code>
              </dt>
              <dd>
                <p>
                  The {{streams}} member is an array of {{MediaStream}} objects
                  representing the {{MediaStream}}s that this event's {{track}}
                  is a part of.
                </p>
              </dd>
              <dt data-tests="RTCTrackEvent-constructor.html">
                <dfn data-idl="">transceiver</dfn> of type <span class=
                "idlMemberType">{{RTCRtpTransceiver}}</span>, required
              </dt>
              <dd>
                <p>
                  The {{transceiver}} attribute represents the
                  {{RTCRtpTransceiver}} object associated with the event.
                </p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
    </section>
    <section>
      <h2>
        Peer-to-peer Data API
      </h2>
      <p>
        The Peer-to-peer Data API lets a web application send and receive
        generic application data peer-to-peer. The API for sending and
        receiving data models the behavior of <a data-cite="?html/web-sockets.html#websocket">Web
        Sockets</a>.
      </p>
      <section>
        <h3>
          RTCPeerConnection Interface Extensions
        </h3>
        <p>
          The Peer-to-peer data API extends the {{RTCPeerConnection}} interface
          as described below.
        </p>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">
          partial interface RTCPeerConnection {
  readonly attribute RTCSctpTransport? sctp;
  RTCDataChannel createDataChannel(USVString label,
                                   optional RTCDataChannelInit dataChannelDict = {});
  attribute EventHandler ondatachannel;
};</pre>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCPeerConnection" data-dfn-for=
            "RTCPeerConnection" class="attributes">
              <dt data-tests="RTCIceTransport.html">
                <dfn data-idl="">sctp</dfn> of type <span class=
                "idlAttrType">{{RTCSctpTransport}}</span>, readonly, nullable
              </dt>
              <dd>
                <p>
                  The SCTP transport over which SCTP data is sent and received.
                  If SCTP has not been negotiated, the value is null. This
                  attribute MUST return the {{RTCSctpTransport}} object stored
                  in the {{RTCPeerConnection/[[SctpTransport]]}} internal slot.
                </p>
              </dd>
              <dt data-tests="RTCPeerConnection-ondatachannel.html">
                <dfn data-idl="">ondatachannel</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd>
                The event type of this event handler is {{RTCPeerConnection/datachannel}}.
              </dd>
            </dl>
          </section>
          <section>
            <h2>
              Methods
            </h2>
            <dl data-link-for="RTCPeerConnection" data-dfn-for=
            "RTCPeerConnection" class="methods">
              <dt>
                <dfn id=
                "dom-peerconnection-createdatachannel">createDataChannel</dfn>
              </dt>
              <dd>
                <p>
                  Creates a new {{RTCDataChannel}} object with the given label.
                  The {{RTCDataChannelInit}} dictionary can be used to
                  configure properties of the underlying channel such as data
                  reliability.
                </p>
                <p>
                  When the {{createDataChannel}} method is invoked, the user
                  agent MUST run the following steps.
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>connection</var> be the {{RTCPeerConnection}}
                      object on which the method is invoked.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                      <code>true</code>, [= exception/throw =] an
                      {{InvalidStateError}}.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      [= Create an RTCDataChannel =], <var>channel</var>.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      Initialize
                      <var>channel</var>.{{RTCDataChannel/[[DataChannelLabel]]}} to the
                      value of the first argument.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      If the UTF-8 representation of
                      {{RTCDataChannel/[[DataChannelLabel]]}} is longer than 65535 bytes,
                      [= exception/throw =] a {{TypeError}}.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>options</var> be the second argument.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      Initialize
                      <var>channel</var>.{{RTCDataChannel/[[MaxPacketLifeTime]]}} to
                      <var>option</var>.{{RTCDataChannelInit/maxPacketLifeTime}},
                      if present, otherwise <code>null</code>.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      Initialize <var>channel</var>.{{RTCDataChannel/[[MaxRetransmits]]}}
                      to
                      <var>option</var>.{{RTCDataChannelInit/maxRetransmits}},
                      if present, otherwise <code>null</code>.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      Initialize <var>channel</var>.{{RTCDataChannel/[[Ordered]]}} to
                      <var>option</var>.{{RTCDataChannelInit/ordered}}.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      Initialize
                      <var>channel</var>.{{RTCDataChannel/[[DataChannelProtocol]]}} to
                      <var>option</var>.{{RTCDataChannelInit/protocol}}.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      If the UTF-8 representation of
                      {{RTCDataChannel/[[DataChannelProtocol]]}} is longer than 65535
                      bytes, [= exception/throw =] a {{TypeError}}.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      Initialize <var>channel</var>.{{RTCDataChannel/[[Negotiated]]}} to
                      <var>option</var>.{{RTCDataChannelInit/negotiated}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      Initialize <var>channel</var>.{{RTCDataChannel/[[DataChannelId]]}}
                      to the value of
                      <var>option</var>.{{RTCDataChannelInit/id}}, if it is
                      present and {{RTCDataChannel/[[Negotiated]]}} is true, otherwise
                      <code>null</code>.
                    </p>
                    <div class="note">
                      This means the {{RTCDataChannelInit/id}} member will be
                      ignored if the data channel is negotiated in-band; this
                      is intentional. Data channels negotiated in-band should
                      have IDs selected based on the DTLS role, as specified in
                      [[RFC8832]].
                    </div>
                  </li>
                  <li>
                    <p>
                      If {{RTCDataChannel/[[Negotiated]]}} is <code>true</code> and
                      {{RTCDataChannel/[[DataChannelId]]}} is <code>null</code>, [=
                      exception/throw =] a {{TypeError}}.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      If both {{RTCDataChannel/[[MaxPacketLifeTime]]}} and
                      {{RTCDataChannel/[[MaxRetransmits]]}} attributes are set (not null),
                      [= exception/throw =] a {{TypeError}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      If a setting, either {{RTCDataChannel/[[MaxPacketLifeTime]]}} or
                      {{RTCDataChannel/[[MaxRetransmits]]}}, has been set to indicate
                      unreliable mode, and that value exceeds the maximum value
                      supported by the user agent, the value MUST be set to the
                      user agents maximum value.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-createDataChannel.html">
                    <p>
                      If {{RTCDataChannel/[[DataChannelId]]}} is equal to 65535, which is
                      greater than the maximum allowed ID of 65534 but still
                      qualifies as an <span class="idlMemberType">unsigned
                      short</span>, [= exception/throw =] a {{TypeError}}.
                    </p>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-createDataChannel.html,RTCDataChannel-id.html">
                    <p>
                      If the {{RTCDataChannel/[[DataChannelId]]}} slot is
                      <code>null</code> (due to no ID being passed into
                      {{createDataChannel}}, or {{RTCDataChannel/[[Negotiated]]}} being
                      false), and the DTLS role of the SCTP transport has
                      already been negotiated, then initialize
                      {{RTCDataChannel/[[DataChannelId]]}} to a value generated by the
                      user agent, according to [[RFC8832]], and
                      skip to the next step. If no available ID could be
                      generated, or if the value of the
                      {{RTCDataChannel/[[DataChannelId]]}} slot is being used by an
                      existing {{RTCDataChannel}}, [= exception/throw =] an
                      {{OperationError}} exception.
                    </p>
                    <div class="note">
                      If the {{RTCDataChannel/[[DataChannelId]]}} slot is
                      <code>null</code> after this step, it will be populated
                      during the [= RTCSctpTransport connected =] procedure.
                    </div>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>transport</var> be
                      <var>connection</var>.{{RTCPeerConnection/[[SctpTransport]]}}.
                    </p>
                    <p>
                      If the {{RTCDataChannel/[[DataChannelId]]}} slot is not
                      <code>null</code>, <var>transport</var> is in the
                      {{RTCSctpTransportState/"connected"}} state and
                      {{RTCDataChannel/[[DataChannelId]]}} is greater or equal to
                      <var>transport</var>.{{RTCSctpTransport/[[MaxChannels]]}}, [=
                      exception/throw =] an {{OperationError}}.
                    </p>
                  </li>
                  <li data-tests="RTCPeerConnection-onnegotiationneeded.html">
                    <p>
                      If <var>channel</var> is the first {{RTCDataChannel}}
                      created on <var>connection</var>, [= update the
                      negotiation-needed flag =] for <var>connection</var>.
                    </p>
                  </li>
                  <li>
                    <p>
                      Return <var>channel</var> and continue the following
                      steps in parallel.
                    </p>
                  </li>
                  <li>
                    <p class="untestable">
                      Create <var>channel</var>'s associated [= underlying data
                      transport =] and configure it according to the relevant
                      properties of <var>channel</var>.
                    </p>
                  </li>
                </ol>
              </dd>
            </dl>
          </section>
        </div>
        <section>
          <h3>
            <dfn>RTCSctpTransport</dfn> Interface
          </h3>
          <p>
            The {{RTCSctpTransport}} interface allows an application access to
            information about the SCTP data channels tied to a particular SCTP
            association.
          </p>
          <section>
            <h4 id="sctp-transport-create">
              Create an instance
            </h4>
            <p>
              To <dfn>create an {{RTCSctpTransport}}</dfn> with an initial
              state, <var>initialState</var>, run the following steps:
            </p>
            <ol>
              <li data-tests=
              "RTCSctpTransport-constructor.html,RTCSctpTransport-events.html">
                <p>
                  Let <var>transport</var> be a new {{RTCSctpTransport}}
                  object.
                </p>
              </li>
              <li>
                <p>
                  Let <var>transport</var> have a
                  <dfn data-dfn-for="RTCSctpTransport">[[\SctpTransportState]]</dfn> internal slot initialized
                  to <var>initialState</var>.
                </p>
              </li>
              <li>
                <p>
                  Let <var>transport</var> have a
                  <dfn data-dfn-for="RTCSctpTransport">[[\MaxMessageSize]]</dfn> internal slot and run the
                  steps labeled [= update the data max message size =] to
                  initialize it.
                </p>
              </li>
              <li data-tests="RTCSctpTransport-maxChannels.html">
                <p>
                  Let <var>transport</var> have a <dfn data-dfn-for="RTCSctpTransport">[[\MaxChannels]]</dfn>
                  internal slot initialized to <code>null</code>.
                </p>
              </li>
              <li class="no-test-needed">
                <p>
                  Return <var>transport</var>.
                </p>
              </li>
            </ol>
          </section>
          <section>
            <h4 id="sctp-transport-update-mms">
              Update max message size
            </h4>
            <p>
              To <dfn>update the data max message size</dfn> of an
              {{RTCSctpTransport}} run the following steps:
            </p>
            <ol>
              <li class="no-test-needed">
                <p>
                  Let <var>transport</var> be the {{RTCSctpTransport}} object
                  to be updated.
                </p>
              </li>
              <li data-tests="RTCSctpTransport-maxMessageSize.html">
                <p>
                  Let <var>remoteMaxMessageSize</var> be the value of the
                  <code class="sdp">max-message-size</code> SDP attribute read
                  from the remote description, as described in [[RFC8841]]
                  (section 6), or 65536 if the attribute is missing.
                </p>
              </li>
              <li>
                <p>
                  Let <var>canSendSize</var> be the number of bytes that this
                  client can send (i.e. the size of the local send buffer) or 0
                  if the implementation can handle messages of any size.
                </p>
              </li>
              <li data-tests="RTCSctpTransport-maxMessageSize.html">
                <p>
                  If both <var>remoteMaxMessageSize</var> and
                  <var>canSendSize</var> are 0, set {{RTCSctpTransport/[[MaxMessageSize]]}}
                  to the positive Infinity value.
                </p>
              </li>
              <li data-tests="RTCSctpTransport-maxMessageSize.html">
                <p>
                  Else, if either <var>remoteMaxMessageSize</var> or
                  <var>canSendSize</var> is 0, set {{RTCSctpTransport/[[MaxMessageSize]]}}
                  to the larger of the two.
                </p>
              </li>
              <li data-tests="RTCSctpTransport-maxMessageSize.html">
                <p>
                  Else, set {{RTCSctpTransport/[[MaxMessageSize]]}} to the smaller of
                  <var>remoteMaxMessageSize</var> or <var>canSendSize</var>.
                </p>
              </li>
            </ol>
          </section>
          <section>
            <h4 id="sctp-transport-connected">
              Connected procedure
            </h4>
            <p>
              Once an <dfn data-lt="rtcsctptransport connected">SCTP transport
              is connected</dfn>, meaning the SCTP association of an {{
              RTCSctpTransport}} has been established, run the following steps:
            </p>
            <ol>
              <li class="no-test-needed">
                <p>
                  Let <var>transport</var> be the {{RTCSctpTransport}} object.
                </p>
              </li>
              <li class="no-test-needed">
                <p>
                  Let <var>connection</var> be the {{RTCPeerConnection}} object
                  associated with <var>transport</var>.
                </p>
              </li>
              <li>
                <p>
                  Set {{RTCSctpTransport/[[MaxChannels]]}} to the minimum of the negotiated
                  amount of incoming and outgoing SCTP streams.
                </p>
              </li>
              <li>
                <p>
                  For each of <var>connection</var>'s {{RTCDataChannel}}:
                </p>
                <ol>
                  <li>
                    <p>
                      Let <var>channel</var> be the {{RTCDataChannel}} object.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>channel</var>.{{RTCDataChannel/[[DataChannelId]]}} is
                      <code>null</code>, initialize {{RTCDataChannel/[[DataChannelId]]}}
                      to the value generated by the underlying sctp data
                      channel, according to [[RFC8832]].
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>channel</var>.{{RTCDataChannel/[[DataChannelId]]}} is
                      greater or equal to
                      <var>transport</var>.{{RTCSctpTransport/[[MaxChannels]]}}, or the
                      previous step failed to assign an id, [= unable to create
                      an RTCDataChannel | close =] the <var>channel</var> due
                      to a failure. Otherwise, [= announce the rtcdatachannel
                      as open | announce the channel as open =].
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <p>
                  [= Fire an event =] named {{RTCSctpTransport/statechange}} at
                  <var>transport</var>.
                </p>
                <p class="note">
                  This event is fired before the {{RTCDataChannel/open}} events fired by [= announce the
                  rtcdatachannel as open | announcing the channel as open =];
                  the {{RTCDataChannel/open}} events are fired from a
                  queued task.
                </p>
              </li>
            </ol>
          </section>
          <div>
            <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCSctpTransport : EventTarget {
  readonly attribute RTCDtlsTransport transport;
  readonly attribute RTCSctpTransportState state;
  readonly attribute unrestricted double maxMessageSize;
  readonly attribute unsigned short? maxChannels;
  attribute EventHandler onstatechange;
};</pre>
            <section>
              <h2>
                Attributes
              </h2>
              <dl data-link-for="RTCSctpTransport" data-dfn-for=
              "RTCSctpTransport" class="attributes">
                <dt data-tests=
                "RTCIceTransport.html,RTCSctpTransport-constructor.html">
                  <dfn data-idl="">transport</dfn> of type <span class=
                  "idlAttrType">{{RTCDtlsTransport}}</span>, readonly
                </dt>
                <dd>
                  <p>
                    The transport over which all SCTP packets for data channels
                    will be sent and received.
                  </p>
                </dd>
                <dt data-tests=
                "RTCSctpTransport-constructor.html,RTCSctpTransport-events.html">
                  <dfn data-idl="">state</dfn> of type <span class=
                  "idlAttrType">{{RTCSctpTransportState}}</span>, readonly
                </dt>
                <dd>
                  <p>
                    The current state of the SCTP transport. On getting, this
                    attribute MUST return the value of the
                    {{RTCSctpTransport/[[SctpTransportState]]}} slot.
                  </p>
                </dd>
                <dt data-tests="RTCSctpTransport-constructor.html">
                  <dfn data-idl="">maxMessageSize</dfn> of type <span class=
                  "idlAttrType">unrestricted double</span>, readonly
                </dt>
                <dd>
                  <p>
                    The maximum size of data that can be passed to
                    {{RTCDataChannel}}'s {{RTCDataChannel/send()}} method. The
                    attribute MUST, on getting, return the value of the
                    {{RTCSctpTransport/[[MaxMessageSize]]}} slot.
                  </p>
                </dd>
                <dt data-tests="RTCSctpTransport-maxChannels.html">
                  <dfn data-idl="">maxChannels</dfn> of type <span class=
                  "idlAttrType">unsigned short</span> , readonly, nullable
                </dt>
                <dd>
                  <p>
                    The maximum amount of {{RTCDataChannel}}'s that can be used
                    simultaneously. The attribute MUST, on getting, return the
                    value of the {{RTCSctpTransport/[[MaxChannels]]}} slot.
                  </p>
                  <div class="note">
                    This attribute's value will be <code>null</code> until the
                    SCTP transport goes into the
                    {{RTCSctpTransportState/"connected"}} state.
                  </div>
                </dd>
                <dt data-tests="RTCSctpTransport-events.html">
                  <dfn data-idl="">onstatechange</dfn> of type <span class=
                  "idlAttrType">EventHandler</span>
                </dt>
                <dd>
                  <p>
                    The event type of this event handler is
                    {{RTCSctpTransport/statechange}}.
                  </p>
                </dd>
              </dl>
            </section>
          </div>
        </section>
        <section id="rtcsctptransportstate">
          <h3>
            <dfn>RTCSctpTransportState</dfn> Enum
          </h3>
          <p>
            {{RTCSctpTransportState}} indicates the state of the SCTP
            transport.
          </p>
          <div>
            <pre class="idl">enum RTCSctpTransportState {
  "connecting",
  "connected",
  "closed"
};</pre>
            <table data-link-for="RTCSctpTransportState" data-dfn-for=
            "RTCSctpTransportState" class="simple">
              <thead>
                <tr>
                  <th colspan="2">
                    Enumeration description
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td data-tests="RTCSctpTransport-events.html">
                    <dfn data-idl="" id=
                    "idl-def-RTCSctpTransportState.connecting">connecting</dfn>
                  </td>
                  <td>
                    <p>
                      The {{RTCSctpTransport}} is in the process of negotiating
                      an association. This is the initial state of the
                      [[\SctpTransportState]] slot when an {{RTCSctpTransport}}
                      is created.
                    </p>
                  </td>
                </tr>
                <tr>
                  <td data-tests="RTCSctpTransport-events.html">
                    <dfn data-idl="" id=
                    "idl-def-RTCSctpTransportState.connected">connected</dfn>
                  </td>
                  <td>
                    <p>
                      When the negotiation of an association is completed, a
                      task is queued to update the [[\SctpTransportState]] slot
                      to {{RTCSctpTransportState/"connected"}}.
                    </p>
                  </td>
                </tr>
                <tr>
                  <td data-tests="RTCSctpTransport-events.html">
                    <dfn data-idl="" id=
                    "idl-def-RTCSctpTransportState.closed">closed</dfn>
                  </td>
                  <td>
                    <p>
                      A task is queued to update the [[\SctpTransportState]]
                      slot to {{RTCSctpTransportState/"closed"}} when:
                    </p>
                    <ul>
                      <li>a SHUTDOWN or ABORT chunk is received.
                      </li>
                      <li>the SCTP association has been closed intentionally,
                      such as by closing the peer connection or applying a
                      remote description that rejects data or changes the SCTP
                      port.
                      </li>
                      <li>the underlying DTLS association has transitioned to
                      {{RTCDtlsTransportState/"closed"}} state.
                      </li>
                    </ul>
                    <p>
                      Note that the last transition is logical due to the fact
                      that an SCTP association requires an established DTLS
                      connection - [[RFC8261]] section 6.1 specifies that SCTP
                      over DTLS is single-homed - and that no way of of
                      switching to an alternate transport is defined in this
                      API.
                    </p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
      </section>
      <section>
        <h3>
          <dfn>RTCDataChannel</dfn>
        </h3>
        <p data-tests="protocol/sctp-format.html">
          The {{RTCDataChannel}} interface represents a bi-directional data
          channel between two peers. An {{RTCDataChannel}} is created via a
          factory method on an {{RTCPeerConnection}} object. The messages sent
          between the browsers are described in [[RFC8831]] and
          [[RFC8832]].
        </p>
        <p>
          There are two ways to establish a connection with {{RTCDataChannel}}.
          The first way is to simply create an {{RTCDataChannel}} at one of the
          peers with the {{RTCDataChannelInit/negotiated}}
          {{RTCDataChannelInit}} dictionary member unset or set to its default
          value false. This will announce the new channel in-band and trigger
          an {{RTCDataChannelEvent}} with the corresponding {{RTCDataChannel}}
          object at the other peer. The second way is to let the application
          negotiate the {{RTCDataChannel}}. To do this, create an
          {{RTCDataChannel}} object with the {{RTCDataChannelInit/negotiated}}
          {{RTCDataChannelInit}} dictionary member set to true, and signal
          out-of-band (e.g. via a web server) to the other side that it SHOULD
          create a corresponding {{RTCDataChannel}} with the
          {{RTCDataChannelInit/negotiated}} {{RTCDataChannelInit}} dictionary
          member set to true and the same {{RTCDataChannel/id}}. This will
          connect the two separately created {{RTCDataChannel}} objects. The
          second way makes it possible to create channels with asymmetric
          properties and to create channels in a declarative way by specifying
          matching {{RTCDataChannelInit/id}}s.
        </p>
        <p>
          Each {{RTCDataChannel}} has an associated <dfn data-lt=
          "data transport">underlying data transport</dfn> that is used to
          transport actual data to the other peer. In the case of SCTP data
          channels utilizing an {{RTCSctpTransport}} (which represents the
          state of the SCTP association), the underlying data transport is the
          SCTP stream pair. The transport properties of the [= underlying data
          transport =], such as in order delivery settings and reliability
          mode, are configured by the peer as the channel is created. The
          properties of a channel cannot change after the channel has been
          created. The actual wire protocol between the peers is specified by
          the WebRTC DataChannel Protocol specification [[RFC8831]].
        </p>
        <p>
          An {{RTCDataChannel}} can be configured to operate in different
          reliability modes. A reliable channel ensures that the data is
          delivered at the other peer through retransmissions. An unreliable
          channel is configured to either limit the number of retransmissions (
          {{RTCDataChannelInit/maxRetransmits}} ) or set a time during which
          transmissions (including retransmissions) are allowed (
          {{RTCDataChannelInit/maxPacketLifeTime}} ). These properties can not
          be used simultaneously and an attempt to do so will result in an
          error. Not setting any of these properties results in a reliable
          channel.
        </p>
        <p>
          An {{RTCDataChannel}}, created with
          {{RTCPeerConnection/createDataChannel}} or dispatched via an
          {{RTCDataChannelEvent}}, MUST initially be in the
          {{RTCDataChannelState/"connecting"}} state. When the
          {{RTCDataChannel}} object's [= underlying data transport =] is ready,
          the user agent MUST [= announce the RTCDataChannel as open =].
        </p>
        <section>
          <h4>
            Creating a data channel
          </h4>
          <p>
            To <dfn>create an {{RTCDataChannel}}</dfn>, run the following
            steps:
          </p>
          <ol>
            <li class="no-test-needed">
              <p>
                Let <var>channel</var> be a newly created {{RTCDataChannel}}
                object.
              </p>
            </li>
            <li data-tests="RTCPeerConnection-ondatachannel.html">
              <p>
                Let <var>channel</var> have a <dfn data-dfn-for="RTCDataChannel">[[\ReadyState]]</dfn>
                internal slot initialized to
                {{RTCDataChannelState/"connecting"}}.
              </p>
            </li>
            <li data-tests="RTCDataChannel-bufferedAmount.html">
              <p>
                Let <var>channel</var> have a <dfn data-dfn-for="RTCDataChannel">[[\BufferedAmount]]</dfn>
                internal slot initialized to <code>0</code>.
              </p>
            </li>
            <li class="no-test-needed">
              <p>
                Let <var>channel</var> have internal slots named
                <dfn data-dfn-for="RTCDataChannel">[[\DataChannelLabel]]</dfn>, <dfn data-dfn-for="RTCDataChannel">[[\Ordered]]</dfn>,
                <dfn data-dfn-for="RTCDataChannel">[[\MaxPacketLifeTime]]</dfn>,
                <dfn data-dfn-for="RTCDataChannel">[[\MaxRetransmits]]</dfn>,
                <dfn data-dfn-for="RTCDataChannel">[[\DataChannelProtocol]]</dfn>,
                <dfn data-dfn-for="RTCDataChannel">[[\Negotiated]]</dfn>, and <dfn data-dfn-for="RTCDataChannel">[[\DataChannelId]]</dfn>.
              </p>
            </li>
            <li class="no-test-needed">
              <p>
                Return <var>channel</var>.
              </p>
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Announcing a data channel as open
          </h4>
          <p>
            When the user agent is to <dfn data-lt=
            "announce the rtcdatachannel as open" id=
            "announce-datachannel-open">announce an {{RTCDataChannel}} as
            open</dfn>, the user agent MUST queue a task to run the following
            steps:
          </p>
          <ol>
            <li>
              <p>
                If the associated {{RTCPeerConnection}} object's
                {{RTCPeerConnection/[[IsClosed]]}} slot is <code>true</code>, abort these
                steps.
              </p>
            </li>
            <li class="no-test-needed">
              <p>
                Let <var>channel</var> be the {{RTCDataChannel}} object to be
                announced.
              </p>
            </li>
            <li>
              <p>
                If <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} is
                {{RTCDataChannelState/"closing"}} or
                {{RTCDataChannelState/"closed"}}, abort these steps.
              </p>
            </li>
            <li>
              <p>
                Set <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} to
                {{RTCDataChannelState/"open"}}.
              </p>
            </li>
            <li data-tests="RTCPeerConnection-ondatachannel.html">
              <p>
                [= Fire an event =] named {{RTCDataChannel/open}} at <var>channel</var>.
              </p>
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Announcing a data channel instance
          </h4>
          <p data-tests="RTCPeerConnection-ondatachannel.html">
            When an [= underlying data transport =] is to be announced (the
            other peer created a channel with {{RTCDataChannelInit/negotiated}}
            unset or set to false), the user agent of the peer that did not
            initiate the creation process MUST queue a task to run the
            following steps:
          </p>
          <ol>
            <li class="no-test-needed">
              <p>
                Let <var>connection</var> be the {{RTCPeerConnection}} object
                associated with the [= underlying data transport =].
              </p>
            </li>
            <li class="untestable">
              <p>
                If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                <code>true</code>, abort these steps.
              </p>
            </li>
            <li>
              <p>
                [= Create an RTCDataChannel =], <var>channel</var>.
              </p>
            </li>
            <li data-tests="RTCPeerConnection-ondatachannel.html">
              <p>
                Let <var>configuration</var> be an information bundle received
                from the other peer as a part of the process to establish the
                [= underlying data transport =] described by the WebRTC
                DataChannel Protocol specification [[RFC8832]].
              </p>
            </li>
            <li data-tests="RTCPeerConnection-ondatachannel.html">
              <p>
                Initialize <var>channel</var>.{{RTCDataChannel/[[DataChannelLabel]]}},
                {{RTCDataChannel/[[Ordered]]}}, {{RTCDataChannel/[[MaxPacketLifeTime]]}},
                {{RTCDataChannel/[[MaxRetransmits]]}}, {{RTCDataChannel/[[DataChannelProtocol]]}},
                and {{RTCDataChannel/[[DataChannelId]]}} internal slots to the
                corresponding values in <var>configuration</var>.
              </p>
            </li>
            <li>
              <p>
                Initialize <var>channel</var>.{{RTCDataChannel/[[Negotiated]]}} to
                <code>false</code>.
              </p>
            </li>
            <li data-tests="RTCPeerConnection-ondatachannel.html">
              <p>
                Set <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} to
                {{RTCDataChannelState/"open"}} (but do not fire the {{RTCDataChannel/open}}
                event, yet).
              </p>
              <div class="note">
                This allows to start sending messages inside of the
                {{RTCPeerConnection/datachannel}} event handler prior to the {{RTCDataChannel/open}} event being
                fired.
              </div>
            </li>
            <li data-tests="RTCPeerConnection-ondatachannel.html">
              <p>
                [= Fire an event =] named {{RTCPeerConnection/datachannel}} using the
                {{RTCDataChannelEvent}} interface with the
                {{RTCDataChannelEvent/channel}} attribute set to
                <var>channel</var> at <var>connection</var>.
              </p>
            </li>
            <li>
              <p>
                [= announce the rtcdatachannel as open | Announce the data
                channel as open =].
              </p>
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Closing procedure
          </h4>
          <p>
            An {{RTCDataChannel}} object's [= underlying data transport =] may
            be torn down in a non-abrupt manner by running the <dfn id=
            "data-transport-closing-procedure">closing procedure</dfn>. When
            that happens the user agent MUST queue a task to run the following
            steps:
          </p>
          <ol>
            <li class="no-test-needed">
              <p>
                Let <var>channel</var> be the {{RTCDataChannel}} object whose
                [= underlying data transport =] was closed.
              </p>
            </li>
            <li>
              <p>
                Unless the procedure was initiated by
                <var>channel</var>.{{RTCDataChannel/close}}, set
                <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} to
                {{RTCDataChannelState/"closing"}} and [= fire an event =] named
                {{RTCDataChannel/closing}} at <var>channel</var>.
              </p>
            </li>
            <li>
              <p>
                Run the following steps in parallel:
              </p>
              <ol>
                <li>
                  <p>
                    Finish sending all currently pending messages of the
                    <var>channel</var>.
                  </p>
                </li>
                <li>
                  <p>
                    Follow the closing procedure defined for the
                    <var>channel</var>'s [= underlying data transport =] :
                  </p>
                  <ol>
                    <li>
                      <p>
                        In the case of an SCTP-based [= underlying data
                        transport | transport =], follow [[RFC8831]],
                        section 6.7.
                      </p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>
                    Render the <var>channel</var>'s [= data transport =]
                    [=closed=] by following the associated procedure.
                  </p>
                </li>
              </ol>
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Announcing a data channel as closed
          </h4>
          <p>
            When an {{RTCDataChannel}} object's [= underlying data transport =]
            has been <dfn id="data-transport-closed" data-dfn-for=
            "">closed</dfn>, the user agent MUST queue a task to run the
            following steps:
          </p>
          <ol data-tests="RTCDataChannel-close.html">
            <li class="no-test-needed">
              <p>
                Let <var>channel</var> be the {{RTCDataChannel}} object whose
                [= underlying data transport =] was closed.
              </p>
            </li>
            <li>If <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} is
            {{RTCDataChannelState/"closed"}}, abort these steps.
            </li>
            <li>
              <p>
                Set <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} to
                {{RTCDataChannelState/"closed"}}.
              </p>
            </li>
            <li>
              <p>
                If the [= underlying data transport | transport =] was closed
                <dfn id="data-transport-closed-error">with an error</dfn>, [=
                fire an event =] named {{RTCDataChannel/error}} using the {{RTCErrorEvent}}
                interface with its {{RTCError/errorDetail}} attribute set to
                {{RTCErrorDetailType/"sctp-failure"}} at <var>channel</var>.
              </p>
            </li>
            <li>
              <p>
                [= Fire an event =] named  <a data-link-for=RTCDataChannel data-link-type=event>close</a> at <var>channel</var>.
              </p>
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Error on creating data channels
          </h4>
          <p>
            In some cases, the user agent may be <dfn>unable to create an
            {{RTCDataChannel}}</dfn> 's [= underlying data transport =]. For
            example, the data channel's {{RTCDataChannel/id}} may be outside
            the range negotiated by the [[RFC8831]] implementations in the
            SCTP handshake. When the user agent determines that an
            {{RTCDataChannel}}'s [= underlying data transport =] cannot be
            created, the user agent MUST queue a task to run the following
            steps:
          </p>
          <ol>
            <li class="no-test-needed">
              <p>
                Let <var>channel</var> be the {{RTCDataChannel}} object for
                which the user agent could not create an [= underlying data
                transport =].
              </p>
            </li>
            <li>
              <p>
                Set <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} to
                {{RTCDataChannelState/"closed"}}.
              </p>
            </li>
            <li>
              <p>
                [= Fire an event =] named {{RTCDataChannel/error}} using the
                {{RTCErrorEvent}} interface with the {{RTCError/errorDetail}}
                attribute set to {{RTCErrorDetailType/"data-channel-failure"}}
                at <var>channel</var>.
              </p>
            </li>
            <li>
              <p>
                [= Fire an event =] named <a data-link-for=RTCDataChannel data-link-type=event>close</a> at <var>channel</var>.
              </p>
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Receiving messages on a data channel
          </h4>
          <p>
            When an <dfn data-lt=
            "receive an rtcdatachannel message">{{RTCDataChannel}} message has
            been received</dfn> via the [= underlying data transport =] with
            type <var>type</var> and data <var>rawData</var>, the user agent
            MUST queue a task to run the following steps:
          </p>
          <ol>
            <li class="no-test-needed">
              <p>
                Let <var>channel</var> be the {{RTCDataChannel}} object for
                which the user agent has received a message.
              </p>
            </li>
            <li class="no-test-needed">
              <p>
                Let <var>connection</var> be the {{RTCPeerConnection}} object
                associated with <var>channel</var>.
              </p>
            </li>
            <li>
              <p>
                If <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} is not
                {{RTCDataChannelState/"open"}}, abort these steps and discard
                <var>rawData</var>.
              </p>
            </li>
            <li data-tests=
            "RTCDataChannel-bufferedAmount.html,RTCDataChannel-send.html">
              <p>
                Execute the sub step by switching on <var>type</var> and
                <var>channel</var>.{{RTCDataChannel/binaryType}}:
              </p>
              <ul>
                <li>
                  <p>
                    If <var>type</var> indicates that <var>rawData</var> is a
                    <code class="param">string</code>:
                  </p>
                  <p>
                    Let <var>data</var> be a <span class=
                    "idlMemberType">DOMString</span> that represents the result
                    of decoding <var>rawData</var> as UTF-8.
                  </p>
                </li>
                <li>
                  <p>
                    If <var>type</var> indicates that <var>rawData</var> is
                    binary and {{RTCDataChannel/binaryType}} is <code class=
                    "html">"blob"</code>:
                  </p>
                  <p>
                    Let <var>data</var> be a new {{Blob}} object containing
                    <var>rawData</var> as its raw data source.
                  </p>
                </li>
                <li>
                  <p>
                    If <var>type</var> indicates that <var>rawData</var> is
                    binary and {{RTCDataChannel/binaryType}} is <code class=
                    "html">"arraybuffer"</code>:
                  </p>
                  <p>
                    Let <var>data</var> be a new {{ArrayBuffer}} object
                    containing <var>rawData</var> as its raw data source.
                  </p>
                </li>
              </ul>
            </li>
            <li data-tests=
            "RTCDataChannel-send.html">
              <p>
                [= Fire an event =] named {{RTCDataChannel/message}} using the
                {{MessageEvent}} interface with its <code class=
                "html">origin</code> attribute initialized to the
                <a>serialization of an origin</a> of
                <var>connection</var>.{{RTCPeerConnection/[[DocumentOrigin]]}}, and the
                <code class="html">data</code> attribute initialized to
                <var>data</var> at <var>channel</var>.
              </p>
            </li>
          </ol>
        </section>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCDataChannel : EventTarget {
  readonly attribute USVString label;
  readonly attribute boolean ordered;
  readonly attribute unsigned short? maxPacketLifeTime;
  readonly attribute unsigned short? maxRetransmits;
  readonly attribute USVString protocol;
  readonly attribute boolean negotiated;
  readonly attribute unsigned short? id;
  readonly attribute RTCDataChannelState readyState;
  readonly attribute unsigned long bufferedAmount;
  [EnforceRange] attribute unsigned long bufferedAmountLowThreshold;
  attribute EventHandler onopen;
  attribute EventHandler onbufferedamountlow;
  attribute EventHandler onerror;
  attribute EventHandler onclosing;
  attribute EventHandler onclose;
  undefined close();
  attribute EventHandler onmessage;
  attribute BinaryType binaryType;
  undefined send(USVString data);
  undefined send(Blob data);
  undefined send(ArrayBuffer data);
  undefined send(ArrayBufferView data);
};</pre>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCDataChannel" data-dfn-for="RTCDataChannel"
            class="attributes">
              <dt data-tests="RTCPeerConnection-createDataChannel.html">
                <dfn id="dom-datachannel-label">label</dfn> of type
                <span class="idlAttrType">USVString</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{label}} attribute represents a label that can be used
                  to distinguish this {{RTCDataChannel}} object from other
                  {{RTCDataChannel}} objects. Scripts are allowed to create
                  multiple {{RTCDataChannel}} objects with the same label. On
                  getting, the attribute MUST return the value of the
                  {{RTCDataChannel/[[DataChannelLabel]]}} slot.
                </p>
              </dd>
              <dt data-tests="RTCPeerConnection-createDataChannel.html">
                <dfn id="dom-datachannel-ordered">ordered</dfn> of type
                <span class="idlAttrType">boolean</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{ordered}} attribute returns true if the
                  {{RTCDataChannel}} is ordered, and false if out of order
                  delivery is allowed. On getting, the attribute MUST return
                  the value of the {{RTCDataChannel/[[Ordered]]}} slot.
                </p>
              </dd>
              <dt data-tests="RTCPeerConnection-createDataChannel.html">
                <dfn id=
                "dom-datachannel-maxpacketlifetime">maxPacketLifeTime</dfn> of
                type <span class="idlAttrType">unsigned short</span>, readonly,
                nullable
              </dt>
              <dd>
                <p>
                  The {{maxPacketLifeTime}} attribute returns the length of the
                  time window (in milliseconds) during which transmissions and
                  retransmissions may occur in unreliable mode. On getting, the
                  attribute MUST return the value of the
                  {{RTCDataChannel/[[MaxPacketLifeTime]]}} slot.
                </p>
              </dd>
              <dt data-tests="RTCPeerConnection-createDataChannel.html">
                <dfn id="dom-datachannel-maxretransmits">maxRetransmits</dfn>
                of type <span class="idlAttrType">unsigned short</span>,
                readonly, nullable
              </dt>
              <dd>
                <p>
                  The {{maxRetransmits}} attribute returns the maximum number
                  of retransmissions that are attempted in unreliable mode. On
                  getting, the attribute MUST return the value of the
                  {{RTCDataChannel/[[MaxRetransmits]]}} slot.
                </p>
              </dd>
              <dt data-tests="RTCPeerConnection-createDataChannel.html">
                <dfn id="dom-datachannel-protocol">protocol</dfn> of type
                <span class="idlAttrType">USVString</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{protocol}} attribute returns the name of the
                  sub-protocol used with this {{RTCDataChannel}}. On getting,
                  the attribute MUST return the value of the
                  {{RTCDataChannel/[[DataChannelProtocol]]}} slot.
                </p>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-createDataChannel.html,RTCPeerConnection-ondatachannel.html">
                <dfn id="dom-datachannel-negotiated">negotiated</dfn> of type
                <span class="idlAttrType">boolean</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{negotiated}} attribute returns true if this
                  {{RTCDataChannel}} was negotiated by the application, or
                  false otherwise. On getting, the attribute MUST return the
                  value of the {{RTCDataChannel/[[Negotiated]]}} slot.
                </p>
              </dd>
              <dt data-tests=
              "RTCDataChannel-id.html, RTCPeerConnection-createDataChannel.html">
                <dfn data-idl="">id</dfn> of type <span class=
                "idlAttrType">unsigned short</span>, readonly, nullable
              </dt>
              <dd>
                <p>
                  The {{id}} attribute returns the ID for this
                  {{RTCDataChannel}}. The value is initially null, which is
                  what will be returned if the ID was not provided at channel
                  creation time, and the DTLS role of the SCTP transport has
                  not yet been negotiated. Otherwise, it will return the ID
                  that was either selected by the script or generated by the
                  user agent according to [[RFC8832]]. After the
                  ID is set to a non-null value, it will not change. On
                  getting, the attribute MUST return the value of the
                  {{RTCDataChannel/[[DataChannelId]]}} slot.
                </p>
              </dd>
              <dt data-tests=
              "RTCDataChannel-send.html, RTCPeerConnection-createDataChannel.html">
                <dfn id="dom-datachannel-readystate">readyState</dfn> of type
                <span class="idlAttrType">{{RTCDataChannelState}}</span>,
                readonly
              </dt>
              <dd>
                <p>
                  The {{readyState}} attribute represents the state of the
                  {{RTCDataChannel}} object. On getting, the attribute MUST
                  return the value of the {{RTCDataChannel/[[ReadyState]]}} slot.
                </p>
              </dd>
              <dt>
                <dfn id="dom-datachannel-bufferedamount">bufferedAmount</dfn>
                of type <span class="idlAttrType">unsigned long</span>,
                readonly
              </dt>
              <dd>
                <p data-tests="RTCDataChannel-bufferedAmount.html">
                  The {{bufferedAmount}} attribute MUST, on getting, return the
                  value of the {{RTCDataChannel/[[BufferedAmount]]}} slot. The attribute
                  exposes the number of bytes of application data (UTF-8 text
                  and binary data) that have been queued using
                  {{RTCDataChannel/send()}}. Even though the data transmission
                  can occur in parallel, the returned value MUST NOT be
                  decreased before the current task yielded back to the event
                  loop to prevent race conditions. The value does not include
                  framing overhead incurred by the protocol, or buffering done
                  by the operating system or network hardware. The value of the
                  {{RTCDataChannel/[[BufferedAmount]]}} slot will only increase with each
                  call to the {{RTCDataChannel/send()}} method as long as the
                  {{RTCDataChannel/[[ReadyState]]}} slot is
                  {{RTCDataChannelState/"open"}}; however, the slot does not
                  reset to zero once the channel closes. When the [= underlying
                  data transport =] sends data from its queue, the user agent
                  MUST queue a task that reduces {{RTCDataChannel/[[BufferedAmount]]}}
                  with the number of bytes that was sent.
                </p>
              </dd>
              <dt data-tests="RTCDataChannel-bufferedAmount.html">
                <dfn data-idl="">bufferedAmountLowThreshold</dfn> of type
                <span class="idlAttrType">unsigned long</span>
              </dt>
              <dd>
                <p>
                  The {{bufferedAmountLowThreshold}} attribute sets the
                  threshold at which the {{RTCDataChannel/bufferedAmount}} is
                  considered to be low. When the
                  {{RTCDataChannel/bufferedAmount}} decreases from above this
                  threshold to equal or below it, the {{bufferedamountlow}}
                  event fires. The
                  {{RTCDataChannel/bufferedAmountLowThreshold}} is initially
                  zero on each new {{RTCDataChannel}}, but the application may
                  change its value at any time.
                </p>
              </dd>
              <dt>
                <dfn data-idl="">onopen</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd>
                The event type of this event handler is {{RTCDataChannel/open}}.
              </dd>
              <dt data-tests="RTCDataChannel-bufferedAmount.html">
                <dfn data-idl="">onbufferedamountlow</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd>
                The event type of this event handler is {{bufferedamountlow}}.
              </dd>
              <dt>
                <dfn data-idl="">onerror</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd>
                <p>
                  The event type of this event handler is {{RTCErrorEvent}}.
                  {{RTCError/errorDetail}} contains "sctp-failure",
                  {{RTCError/sctpCauseCode}} contains the SCTP Cause Code
                  value, and {{DOMException/message}} contains the SCTP
                  Cause-Specific-Information, possibly with additional text.
                </p>
              </dd>
              <dt>
                <dfn data-idl="">onclosing</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd>
                <p>
                  The event type of this event handler is {{RTCDataChannel/closing}}.
                </p>
              </dd>
              <dt>
                <dfn data-idl="">onclose</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd data-link-for="">
                <p>
                  The event type of this event handler is <a data-link-for=RTCDataChannel data-link-type=event>close</a>.
                </p>
              </dd>
              <dt data-tests=
              "RTCDataChannel-send.html">
                <dfn data-idl="">onmessage</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd>
                <p>
                  The event type of this event handler is {{RTCDataChannel/message}}.
                </p>
              </dd>
              <dt data-tests="RTCDataChannel-send.html">
                <dfn id="dom-datachannel-binarytype">binaryType</dfn> of type
                <span class="idlAttrType">BinaryType</span>
              </dt>
              <dd>
                <p>
                  The {{binaryType}} attribute MUST, on getting, return the
                  value to which it was last set. On setting, if the new value
                  is either the string <code class="html">"blob"</code> or the
                  string <code class="html">"arraybuffer"</code>, then set the
                  IDL attribute to this new value. Otherwise, [=
                  exception/throw =] a {{SyntaxError}}. <span data-tests=
                  "RTCPeerConnection-createDataChannel.html">When an
                  {{RTCDataChannel}} object is created, the
                  {{RTCDataChannel/binaryType}} attribute MUST be initialized
                  to the string <code class="html">"blob"</code>.</span>
                </p>
                <p>
                  This attribute controls how binary data is exposed to
                  scripts. See Web Socket's {{WebSocket/binaryType}}.
                </p>
              </dd>
            </dl>
          </section>
          <section>
            <h2>
              Methods
            </h2>
            <dl data-link-for="RTCDataChannel" data-dfn-for="RTCDataChannel"
            class="methods">
              <dt>
                <dfn data-idl>close()</dfn>
              </dt>
              <dd>
                <p>
                  Closes the {{RTCDataChannel}}. It may be called regardless of
                  whether the {{RTCDataChannel}} object was created by this
                  peer or the remote peer.
                </p>
                <p>
                  When the {{close}} method is called, the user agent MUST run
                  the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>channel</var> be the {{RTCDataChannel}} object
                      which is about to be closed.
                    </p>
                  </li>
                  <li>
                    <p>
                      If <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} is
                      {{RTCDataChannelState/"closing"}} or
                      {{RTCDataChannelState/"closed"}}, then abort these steps.
                    </p>
                  </li>
                  <li>
                    <p>
                      Set <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} to
                      {{RTCDataChannelState/"closing"}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      If the [= closing procedure =] has not started yet, start
                      it.
                    </p>
                  </li>
                </ol>
              </dd>
              <dt data-tests="RTCDataChannel-send.html">
                <dfn data-idl="">send</dfn>
              </dt>
              <dd>
                <p>
                  Run the steps described by the [= send() algorithm =] with
                  argument type <code class="param">string</code> object.
                </p>
              </dd>
              <dt data-tests="RTCDataChannel-send.html">
                <dfn data-lt="send!overload-1" data-lt-nodefault=
                "true">send</dfn>
              </dt>
              <dd>
                <p>
                  Run the steps described by the [= send() algorithm =] with
                  argument type {{Blob}} object.
                </p>
              </dd>
              <dt data-tests="RTCDataChannel-send.html">
                <dfn data-lt="send!overload-2" data-lt-nodefault=
                "true">send</dfn>
              </dt>
              <dd>
                <p>
                  Run the steps described by the [= send() algorithm =] with
                  argument type {{ArrayBuffer}} object.
                </p>
              </dd>
              <dt data-tests="RTCDataChannel-send.html">
                <dfn data-lt="send!overload-3" data-lt-nodefault=
                "true">send</dfn>
              </dt>
              <dd>
                <p>
                  Run the steps described by the [= send() algorithm =] with
                  argument type {{ArrayBufferView}} object.
                </p>
              </dd>
            </dl>
            <p>
              The <code class="overload">send()</code> method is overloaded to
              handle different data argument types. When any version of the
              method is called, the user agent MUST <dfn id="datachannel-send"
              data-lt="send() algorithm" data-lt-nodefault="">run the following
              steps</dfn>:
            </p>
            <ol>
              <li class="no-test-needed">
                <p>
                  Let <var>channel</var> be the {{RTCDataChannel}} object on
                  which data is to be sent.
                </p>
              </li>
              <li data-tests="RTCDataChannel-send.html">
                <p>
                  If <var>channel</var>.{{RTCDataChannel/[[ReadyState]]}} is not
                  {{RTCDataChannelState/"open"}}, [= exception/throw =] an
                  {{InvalidStateError}}.
                </p>
              </li>
              <li>
                <p>
                  Execute the sub step that corresponds to the type of the
                  methods argument:
                </p>
                <ul>
                  <li>
                    <p>
                      <code class="param">string</code> object:
                    </p>
                    <p>
                      Let <var>data</var> be a byte buffer that represents the
                      result of encoding the method's argument as UTF-8.
                    </p>
                  </li>
                  <li>
                    <p>
                      {{Blob}} object:
                    </p>
                    <p>
                      Let <var>data</var> be the raw data represented by the
                      {{Blob}} object.
                    </p>
                    <div class="note" data-tests=
                    "RTCDataChannel-send-blob-order.html">
                      Although the actual retrieval of <var>data</var> from a
                      {{Blob}} object can happen asynchronously, the user agent
                      will make sure to queue the data on the
                      <var>channel</var>'s [= underlying data transport =] in
                      the same order as the send method is called. The byte
                      size of <var>data</var> needs to be known synchronously.
                    </div>
                  </li>
                  <li>
                    <p>
                      {{ArrayBuffer}} object:
                    </p>
                    <p>
                      Let <var>data</var> be the data stored in the buffer
                      described by the {{ArrayBuffer}} object.
                    </p>
                  </li>
                  <li>
                    <p>
                      {{ArrayBufferView}} object:
                    </p>
                    <p>
                      Let <var>data</var> be the data stored in the section of
                      the buffer described by the {{ArrayBuffer}} object that
                      the {{ArrayBufferView}} object references.
                    </p>
                  </li>
                </ul>
                <div class="note">
                  Any data argument type this method has not been overloaded
                  with will result in a {{TypeError}}. This includes
                  <code>null</code> and <code>undefined</code>.
                </div>
              </li>
              <li data-tests="RTCDataChannel-send.html">
                <p>
                  If the byte size of <var>data</var> exceeds the value of
                  {{RTCSctpTransport/maxMessageSize}} on <var>channel</var>'s
                  associated {{RTCSctpTransport}}, [= exception/throw =] a
                  {{TypeError}}.
                </p>
              </li>
              <li data-tests="RTCDataChannel-send.html">
                <p>
                  Queue <var>data</var> for transmission on
                  <var>channel</var>'s [= underlying data transport =]. If
                  queuing <var>data</var> is not possible because not enough
                  buffer space is available, [= exception/throw =] an
                  {{OperationError}}.
                </p>
                <div class="note">
                  The actual transmission of data occurs in parallel. If
                  sending data leads to an SCTP-level error, the application
                  will be notified asynchronously through
                  {{RTCDataChannel/onerror}}.
                </div>
              </li>
              <li data-tests="RTCDataChannel-bufferedAmount.html">
                <p>
                  Increase the value of the {{RTCDataChannel/[[BufferedAmount]]}} slot by
                  the byte size of <var>data</var>.
                </p>
              </li>
            </ol>
          </section>
        </div>
        <div>
          <pre class="idl">dictionary RTCDataChannelInit {
  boolean ordered = true;
  [EnforceRange] unsigned short maxPacketLifeTime;
  [EnforceRange] unsigned short maxRetransmits;
  USVString protocol = "";
  boolean negotiated = false;
  [EnforceRange] unsigned short id;
};</pre>
          <section>
            <h2>
              Dictionary <dfn>RTCDataChannelInit</dfn> Members
            </h2>
            <dl data-link-for="RTCDataChannelInit" data-dfn-for=
            "RTCDataChannelInit" class="dictionary-members">
              <dt data-tests="RTCPeerConnection-createDataChannel.html">
                <dfn data-idl="">ordered</dfn> of type <span class=
                "idlMemberType">boolean</span>, defaulting to <code>true</code>
              </dt>
              <dd>
                <p>
                  If set to false, data is allowed to be delivered out of
                  order. The default value of true, guarantees that data will
                  be delivered in order.
                </p>
              </dd>
              <dt data-tests="RTCPeerConnection-createDataChannel.html">
                <dfn data-idl="">maxPacketLifeTime</dfn> of type <span class=
                "idlMemberType">unsigned short</span>
              </dt>
              <dd>
                <p>
                  Limits the time (in milliseconds) during which the channel
                  will transmit or retransmit data if not acknowledged. This
                  value may be clamped if it exceeds the maximum value
                  supported by the user agent.
                </p>
              </dd>
              <dt data-tests="RTCPeerConnection-createDataChannel.html">
                <dfn data-idl="">maxRetransmits</dfn> of type <span class=
                "idlMemberType">unsigned short</span>
              </dt>
              <dd>
                <p>
                  Limits the number of times a channel will retransmit data if
                  not successfully delivered. This value may be clamped if it
                  exceeds the maximum value supported by the user agent.
                </p>
              </dd>
              <dt data-tests="RTCPeerConnection-createDataChannel.html">
                <dfn data-idl="">protocol</dfn> of type <span class=
                "idlMemberType">USVString</span>, defaulting to <code>""</code>
              </dt>
              <dd>
                <p>
                  Subprotocol name used for this channel.
                </p>
              </dd>
              <dt data-tests=
              "RTCPeerConnection-createDataChannel.html,RTCPeerConnection-ondatachannel.html">
                <dfn data-idl="">negotiated</dfn> of type <span class=
                "idlMemberType">boolean</span>, defaulting to
                <code>false</code>
              </dt>
              <dd>
                <p>
                  The default value of false tells the user agent to announce
                  the channel in-band and instruct the other peer to dispatch a
                  corresponding {{RTCDataChannel}} object. If set to true, it
                  is up to the application to negotiate the channel and create
                  an {{RTCDataChannel}} object with the same
                  {{RTCDataChannel/id}} at the other peer.
                </p>
                <div class="note">
                  If set to true, the application must also take care to not
                  send a message until the other peer has created a data
                  channel to receive it. Receiving a message on an SCTP stream
                  with no associated data channel is undefined behavior, and it
                  may be silently dropped. This will not be possible as long as
                  both endpoints create their data channel before the first
                  offer/answer exchange is complete.
                </div>
              </dd>
              <dt data-tests="RTCPeerConnection-createDataChannel.html">
                <dfn data-idl="">id</dfn> of type <span class=
                "idlMemberType">unsigned short</span>
              </dt>
              <dd>
                <p>
                  Sets the channel ID when {{RTCDataChannelInit/negotiated}} is
                  true. Ignored when {{RTCDataChannelInit/negotiated}} is
                  false.
                </p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">enum RTCDataChannelState {
  "connecting",
  "open",
  "closing",
  "closed"
};</pre>
          <table class="simple">
            <thead>
              <tr>
                <th colspan="2">
                  <dfn>RTCDataChannelState</dfn> Enumeration description
                </th>
              </tr>
            </thead>
            <tbody data-link-for="RTCDataChannelState" data-dfn-for=
            "RTCDataChannelState">
              <tr>
                <td data-tests="RTCPeerConnection-createDataChannel.html">
                  <dfn data-idl="">connecting</dfn>
                </td>
                <td>
                  <p>
                    The user agent is attempting to establish the [= underlying
                    data transport =]. This is the initial state of an
                    {{RTCDataChannel}} object, whether created with
                    {{RTCPeerConnection/createDataChannel}}, or dispatched as a
                    part of an {{RTCDataChannelEvent}}.
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <dfn data-idl="">open</dfn>
                </td>
                <td>
                  <p>
                    The [= underlying data transport =] is established and
                    communication is possible.
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <dfn data-idl="">closing</dfn>
                </td>
                <td>
                  <p>
                    The [= closing procedure | procedure =] to close down the
                    [= underlying data transport =] has started.
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <dfn data-idl="">closed</dfn>
                </td>
                <td>
                  <p>
                    The [= underlying data transport =] has been {{closed}} or
                    could not be established.
                  </p>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section>
        <h3>
          <dfn>RTCDataChannelEvent</dfn>
        </h3>
        <p data-tests="RTCPeerConnection-ondatachannel.html">
          The {{RTCPeerConnection/datachannel}} event uses the {{RTCDataChannelEvent}} interface.
        </p>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCDataChannelEvent : Event {
  constructor(DOMString type, RTCDataChannelEventInit eventInitDict);
  readonly attribute RTCDataChannel channel;
};</pre>
          <section data-tests="RTCDataChannelEvent-constructor.html">
            <h2>
              Constructors
            </h2>
            <dl data-link-for="RTCDataChannelEvent" data-dfn-for=
            "RTCDataChannelEvent" class="constructors">
              <dt data-tests="idlharness.https.window.js">
                <dfn>RTCDataChannelEvent.constructor()</dfn>
              </dt>
              <dd></dd>
            </dl>
          </section>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCDataChannelEvent" data-dfn-for=
            "RTCDataChannelEvent" class="attributes">
              <dt>
                <dfn id="dom-datachannelevent-channel">channel</dfn> of type
                <span class="idlAttrType">{{RTCDataChannel}}</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{channel}} attribute represents the {{RTCDataChannel}}
                  object associated with the event.
                </p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">dictionary RTCDataChannelEventInit : EventInit {
  required RTCDataChannel channel;
};</pre>
          <section>
            <h2>
              Dictionary <dfn>RTCDataChannelEventInit</dfn> Members
            </h2>
            <dl data-link-for="RTCDataChannelEventInit" data-dfn-for=
            "RTCDataChannelEventInit" class="dictionary-members">
              <dt>
                <dfn data-idl="">channel</dfn> of type <span class=
                "idlMemberType">{{RTCDataChannel}}</span>, required
              </dt>
              <dd>
                <p>
                  The {{RTCDataChannel}} object to be announced by the event.
                </p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
      <section>
        <h3>
          Garbage Collection
        </h3>
        <p class="untestable">
          An {{RTCDataChannel}} object MUST not be garbage collected if its
        </p>
        <ul>
          <li>
            <p>
              {{RTCDataChannel/[[ReadyState]]}} slot is
              {{RTCDataChannelState/"connecting"}} and at least one event
              listener is registered for {{RTCDataChannel/open}}
              events, {{RTCDataChannel/message}} events,
              {{RTCDataChannel/error}} events, {{RTCDataChannel/closing}}
              events, or <a data-link-for=RTCDataChannel data-link-type=event>close</a> events.
            </p>
          </li>
          <li>
            <p>
              {{RTCDataChannel/[[ReadyState]]}} slot is {{RTCDataChannelState/"open"}} and
              at least one event listener is registered for
              {{RTCDataChannel/message}} events, {{RTCDataChannel/error}}
              events, {{RTCDataChannel/closing}} events, or
              <a class=todo data-link-for=RTCDataChannel data-link-type=event>close</a> events.
            </p>
          </li>
          <li>
            <p>
              {{RTCDataChannel/[[ReadyState]]}} slot is {{RTCDataChannelState/"closing"}}
              and at least one event listener is registered for
              {{RTCDataChannel/error}} events, or <a class=todo data-link-for=RTCDataChannel data-link-type=event>close</a>
              events.
            </p>
          </li>
          <li>
            <p>
              [= underlying data transport =] is established and data is queued
              to be transmitted.
            </p>
          </li>
        </ul>
      </section>
    </section>
    <section>
      <h3>
        Peer-to-peer DTMF
      </h3>
      <p>
        This section describes an interface on {{RTCRtpSender}} to send DTMF
        (phone keypad) values across an {{RTCPeerConnection}}. Details of how
        DTMF is sent to the other peer are described in [[RFC7874]].
      </p>
      <section>
        <h3>
          RTCRtpSender Interface Extensions
        </h3>
        <p>
          The Peer-to-peer DTMF API extends the {{RTCRtpSender}} interface as
          described below.
        </p>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">
          partial interface RTCRtpSender {
  readonly attribute RTCDTMFSender? dtmf;
};</pre>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCRtpSender" data-dfn-for="RTCRtpSender" class=
            "attributes">
              <dt>
                <dfn>dtmf</dfn> of type <span class=
                "idlAttrType">{{RTCDTMFSender}}</span>, readonly, nullable
              </dt>
              <dd class="needs-tests">
                <p>
                  On getting, the {{dtmf}} attribute returns the value of the
                  {{RTCRtpSender/[[Dtmf]]}} internal slot, which represents a
                  {{RTCDTMFSender}} which can be used to send DTMF, or
                  <code>null</code> if unset. The {{RTCRtpSender/[[Dtmf]]}} internal
                  slot is set when the kind of an {{RTCRtpSender}}'s
                  {{RTCRtpSender/[[SenderTrack]]}} is <code>"audio"</code>.
                </p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
      <section>
        <h4>
          <dfn>RTCDTMFSender</dfn>
        </h4>
        <p class="no-test-needed">
          To <dfn>create an RTCDTMFSender</dfn>, the user agent MUST run the
          following steps:
        </p>
        <ol class="no-test-needed">
          <li>
            <p>
              Let <var>dtmf</var> be a newly created {{RTCDTMFSender}} object.
            </p>
          </li>
          <li>
            <p>
              Let <var>dtmf</var> have a <dfn data-dfn-for="RTCDTMFSender">[[\Duration]]</dfn> internal
              slot.
            </p>
          </li>
          <li>
            <p>
              Let <var>dtmf</var> have a <dfn data-dfn-for="RTCDTMFSender">[[\InterToneGap]]</dfn> internal
              slot.
            </p>
          </li>
          <li>
            <p>
              Let <var>dtmf</var> have a <dfn data-dfn-for="RTCDTMFSender">[[\ToneBuffer]]</dfn> internal
              slot.
            </p>
          </li>
        </ol>
        <div>
          <pre class="idl" data-tests="">[Exposed=Window]
interface RTCDTMFSender : EventTarget {
  undefined insertDTMF(DOMString tones, optional unsigned long duration = 100, optional unsigned long interToneGap = 70);
  attribute EventHandler ontonechange;
  readonly attribute boolean canInsertDTMF;
  readonly attribute DOMString toneBuffer;
};</pre>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCDTMFSender" data-dfn-for="RTCDTMFSender"
            class="attributes">
              <dt data-tests="RTCDTMFSender-ontonechange-long.https.html">
                <dfn data-idl="">ontonechange</dfn> of type <span class=
                "idlAttrType">EventHandler</span>
              </dt>
              <dd>
                <p>
                  The event type of this event handler is {{RTCDTMFSender/tonechange}}.
                </p>
              </dd>
              <dt>
                <dfn data-idl="">canInsertDTMF</dfn> of type <span class=
                "idlAttrType">boolean</span>, readonly
              </dt>
              <dd>
                <p>
                  Whether the {{RTCDTMFSender}} <var>dtmfSender</var> is
                  capable of sending DTMF. On getting, the user agent MUST
                  return the result of running [= determine if DTMF can be sent
                  =] for <var>dtmfSender</var>.
                </p>
              </dd>
              <dt>
                <dfn id="dom-RTCDTMFSender-tonebuffer">toneBuffer</dfn> of type
                <span class="idlAttrType">DOMString</span>, readonly
              </dt>
              <dd>
                <p>
                  The {{toneBuffer}} attribute MUST return a list of the tones
                  remaining to be played out. For the syntax, content, and
                  interpretation of this list, see {{insertDTMF}}.
                </p>
              </dd>
            </dl>
          </section>
          <section>
            <h2>
              Methods
            </h2>
            <dl data-link-for="RTCDTMFSender" data-dfn-for="RTCDTMFSender"
            class="methods">
              <dt>
                <dfn id="dom-RTCDTMFSender-insertDTMF">insertDTMF</dfn>
              </dt>
              <dd>
                <p>
                  An {{RTCDTMFSender}} object's {{insertDTMF}} method is used
                  to send DTMF tones.
                </p>
                <p data-tests="RTCDTMFSender-insertDTMF.https.html">
                  The tones parameter is treated as a series of characters. The
                  characters 0 through 9, A through D, #, and * generate the
                  associated DTMF tones. The characters a to d MUST be
                  normalized to uppercase on entry and are equivalent to A to
                  D. As noted in [[RTCWEB-AUDIO]] Section 3, support for the
                  characters 0 through 9, A through D, #, and * are required.
                  The character ',' MUST be supported, and indicates a delay of
                  2 seconds before processing the next character in the tones
                  parameter. All other characters (and only those other
                  characters) MUST be considered <dfn id=
                  "dtmf-unrecognized">unrecognized</dfn>.
                </p>
                <p id="clamped-duration" data-tests=
                "RTCDTMFSender-insertDTMF.https.html">
                  The duration parameter indicates the duration in ms to use
                  for each character passed in the tones parameters. The
                  duration cannot be more than 6000 ms or less than 40 ms. The
                  default duration is 100 ms for each tone.
                </p>
                <p>
                  The <var>interToneGap</var> parameter indicates the gap
                  between tones in ms. The user agent clamps it to at least 30
                  ms and at most 6000 ms. The default value is 70 ms.
                </p>
                <p>
                  The browser MAY increase the <var>duration</var> and
                  <var>interToneGap</var> times to cause the times that DTMF
                  start and stop to align with the boundaries of RTP packets
                  but it MUST not increase either of them by more than the
                  duration of a single RTP audio packet.
                </p>
                <p>
                  When the {{insertDTMF()}} method is invoked, the user agent
                  MUST run the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">Let <var>sender</var> be the
                  {{RTCRtpSender}} used to send DTMF.
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>transceiver</var> be the {{RTCRtpTransceiver}}
                      object associated with <var>sender</var>.
                    </p>
                  </li>
                  <li class="no-test-needed">Let <var>dtmf</var> be the
                  {{RTCDTMFSender}} associated with <var>sender</var>.
                  </li>
                  <li>If [= determine if DTMF can be sent =] for
                  <var>dtmf</var> returns <code>false</code>, [=
                  exception/throw =] an {{InvalidStateError}}.
                  </li>
                  <li class="no-test-needed">Let <var>tones</var> be the
                  method's first argument.
                  </li>
                  <li class="no-test-needed">Let <var>duration</var> be the
                  method's second argument.
                  </li>
                  <li class="no-test-needed">Let <var>interToneGap</var> be the
                  method's third argument.
                  </li>
                  <li data-tests="RTCDTMFSender-insertDTMF.https.html">If <var>
                    tones</var> contains any {{unrecognized}} characters, [=
                    exception/throw =] an {{InvalidCharacterError}}.
                  </li>
                  <li>Set the object's {{RTCDTMFSender/[[ToneBuffer]]}} slot to
                  <var>tones</var>.
                  </li>
                  <li>Set <var>dtmf</var>.{{RTCDTMFSender/[[Duration]]}} to the value of
                  <var>duration</var>.
                  </li>
                  <li>Set <var>dtmf</var>.{{RTCDTMFSender/[[InterToneGap]]}} to the value
                  of <var>interToneGap</var>.
                  </li>
                  <li data-tests=
                  "RTCDTMFSender-ontonechange-long.https.html,RTCDTMFSender-ontonechange.https.html">
                  If the value of <var>duration</var> is less than 40 ms, set
                  <var>dtmf</var>.{{RTCDTMFSender/[[Duration]]}} to 40 ms.
                  </li>
                  <li data-tests=
                  "RTCDTMFSender-ontonechange-long.https.html,RTCDTMFSender-ontonechange.https.html">
                  If the value of <var>duration</var> parameter is greater than
                  6000 ms, set <var>dtmf</var>.{{RTCDTMFSender/[[Duration]]}} to 6000 ms.
                  </li>
                  <li data-tests="RTCDTMFSender-ontonechange.https.html">If the
                  value of <var>interToneGap</var> is less than 30 ms, set
                  <var>dtmf</var>.{{RTCDTMFSender/[[InterToneGap]]}} to 30 ms.
                  </li>
                  <li data-tests=
                  "RTCDTMFSender-ontonechange-long.https.html,RTCDTMFSender-ontonechange.https.html">
                  If the value of <var>interToneGap</var> is greater than 6000
                  ms, set <var>dtmf</var>.{{RTCDTMFSender/[[InterToneGap]]}} to 6000 ms.
                  </li>
                  <li data-tests="RTCDTMFSender-ontonechange.https.html">If <a>
                    [[\ToneBuffer]]</a> slot is an empty string, abort these
                    steps.
                  </li>
                  <li data-tests="RTCDTMFSender-ontonechange.https.html">If a
                  <em>Playout task</em> is scheduled to be run, abort these
                  steps; otherwise queue a task that runs the following steps
                  (<em>Playout task</em>):
                    <ol>
                      <li>If
                      <var>transceiver</var>.{{RTCRtpTransceiver/[[CurrentDirection]]}} is
                      neither {{RTCRtpTransceiverDirection/"sendrecv"}} nor
                      {{RTCRtpTransceiverDirection/"sendonly"}}, abort these
                      steps.
                      </li>
                      <li>If the {{RTCDTMFSender/[[ToneBuffer]]}} slot contains the empty
                      string, [= fire an event =] named {{RTCDTMFSender/tonechange}} using
                      the {{RTCDTMFToneChangeEvent}} interface with the
                      {{RTCDTMFToneChangeEvent/tone}} attribute set to an empty
                      string at the {{RTCDTMFSender}} object and abort these
                      steps.
                      </li>
                      <li>Remove the first character from the
                      {{RTCDTMFSender/[[ToneBuffer]]}} slot and let that character be
                      <var>tone</var>.
                      </li>
                      <li>If <var>tone</var> is <code>","</code> delay sending
                      tones for <code>2000</code> ms on the associated RTP
                      media stream, and queue a task to be executed in
                      <code>2000</code> ms from now that runs the steps
                      labelled <em>Playout task</em>.
                      </li>
                      <li>If <var>tone</var> is not <code>","</code> start
                      playout of <var>tone</var> for {{RTCDTMFSender/[[Duration]]}} ms on
                      the associated RTP media stream, using the appropriate
                      codec, then queue a task to be executed in
                      {{RTCDTMFSender/[[Duration]]}} + {{RTCDTMFSender/[[InterToneGap]]}} ms from
                      now that runs the steps labelled <em>Playout task</em>.
                      </li>
                      <li>[= Fire an event =] named {{RTCDTMFSender/tonechange}} using the
                      {{RTCDTMFToneChangeEvent}} interface with the
                      {{RTCDTMFToneChangeEvent/tone}} attribute set to
                      <var>tone</var> at the {{RTCDTMFSender}} object.
                      </li>
                    </ol>
                  </li>
                </ol>
                <p>
                  Since {{insertDTMF}} replaces the tone buffer, in order to
                  add to the DTMF tones being played, it is necessary to call
                  {{insertDTMF}} with a string containing both the remaining
                  tones (stored in the {{RTCDTMFSender/[[ToneBuffer]]}} slot) and the new
                  tones appended together. Calling {{insertDTMF}} with an empty
                  tones parameter can be used to cancel all tones queued to
                  play after the currently playing tone.
                </p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
      <section>
        <h3>
          canInsertDTMF algorithm
        </h3>
        <p>
          To <dfn>determine if DTMF can be sent</dfn> for an {{RTCDTMFSender}}
          instance <var>dtmfSender</var>, the user agent MUST queue a task that
          runs the following steps:
        </p>
        <ol>
          <li class="no-test-needed">Let <var>sender</var> be the
          {{RTCRtpSender}} associated with <var>dtmfSender</var>.
          </li>
          <li class="no-test-needed">Let <var>transceiver</var> be the
          {{RTCRtpTransceiver}} associated with <var>sender</var>.
          </li>
          <li class="no-test-needed">Let <var>connection</var> be the
          {{RTCPeerConnection}} associated with <var>transceiver</var>.
          </li>
          <li>If <var>connection</var>'s {{RTCPeerConnectionState}} is not
          {{RTCPeerConnectionState/"connected"}} return <code>false</code>.
          </li>
          <li>If <var>sender</var>.{{RTCRtpSender/[[SenderTrack]]}} is <code>null</code>
          return <code>false</code>.
          </li>
          <li>If <var>transceiver</var>.{{RTCRtpTransceiver/[[CurrentDirection]]}} is neither
          {{RTCRtpTransceiverDirection/"sendrecv"}} nor
          {{RTCRtpTransceiverDirection/"sendonly"}} return <code>false</code>.
          </li>
          <li>If
          <var>sender</var>.{{RTCRtpSender/[[SendEncodings]]}}<code>[0]</code>.{{RTCRtpEncodingParameters/active}}
          is <code>false</code> return <code>false</code>.
          </li>
          <li>If no codec with mimetype <code class=
          "mime">"audio/telephone-event"</code> has been negotiated for sending
          with this <var>sender</var>, return <code>false</code>.
          </li>
          <li>Otherwise, return <code>true</code>.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          <dfn>RTCDTMFToneChangeEvent</dfn>
        </h3>
        <p>
          The {{RTCDTMFSender/tonechange}} event uses the {{RTCDTMFToneChangeEvent}}
          interface.
        </p>
        <div>
          <pre class="idl" data-tests="">[Exposed=Window]
interface RTCDTMFToneChangeEvent : Event {
  constructor(DOMString type, optional RTCDTMFToneChangeEventInit eventInitDict = {});
  readonly attribute DOMString tone;
};</pre>
          <section>
            <h2>
              Constructors
            </h2>
            <dl data-link-for="RTCDTMFToneChangeEvent" data-dfn-for=
            "RTCDTMFToneChangeEvent" class="constructors">
              <dt>
                <dfn>RTCDTMFToneChangeEvent.constructor()</dfn>
              </dt>
              <dd></dd>
            </dl>
          </section>
          <section>
            <h2>
              Attributes
            </h2>
            <dl data-link-for="RTCDTMFToneChangeEvent" data-dfn-for=
            "RTCDTMFToneChangeEvent" class="attributes">
              <dt class="needs-tests">
                <dfn data-idl="">tone</dfn> of type <span class=
                "idlAttrType">DOMString</span>, readonly
              </dt>
              <dd>
                <p class="needs-tests">
                  The {{tone}} attribute contains the character for the tone
                  (including <code>","</code>) that has just begun playout (see
                  {{RTCDTMFSender/insertDTMF}} ). If the value is the empty
                  string, it indicates that the {{RTCDTMFSender/[[ToneBuffer]]}} slot is
                  an empty string and that the previous tones have completed
                  playback.
                </p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl" data-cite="DOM">
          dictionary RTCDTMFToneChangeEventInit : EventInit {
  DOMString tone = "";
};</pre>
          <section>
            <h2>
              Dictionary <dfn>RTCDTMFToneChangeEventInit</dfn> Members
            </h2>
            <dl data-link-for="RTCDTMFToneChangeEventInit" data-dfn-for=
            "RTCDTMFToneChangeEventInit" class="dictionary-members">
              <dt>
                <dfn data-idl="">tone</dfn> of type <span class=
                "idlMemberType">DOMString</span>, defaulting to <code>""</code>
              </dt>
              <dd>
                <p class="needs-tests">
                  The {{tone}} attribute contains the character for the tone
                  (including <code>","</code>) that has just begun playout (see
                  {{RTCDTMFSender/insertDTMF}} ). If the value is the empty
                  string, it indicates that the {{RTCDTMFSender/[[ToneBuffer]]}} slot is
                  an empty string and that the previous tones have completed
                  playback.
                </p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
    </section>
    <section>
      <h2 id="sec.stats-model">
        Statistics Model
      </h2>
      <section>
        <h3>
          Introduction
        </h3>
        <p class="no-test-needed">
          The basic statistics model is that the browser maintains a set of
          statistics for [= monitored object =]s, in the form of [= stats
          object =]s.
        </p><!-- Non-normative description of normative steps. -->
        <p class="no-test-needed">
          A group of related objects may be referenced by a <dfn id=
          "stats-selector">selector</dfn>. The selector may, for example, be a
          {{MediaStreamTrack}}. For a track to be a valid selector, it MUST be
          a {{MediaStreamTrack}} that is sent or received by the
          {{RTCPeerConnection}} object on which the stats request was issued.
          The calling Web application provides the selector to the
          {{RTCPeerConnection/getStats()}} method and the browser emits (in the
          JavaScript) a set of statistics that are relevant to the selector,
          according to the [= stats selection algorithm =]. Note that that
          algorithm takes the sender or receiver of a selector.
        </p>
        <!-- Lifetime of stats objects need to be tested on a per-type basis. -->
        <p class="no-test-needed">
          The statistics returned in [= stats object =]s are designed in such a
          way that repeated queries can be linked by the {{RTCStats}}
          {{RTCStats/id}} dictionary member. Thus, a Web application can make
          measurements over a given time period by requesting measurements at
          the beginning and end of that period.
        </p>
        <p class="no-test-needed">
          With a few exceptions, [= monitored object =]s, once created, exist
          for the duration of their associated {{RTCPeerConnection}}. This
          ensures statistics from them are available in the result from
          {{RTCPeerConnection/getStats()}} even past the associated peer
          connection being {{RTCPeerConnection/close}}d.
        </p>
        <!-- Lifetime of stats objects need to be tested on a per-type basis. -->
        <p class="no-test-needed">
          Only a few monitored objects have <a data-cite=
          "!WEBRTC-STATS#lifetime-considerations-for-monitored-objects">shorter
          lifetimes</a>. Statistics from these objects are no longer available
          in subsequent getStats() results. The object descriptions in
          [[!WEBRTC-STATS]] describe when these monitored objects are deleted.
        </p>
      </section>
      <section>
        <h3>
          RTCPeerConnection Interface Extensions
        </h3>
        <p class="no-test-needed">
          The Statistics API extends the {{RTCPeerConnection}} interface as
          described below.
        </p>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">
          partial interface RTCPeerConnection {
  Promise&lt;RTCStatsReport&gt; getStats(optional MediaStreamTrack? selector = null);
};</pre>
          <section>
            <h2>
              Methods
            </h2>
            <dl data-link-for="RTCPeerConnection" data-dfn-for=
            "RTCPeerConnection" class="methods">
              <dt data-tests=
              "RTCPeerConnection-getStats.https.html,getstats.html">
                <dfn id=
                "widl-RTCPeerConnection-getStats-Promise-RTCStatsReport--MediaStreamTrack-selector">
                getStats</dfn>
              </dt>
              <dd>
                <!-- Non-normative description of normative steps. -->
                <p class="no-test-needed">
                  Gathers stats for the given [= selector =] and reports the
                  result asynchronously.
                </p>
                <p class="no-test-needed">
                  When the {{getStats()}} method is invoked, the user agent
                  MUST run the following steps:
                </p>
                <ol>
                  <li class="no-test-needed">
                    <p>
                      Let <var>selectorArg</var> be the method's first
                      argument.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>connection</var> be the {{RTCPeerConnection}}
                      object on which the method was invoked.
                    </p>
                  </li><!-- Test status for getStats(null) is covered in
                     [= stats selection algorithm =]. -->
                  <li class="no-test-needed">
                    <p>
                      If <var>selectorArg</var> is <code>null</code>, let
                      <var>selector</var> be <code>null</code>.
                    </p>
                  </li>
                  <li data-tests=
                  "RTCPeerConnection-getStats.https.html,RTCPeerConnection-track-stats.https.html">
                    <p>
                      If <var>selectorArg</var> is a {{MediaStreamTrack}} let
                      <var>selector</var> be an {{RTCRtpSender}} or
                      {{RTCRtpReceiver}} on <var>connection</var> which
                      {{RTCRtpSender/track}} attribute matches
                      <var>selectorArg</var>. If no such sender or receiver
                      exists, or if more than one sender or receiver fit this
                      criteria, return a promise [= rejected =] with a newly [=
                      exception/created =] {{InvalidAccessError}}.
                    </p>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Let <var>p</var> be a new promise.
                    </p>
                  </li>
                  <!-- See [= stats selection algorithm =] for test status. -->
                  <li class="no-test-needed">
                    <p>
                      Run the following steps in parallel:
                    </p>
                    <ol>
                      <li>
                        <p>
                          Gather the stats indicated by <var>selector</var>
                          according to the [= stats selection algorithm =].
                        </p>
                      </li>
                      <li>
                        <p>
                          [= Resolve =] <var>p</var> with the resulting
                          {{RTCStatsReport}} object, containing the gathered
                          stats.
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li class="no-test-needed">
                    <p>
                      Return <var>p</var>.
                    </p>
                  </li>
                </ol>
              </dd>
            </dl>
          </section>
        </div>
      </section>
      <section>
        <h3>
          <dfn>RTCStatsReport</dfn> Object
        </h3>
        <p class="no-test-needed">
          The {{RTCPeerConnection/getStats()}} method delivers a successful
          result in the form of an {{RTCStatsReport}} object. An
          {{RTCStatsReport}} object is a map between strings that identify the
          inspected objects ({{RTCStats/id}} attribute in {{RTCStats}}
          instances), and their corresponding {{RTCStats}}-derived
          dictionaries.
        </p>
        <p class="no-test-needed">
          An {{RTCStatsReport}} may be composed of several {{RTCStats}}-derived
          dictionaries, each reporting stats for one underlying object that the
          implementation thinks is relevant for the [= selector =]. One
          achieves the total for the [= selector =] by summing over all the
          stats of a certain type; for instance, if an {{RTCRtpSender}} uses
          multiple SSRCs to carry its track over the network, the
          {{RTCStatsReport}} may contain one {{RTCStats}}-derived dictionary
          per SSRC (which can be distinguished by the value of the
          {{RTCRtpStreamStats/ssrc}} stats attribute).
        </p>
        <div>
          <pre class="idl">[Exposed=Window]
interface RTCStatsReport {
  readonly maplike&lt;DOMString, object&gt;;
};</pre>
          <p class="no-test-needed">
            Use these to retrieve the various dictionaries descended from
            {{RTCStats}} that this stats report is composed of. The set of
            supported property names [[!WEBIDL]] is defined as the ids of all
            the {{RTCStats}}-derived dictionaries that have been generated for
            this stats report.
          </p>
        </div>
      </section>
      <section>
        <h3>
          <dfn>RTCStats</dfn> Dictionary
        </h3>
        <p class="no-test-needed">
          An {{RTCStats}} dictionary represents the [= stats object =]
          constructed by inspecting a specific [= monitored object =]. The
          {{RTCStats}} dictionary is a base type that specifies as set of
          default attributes, such as {{RTCStats/timestamp}} and
          {{RTCStats/type}}. Specific stats are added by extending the
          {{RTCStats}} dictionary.
        </p>
        <p class="no-test-needed">
          Note that while stats names are standardized, any given
          implementation may be using experimental values or values not yet
          known to the Web application. Thus, applications MUST be prepared to
          deal with unknown stats.
        </p>
        <!-- This is not testable in isolation, but should be covered by tests for
           specific metrics. -->
        <p class="untestable">
          Statistics need to be synchronized with each other in order to yield
          reasonable values in computation; for instance, if
          {{RTCSentRtpStreamStats/bytesSent}} and
          {{RTCSentRtpStreamStats/packetsSent}} are both reported, they both
          need to be reported over the same interval, so that "average packet
          size" can be computed as "bytes / packets" - if the intervals are
          different, this will yield errors. Thus implementations MUST return
          synchronized values for all stats in an {{RTCStats}}-derived
          dictionary.
        </p>
        <div>
          <pre class="idl" data-cite="HR-TIME">dictionary RTCStats {
  required DOMHighResTimeStamp timestamp;
  required RTCStatsType type;
  required DOMString id;
};</pre>
          <section>
            <h2>
              Dictionary {{RTCStats}} Members
            </h2>
            <dl data-link-for="RTCStats" data-dfn-for="RTCStats" class=
            "dictionary-members">
              <dt>
                <dfn data-idl="">timestamp</dfn> of type <span class=
                "idlMemberType">DOMHighResTimeStamp</span>
              </dt>
              <dd>
                <p data-tests="RTCPeerConnection-getStats.https.html">
                  The {{timestamp}}, of type {{DOMHighResTimeStamp}},
                  associated with this object. The time is relative to the UNIX
                  epoch (Jan 1, 1970, UTC). For statistics that came from a
                  remote source (e.g., from received RTCP packets),
                  {{timestamp}} represents the time at which the information
                  arrived at the local endpoint. The remote timestamp can be
                  found in an additional field in an {{RTCStats}}-derived
                  dictionary, if applicable.
                </p>
              </dd>
              <dt>
                <dfn data-idl="">type</dfn> of type <span class=
                "idlMemberType">{{RTCStatsType}}</span>
              </dt>
              <dd>
                <p class="no-test-needed">
                  The type of this object.
                </p>
                <!-- This is not testable in isolation, but is implicitly tested
                   when you test particular metrics. -->
                <p class="untestable">
                  The {{type}} attribute MUST be initialized to the name of the
                  most specific type this {{RTCStats}} dictionary represents.
                </p>
              </dd>
              <dt>
                <dfn data-idl="">id</dfn> of type <span class=
                "idlMemberType">DOMString</span>
              </dt>
              <dd>
                <!-- This is not testable in isolation, but should be tested on a
                   per-stats type basis, where the tests verify the lifetime of
                   the stats objects according to their definition. -->
                <p class="untestable">
                  A unique {{id}} that is associated with the object that was
                  inspected to produce this {{RTCStats}} object. Two
                  {{RTCStats}} objects, extracted from two different
                  {{RTCStatsReport}} objects, MUST have the same id if they
                  were produced by inspecting the same underlying object.
                </p>
                <p class="untestable">
                  Stats ids MUST NOT be predictable by an application. This
                  prevents applications from depending on a particular user
                  agent's way of generating ids, since this prevents an
                  application from getting stats objects by their id unless
                  they have already read the id of that specific stats object.
                </p>
                <p class="no-test-needed">
                  User agents are free to pick any format for the id as long as
                  it meets the requirements above.
                </p>
                <p class="note">
                  A user agent can turn a predictably generated string into an
                  unpredictable string using a hash function, as long as it
                  uses a salt that is unique to the peer connection. This
                  allows an implementation to have predictable ids internally,
                  which may make it easier to guarantee that stats objects have
                  stable ids across getStats() calls.
                </p>
              </dd>
            </dl>
          </section>
        </div>
        <p>
          The set of valid values for {{RTCStatsType}}, and the dictionaries
          derived from RTCStats that they indicate, are documented in
          [[!WEBRTC-STATS]].
        </p>
      </section>
      <section>
        <h3>
          The stats selection algorithm
        </h3>
        <p>
          The <dfn>stats selection algorithm</dfn> is as follows:
        </p>
        <ol>
          <li class="no-test-needed">Let <var>result</var> be an empty
          {{RTCStatsReport}}.
          </li>
          <li data-tests="RTCPeerConnection-getStats.https.html">If
          <var>selector</var> is <code>null</code>,
          gather stats for the whole <var>connection</var>, add them to
          <var>result</var>, return <var>result</var>, and abort these steps.
          </li>
          <li data-tests="RTCRtpSender-getStats.https.html">
          If <var>selector</var> is an {{RTCRtpSender}}, gather stats for and
          add the following objects to <var>result</var>:
            <ul>
              <li>All {{RTCOutboundRtpStreamStats}} objects representing RTP
              streams being sent by <var>selector</var>.
              </li>
              <li>All stats objects referenced directly or indirectly by the
              {{RTCOutboundRtpStreamStats}} objects added.
              </li>
            </ul>
          </li>
          <li data-tests="RTCRtpReceiver-getStats.https.html">
          If <var>selector</var> is an {{RTCRtpReceiver}}, gather stats for and
          add the following objects to <var>result</var>:
            <ul>
              <li>All {{RTCInboundRtpStreamStats}} objects representing RTP
              streams being received by <var>selector</var>.
              </li>
              <li>All stats objects referenced directly or indirectly by the
              {{RTCInboundRtpStreamStats}} added.
              </li>
            </ul>
          </li>
          <li class="no-test-needed">Return <var>result</var>.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          Mandatory To Implement Stats
        </h3>
        <p class="no-test-needed">
          The stats listed in [[WEBRTC-STATS]] are intended to cover a wide
          range of use cases. Not all of them have to be implemented by every
          WebRTC implementation.
        </p><!-- See tests on a per-stats type basis. -->
        <p class="no-test-needed">
          An implementation MUST support generating statistics of the following
          {{RTCStats/type}}s when the corresponding objects exist on a
          {{RTCPeerConnection}}, with the fields that are listed when they are
          valid for that object in addition to the generic fields defined in
          the {{RTCStats}} dictionary:
        </p>
        <table class="simple">
          <thead>
            <tr>
              <th>
                {{RTCStatsType}}
              </th>
              <th>
                Dictionary
              </th>
              <th>
                Fields
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th class="row">
                {{RTCStatsType/"codec"}}
              </th>
              <td>
                {{RTCCodecStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCCodecStats/payloadType}}, {{RTCCodecStats/codecType}},
                {{RTCCodecStats/mimeType}}, {{RTCCodecStats/clockRate}},
                {{RTCCodecStats/channels}}, {{RTCCodecStats/sdpFmtpLine}}
              </td>
            </tr>
            <tr>
              <th rowspan="3" class="row">
                {{RTCStatsType/"inbound-rtp"}}
              </th>
              <td>
                {{RTCRtpStreamStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCRtpStreamStats/ssrc}}, {{RTCRtpStreamStats/kind}},
                {{RTCRtpStreamStats/transportId}},
                {{RTCRtpStreamStats/codecId}}
              </td>
            </tr>
            <tr>
              <td>
                {{RTCReceivedRtpStreamStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCRtpReceiver-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCReceivedRtpStreamStats/packetsReceived}},
                {{RTCReceivedRtpStreamStats/packetsLost}},
                {{RTCReceivedRtpStreamStats/jitter}},
                {{RTCReceivedRtpStreamStats/packetsDiscarded}},
                {{RTCReceivedRtpStreamStats/framesDropped}}
              </td>
            </tr>
            <tr>
              <td>
                {{RTCInboundRtpStreamStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-track-stats.https.html,RTCRtpReceiver-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCInboundRtpStreamStats/receiverId}},
                {{RTCInboundRtpStreamStats/remoteId}},
                {{RTCInboundRtpStreamStats/framesDecoded}},
                {{RTCInboundRtpStreamStats/nackCount}},
                {{RTCInboundRtpStreamStats/framesReceived}},
                {{RTCInboundRtpStreamStats/bytesReceived}},
                {{RTCInboundRtpStreamStats/totalAudioEnergy}},
                {{RTCInboundRtpStreamStats/totalSamplesDuration}}
              </td>
            </tr>
            <tr>
              <th rowspan="3" class="row">
                {{RTCStatsType/"outbound-rtp"}}
              </th>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCRtpStreamStats}}
              </td>
              <td>
                {{RTCRtpStreamStats/ssrc}}, {{RTCRtpStreamStats/kind}},
                {{RTCRtpStreamStats/transportId}},
                {{RTCRtpStreamStats/codecId}}
              </td>
            </tr>
            <tr>
              <td>
                {{RTCSentRtpStreamStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCRtpSender-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCSentRtpStreamStats/packetsSent}},
                {{RTCSentRtpStreamStats/bytesSent}}
              </td>
            </tr>
            <tr>
              <td>
                {{RTCOutboundRtpStreamStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-track-stats.https.html,RTCRtpSender-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCOutboundRtpStreamStats/senderId}},
                {{RTCOutboundRtpStreamStats/remoteId}},
                {{RTCOutboundRtpStreamStats/framesEncoded}},
                {{RTCOutboundRtpStreamStats/nackCount}},
                {{RTCOutboundRtpStreamStats/framesSent}}
              </td>
            </tr>
            <tr>
              <th rowspan="3" class="row">
                {{RTCStatsType/"remote-inbound-rtp"}}
              </th>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCRtpStreamStats}}
              </td>
              <td>
                {{RTCRtpStreamStats/ssrc}}, {{RTCRtpStreamStats/kind}},
                {{RTCRtpStreamStats/transportId}},
                {{RTCRtpStreamStats/codecId}}
              </td>
            </tr>
            <tr>
              <td>
                {{RTCReceivedRtpStreamStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCRtpReceiver-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCReceivedRtpStreamStats/packetsReceived}},
                {{RTCReceivedRtpStreamStats/packetsLost}},
                {{RTCReceivedRtpStreamStats/jitter}},
                {{RTCReceivedRtpStreamStats/packetsDiscarded}},
                {{RTCReceivedRtpStreamStats/framesDropped}}
              </td>
            </tr>
            <tr>
              <td>
                {{RTCRemoteInboundRtpStreamStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCRemoteInboundRtpStreamStats/localId}},
                {{RTCRemoteInboundRtpStreamStats/roundTripTime}}
              </td>
            </tr>
            <tr>
              <th rowspan="3" class="row">
                {{RTCStatsType/"remote-outbound-rtp"}}
              </th>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCRtpStreamStats}}
              </td>
              <td>
                {{RTCRtpStreamStats/ssrc}}, {{RTCRtpStreamStats/kind}},
                {{RTCRtpStreamStats/transportId}},
                {{RTCRtpStreamStats/codecId}}
              </td>
            </tr>
            <tr>
              <td>
                {{RTCSentRtpStreamStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCRtpSender-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCSentRtpStreamStats/packetsSent}},
                {{RTCSentRtpStreamStats/bytesSent}}
              </td>
            </tr>
            <tr>
              <td>
                {{RTCRemoteOutboundRtpStreamStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCRemoteOutboundRtpStreamStats/localId}},
                {{RTCRemoteOutboundRtpStreamStats/remoteTimestamp}}
              </td>
            </tr>
            <tr>
              <th rowspan="3" class="row">
                {{RTCStatsType/"media-source"}}
              </th>
              <td>
                {{RTCMediaSourceStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-track-stats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCMediaSourceStats/trackIdentifier}},
                {{RTCMediaSourceStats/kind}}
              </td>
            </tr>
            <tr>
              <td>
                {{RTCAudioSourceStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-track-stats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCAudioSourceStats/totalAudioEnergy}},
                {{RTCAudioSourceStats/totalSamplesDuration}} (for audio tracks
                attached to senders)
              </td>
            </tr>
            <tr>
              <td>
                {{RTCVideoSourceStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-track-stats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCVideoSourceStats/width}}, {{RTCVideoSourceStats/height}},
                {{RTCVideoSourceStats/framesPerSecond}} (for video tracks
                attached to senders)
              </td>
            </tr>
            <tr>
              <th class="row">
                {{RTCStatsType/"peer-connection"}}
              </th>
              <td>
                {{RTCPeerConnectionStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,getstats.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCPeerConnectionStats/dataChannelsOpened}},
                {{RTCPeerConnectionStats/dataChannelsClosed}}
              </td>
            </tr>
            <tr>
              <th class="row">
                {{RTCStatsType/"data-channel"}}
              </th>
              <td>
                {{RTCDataChannelStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCDataChannelStats/label}} ,
                {{RTCDataChannelStats/protocol}},
                {{RTCDataChannelStats/dataChannelIdentifier}},
                {{RTCDataChannelStats/state}},
                {{RTCDataChannelStats/messagesSent}},
                {{RTCDataChannelStats/bytesSent}},
                {{RTCDataChannelStats/messagesReceived}},
                {{RTCDataChannelStats/bytesReceived}}
              </td>
            </tr>
            <tr>
              <th class="row">
                {{RTCStatsType/"sender"}}
              </th>
              <td rowspan="2">
                {{RTCMediaHandlerStats}}
              </td>
              <td rowspan="2" data-tests=
              "RTCPeerConnection-track-stats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCMediaHandlerStats/trackIdentifier}}
              </td>
            </tr>
            <tr>
              <th class="row">
                {{RTCStatsType/"receiver"}}
              </th>
            </tr>
            <tr>
              <th class="row">
                {{RTCStatsType/"transport"}}
              </th>
              <td>
                {{RTCTransportStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-track-stats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCTransportStats/bytesSent}},
                {{RTCTransportStats/bytesReceived}},
                {{RTCTransportStats/selectedCandidatePairId}},
                {{RTCTransportStats/localCertificateId}},
                {{RTCTransportStats/remoteCertificateId}}
              </td>
            </tr>
            <tr>
              <th class="row">
                {{RTCStatsType/"candidate-pair"}}
              </th>
              <td>
                {{RTCIceCandidatePairStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-track-stats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCIceCandidatePairStats/transportId}},
                {{RTCIceCandidatePairStats/localCandidateId}},
                {{RTCIceCandidatePairStats/remoteCandidateId}},
                {{RTCIceCandidatePairStats/state}},
                {{RTCIceCandidatePairStats/nominated}},
                {{RTCIceCandidatePairStats/bytesSent}},
                {{RTCIceCandidatePairStats/bytesReceived}},
                {{RTCIceCandidatePairStats/totalRoundTripTime}},
                {{RTCIceCandidatePairStats/currentRoundTripTime}}
              </td>
            </tr>
            <tr>
              <th class="row">
                {{RTCStatsType/"local-candidate"}}
              </th>
              <td rowspan="2">
                {{RTCIceCandidateStats}}
              </td>
              <td rowspan="2" data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-track-stats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCIceCandidateStats/address}},
                {{RTCIceCandidateStats/port}},
                {{RTCIceCandidateStats/protocol}},
                {{RTCIceCandidateStats/candidateType}},
                {{RTCIceCandidateStats/url}}
              </td>
            </tr>
            <tr>
              <th class="row">
                {{RTCStatsType/"remote-candidate"}}
              </th>
            </tr>
            <tr>
              <th class="row">
                {{RTCStatsType/"certificate"}}
              </th>
              <td>
                {{RTCCertificateStats}}
              </td>
              <td data-tests=
              "RTCPeerConnection-getStats.https.html,RTCPeerConnection-mandatory-getStats.https.html">
                {{RTCCertificateStats/fingerprint}},
                {{RTCCertificateStats/fingerprintAlgorithm}},
                {{RTCCertificateStats/base64Certificate}},
                {{RTCCertificateStats/issuerCertificateId}}
              </td>
            </tr>
          </tbody>
        </table>
        <p>
          An implementation MAY support generating any other statistic defined
          in [[!WEBRTC-STATS]], and MAY generate statistics that are not
          documented.
        </p>
      </section>
      <section>
        <h3>
          GetStats Example
        </h3>
        <p>
          Consider the case where the user is experiencing bad sound and the
          application wants to determine if the cause of it is packet loss. The
          following example code might be used:
        </p>
        <pre class="example highlight">
async function gatherStats(pc) {
  try {
    const [sender] = pc.getSenders();
    const baselineReport = await sender.getStats();
    await new Promise(resolve =&gt; setTimeout(resolve, aBit)); // wait a bit
    const currentReport = await sender.getStats();

    // compare the elements from the current report with the baseline
    for (const now of currentReport.values()) {
      if (now.type != 'outbound-rtp') continue;

      // get the corresponding stats from the baseline report
      const base = baselineReport.get(now.id);
      if (!base) continue;

      const remoteNow = currentReport.get(now.remoteId);
      const remoteBase = baselineReport.get(base.remoteId);

      const packetsSent = now.packetsSent - base.packetsSent;
      const packetsReceived = remoteNow.packetsReceived -
                              remoteBase.packetsReceived;

      const fractionLost = (packetsSent - packetsReceived) / packetsSent;
      if (fractionLost &gt; 0.3) {
        // if fractionLost is &gt; 0.3, we have probably found the culprit
      }
    }
  } catch (err) {
    console.error(err);
  }
}
      </pre>
      </section>
    </section>
    <section>
      <h2>
        Media Stream API Extensions for Network Use
      </h2>
      <section>
        <h3>
          Introduction
        </h3>
        <p class="no-test-needed">
          The {{MediaStreamTrack}} interface, as defined in the
          [[!GETUSERMEDIA]] specification, typically represents a stream of
          data of audio or video. One or more {{MediaStreamTrack}}s can be
          collected in a {{MediaStream}} (strictly speaking, a {{MediaStream}}
          as defined in [[!GETUSERMEDIA]] may contain zero or more
          {{MediaStreamTrack}} objects).
        </p>
        <p>
          A {{MediaStreamTrack}} may be extended to represent a media flow that
          either comes from or is sent to a remote peer (and not just the local
          camera, for instance). The extensions required to enable this
          capability on the {{MediaStreamTrack}} object will be described in
          this section. How the media is transmitted to the peer is described
          in [[RFC8834]], [[RFC7874]], and [[RFC8835]].
        </p>
        <p class="no-test-needed">
          A {{MediaStreamTrack}} sent to another peer will appear as one and
          only one {{MediaStreamTrack}} to the recipient. A peer is defined as
          a user agent that supports this specification. In addition, the
          sending side application can indicate what {{MediaStream}} object(s)
          the {{MediaStreamTrack}} is a member of. The corresponding
          {{MediaStream}} object(s) on the receiver side will be created (if
          not already present) and populated accordingly.
        </p>
        <p>
          As also described earlier in this document, the objects
          {{RTCRtpSender}} and {{RTCRtpReceiver}} can be used by the
          application to get more fine grained control over the transmission
          and reception of {{MediaStreamTrack}}s.
        </p>
        <p class="untestable">
          Channels are the smallest unit considered in the Media Capture and
          Streams specification. Channels are intended to be encoded together
          for transmission as, for instance, an RTP payload type. All of the
          channels that a codec needs to encode jointly MUST be in the same
          {{MediaStreamTrack}} and the codecs SHOULD be able to encode, or
          discard, all the channels in the track.
        </p>
        <p class="no-test-needed">
          The concepts of an input and output to a given {{MediaStreamTrack}}
          apply in the case of {{MediaStreamTrack}} objects transmitted over
          the network as well. A {{MediaStreamTrack}} created by an
          {{RTCPeerConnection}} object (as described previously in this
          document) will take as input the data received from a remote peer.
          Similarly, a {{MediaStreamTrack}} from a local source, for instance a
          camera via [[!GETUSERMEDIA]], will have an output that represents
          what is transmitted to a remote peer if the object is used with an
          {{RTCPeerConnection}} object.
        </p>
        <p class="no-test-needed">
          The concept of duplicating {{MediaStream}} and {{MediaStreamTrack}}
          objects as described in [[!GETUSERMEDIA]] is also applicable here.
          This feature can be used, for instance, in a video-conferencing
          scenario to display the local video from the user's camera and
          microphone in a local monitor, while only transmitting the audio to
          the remote peer (e.g. in response to the user using a "video mute"
          feature). Combining different {{MediaStreamTrack}} objects into new
          {{MediaStream}} objects is useful in certain situations.
        </p>
        <p class="note">
          In this document, we only specify aspects of the following objects
          that are relevant when used along with an {{RTCPeerConnection}}.
          Please refer to the original definitions of the objects in the
          [[!GETUSERMEDIA]] document for general information on using
          {{MediaStream}} and {{MediaStreamTrack}}.
        </p>
      </section>
      <section>
        <h3 id="mediastream-network-use">
          MediaStream
        </h3>
        <section>
          <h4>
            id
          </h4>
          <p class="needs-test">
            The {{MediaStream/id}} attribute specified in {{MediaStream}}
            returns an id that is unique to this stream, so that streams can be
            recognized at the remote end of the {{RTCPeerConnection}} API.
          </p>
          <p class="needs-test">
            When a {{MediaStream}} is created to represent a stream obtained
            from a remote peer, the {{MediaStream/id}} attribute is initialized
            from information provided by the remote source.
          </p>
          <p class="note">
            The {{MediaStream/id}} of a {{MediaStream}} object is unique to the
            source of the stream, but that does not mean it is not possible to
            end up with duplicates. For example, the tracks of a locally
            generated stream could be sent from one user agent to a remote peer
            using {{RTCPeerConnection}} and then sent back to the original user
            agent in the same manner, in which case the original user agent
            will have multiple streams with the same id (the locally-generated
            one and the one received from the remote peer).
          </p>
        </section>
      </section>
      <section>
        <h3 id="mediastreamtrack-network-use">
          MediaStreamTrack
        </h3>
        <p class="needs-test">
          A {{MediaStreamTrack}} object's reference to its {{MediaStream}} in
          the non-local media source case (an RTP source, as is the case for
          each {{MediaStreamTrack}} associated with an {{RTCRtpReceiver}}) is
          always strong.
        </p>
        <p data-tests="RTCPeerConnection-remote-track-mute.https.html">
          Whenever an {{RTCRtpReceiver}} receives data on an RTP source whose
          corresponding {{MediaStreamTrack}} is muted, but not ended, and the
          {{RTCRtpTransceiver/[[Receptive]]}} slot of the {{RTCRtpTransceiver}} object the
          {{RTCRtpReceiver}} is a member of is <code>true</code>, it MUST queue
          a task to [= set the muted state =] of the corresponding
          {{MediaStreamTrack}} to <code>false</code>.
        </p>
        <p class="needs-test">
          When one of the SSRCs for RTP source media streams received by an
          {{RTCRtpReceiver}} is removed either due to reception of a BYE or via
          timeout, it MUST queue a task to [= set the muted state =] of the
          corresponding {{MediaStreamTrack}} to <code>true</code>. Note that
          {{RTCPeerConnection/setRemoteDescription}} can also lead to [= set
          the muted state | the setting of the muted state =] of the
          {{RTCRtpReceiver/track}} to the value <code>true</code>.
        </p>
        <p class="no-test-needed">
          The procedures <dfn data-lt="add the track" id="add-track">add a
          track</dfn>, <dfn data-lt="remove the track" id="remove-track">remove
          a track</dfn> and <dfn data-lt="set the muted state" id=
          "set-track-muted">set a track's muted state</dfn> are specified in
          [[!GETUSERMEDIA]].
        </p>
        <p class="untestable">
          When a {{MediaStreamTrack}} track produced by an {{RTCRtpReceiver}}
          <var>receiver</var> has <code class="gum">ended</code>
          [[!GETUSERMEDIA]] (such as via a call to
          <var>receiver</var>.{{RTCRtpReceiver/track}}.<code class=
          "gum">stop</code>), the user agent MAY choose to free resources
          allocated for the incoming stream, by for instance turning off the
          decoder of <var>receiver</var>.
        </p>
        <section>
          <h4>
            MediaTrackSupportedConstraints, MediaTrackCapabilities,
            MediaTrackConstraints and MediaTrackSettings
          </h4>
          <p class="no-test-needed">
            The concept of constraints and constrainable properties, including
            {{MediaTrackConstraints}} ({{MediaStreamTrack}}.<code class=
            "gum">getConstraints()</code>, {{MediaStreamTrack}}.<code class=
            "gum">applyConstraints()</code>), and {{MediaTrackSettings}}
            ({{MediaStreamTrack}}.<code class="gum">getSettings()</code>) are
            outlined in [[!GETUSERMEDIA]]. However, the constrainable
            properties of tracks sourced from a peer connection are different
            than those sourced by <code class="gum">getUserMedia()</code>; the
            constraints and settings applicable to {{MediaStreamTrack}}s
            sourced from a [= remote source =] are defined here. The settings
            of a remote track represent the latest frame received.
          </p>
          <p class="needs-test">
            {{MediaStreamTrack}}.<code class="gum">getCapabilities()</code>
            MUST always return the empty set and
            {{MediaStreamTrack}}.<code class="gum">applyConstraints()</code>
            MUST always reject with <code class=
            "gum">OverconstrainedError</code> on remote tracks for constraints
            defined here.
          </p>
          <p class="needs-test">
            The following constrainable properties are defined to apply to
            video {{MediaStreamTrack}}s sourced from a [= remote source =]:
          </p>
          <table class="simple">
            <thead>
              <tr>
                <th>
                  Property Name
                </th>
                <th>
                  Values
                </th>
                <th>
                  Notes
                </th>
              </tr>
            </thead>
            <tbody>
              <tr id="def-constraint-width">
                <td data-tests="">
                  <dfn>width</dfn>
                </td>
                <td>
                  {{ConstrainULong}}
                </td>
                <td>
                  As a setting, this is the width, in pixels, of the latest
                  frame received.
                </td>
              </tr>
              <tr id="def-constraint-height">
                <td data-tests="">
                  <dfn>height</dfn>
                </td>
                <td>
                  {{ConstrainULong}}
                </td>
                <td>
                  As a setting, this is the height, in pixels, of the latest
                  frame received.
                </td>
              </tr>
              <tr id="def-constraint-frameRate">
                <td data-tests="">
                  <dfn>frameRate</dfn>
                </td>
                <td>
                  {{ConstrainDouble}}
                </td>
                <td>
                  As a setting, this is an estimate of the frame rate based on
                  recently received frames.
                </td>
              </tr>
              <tr id="def-constraint-aspect">
                <td data-tests="">
                  <dfn>aspectRatio</dfn>
                </td>
                <td>
                  {{ConstrainDouble}}
                </td>
                <td>
                  As a setting, this is the aspect ratio of the latest frame;
                  this is the width in pixels divided by height in pixels as a
                  double rounded to the tenth decimal place.
                </td>
              </tr>
            </tbody>
          </table>
          <p class="no-test-needed">
            This document does not define any constrainable properties to apply
            to audio {{MediaStreamTrack}}s sourced from a [= remote source =].
          </p>
        </section>
      </section>
    </section>
    <section class="informative">
      <h2>
        Examples and Call Flows
      </h2>
      <section>
        <h3>
          Simple Peer-to-peer Example
        </h3>
        <div>
          <p>
            When two peers decide they are going to set up a connection to each
            other, they both go through these steps. The STUN/TURN server
            configuration describes a server they can use to get things like
            their public IP address or to set up NAT traversal. They also have
            to send data for the signaling channel to each other using the same
            out-of-band mechanism they used to establish that they were going
            to communicate in the first place.
          </p>
          <pre class="example highlight">
const signaling = new SignalingChannel(); // handles JSON.stringify/parse
const constraints = {audio: true, video: true};
const configuration = {iceServers: [{urls: 'stun:stun.example.org'}]};
const pc = new RTCPeerConnection(configuration);

// send any ice candidates to the other peer
pc.onicecandidate = ({candidate}) =&gt; signaling.send({candidate});

// let the "negotiationneeded" event trigger offer generation
pc.onnegotiationneeded = async () =&gt; {
  try {
    await pc.setLocalDescription();
    // send the offer to the other peer
    signaling.send({description: pc.localDescription});
  } catch (err) {
    console.error(err);
  }
};

pc.ontrack = ({track, streams}) =&gt; {
  // once media for a remote track arrives, show it in the remote video element
  track.onunmute = () =&gt; {
    // don't set srcObject again if it is already set.
    if (remoteView.srcObject) return;
    remoteView.srcObject = streams[0];
  };
};

// call start() to initiate
function start() {
  addCameraMic();
}

// add camera and microphone to connection
async function addCameraMic() {
  try {
    // get a local stream, show it in a self-view and add it to be sent
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    for (const track of stream.getTracks()) {
      pc.addTrack(track, stream);
    }
    selfView.srcObject = stream;
  } catch (err) {
    console.error(err);
  }
}

signaling.onmessage = async ({data: {description, candidate}}) =&gt; {
  try {
    if (description) {
      await pc.setRemoteDescription(description);
      // if we got an offer, we need to reply with an answer
      if (description.type == 'offer') {
        if (!selfView.srcObject) {
          // blocks negotiation on permission (not recommended in production code)
          await addCameraMic();
        }
        await pc.setLocalDescription();
        signaling.send({description: pc.localDescription});
      }
    } else if (candidate) {
      await pc.addIceCandidate(candidate);
    }
  } catch (err) {
    console.error(err);
  }
};
        </pre>
        </div>
      </section>
      <section>
        <h3>
          Advanced Peer-to-peer Example with Warm-up
        </h3>
        <div>
          <p>
            When two peers decide they are going to set up a connection to each
            other and want to have the ICE, DTLS, and media connections "warmed
            up" such that they are ready to send and receive media immediately,
            they both go through these steps.
          </p>
          <pre class="example highlight">
const signaling = new SignalingChannel(); // handles JSON.stringify/parse
const constraints = {audio: true, video: true};
const configuration = {iceServers: [{urls: 'stun:stun.example.org'}]};
let pc;
let audio;
let video;
let started = false;

// Call warmup() before media is ready, to warm-up ICE, DTLS, and media.
async function warmup(isAnswerer) {
  pc = new RTCPeerConnection(configuration);
  if (!isAnswerer) {
    audio = pc.addTransceiver('audio');
    video = pc.addTransceiver('video');
  }

  // send any ice candidates to the other peer
  pc.onicecandidate = ({candidate}) =&gt; signaling.send({candidate});

  // let the "negotiationneeded" event trigger offer generation
  pc.onnegotiationneeded = async () =&gt; {
    try {
      await pc.setLocalDescription();
      // send the offer to the other peer
      signaling.send({description: pc.localDescription});
    } catch (err) {
      console.error(err);
    }
  };

  pc.ontrack = async ({track, transceiver}) =&gt; {
    try {
      // once media for the remote track arrives, show it in the video element
      event.track.onunmute = () =&gt; {
        // don't set srcObject again if it is already set.
        if (!remoteView.srcObject) {
          remoteView.srcObject = new MediaStream();
        }
        remoteView.srcObject.addTrack(track);
      }

      if (isAnswerer) {
        if (track.kind == 'audio') {
          audio = transceiver;
        } else if (track.kind == 'video') {
          video = transceiver;
        }
        if (started) await addCameraMicWarmedUp();
      }
    } catch (err) {
      console.error(err);
    }
  };

  try {
    // get a local stream, show it in a self-view and add it to be sent
    selfView.srcObject = await navigator.mediaDevices.getUserMedia(constraints);
    if (started) await addCameraMicWarmedUp();
  } catch (err) {
    console.error(err);
  }
}

// call start() after warmup() to begin transmitting media from both ends
function start() {
  signaling.send({start: true});
  signaling.onmessage({data: {start: true}});
}

// add camera and microphone to already warmed-up connection
async function addCameraMicWarmedUp() {
  const stream = selfView.srcObject;
  if (audio &amp;& video &amp;& stream) {
    await Promise.all([
      audio.sender.replaceTrack(stream.getAudioTracks()[0]),
      video.sender.replaceTrack(stream.getVideoTracks()[0]),
    ]);
  }
}

signaling.onmessage = async ({data: {start, description, candidate}}) =&gt; {
  if (!pc) warmup(true);

  try {
    if (start) {
      started = true;
      await addCameraMicWarmedUp();
    } else if (description) {
      await pc.setRemoteDescription(description);
      // if we got an offer, we need to reply with an answer
      if (description.type == 'offer') {
        await pc.setLocalDescription();
        signaling.send({description: pc.localDescription});
      }
    } else {
      await pc.addIceCandidate(candidate);
    }
  } catch (err) {
    console.error(err);
  }
};
        </pre>
        </div>
      </section>
      <section>
        <h3>
          Simulcast Example
        </h3>
        <div>
          <p>
            A client wants to send multiple RTP encodings (simulcast) to a
            server.
          </p>
          <pre class="example highlight">
const signaling = new SignalingChannel(); // handles JSON.stringify/parse
const constraints = {audio: true, video: true};
const configuration = {'iceServers': [{'urls': 'stun:stun.example.org'}]};
let pc;

// call start() to initiate
async function start() {
  pc = new RTCPeerConnection(configuration);

  // let the "negotiationneeded" event trigger offer generation
  pc.onnegotiationneeded = async () =&gt; {
    try {
      await pc.setLocalDescription();
      // send the offer to the other peer
      signaling.send({description: pc.localDescription});
    } catch (err) {
      console.error(err);
    }
  };

  try {
    // get a local stream, show it in a self-view and add it to be sent
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    selfView.srcObject = stream;
    pc.addTransceiver(stream.getAudioTracks()[0], {direction: 'sendonly'});
    pc.addTransceiver(stream.getVideoTracks()[0], {
      direction: 'sendonly',
      sendEncodings: [
        {rid: 'q', scaleResolutionDownBy: 4.0}
        {rid: 'h', scaleResolutionDownBy: 2.0},
        {rid: 'f'},
      ]
    });
  } catch (err) {
    console.error(err);
  }
}

signaling.onmessage = async ({data: {description, candidate}}) =&gt; {
  try {
    if (description) {
      await pc.setRemoteDescription(description);
      // if we got an offer, we need to reply with an answer
      if (description.type == 'offer') {
        await pc.setLocalDescription();
        signaling.send({description: pc.localDescription});
      }
    } else if (candidate) {
      await pc.addIceCandidate(candidate);
    }
  } catch (err) {
    console.error(err);
  }
};
        </pre>
        </div>
      </section>
      <section>
        <h3>
          Peer-to-peer Data Example
        </h3>
        <div>
          <p>
            This example shows how to create an {{RTCDataChannel}} object and
            perform the offer/answer exchange required to connect the channel
            to the other peer. The {{RTCDataChannel}} is used in the context of
            a simple chat application using an <code>input</code> field for
            user input.
          </p>
          <pre class="example highlight">
const signaling = new SignalingChannel(); // handles JSON.stringify/parse
const configuration = {iceServers: [{urls: 'stun:stun.example.org'}]};
let pc, channel;

// call start() to initiate
function start() {
  pc = new RTCPeerConnection(configuration);

  // send any ice candidates to the other peer
  pc.onicecandidate = ({candidate}) =&gt; signaling.send({candidate});

  // let the "negotiationneeded" event trigger offer generation
  pc.onnegotiationneeded = async () =&gt; {
    try {
      await pc.setLocalDescription();
      // send the offer to the other peer
      signaling.send({description: pc.localDescription});
    } catch (err) {
      console.error(err);
    }
  };

  // create data channel and setup chat using "negotiated" pattern
  channel = pc.createDataChannel('chat', {negotiated: true, id: 0});
  channel.onopen = () =&gt; input.disabled = false;
  channel.onmessage = ({data}) =&gt; showChatMessage(data);

  input.onkeypress = ({keyCode}) =&gt; {
    // only send when user presses enter
    if (keyCode != 13) return;
    channel.send(input.value);
  }
}

signaling.onmessage = async ({data: {description, candidate}}) =&gt; {
  if (!pc) start(false);

  try {
    if (description) {
      await pc.setRemoteDescription(description);
      // if we got an offer, we need to reply with an answer
      if (description.type == 'offer') {
        await pc.setLocalDescription();
        signaling.send({description: pc.localDescription});
      }
    } else if (candidate) {
      await pc.addIceCandidate(candidate);
    }
  } catch (err) {
    console.error(err);
  }
};
        </pre>
        </div>
      </section>
      <section>
        <h3>
          Call Flow Browser to Browser
        </h3>
        <p>
          This shows an example of one possible call flow between two browsers.
          This does not show the procedure to get access to local media or
          every callback that gets fired but instead tries to reduce it down to
          only show the key events and messages.
        </p>
        <p>
          <img alt=
          "A message sequence chart detailing a call flow between two browsers"
          src="images/ladder-2party-simple.svg" style="width:100%">
        </p>
      </section>
      <section>
        <h3>
          DTMF Example
        </h3>
        <p>
          Examples assume that <var>sender</var> is an {{RTCRtpSender}}.
        </p>
        <p>
          Sending the DTMF signal "1234" with 500 ms duration per tone:
        </p>
        <pre class="example highlight">
if (sender.dtmf.canInsertDTMF) {
  const duration = 500;
  sender.dtmf.insertDTMF('1234', duration);
} else {
  console.log('DTMF function not available');
}
      </pre>
        <p>
          Send the DTMF signal "123" and abort after sending "2".
        </p>
        <pre class="example highlight">
async function sendDTMF() {
  if (sender.dtmf.canInsertDTMF) {
    sender.dtmf.insertDTMF('123');
    await new Promise(r =&gt; sender.dtmf.ontonechange = e =&gt; e.tone == '2' &amp;& r());
    // empty the buffer to not play any tone after "2"
    sender.dtmf.insertDTMF('');
  } else {
    console.log('DTMF function not available');
  }
}
      </pre>
        <p>
          Send the DTMF signal "1234", and light up the active key using
          <code class="example">lightKey(key)</code> while the tone is playing
          (assuming that <code class="example">lightKey("")</code> will darken
          all the keys):
        </p>
        <pre class="example highlight">
const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));

if (sender.dtmf.canInsertDTMF) {
  const duration = 500; // ms
  sender.dtmf.insertDTMF(sender.dtmf.toneBuffer + '1234', duration);
  sender.dtmf.ontonechange = async ({tone}) =&gt; {
    if (!tone) return;
    lightKey(tone); // light up the key when playout starts
    await wait(duration);
    lightKey(''); // turn off the light after tone duration
  };
} else {
  console.log('DTMF function not available');
}
      </pre>
        <p>
          It is always safe to append to the tone buffer. This example appends
          before any tone playout has started as well as during playout.
        </p>
        <pre class="example highlight">
if (sender.dtmf.canInsertDTMF) {
  sender.dtmf.insertDTMF('123');
  // append more tones to the tone buffer before playout has begun
  sender.dtmf.insertDTMF(sender.dtmf.toneBuffer + '456');

  sender.dtmf.ontonechange = ({tone}) =&gt; {
    // append more tones when playout has begun
    if (tone != '1') return;
    sender.dtmf.insertDTMF(sender.dtmf.toneBuffer + '789');
  };
} else {
  console.log('DTMF function not available');
}
      </pre>
        <p>
          Send a 1-second "1" tone followed by a 2-second "2" tone:
        </p>
        <pre class="example highlight">
if (sender.dtmf.canInsertDTMF) {
  sender.dtmf.ontonechange = ({tone}) =&gt; {
    if (tone == '1') {
      sender.dtmf.insertDTMF(sender.dtmf.toneBuffer + '2', 2000);
    }
  };
  sender.dtmf.insertDTMF(sender.dtmf.toneBuffer + '1', 1000);
} else {
  console.log('DTMF function not available');
}
      </pre>
      </section>
      <section>
        <h3>
          Perfect Negotiation Example
        </h3>
        <p>
          Perfect negotiation is a recommended pattern to manage negotiation
          transparently, abstracting this asymmetric task away from the rest of
          an application. This pattern has advantages over one side always
          being the offerer, as it lets applications operate on both peer
          connection objects simultaneously without risk of glare (an offer
          coming in outside of {{RTCSignalingState/"stable"}} state). The rest
          of the application may use any and all modification methods and
          attributes, without worrying about signaling state races.
        </p>
        <p>
          It designates different roles to the two peers, with behavior to
          resolve signaling collisions between them:
        </p>
        <ol>
          <li>
            <p>
              The <dfn>polite peer</dfn> uses rollback to avoid collision with
              an incoming offer.
            </p>
          </li>
          <li>
            <p>
              The <dfn>impolite peer</dfn> ignores an incoming offer when this
              would collide with its own.
            </p>
          </li>
        </ol>
        <p>
          Together, they manage signaling for the rest of the application in a
          manner that doesn't deadlock. The example assumes a
          <code>polite</code> boolean variable indicating the designated role:
        </p>
        <pre class="example highlight">
const signaling = new SignalingChannel(); // handles JSON.stringify/parse
const constraints = {audio: true, video: true};
const configuration = {iceServers: [{urls: 'stun:stun.example.org'}]};
const pc = new RTCPeerConnection(configuration);

// call start() anytime on either end to add camera and microphone to connection
async function start() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    for (const track of stream.getTracks()) {
      pc.addTrack(track, stream);
    }
    selfView.srcObject = stream;
  } catch (err) {
    console.error(err);
  }
}

pc.ontrack = ({track, streams}) =&gt; {
  // once media for a remote track arrives, show it in the remote video element
  track.onunmute = () =&gt; {
    // don't set srcObject again if it is already set.
    if (remoteView.srcObject) return;
    remoteView.srcObject = streams[0];
  };
};

// - The perfect negotiation logic, separated from the rest of the application ---

// keep track of some negotiation state to prevent races and errors
let makingOffer = false;
let ignoreOffer = false;
let isSettingRemoteAnswerPending = false;

// send any ice candidates to the other peer
pc.onicecandidate = ({candidate}) =&gt; signaling.send({candidate});

// let the "negotiationneeded" event trigger offer generation
pc.onnegotiationneeded = async () =&gt; {
  try {
    makingOffer = true;
    await pc.setLocalDescription();
    signaling.send({description: pc.localDescription});
  } catch (err) {
     console.error(err);
  } finally {
    makingOffer = false;
  }
};

signaling.onmessage = async ({data: {description, candidate}}) =&gt; {
  try {
    if (description) {
      // An offer may come in while we are busy processing SRD(answer).
      // In this case, we will be in "stable" by the time the offer is processed
      // so it is safe to chain it on our Operations Chain now.
      const readyForOffer =
          !makingOffer &amp;&
          (pc.signalingState == "stable" || isSettingRemoteAnswerPending);
      const offerCollision = description.type == "offer" &amp;& !readyForOffer;

      ignoreOffer = !polite &amp;& offerCollision;
      if (ignoreOffer) {
        return;
      }
      isSettingRemoteAnswerPending = description.type == "answer";
      await pc.setRemoteDescription(description); // SRD rolls back as needed
      isSettingRemoteAnswerPending = false;
      if (description.type == "offer") {
        await pc.setLocalDescription();
        signaling.send({description: pc.localDescription});
      }
    } else if (candidate) {
      try {
        await pc.addIceCandidate(candidate);
      } catch (err) {
        if (!ignoreOffer) throw err; // Suppress ignored offer's candidates
      }
    }
  } catch (err) {
    console.error(err);
  }
}
      </pre>
        <p>
          Note that this is timing sensitive, and deliberately uses versions of
          {{RTCPeerConnection/setLocalDescription}} (without arguments) and
          {{RTCPeerConnection/setRemoteDescription}} (with implicit rollback)
          to avoid races with other signaling messages being serviced.
        </p>
        <p>
          The <var>ignoreOffer</var> variable is needed, because the
          {{RTCPeerConnection}} object on the impolite side is never told about
          ignored offers. We must therefore suppress errors from incoming
          candidates belonging to such offers.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Error Handling
      </h2>
      <p>
        Some operations throw or fire {{RTCError}}. This is an extension of
        {{DOMException}} that carries additional WebRTC-specific information.
      </p>
      <section>
        <h3>
          <dfn>RTCError</dfn> Interface
        </h3>
        <div>
          <pre class="idl" data-tests="">[Exposed=Window]
interface RTCError : DOMException {
  constructor(RTCErrorInit init, optional DOMString message = "");
  readonly attribute RTCErrorDetailType errorDetail;
  readonly attribute long? sdpLineNumber;
  readonly attribute long? sctpCauseCode;
  readonly attribute unsigned long? receivedAlert;
  readonly attribute unsigned long? sentAlert;
};</pre>
        </div>
        <section>
          <h2>
            Constructors
          </h2>
          <dl data-link-for="RTCError" data-dfn-for="RTCError" class=
          "constructors">
            <dt>
              <dfn data-idl="">constructor()</dfn>
            </dt>
            <dd>
              <p>
                Run the following steps:
              </p>
              <ol>
                <li class="no-test-needed">
                  <p>
                    Let <var>init</var> be the constructor's first argument.
                  </p>
                </li>
                <li class="no-test-needed">
                  <p>
                    Let <var>message</var> be the constructor's second
                    argument.
                  </p>
                </li>
                <li class="no-test-needed">
                  <p>
                    Let <var>e</var> be a new {{RTCError}} object.
                  </p>
                </li>
                <li data-tests="RTCError.html">
                  <p>
                    Invoke the {{DOMException}} constructor of <var>e</var>
                    with the {{DOMException/message}} argument set to
                    <var>message</var> and the {{DOMException/name}} argument
                    set to <code>"OperationError"</code>.
                  </p>
                  <p class="note">
                    This name does not have a mapping to a legacy code so
                    <var>e</var>.{{DOMException/code}} will return 0.
                  </p>
                </li>
                <li data-tests="RTCError.html">
                  <p>
                    Set all {{RTCError}} attributes of <var>e</var> to the
                    value of the corresponding attribute in <var>init</var> if
                    it is present, otherwise set it to <code>null</code>.
                  </p>
                </li>
                <li class="no-test-needed">
                  <p>
                    Return <var>e</var>.
                  </p>
                </li>
              </ol>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Attributes
          </h2>
          <dl data-link-for="RTCError" data-dfn-for="RTCError" class=
          "attributes">
            <dt data-tests=
            "RTCError.html,RTCPeerConnection-setRemoteDescription-offer.html">
              <dfn data-idl="">errorDetail</dfn> of type <span class=
              "idlAttrType">RTCErrorDetailType</span>, readonly
            </dt>
            <dd>
              <p>
                The WebRTC-specific error code for the type of error that
                occurred.
              </p>
            </dd>
            <dt data-tests=
            "RTCError.html,RTCPeerConnection-setRemoteDescription-offer.html">
              <dfn data-idl="">sdpLineNumber</dfn> of type <span class=
              "idlAttrType">long</span>, readonly, nullable
            </dt>
            <dd class="needs-test">
              <p>
                If {{RTCError/errorDetail}} is
                {{RTCErrorDetailType/"sdp-syntax-error"}} this is the line
                number where the error was detected (the first line has line
                number 1).
              </p>
            </dd>
            <dt data-tests="RTCError.html">
              <dfn data-idl="">sctpCauseCode</dfn> of type <span class=
              "idlAttrType">long</span>, readonly, nullable
            </dt>
            <dd class="untestable">
              <p>
                If {{RTCError/errorDetail}} is
                {{RTCErrorDetailType/"sctp-failure"}} this is the SCTP cause
                code of the failed SCTP negotiation.
              </p>
            </dd>
            <dt data-tests="RTCError.html">
              <dfn data-idl="">receivedAlert</dfn> of type <span class=
              "idlAttrType">unsigned long</span>, readonly, nullable
            </dt>
            <dd class="untestable">
              <p>
                If {{RTCError/errorDetail}} is
                {{RTCErrorDetailType/"dtls-failure"}} and a fatal DTLS alert
                was received, this is the value of the DTLS alert received.
              </p>
            </dd>
            <dt data-tests="RTCError.html">
              <dfn data-idl="">sentAlert</dfn> of type <span class=
              "idlAttrType">unsigned long</span>, readonly, nullable
            </dt>
            <dd class="untestable">
              <p>
                If {{RTCError/errorDetail}} is
                {{RTCErrorDetailType/"dtls-failure"}} and a fatal DTLS alert
                was sent, this is the value of the DTLS alert sent.
              </p>
            </dd>
            <dd>
              <div class="issue atrisk">
                <p>
                  All attributes defined in {{RTCError}} are marked at risk due
                  to lack of implementation ({{errorDetail}},
                  {{sdpLineNumber}}, {{sctpCauseCode}}, {{receivedAlert}} and
                  {{sentAlert}}). This does not include attributes inherited
                  from {{DOMException}}.
                </p>
              </div>
            </dd>
          </dl>
        </section>
        <h3>
          <dfn>RTCErrorInit</dfn> Dictionary
        </h3>
        <div>
          <pre class="idl">dictionary RTCErrorInit {
  required RTCErrorDetailType errorDetail;
  long sdpLineNumber;
  long sctpCauseCode;
  unsigned long receivedAlert;
  unsigned long sentAlert;
};</pre>
          <p data-dfn-for="RTCErrorInit">
            The <dfn data-idl="">errorDetail</dfn>, <dfn data-idl=
            "">sdpLineNumber</dfn>, <dfn data-idl="">sctpCauseCode</dfn>,
            <dfn data-idl="">receivedAlert</dfn> and <dfn data-idl=
            "">sentAlert</dfn> members of {{RTCErrorInit}} have the same
            definitions as the attributes of the same name of {{RTCError}}.
          </p>
        </div>
      </section>
      <section>
        <h3>
          <code><dfn>RTCErrorDetailType</dfn></code> Enum
        </h3>
        <div>
          <pre class="idl">enum RTCErrorDetailType {
  "data-channel-failure",
  "dtls-failure",
  "fingerprint-failure",
  "sctp-failure",
  "sdp-syntax-error",
  "hardware-encoder-not-available",
  "hardware-encoder-error"
};</pre>
        </div>
        <table data-link-for="RTCErrorDetailType" data-dfn-for=
        "RTCErrorDetailType" class="simple">
          <thead>
            <tr>
              <th colspan="2">
                Enumeration description
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td data-tests="RTCError.html">
                <dfn data-idl="">data-channel-failure</dfn>
              </td>
              <td>
                The data channel has failed.
              </td>
            </tr>
            <tr>
              <td class="untestable">
                <dfn data-idl="">dtls-failure</dfn>
              </td>
              <td>
                The DTLS negotiation has failed or the connection has been
                terminated with a fatal error. The {{DOMException/message}}
                contains information relating to the nature of error. If a
                fatal DTLS alert was received, the {{RTCError/receivedAlert}}
                attribute is set to the value of the DTLS alert received. If a
                fatal DTLS alert was sent, the {{RTCError/sentAlert}} attribute
                is set to the value of the DTLS alert sent.
              </td>
            </tr>
            <tr>
              <td class="needs-test">
                <dfn data-idl="">fingerprint-failure</dfn>
              </td>
              <td>
                The {{RTCDtlsTransport}}'s remote certificate did not match any
                of the fingerprints provided in the SDP. If the remote peer
                cannot match the local certificate against the provided
                fingerprints, this error is not generated. Instead a
                "bad_certificate" (42) DTLS alert might be received from the
                remote peer, resulting in a
                {{RTCErrorDetailType/"dtls-failure"}}.
              </td>
            </tr>
            <tr>
              <td class="untestable">
                <dfn data-idl="">sctp-failure</dfn>
              </td>
              <td>
                The SCTP negotiation has failed or the connection has been
                terminated with a fatal error. The {{RTCError/sctpCauseCode}}
                attribute is set to the SCTP cause code.
              </td>
            </tr>
            <tr>
              <td data-tests=
              "RTCPeerConnection-setRemoteDescription-offer.html">
                <dfn data-idl="">sdp-syntax-error</dfn>
              </td>
              <td>
                The SDP syntax is not valid. The {{RTCError/sdpLineNumber}}
                attribute is set to the line number in the SDP where the syntax
                error was detected.
              </td>
            </tr>
            <tr>
              <td class="untestable">
                <dfn data-idl="">hardware-encoder-not-available</dfn>
              </td>
              <td>
                The hardware encoder resources required for the requested
                operation are not available.
              </td>
            </tr>
            <tr>
              <td class="untestable">
                <dfn data-idl="">hardware-encoder-error</dfn>
              </td>
              <td>
                The hardware encoder does not support the provided parameters.
              </td>
            </tr>
          </tbody>
        </table>
      </section>
      <section>
        <h3>
          <dfn>RTCErrorEvent</dfn> Interface
        </h3>
        <p>
          The {{RTCErrorEvent}} interface is defined for cases when an
          {{RTCError}} is raised as an event:
        </p>
        <div>
          <pre class="idl" data-tests="idlharness.https.window.js">[Exposed=Window]
interface RTCErrorEvent : Event {
  constructor(DOMString type, RTCErrorEventInit eventInitDict);
  [SameObject] readonly attribute RTCError error;
};</pre>
        </div>
        <section>
          <h2>
            Constructors
          </h2>
          <dl data-link-for="RTCErrorEvent" data-dfn-for="RTCErrorEvent" class=
          "constructors">
            <dt data-tests="idlharness.https.window.js">
              <dfn data-idl="">constructor()</dfn>
            </dt>
            <dd>
              <p>
                Constructs a new {{RTCErrorEvent}}.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Attributes
          </h2>
          <dl data-link-for="RTCErrorEvent" data-dfn-for="RTCErrorEvent" class=
          "attributes">
            <dt>
              <dfn data-idl="">error</dfn> of type <span class=
              "idlAttrType">{{RTCError}}</span>, readonly
            </dt>
            <dd>
              <p>
                The {{RTCError}} describing the error that triggered the event.
              </p>
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>
          <dfn>RTCErrorEventInit</dfn> Dictionary
        </h3>
        <div>
          <pre class="idl" data-cite="DOM">
          dictionary RTCErrorEventInit : EventInit {
  required RTCError error;
};</pre>
        </div>
        <section>
          <h2>
            Dictionary RTCErrorEventInit Members
          </h2>
          <dl data-link-for="RTCErrorEventInit" data-dfn-for=
          "RTCErrorEventInit" class="dictionary-members">
            <dt>
              <dfn data-idl="">error</dfn> of type <span class=
              "idlMemberType">{{RTCError}}</span>
            </dt>
            <dd>
              <p>
                The {{RTCError}} describing the error associated with the event
                (if any).
              </p>
            </dd>
          </dl>
        </section>
      </section>
    </section>
    <section class="informative">
      <h2>
        Event summary
      </h2>
      <p>
        The following events fire on {{RTCDataChannel}} objects:
      </p>
      <table>
        <thead>
          <tr>
            <th>
              Event name
            </th>
            <th>
              Interface
            </th>
            <th>
              Fired when...
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <dfn data-dfn-for=RTCDataChannel id="event-datachannel-open" data-dfn-type=event>
              open</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCDataChannel}} object's [= underlying data transport =]
              has been established (or re-established).
            </td>
          </tr>
          <tr>
            <td>
              <dfn data-dfn-for=RTCDataChannel id="event-datachannel-message" data-dfn-type=event>
              message</dfn>
            </td>
            <td>
              {{MessageEvent}}
              [[html]]
            </td>
            <td>
              A message was successfully received.
            </td>
          </tr>
          <tr>
            <td>
              <dfn data-dfn-for=RTCDataChannel id="event-datachannel-bufferedamountlow" data-dfn-type=event>
              bufferedamountlow</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCDataChannel}} object's {{RTCDataChannel/bufferedAmount}}
              decreases from above its
              {{RTCDataChannel/bufferedAmountLowThreshold}} to less than or
              equal to its {{RTCDataChannel/bufferedAmountLowThreshold}}.
            </td>
          </tr>
          <tr>
            <td>
              <dfn  data-dfn-for=RTCDataChannel data-dfn-type=event id="event-datachannel-error">error</dfn>
            </td>
            <td>
              {{RTCErrorEvent}}
            </td>
            <td>
              An error occurred on the data channel.
            </td>
          </tr>
          <tr>
            <td>
              <dfn  data-dfn-for=RTCDataChannel data-dfn-type=event id="event-datachannel-closing">closing</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCDataChannel}} object transitions to the
              {{RTCDataChannelState/"closing"}} state
            </td>
          </tr>
          <tr>
            <td>
              <dfn  data-dfn-for=RTCDataChannel data-dfn-type="event" id="event-datachannel-close">close</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCDataChannel}} object's [= underlying data transport =]
              has been closed.
            </td>
          </tr>
        </tbody>
      </table>
      <p>
        The following events fire on {{RTCPeerConnection}} objects:
      </p>
      <table>
        <thead>
          <tr>
            <th>
              Event name
            </th>
            <th>
              Interface
            </th>
            <th>
              Fired when...
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <dfn data-dfn-for=RTCPeerConnection id="event-track" data-dfn-type=event>track</dfn>
            </td>
            <td>
              {{RTCTrackEvent}}
            </td>
            <td>
              New incoming media has been negotiated for a specific
              {{RTCRtpReceiver}}, and that receiver's {{RTCRtpReceiver/track}}
              has been added to any associated remote {{MediaStream}}s.
            </td>
          </tr>
          <tr>
            <td>
              <dfn  data-dfn-for=RTCPeerConnection id="event-negotiation" data-dfn-type=event>
              negotiationneeded</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The browser wishes to inform the application that session
              negotiation needs to be done (i.e. a createOffer call followed by
              setLocalDescription).
            </td>
          </tr>
          <tr>
            <td>
              <dfn  data-dfn-for=RTCPeerConnection id="event-signalingstatechange" data-dfn-type=event>
              signalingstatechange</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The [= signaling state =] has changed. This state change is the
              result of either {{RTCPeerConnection/setLocalDescription}} or
              {{RTCPeerConnection/setRemoteDescription}} being invoked.
            </td>
          </tr>
          <tr>
            <td>
              <dfn  data-dfn-for=RTCPeerConnection id="event-iceconnectionstatechange" data-dfn-type=event>
              iceconnectionstatechange</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCPeerConnection}}'s [= ICE connection state =] has
              changed.
            </td>
          </tr>
          <tr>
            <td>
              <dfn data-dfn-for=RTCPeerConnection id="event-icegatheringstatechange" data-dfn-type=event>
              icegatheringstatechange</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCPeerConnection}}'s [= ICE gathering state =] has
              changed.
            </td>
          </tr>
          <tr>
            <td>
              <dfn data-dfn-for=RTCPeerConnection id="event-icecandidate" data-dfn-type=event>
              icecandidate</dfn>
            </td>
            <td>
              {{RTCPeerConnectionIceEvent}}
            </td>
            <td>
              A new {{RTCIceCandidate}} is made available to the script.
            </td>
          </tr>
          <tr>
            <td>
              <dfn data-dfn-for=RTCPeerConnection id="event-connectionstatechange" data-dfn-type=event>
              connectionstatechange</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCPeerConnection}}.{{RTCPeerConnection/connectionState}}
              has changed.
            </td>
          </tr>
          <tr>
            <td>
              <dfn data-dfn-for=RTCPeerConnection id="event-icecandidateerror" data-dfn-type=event>
              icecandidateerror</dfn>
            </td>
            <td>
              {{RTCPeerConnectionIceErrorEvent}}
            </td>
            <td>
              A failure occured when gathering ICE candidates.
            </td>
          </tr>
          <tr>
            <td>
              <dfn data-dfn-for=RTCPeerConnection id="event-datachannel" data-dfn-type=event>datachannel</dfn>
            </td>
            <td>
              {{RTCDataChannelEvent}}
            </td>
            <td>
              A new {{RTCDataChannel}} is dispatched to the script in response
              to the other peer creating a channel.
            </td>
          </tr>
        </tbody>
      </table>
      <p>
        The following events fire on {{RTCDTMFSender}} objects:
      </p>
      <table>
        <thead>
          <tr>
            <th>
              Event name
            </th>
            <th>
              Interface
            </th>
            <th>
              Fired when...
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <dfn  data-dfn-for=RTCDTMFSender id="event-RTCDTMFSender-tonechange" data-dfn-type=event>
              tonechange</dfn>
            </td>
            <td>
              {{RTCDTMFToneChangeEvent}}
            </td>
            <td data-tests="RTCDTMFSender-ontonechange-long.https.html">
              The {{RTCDTMFSender}} object has either just begun playout of a
              tone (returned as the {{RTCDTMFToneChangeEvent/tone}} attribute)
              or just ended the playout of tones in the
              {{RTCDTMFSender/toneBuffer}} (returned as an empty value in the
              {{RTCDTMFToneChangeEvent/tone}} attribute).
            </td>
          </tr>
        </tbody>
      </table>
      <p>
        The following events fire on {{RTCIceTransport}} objects:
      </p>
      <table>
        <thead>
          <tr>
            <th>
              Event name
            </th>
            <th>
              Interface
            </th>
            <th>
              Fired when...
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <dfn data-dfn-for=RTCIceTransport id="event-icetransport-statechange"  data-dfn-type=event>statechange</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCIceTransport}} state changes.
            </td>
          </tr>
          <tr>
            <td>
              <dfn data-dfn-for=RTCIceTransport id="event-icetransport-gatheringstatechange" data-dfn-type=event>gatheringstatechange</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCIceTransport}} gathering state changes.
            </td>
          </tr>
          <tr>
            <td>
              <dfn  data-dfn-for=RTCIceTransport id=
              "event-icetransport-selectedcandidatepairchange" data-dfn-type=event>selectedcandidatepairchange</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCIceTransport}}'s selected candidate pair changes.
            </td>
          </tr>
        </tbody>
      </table>
      <p>
        The following events fire on {{RTCDtlsTransport}} objects:
      </p>
      <table>
        <thead>
          <tr>
            <th>
              Event name
            </th>
            <th>
              Interface
            </th>
            <th>
              Fired when...
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <dfn data-dfn-for=RTCDtlsTransport id="event-dtlstransport-statechange" data-dfn-type=event>
              statechange</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCDtlsTransport}} state changes.
            </td>
          </tr>
          <tr>
            <td>
              <dfn data-dfn-for=RTCDtlsTransport data-dfn-type="event">error</dfn>
            </td>
            <td>
              {{RTCErrorEvent}}
            </td>
            <td>
              An error occurred on the {{RTCDtlsTransport}} (either
              {{RTCErrorDetailType/"dtls-failure"}} or
              {{RTCErrorDetailType/"fingerprint-failure"}}).
            </td>
          </tr>
        </tbody>
      </table>
      <p>
        The following events fire on {{RTCSctpTransport}} objects:
      </p>
      <table>
        <thead>
          <tr>
            <th>
              Event name
            </th>
            <th>
              Interface
            </th>
            <th>
              Fired when...
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <dfn data-dfn-for=RTCSctpTransport id="event-sctptransport-statechange" data-dfn-type=event>
              statechange</dfn>
            </td>
            <td>
              {{Event}}
            </td>
            <td>
              The {{RTCSctpTransport}} state changes.
            </td>
          </tr>
        </tbody>
      </table>
    </section>
    <section class="informative">
      <h2>
        Privacy and Security Considerations
      </h2>
      <p>
        This section is non-normative; it specifies no new behaviour, but
        instead summarizes information already present in other parts of the
        specification. The overall security considerations of the general set
        of APIs and protocols used in WebRTC are described in
        [[?RFC8827]].
      </p>
      <section>
        <h2>
          Impact on same origin policy
        </h2>
        <p>
          This document extends the Web platform with the ability to set up
          real-time, direct communication between browsers and other devices,
          including other browsers.
        </p>
        <p>
          This means that data and media can be shared between applications
          running in different browsers, or between an application running in
          the same browser and something that is not a browser, something that
          is an extension to the usual barriers in the Web model against
          sending data between entities with different origins.
        </p>
        <p>
          The WebRTC specification provides no user prompts or chrome
          indicators for communication; it assumes that once the Web page has
          been allowed to access media, it is free to share that media with
          other entities as it chooses. Peer-to-peer exchanges of data view
          WebRTC datachannels can thus occur without any user explicit consent
          or involvement, similarly as a server-mediated exchange (e.g. via Web
          Sockets) could occur without user involvement.
        </p>
      </section>
      <section>
        <h2>
          Revealing IP addresses
        </h2>
        <p>
          Even without WebRTC, the Web server providing a Web application will
          know the public IP address to which the application is delivered.
          Setting up communications exposes additional information about the
          browser’s network context to the web application, and may include the
          set of (possibly private) IP addresses available to the browser for
          WebRTC use. Some of this information has to be passed to the
          corresponding party to enable the establishment of a communication
          session.
        </p>
        <p>
          Revealing IP addresses can leak location and means of connection;
          this can be sensitive. Depending on the network environment, it can
          also increase the fingerprinting surface and create persistent
          cross-origin state that cannot easily be cleared by the user.
        </p>
        <p>
          A connection will always reveal the IP addresses proposed for
          communication to the corresponding party. The application can limit
          this exposure by choosing not to use certain addresses using the
          settings exposed by the {{RTCIceTransportPolicy}} dictionary, and by
          using relays (for instance TURN servers) rather than direct
          connections between participants. One will normally assume that the
          IP address of TURN servers is not sensitive information. These
          choices can for instance be made by the application based on whether
          the user has indicated consent to start a media connection with the
          other party.
        </p>
        <p>
          Mitigating the exposure of IP addresses to the application itself
          requires limiting the IP addresses that can be used, which will
          impact the ability to communicate on the most direct path between
          endpoints. Browsers are encouraged to provide appropriate controls
          for deciding which IP addresses are made available to applications,
          based on the security posture desired by the user. The choice of
          which addresses to expose is controlled by local policy (see
          [[RFC8828]] for details).
        </p>
      </section>
      <section>
        <h2>
          Impact on local network
        </h2>
        <p>
          Since the browser is an active platform executing in a trusted
          network environment (inside the firewall), it is important to limit
          the damage that the browser can do to other elements on the local
          network, and it is important to protect data from interception,
          manipulation and modification by untrusted participants.
        </p>
        <p>
          Mitigations include:
        </p>
        <ul>
          <li>A user agent will always request permission from the
          correspondent user agent to communicate using ICE. This ensures that
          the user agent can only send to partners who you have shared
          credentials with.
          </li>
          <li>A user agent will always request ongoing permission to continue
          sending using ICE continued consent. This enables a receiver to
          withdraw consent to receive.
          </li>
          <li>A user agent will always encrypt data, with strong per-session
          keying (DTLS-SRTP).
          </li>
          <li>A user agent will always use congestion control. This ensures
          that WebRTC cannot be used to flood the network.
          </li>
        </ul>
        <p>
          These measures are specified in the relevant IETF documents.
        </p>
      </section>
      <section>
        <h2>
          Confidentiality of Communications
        </h2>
        <p>
          The fact that communication is taking place cannot be hidden from
          adversaries that can observe the network, so this has to be regarded
          as public information.
        </p>
        <p>
          Communication certificates may be opaquely shared using
          {{MessagePort/postMessage(message, options)}} in anticipation of future needs. User
          agents are strongly encouraged to isolate the private keying material
          these objects hold a handle to, from the processes that have access
          to the {{RTCCertificate}} objects, to reduce memory attack surface.
        </p>
      </section>
      <section>
        <h2>
          Persistent information exposed by WebRTC
        </h2>
        <p>
          As described above, the list of IP addresses exposed by the WebRTC
          API can be used as a persistent cross-origin state.
        </p>
        <p>
          Beyond IP addresses, the WebRTC API exposes information about the
          underlying media system via the
          {{RTCRtpSender}}.{{RTCRtpSender/getCapabilities}} and
          {{RTCRtpReceiver}}.{{RTCRtpReceiver/getCapabilities}} methods,
          including detailed and ordered information about the codecs that the
          system is able to produce and consume. A subset of that information
          is likely to be represented in the SDP session descriptions
          generated, exposed and transmitted during <a href=
          "#session-negotiation-model">session negotiation</a>. That
          information is in most cases persistent across time and origins, and
          increases the fingerprint surface of a given device.
        </p>
        <p>
          When establishing DTLS connections, the WebRTC API can generate
          certificates that can be persisted by the application (e.g. in
          IndexedDB). These certificates are not shared across origins, and get
          cleared when persistent storage is cleared for the origin.
        </p>
      </section>
      <section>
        <h2>
          Setting SDP from remote endpoints
        </h2>
        <p>
          {{RTCPeerConnection/setRemoteDescription}} guards against malformed
          and invalid SDP by throwing exceptions, but makes no attempt to guard
          against SDP that might be unexpected by the application. Setting the
          remote description can cause significant resources to be allocated
          (including image buffers and network ports), media to start flowing
          (which may have privacy and bandwidth implications) among other
          things. An application that does not guard against malicious SDP
          could be at risk of resource deprivation, unintentionally allowing
          incoming media or at risk of not having certain events fire like
          {{RTCPeerConnection/ontrack}} if the other endpoint does not
          negotiate sending. Applications need to be on guard against
          malevolent SDP.
        </p>
      </section>
    </section>
    <section class="informative">
      <h2>
        Accessibility Considerations
      </h2>
      <p>
        The WebRTC 1.0 specification exposes an API to control protocols
        (defined within the IETF) necessary to establish real-time audio, video
        and data exchange.
      </p>
      <p>
        The Telecommunications Device for the Deaf (TDD/TTY) enables
        individuals who are hearing or speech impaired (among others) to
        communicate over telephone lines. Real-Time Text, defined in
        [[RFC4103]], utilizes T.140 encapsulated in RTP to enable the
        transition from TDD/TTY devices to IP-based communications, including
        emergency communication with <a href=
        "https://www.ecfr.gov/cgi-bin/text-idx?SID=ada7cebd65433a9e05c35426a2bc76b8&amp;mc=true&amp;node=pt47.3.67&amp;rgn=div5">
        Public Safety Access Points (PSAP)</a>.
      </p>
      <p>
        Since Real-Time Text requires the ability to send and receive data in
        near real time, it can be best supported via the WebRTC 1.0 data
        channel API. As defined by the IETF, the data channel protocol utilizes
        the SCTP/DTLS/UDP protocol stack, which supports both reliable and
        unreliable data channels. The IETF chose to standardize SCTP/DTLS/UDP
        over proposals for an RTP data channel which relied on SRTP key
        management and were focused on unreliable communications.
      </p>
      <p>
        Since the IETF chose a different approach than the RTP data channel as
        part of the WebRTC suite of protocols, as of the time of this
        publication there is no standardized way for the WebRTC APIs to
        directly support Real-Time Text as defined at IETF and implemented in
        U.S. (FCC) regulations. The WebRTC working Group will evaluate whether
        the developing IETF protocols in this space warrant direct exposure in
        the browser APIs and is looking for input from the relevant user
        communities on this potential gap.
      </p>
      <p>
        Within the <a href="https://datatracker.ietf.org/wg/mmusic/">IETF MMUSIC
        Working Group</a>, work is ongoing to enable <a href=
        "https://datatracker.ietf.org/doc/html/draft-holmberg-mmusic-t140-usage-data-channel">
        Real-time text to be sent over the WebRTC data channel</a>, allowing
        gateways to be deployed to translate between the SCTP data channel
        protocol and RFC 4103 Real-Time Text. This work, once completed, is
        expected to enable a unified and interoperable approach for integrating
        real-time text in WebRTC user-agents (including browsers) - through a
        gateway or otherwise.
      </p>
      <p>
        At the time of this publication, gateways that enable effective RTT
        support in WebRTC clients can be developed e.g. through a custom WebRTC
        data channel. This is deemed sufficient until such time as future
        standardized gateways are enabled via IETF protocols such as the SCTP
        data channel protocol and RFC 4103 Real-Time Text. This will need to be
        defined at IETF in conjunction with related work at W3C groups to
        effectively and consistently standardise RTT support internationally.
      </p>
    </section>
    <section class="appendix">
      <h2>
        Acknowledgements
      </h2>
      <p>
        The editors wish to thank the Working Group chairs and Team Contact,
        Harald Alvestrand, Stefan Håkansson, Erik Lagerway and Dominique
        Hazaël-Massieux, for their support. Substantial text in this
        specification was provided by many people including Martin Thomson,
        Harald Alvestrand, Justin Uberti, Eric Rescorla, Peter Thatcher,
        Jan-Ivar Bruaroey and Peter Saint-Andre. Dan Burnett would like to
        acknowledge the significant support received from Voxeo and Aspect
        during the development of this specification.
      </p>
      <p>
        The {{RTCRtpSender}} and {{RTCRtpReceiver}} objects were initially
        described in the <a href="https://www.w3.org/community/ortc/">W3C ORTC
        CG</a>, and have been adapted for use in this specification.
      </p>
    </section>
  </body>
</html>
