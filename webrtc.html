<!DOCTYPE html>
<html lang="en">

  <head>
    <link href="./webrtc.css" rel="stylesheet" type="text/css" />

    <title>WebRTC 1.0: Real-time Communication Between
    Browsers</title>

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

    <!--
     === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline.

      To tag a new releas in git hub

          Once the version is checked in and ready to go, you tag it with (need
          to chance the 20110823 to correct date )

               git tag -a v20120323 -m "This is release 20120323"

         Tags are not transferred by default with the push so you have to
         add a - -tags parameter to the push so it looks like. Note you need to
         remoce the space between the - and -tag to make a double dash. 

              git push - -tags 

         or alternatively you can push just the new tag with 

              git push origin v20120323


      To generate the dated version of the specification:

           Open this doc in Mozilla. 

           Do a CTRL-ALT-SHIFT-S

           Select "XHMTL( source)" from dialog box. This will pop a new tab with
           generated version of the document.

           This will open a new tab with generated html. Copy and paste this to
           a new file. Note if you use Chrome or Safari, this step will not
           work. What will happen is the paste will have the original document,
           not what was displayed in the window that you did the copy on.

           Rename the new file to the correct day such as
           webrtc-broken-20111003.html then search for and edit the links for
           "This version" and "Previos version". Add the new file into CVS and
           check in. 

           Once everyone is happy, the webrtc-broken.html and
           webrtc-broken-20111003.html files can be copied to
           webrtc.html and webrtc-20111003.html
           respectively in the ../editor/. directory. 
    -->
    <script class="remove" src="http://www.w3.org/Tools/respec/respec-w3c-common" type="text/javascript">
      <!-- keep this comment -->
    </script>

    <script class="remove" src="webrtc.js" type="text/javascript">
     // keep this comment
    </script>
  </head>

  <body>
    <section id="abstract">
      <p>This document defines a set of APIs to represent streaming media,
      including audio and video, in JavaScript, to allow media to be sent over
      the network to another browser or device implementing the appropriate
      set of real-time protocols, and media received from another browser or
      device to be processed and displayed locally. This specification is
      being developed in conjunction with a protocol specification developed
      by the IETF RTCWEB group and an API specification to get access to local
      media devices developed by the Media Capture Task Force.</p>
    </section>

    <section id="conformance">
      <p> Implementations that use ECMAScript to implement the APIs defined in
      this specification must implement them in a manner consistent with the
      ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]], as
      this specification uses that specification and terminology. </p>
    </section>

    <section id="sotd">
      <p>This document is not complete. It is subject to major changes and,
      while early experimentation is encouraged, it is therefore not
      intended for implementation. The API is based on preliminary work done
      in the WHATWG. The Web Real-Time Communications Working Group expects
      this specification to evolve significantly based on:</p>

      <ul>
        <li>The outcome of ongoing exchanges in the companion RTCWEB group at
        IETF to define the set of protocols that, together with this document,
        will enable real-time communications in Web browsers.</li>

        <li>Privacy issues that arise when exposing local capabilities and
        local streams.</li>

        <li>Technical discussions within the group, on the data channel in
        particular.</li>

        <li>Experience gained through early experimentations.</li>

        <li>Feedback received from other groups and individuals.</li>
      </ul>
    </section>

    <section class="informative" id="intro">
      <h2>Introduction</h2>

      <p>There are a number of facets to video-conferencing in HTML covered by
      this specification:</p>

      <ul>
        <li>Representing a multimedia stream (video, audio, or both) from
        local devices (video cameras, microphones, Web cams) or from
        prerecorded files provided by the user.</li>

        <li>Connecting to remote peers using NAT-traversal technologies such
        as ICE, STUN, and TURN.</li>

        <li>Sending the locally-produced streams to remote peers and receiving
        streams from remote peers.</li>

        <li>Sending arbitrary data directly to remote peers.</li>
      </ul>

      <p>This document defines the APIs used for these features. This
      specification is being developed in conjunction with a protocol
      specification developed by the <a
      href="http://datatracker.ietf.org/wg/rtcweb/">IETF RTCWEB group</a> and
      an API specification to get access to local media devices developed by
      the <a href="http://www.w3.org/2011/04/webrtc/">Media Capture Task
      Force</a>.</p>
    </section>

    <section>
      <h2>Network Stream API</h2>

      <section>
        <h3>Introduction</h3>

        <p>The <code>MediaStream</code> interface, as defined in the
        [[!GETUSERMEDIA]] specification, typically represents a stream of data
        of audio and/or video. A <code>MediaStream</code> may be extended to represent a
        stream that either comes from or is sent to a remote node (and not
        just the local camera, for instance). The extensions required to
        enable this capability on the <code>MediaStream</code> object will be
        described in this document.</p>

        <p>A <code>MediaStream</code> as defined in [[!GETUSERMEDIA]] may
        contain zero or more <code>MediaStreamTrack</code> objects. A
        <code>MediaStreamTrack</code> sent to another peer will appear as one
        and only one <code>MediaStreamTrack</code> to the recipient.</p>

        <p>Channels are the smallest unit considered in the
        <code>MediaStream</code> specification. Channels are intended to be
        encoded together for transmission as, for instance, an RTP payload
        type. All of the channels that a codec needs to encode jointly MUST be
        in the same <code>MediaStreamTrack</code> and the codecs SHOULD be
        able to encode, or discard, all the channels in the track.</p>

        <p>The concepts of an input and output to a given
        <code>MediaStream</code> apply in the case of <code>MediaStream</code>
        objects transmitted over the network as well. A <code>
            <a>MediaStream</a>
          </code> created by a <code>
            <a>PeerConnection</a>
          </code> object (later described in this document) will take as input
        the data received from a remote peer. Similarly, a
        <code>MediaStream</code> from a local source, for instance a camera
        via [[!GETUSERMEDIA]] will have an output that represents what is
        transmitted to a remote peer if the object is used with a <code>
            <a>PeerConnection</a>
          </code> object.</p>

        <p>The concept of duplicating <code>MediaStream</code> objects as
        described in [[!GETUSERMEDIA]] is also applicable here. This feature
        can be used, for instance, in a video-conferencing scenario to display
        the local video from the user’s camera and microphone in a local
        monitor, while only transmitting the audio to the remote peer (e.g. in
        response to the user using a "video mute" feature). Combining tracks
        from different <code>
            <a>MediaStream</a>
          </code> objects into a new <code>
            <a>MediaStream</a>
          </code> is useful in certain cases.</p>
      </section>

      <section>
        <h3>Interface definitions</h3>

        <p class="note">In this section, we only specify aspects of the the
        following objects that are relevant when used along with a
        <code>PeerConnection</code>. Please refer to the original definitions
        of the objects in the [[!GETUSERMEDIA]] document for general
        information on using <code>MediaStream</code> and
        <code>MediaStreamTrack</code> both in and outside the context of
        <code>PeerConnection</code>.</p>

        <section>
          <h4>MediaStream</h4>

          <section>
            <h4>label</h4>

            <p>The <code>label</code> attribute specified in
            <code>MediaStream</code> returns a label that is unique to this
            stream, so that streams can be recognized after they are sent
            through the <code>
                <a href="#peerconnection">PeerConnection</a>
              </code> API.</p>

            <p>When a <code>
                <a href="#mediastream">MediaStream</a>
              </code> is created to represent a stream obtained from a remote
            peer, the <code>label</code> attribute is initialized from
            information provided by the remote source.</p>

            <p class="note">The label of a <code>
                <a>MediaStream</a>
              </code> object is unique to the source of the stream, but that
            does not mean it is not possible to end up with duplicates. For
            example, a locally generated stream could be sent from one user to
            a remote peer using <code>
                <a>PeerConnection</a>
              </code>, and then sent back to the original user in the same
            manner, in which case the original user will have multiple streams
            with the same label (the locally-generated one and the one
            received from the remote peer).</p>
          </section>

          <section>
            <h4>Events on MediaStream</h4>

            <p>A new media component may be associated with an existing <code>
                <a>MediaStream</a>
              </code>. This happens, e.g., on the A-side when the B-side adds
            a new <code>
                <a>MediaStreamTrack</a>
              </code> object to one of the track lists of a <code>
                <a>MediaStream</a>
              </code> that is being sent over a <code>
                <a>PeerConnection</a>
              </code>. If this happens for the reason exemplified, or for any
            other reason than the <code>add()</code> [[!GETUSERMEDIA]] method
            being invoked locally on a <code>
                <a>MediaStreamTrackList</a>
              </code> or tracks are being added as the stream is created (i.e.
            the stream is initialized with tracks), the user agent MUST run
            the following steps:</p>

            <ol>
              <li>
                <p>Create a <code>
                    <a>MediaStreamTrack</a>
                  </code> object <var>track</var> to represent the new media
                component.</p>
              </li>

              <li>
                <p>If <var>track’s</var> <code>
                    <a href="#dom-mediastreamtrack-kind">kind</a>
                  </code> attribute equals "<code>audio</code>", add it to the
                <code>
                    <a>MediaStream</a>
                  </code> object’s <code>
                    <a href="#dom-mediastream-audiotracks">audioTracks</a>
                  </code> <code>
                    <a>MediaStreamTrackList</a>
                  </code> object. [[OPEN ISSUE: Is there a way to generalize this
		so that if we add a "smell" track this continues to work.]]</p>
              </li>

              <li>
                <p>If <var>track’s</var> <code>
                    <a href="#dom-mediastreamtrack-kind">kind</a>
                  </code> attribute equals "<code>video</code>", add it to the
                <code>
                    <a>MediaStream</a>
                  </code> object’s <code>
                    <a href="#dom-mediastream-videotracks">videoTracks</a>
                  </code> <code>
                    <a>MediaStreamTrackList</a>
                  </code> object.</p>
              </li>

              <li>
                <p><a>Fire a track event</a> named <code>
                    <a
                    href="#event-mediastreamtracklist-addtrack">addtrack</a>
                  </code> with the newly created <var>track</var> at the <code>
                    <a>MediaStreamTrackList</a>
                  </code> object.</p>
              </li>
            </ol>

            <p>An existing media component may also be disassociated from a
            <code>
                <a>MediaStream</a>
              </code>. If this happens for any other reason than the
            <code>remove()</code> [[!GETUSERMEDIA]] method being invoked
            locally on a <code>
                <a>MediaStreamTrackList</a>
              </code> or the stream is being destroyed, the user agent MUST
            run the following steps:</p>

            <ol>
              <li>
                <p>Let <var>track</var> be the <code>
                    <a>MediaStreamTrack</a>
                  </code> object representing the media component about to be
                removed.</p>
              </li>

              <li>
                <p>Remove <var>track</var> from the <code>
                    <a>MediaStreamTrackList</a>
                  </code> object.</p>
              </li>

              <li>
                <p><a>Fire a track event</a> named <code>
                    <a
                    href="#event-mediastreamtracklist-removetrack">removetrack</a>
                  </code> with <var>track</var> at the <code>
                    <a>MediaStreamTrackList</a>
                  </code> object.</p>
              </li>
            </ol>

            <p>The event source for the <code>onended</code> event in the
            networked case is the <code>PeerConnection</code> object.</p>
          </section>
        </section>

        <section>
          <h4>MediaStreamTrack</h4>

          <p>A <code>MediaStreamTrack</code> object’s reference to its
          <code>MediaStream</code> in the non-local media source case (an RTP
          source, as is the case for a <code>MediaStream</code> received over
          a <code>PeerConnection</code>) is always strong.</p>

          <p>When a track belongs to a <code>
              <a>MediaStream</a>
            </code> that comes from a remote peer and the remote peer has
          permanently stopped sending data the <code>ended</code> event MUST
          be fired on the track, as specified in [[!GETUSERMEDIA]].
	  [[ OPEN ISSUE: How do you know when it has stopped? This seems like
	  an SDP question, not a media-levelquestion.]]</p>

          <p>A track in a <code>
              <a>MediaStream</a>
            </code>, received with a <code>
              <a>PeerConnection</a>
            </code>, MUST have its <code>readyState</code> attribute
          [[!GETUSERMEDIA]] set to <code>
              <a href="#widl-MediaStreamTrack-MUTED">MUTED</a>
            </code> (1) until media data arrives.</p>

          <p>In addition, a <code>MediaStreamTrack</code> has its
          <code>readyState</code> set to <code>MUTED</code> on the B-side if
          the A-side disables the corresponding <code>
              <a>MediaStreamTrack</a>
            </code> in the <code>
              <a>MediaStream</a>
            </code> that is being sent. When the addstream event triggers on a
          <code>
              <a>PeerConnection</a>
            </code>, all <code>
              <a>MediaStreamTrack</a>
            </code> objects in the resulting <code>
              <a>MediaStream</a>
            </code> are muted until media data can be read from the RTP
          source.
	  [[ OPEN ISSUE: How do you know when it has been disabled? This seems like
	  an SDP question, not a media-levelquestion.]]
	  </p>
        </section>
      </section>

      <section>
        <h4>AudioMediaStreamTrack</h4>

        <p>The <code>
            <a>AudioMediaStreamTrack</a>
          </code> is a specialization of of a normal <code>
            <a>MediaStreamTrack</a>
          </code> that only carries audio and is extended to have the
        capability to send and/or receive DTMF codes.</p>

        <dl class="idl"
            title="interface AudioMediaStreamTrack : MediaStreamTrack">
          <dt>readonly attribute boolean canInsertDTMF</dt>

          <dd>
            <p>The <dfn id="dom-audiomediastreamtrack-caninsertdtmf">
                <code>canInsertDTMF</code>
              </dfn> attribute MUST indicate if the <code>
                <a>AudioMediaStreamTrack</a>
              </code> is capable of sending DTMF.</p>
          </dd>

          <dt>void insertDTMF(in DOMString tones, optional long duration)</dt>

          <dd>
            <p>When a <code>
                <a>AudioMediaStreamTrack</a>
              </code> object’s <dfn id="dom-AudioMediaStreamTrack-insertDTMF">
                <code>insertDTMF()</code>
              </dfn> method is invoked, the user agent MUST queue a task that
            that sends the DTMF tones.</p>

            <p>The tone parameters is treated as a series of characters. The
            characters 0 to 9, A to D, #, and * generated the associated DTMF
            tones. The characters a to d are equivalent to A to D. The
            character , indicates a an delay of 2 seconds before processing
            the next character in the tones parameter. Unrecognized characters
            are ignored.</p>

            <p>The duration parameters indicates the duration in ms to play
            the each DTMF passed in the tones parameters. The duration can not
            be more than 6000 or less than 70. The default duration is 100 ms
            for each tone. The gap between tones MUST be at least 50 ms but
            should be as short as possible. [[OPEN ISSUE: How are invalid values
	    handled?]]</p>

            <p>If insertDTMF is called on the same object while an existing
            task for this object is generate DTMF is still running, the
            previous task is canceled. Calling insertDTMF with an empty tones
            parameter can be used to cancel any tones currently being
            send.</p>

            <p class="note">Editor Note: We need to add a callback that is set
            on the object that is called after the tones are sent. This is
            needed to allow the application to know when it can send new tones
            without canceling the tones that are currently being sent.</p>

            <p class="note">Editor Note: It seems we would want a callback or
            event for incoming tones. The proposal sent to the list had them
            played as audio to the speaker but I don’t see how that is
            useful.</p>
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h2>Peer-to-peer connections</h2>

      <p>A <code>
          <a>PeerConnection</a>
        </code> allows two users to communicate directly, browser to browser.
      Communications are coordinated via a signaling channel which is provided
      by unspecified means, but generally by a script in the page via the server,
      e.g. using <code>XMLHttpRequest</code>.</p>

      <p>Calling <code>new <a>PeerConnection</a>(<var>configuration</var>
      )</code> creates a <code>
          <a>PeerConnection</a>
        </code> object.</p>

      <p>The <var>configuration</var> has the information to find and access
      the [[!STUN]] and [[!TURN]] servers. There may be multiple servers of
      each type and any TURN server also acts as a STUN server. </p>

      <p>A PeerConnection object has an associated ICE Agent, PeerConnection
      state, and ICE State. These are initialized when the object is
      created.</p>

      <p>When the <dfn id="dom-peerconnection">
          <code>PeerConnection()</code>
        </dfn> constructor is invoked, the user agent MUST run the following
      steps. This algorithm has a synchronous section (which is triggered as
      part of the event loop algorithm).</p>

      <ol>
        <li>
          <p>Create an ICE Agent and let <var>connection</var>’s <a
          href="#peerconnection-ice-agent"><code>PeerConnection</code> ICE
          Agent</a> be that ICE Agent and provide it the STUN and TURN servers
          from the configuration array. The [[!ICE]] will proceed with
          gathering as soon as the IceTransports constraint is not set to
          "none". At this point the ICE Agent does not know how many 
	  ICE components it needs (and hence the number of candidates to
	  gather) but it can make a reasonable
          assumption and as the PeerConnection object gets more information,
          it can adjust the number of components. </p>
        </li>

        <li>
          <p>Set <var>connection</var>’s <a
          href="#peerconnection-readiness-state"><code>PeerConnection</code>
          readiness state</a> to <code>
              <a href="#widl-PeerConnection-NEW">"new"</a>
            </code>. </p>
        </li>

        <li>
          <p>Set <var>connection</var>’s <a
          href="#peerconnection-readiness-state"><code>PeerConnection</code>
          ice state </a> to <code>
              <a href="#widl-PeerConnection-NEW">"new"</a>
            </code>. </p>
        </li>

        <li>
          <p>Let <var>connection</var>’s <code
              title="dom-PeerConnection-localStreams">
              <a href="#widl-PeerConnection-localStreams">localStreams</a>
            </code> attribute be an empty read-only <code>
              <a>MediaStream</a>
            </code> array. </p>
        </li>

        <li>
          <p>Let <var>connection</var>’s <code
              title="dom-PeerConnection-remoteStreams">
              <a href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
            </code> attribute be an empty read-only <code>
              <a>MediaStream</a>
            </code> array. </p>
        </li>

        <li>
          <p>Return <var>connection</var>, but continue these steps
          asynchronously.</p>
        </li>

        <li>
          <p>Await a stable state. The synchronous section consists of the
          remaining steps of this algorithm. </p>
        </li>
      </ol>

      <p> During the lifetime of the PeerConnection object, the following
      procedures are followed: </p>

      <ol>
        <li>
          <p>If the ice state is "new" and the IceTransports constraint
          is not set to "none", it MUST queue a task to start gathering ICE
          address and set the ice state to "gathering".</p>
        </li>

        <li>
          <p> If the ICE Agent has found one or more candidate pairs for any
          MediaTrack that forms a valid connection, the ICE state is changed
          to "connected". </p>
        </li>

        <li>
          <p> When the ICE Agent finishes checking all candidate pairs, if at least
          one connection has been found for some MediaTrack, the iceState is
          changed to "completed" and if no connection has been found for any
          MediaTrack, the iceState is changed to "failed". 
	  [[OPEN ISSUE: Note that this means that if I was able to negotiate
	    audio but not video via ICE, then iceState == "completed". Is this
	    really what is desired?]]
	  </p>
        </li>

        <li>
          <p> If the iceState is "connected" or "completed" and both the local
          and remote session descriptions are set, the peerState is set to
          "active". </p>
        </li>

        <li>
          <p> If the iceState is "failed", a task is queued to calls the close
          method. Open Issue: CJ - this seems wrong to me. </p>
        </li>
      </ol>

      <p>User agents negotiate the codec resolution, bitrate, and other media
      parameters. User agents are encouraged to initially negotiate for the
      maximum resolution of a video stream. For streams that are then rendered
      (using a <code>video</code> element), user agents are encouraged to
      renegotiate for a resolution that matches the rendered display size.</p>

      <p class="note">Starting with the native resolution means that if the
      Web application notifies its peer of the native resolution as it starts
      sending data, and the peer prepares its <code>video</code> element
      accordingly, there will be no need for a renegotiation once the stream
      is flowing.</p>

      <!--
      <p>All SDP media descriptions for RTP flows represented by <code>
          <a>MediaTrack</a>
        </code> objects MUST include a label attribute ("<code
      title="">a=label:</code>") whose value is the value of the <code>
          <a>MediaStream</a>
        </code> object's <code title="dom-MediaStream-label">
          <a href="#dom-mediastream-label">label</a>
        </code> attribute. [[!SDP]] [[!SDPLABEL]]</p>

      <p><a href="#peerconnection"><code>PeerConnection</code>s</a> MUST not
      generate any candidates for media streams whose media descriptions do
      not have a label attribute ("<code>a=label:</code>"). [[!ICE]] [[!SDP]]
      [[!SDPLABEL]]  (Note: CJ - I have no idea why this is here) </p>
      -->

      <p> The word "components" in this context refers to an RTP media flow
      and does not have anything to do with how [[ICE]] uses the term
      "component". </p>

      <p>When a user agent has reached the point where a <code>
          <a>MediaStream</a>
        </code> can be created to represent incoming components, the user
      agent MUST run the following steps:</p>

      <ol>
        <li>
          <p>Let <var>connection</var> be the <code>
              <a>PeerConnection</a>
            </code> expecting this media.</p>
        </li>

        <li>
          <p>Create a <code>
              <a>MediaStream</a>
            </code> object to represent the media stream.
        <!-- Set its <code>
              <a href="#dom-mediastream-label">label</a>
            </code> attribute to the value of the SDP Label attribute for that
          component's media stream. -->
	    [[OPEN ISSUE: What if one already exists?]]
	  </p>
        </li>

        <li>
          <p>Run the following steps for each component in the media
          stream.</p>

          <ol>
            <li>
              <p>Create a <code>
                  <a>MediaStreamTrack</a>
                </code> object <var>track</var> to represent the
              component.
		[[EDITORIAL: Can we just reference 3.2.1.2 here?]]
	      </p>
            </li>

            <li>
              <p>If <var>track's</var> <code>
                  <a href="#dom-mediastreamtrack-kind">kind</a>
                </code> attribute equals "<code>audio</code>", add it to the
              <code>
                  <a>MediaStream</a>
                </code> object's <code>
                  <a href="#dom-mediastream-audiotracks">audioTracks</a>
                </code> <code>
                  <a>MediaStreamTrackList</a>
                </code> object.</p>
            </li>

            <li>
              <p>If <var>track's</var> <code>
                  <a href="#dom-mediastreamtrack-kind">kind</a>
                </code> attribute equals "<code>video</code>", add it to the
              <code>
                  <a>MediaStream</a>
                </code> object's <code>
                  <a href="#dom-mediastream-videotracks">videoTracks</a>
                </code> <code>
                  <a>MediaStreamTrackList</a>
                </code> object.</p>
            </li>
          </ol>

           <p class="note">
	    The creation of new incoming <code>MediaStream</code>s may be
	    triggered either by SDP negotiation or by the receipt of
	    media on a given flow.
	  <!--  [[OPEN ISSUE: How many <code>MediaStream</code>s are created
	    when you receive multiple conflicting pranswers?]] -->
	  </p>
          
          <p class="note">The internal order in the <code>
              <a>MediaStreamTrackList</a>
            </code> objects on the receiving side should reflect the order on
          the sending side. One way to enforce this is to specify the order in
          the SDP.</p>
        </li>

        <li>
          <p>Queue a task to run the following substeps:</p>

          <ol>
            <li>
              <p>If the <var>connection</var>’s <a
              href="#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> is <code>
                  <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                </code> (3), abort these steps.</p>
            </li>

            <!-- close() was probably called just before this
     task ran -->

            <li>
              <p>Add the newly created <code>
                  <a>MediaStream</a>
                </code> object to the end of <var>connection</var>’s <code
                  title="dom-PeerConnection-remoteStreams">
                  <a
                  href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
                </code> array.</p>
            </li>

            <li>
              <p><a href="#fire-a-stream-event">Fire a stream event</a> named
              <code title="event-MediaStream-addstream">
                  <a href="#event-mediastream-addstream">addstream</a>
                </code> with the newly created <code>
                  <a>MediaStream</a>
                </code> object at the <var title="">connection</var> object.
              </p>
            </li>
          </ol>
        </li>
      </ol>

      <p>When a user agent has negotiated media for a component that belongs
      to a media stream that is already represented by an existing <code>
          <a>MediaStream</a>
        </code> object, the user agent MUST associate the component with that
      <code>
          <a>MediaStream</a>
        </code> object.</p>

      <p>When a <a href="#peerconnection">
          <code>PeerConnection</code>
        </a> finds that a stream from the remote peer has been removed <!-- (its
      port has been set to zero in a media description sent on the signaling
      channel), -->, the user agent MUST follow these steps:</p>

      <ol>
        <li>
          <p>Let <var>connection</var> be the <code>
              <a>PeerConnection</a>
            </code> associated with the stream being removed.</p>
        </li>

        <li>
          <p>Let <var>stream</var> be the <code>
              <a>MediaStream</a>
            </code> object that represents the media stream being removed, if
          any. If there isn't one, then abort these steps.</p>
        </li>

        <li>
          <p>By definition, <var>stream</var> is now <a>finished</a>.</p>

          <p class="note">A <span title="concept-task">task</span> is thus
          <span title="queue a task">queued</span> to update <var>stream</var>
          and fire an event.</p>
        </li>

        <li>
          <p>Queue a task to run the following substeps:</p>

          <ol>
            <li>
              <p>If the <var>connection</var>’s <a
              href="#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> is <code>
                  <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                </code> (3), abort these steps.</p>
            </li>

            <!-- close() was probably called just before this
     task ran -->

            <li>
              <p>Remove <var>stream</var> from <var>connection</var>’s <code>
                  <a
                  href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
                </code> array.</p>
            </li>

            <li>
              <p><a href="#fire-a-stream-event">Fire a stream event</a> named
              <code title="event-MediaStream-removestream">
                  <a href="#event-mediastream-removestream">removestream</a>
                </code> with <var title="">stream</var> at the
              <var>connection</var> object.</p>
            </li>
          </ol>
        </li>
      </ol>

      <p>The task source for the <span title="concept-task">tasks</span>
      listed in this section is the networking task source.</p>

      <p>If something in the browser changes that causes the <code>
          <a>PeerConnection</a>
        </code> object to need to initiate a new session descipriton
      negotiation, an <code>
          <a href="#event-renegotiation">renegotiationneeded</a>
        </code> event is fired at the <code>
          <a>PeerConnection</a>
        </code> object. </p>

      <p>In particular, if a <code>
          <a>PeerConnection</a>
        </code> object is <a title="consumer">consuming</a> a <code>
          <a>MediaStream</a>
        </code> and a track is added to one of the stream's <code>
          <a>MediaStreamTrackList</a>
        </code> objects, by, e.g., the <code>
          <a href="#dom-mediastreamtracklist-add">add()</a>
        </code> method being invoked, the <code>
          <a>PeerConnection</a>
        </code> object MUST fire the "renegotiationneeded" event. Removal
      of media components must also trigger "renegotianneeded".</p>


      <p class="warning">To prevent network sniffing from allowing a fourth
      party to establish a connection to a peer using the information sent
      out-of-band to the other peer and thus spoofing the client, the
      configuration information SHOULD always be transmitted using an
      encrypted connection.</p>

      <section>
        <h3>PeerConnection</h3>

        <p> The general operation of the PeerConnection is described in
        [[RTCWEB-JSEP]]. </p>

        <section>
          <h3>SdpType</h3>

          <p> The SdpType enums serve as arguments to setLocalDescription and
          setRemoteDescription. They provide information as to how the SDP
          should be handled. </p>


          <pre> enum SdpType { "offer", "pranswer", "answer" } </pre>

      
          <!-- <dl class='idl' title='enum SdpType { "offer", "pranswer",  "answer" }'> </dl>-->

          <dl>
            <dt>
              <code title="widl-SdpType-offer">
                <a href="#widl-SdpType-offer">"offer"</a>
              </code>
            </dt>

            <dd>
              <p> An SdpType of "offer" indicates that a description should be
              treated as an [[!SDP]] offer. </p>
            </dd>

            <dt>
              <code title="widl-SdpType-pranswer">
                <a href="#widl-SdpType-pranswer">"pranswer"</a>
              </code>
            </dt>

            <dd>
              <p> An SdpType of "pranswer" indicates that a description should
              be treated as an [[!SDP]] answer, but not a final answer. A
              description used as a SDP "pranswer" may be applied as a
              response to a SDP offer, or an update to a previously sent SDP
              "pranswer". </p>
            </dd>

            <dt>
              <code title="widl-SdpType-answer">
                <a href="#widl-SdpType-answer">"answer"</a>
              </code>
            </dt>

            <dd>
              <p> An SdpType of "answer" indicates that a description should
              be treated as an [[!SDP]] final answer, and the offer-answer
              exchange should be considered complete. A description used as a
              SDP answer may be applied as a response to a SDP offer, or an
              update to a previously send SDP "pranswer". </p>
            </dd>
          </dl>
        </section>

        <section>
          <h3> SessionDescription Class </h3>

          <p>The <dfn id="dom-sessiondescription">
              <code>SessionDescription()</code>
            </dfn> constructor takes one argument, <var>description</var>,
          whose content is used to construct the new <code>
              <a>SessionDescription</a>
            </code> object. This class is a future extensible carrier
              for for the data contained in it and does not perform any
              substantive processing. </p>

          <dl class="idl"
              title="[Constructor (DOMString description)] interface SessionDescription">
            <dt>attribute SdpType type</dt>

            <dd>What type of SDP this SessionDescription represents.</dd>

            <dt>attribute DOMString sdp</dt>

            <dd>The string representation of the SDP [[!SDP]]</dd>

            <!-- FIXME: this syntax is not fully supported by ReSpec -->

            <dt>stringifier DOMString ()</dt>

            <dd>
              <p>Objects that implement the <code>
                  <a>SessionDescription</a>
                </code> interface must stringify as [[!SDP]]. </p>
            </dd>
          </dl>
        </section>

        <section>
          <h3> SessionDescriptionCallback </h3>

        <pre> callback SessionDescriptionCallback = void (SessionDescription
          sdp) </pre> 

          <dl>
            <!-- dl title='callback SessionDescriptionCallback = void' class='idl' -->

            <dt>SessionDescription sdp</dt>

            <dd>The object containing the SDP [[!SDP]]. </dd>
          </dl>
        </section>

        <section>
          <h3> PeerConnectionErrorCallback </h3>

         <pre> callback PeerConnectionErrorCallback = void (DOMString errorInformation)
          </pre> 

          <dl>
            <!--  dl title='callback PeerConnectionErrorCallback = void' class='idl' -->

            <dt>DOMString errorInformation</dt>

            <dd>Information about what went wrong. Open Issue: How does this
          work? Is it human readable? I18N? ENUM? </dd>
          </dl>

          <p> TODO: Open Issue: should this be defined as event like
          NavigatorUserMediaErrorCallback in getusermedia </p>
        </section>

        <section>
          <h3> PeerState Enum </h3>

         <pre>enum PeerState { "new" "opening", "active", "closing", "closed"
          }</pre> 

          <!--  <dl  title='enum PeerState { "new" "opening","active", "closing", "closed" }' class='idl' > </dl> -->

          <dl>
            <dt>
              <code title="widl-PeerConnection-NEW">
                <a href="#widl-PeerConnection-NEW">"new"</a>
              </code>
            </dt>

            <dd> The object was just created, and no networking has yet
            occurred. </dd>

            <dt>
              <code title="dom-PeerConnection-NEGOTIATING">
                <a href="#widl-PeerConnection-OPENING">"opening"</a>
              </code>
            </dt>

            <dd>The user agent is attempting to establish an connection with
            the ICE Agent and waiting for local and remote SDP to be set.
            (Open Issue: do we need more states between "opening" and
            "active") </dd>

            <dt>
              <code title="dom-PeerConnection-ACTIVE">
                <a href="#widl-PeerConnection-ACTIVE">"active"</a>
              </code>
            </dt>

            <dd>The ICE Agent has found a connection both the local and remote
            SDP have been set. It is possible for media to flow. </dd>

            <dt>
              <code title="dom-PeerConnection-CLOSING">
                <a href="#widl-PeerConnection-CLOSED">"closing"</a>
              </code>
            </dt>

            <dd> The <code>
                <a>PeerConnection</a>
              </code> object is terminating all media and is in the process of
            closing the connection. </dd>

            <dt>
              <code title="dom-PeerConnection-CLOSED">
                <a href="#widl-PeerConnection-CLOSED">"closed"</a>
              </code>
            </dt>

            <dd> The connection is closed. </dd>
          </dl>
        </section>

        <section>
          <h3> IceState Enum </h3>

     <pre> enum IceState { "new" "gathering", "waiting", "checking",
          "connected", "completed","failed", "closed" }</pre> 

          <!-- <dl class='idl' title='enum IceState { "new" "gathering", "waiting", "checking", "connected", "completed","failed", "closed"}'> </dl> -->

          <dl>
            <dt>
              <code title="widl-PeerConnection-NEW">
                <a href="#widl-PeerConnection-NEW">"new"</a>
              </code>
            </dt>

            <dd>The PeerConnection object was just created, and no networking
            has yet occurred.</dd>

            <dt>
              <code title="dom-PeerConnection-GATHERING">
                <a href="#widl-PeerConnection-ICE_GATHERING">"gathering"</a>
              </code>
            </dt>

            <dd>The ICE Agent is attempting to gather addresses.</dd>

            <dt>
              <code title="dom-PeerConnection-ICE_WAITING">
                <a href="#widl-PeerConnection-ICE_WAITING">"waiting"</a>
              </code>
            </dt>

            <dd>The ICE Agent is not gathering any addresses and is waiting
            for candidates from the other side before it can start
            checking.</dd>

            <dt>
              <code title="dom-PeerConnection-CHECKING">
                <a href="#widl-PeerConnection-ACTIVE">"checking"</a>
              </code>
            </dt>

            <dd>The ICE Agent is checking candidate pairs but has not yet found a
            connection. In addition to checking, it may also still be
            gathering. </dd>

            <dt>
              <code title="dom-PeerConnection-CONNECTED">
                <a href="#widl-PeerConnection-CLOSED">"connected"</a>
              </code>
            </dt>

            <dd>The ICE Agent has found a connection but is still checking
            other candidate pairs to see if there is a better connection. It may
            also still be gathering. </dd>

            <dt>
              <code title="dom-PeerConnection-COMPLETED">
                <a href="#widl-PeerConnection-CLOSED">"completed"</a>
              </code>
            </dt>

            <dd>The ICE Agent has finished gathering and checking and found a
            connection.</dd>

            <dt>
              <code title="dom-PeerConnection-ICE_FAILED">
                <a href="#widl-PeerConnection-CLOSED">"failed"</a>
              </code>
            </dt>

            <dd>The ICE Agent is finished checking all candidate pairs and failed
            to find a connection.</dd>

            <dt>
              <code title="dom-PeerConnection-CLOSED">
                <a href="#widl-PeerConnection-CLOSED">"closed"</a>
              </code>
            </dt>

            <dd>The ICE Agent has shut down and is no longer responding to
            STUN requests.</dd>
          </dl>
        </section>

        <section>
          <h3> IceCandidate Type </h3>

          <p>The <dfn id="dom-icecandidate">
              <code>IceCandidate()</code>
            </dfn> constructor takes one argument, <var>candidate</var>, whose
          content is used to construct the new <code>
              <a>IceCandidate</a>
            </code> object. This class is a future extensible carrier
              for for the data contained in it and does not perform any
              substantive processing. </p>

          <dl class="idl"
              title="[Constructor (DOMString candidate)] interface IceCandidate">
            <dt> attribute DOMString candidate </dt>

            <dd> This carries the candidate-attribute as defined in section
            15.1 of [[!ICE]]. ( TODO - need to add more information to allow
            this to match to correct m line - Open Issue: How to correlate. Need
            to wait for the mapping from media tracks to SDP to be resolved in
            IETF before tackling this problem). </dd>

            <!-- FIXME: this syntax is not fully supported by ReSpec -->

            <dt>stringifier DOMString ()</dt>

            <dd>
              <p>Objects that implement the <code>
                  <a>IceCandidate</a>
                </code> interface must stringify as the candidate-attribute as defined in section
            15.1 of [[!ICE]].</p>
            </dd>
          </dl>
        </section>

        <section>
          <h3> IceCandidateCallback </h3>

     <pre> callback IceCandidateCallback = void (IceCandidate candidate)
          </pre> 

          <dl>
            <!--  dl title='callback IceCandidateCallback = void' class='idl' -->

            <dt>IceCandidate candidate</dt>

            <dd>The new ICE candidate. </dd>
          </dl>
        </section>

        <section>
          <h3> IceServers Type - Option 1</h3>
          <p> Open Issue: choose option 1 or option 2 for IceServers Type. </p>
          <dl class="idl" title="dictionary IceServers">
            <dt> attribute DOMString[][] servers</dt>

            <dd> <p> The IceServers type is a array of arrays where each inner array is
              defined as follows:
              The first element is a stun or turn URI as defined in
            [[!STUN-URI]] and [[!TURN-URI]]. If the first element of the internal
	    array is TURN URI, then the second element of the array is the credential
            to use with that TURN server. </p> </dd>

          </dl>

          <p> In network topologies with multiple layers of NATs, it is
          desirable to have a STUN servers between every layer of NATs in
          addition to the TURN servers to minimize the number peer to peer
          network latency. </p>

          <p>An example configuration object is:</p>

          <p>
              <code> { servers:[ ["stun:stun.example.net"] ,
              ["turn:user@turn.example.org","myPassword"] ]} </code>
            </p>
        </section>

              <section>
          <h3> IceServers Type - Option 2</h3>
          <p> Open Issue: choose option 1 or option 2 for IceServers Type. </p>
          <dl class="idl" title="dictionary IceServers">
            <dt> attribute DOMString[] servers</dt>

            <dd> <p> The IceServers type is an array of strings where each string
            provides the URL and credentials for a server. Each string is either
            a the URL to reach a STUN server ad defined in 
            [[!STUN-URI]] or is the URL of a TURN server as defined in [[!TURN-URI]]
            followed by a single space and then the rest of the string is the
            credential used to access that server. Note the credential may
            contains spaces. </p> </dd>
          </dl>

          <p> In network topologies with multiple layers of NATs, it is
          desirable to have a STUN servers between every layer of NATs in
          addition to the TURN servers to minimize the number peer to peer
          network latency. </p>

          <p>An example configuration object is:</p>

          <p>
              <code> { servers:[ "stun:stun.example.net" ,
            "turn:user@turn.example.org myPassword" ]} </code>
            </p>
        </section>

        <section>
          <h3>PeerConnection Interface</h3>

          <p> Open Issue: should we collapse some of these functions a single
          "processRemoteSignal" method? </p>


          <dl class="idl"
              title="[Constructor (IceServers configuration, optional MediaConstraints constraints)] interface PeerConnection">

                      <!--
            <dt>void getCapabilities ( SessionDescriptionCallback
            successCallback )</dt>

            <dd>
              <p> The getCapabilities method generates a blob of SDP that
              contains a RFC offer that represets the most optimist view on
              the capabilities of the media system. It does not reserver any
              resources, ports, or other state but is meant to provide a way
              to discover the types of capabilities of the browser including
              which codecs may be supported. The SDP should have any ports set
              to 0 (Open Issue: should this be 9?). Other values that would
              allocate state should be set to static, unusable values. It
              should include the SDP for media stream for each media type the
              browser supports along with all the codecs that are supported.
              It does not matter if any streams have been added to the
              PeerConnection object. </p>

              <p> TODO - discuss privacy implications. </p>
            </dd>
           -->
            
            <dt>void createOffer ( SessionDescriptionCallback successCallback,
            optional PeerConnectionErrorCallback failureCallback, optional MediaConstraints
            constraints)</dt>

            <dd>
              <p> The createOffer method generates a blob of SDP that contains
              a RFC offer with the supported configurations for the session,
              including descriptions of the local MediaStreams attached to
              this PeerConnection, the codec/RTP/RTCP options supported by
              this implementation, and any candidates that have been gathered
              by the ICE Agent. The constraints parameter may be supplied to
              provide additional control over the offer generated. </p>

              <p> As an offer, the generated SDP will contain the full set of
              capabilities supported by the session (as opposed to an answer,
              which will include only a specific negotiated subset to use);
              for each SDP line, the generation of the SDP must follow the
              appropriate process for generating an offer. In the event
              createOffer is called after the session is established,
              createOffer will generate an offer that is compatible with the
              current session, incorporating any changes that have been made
              to the session since the last complete offer-answer exchange,
              such as addition or removal of streams. If no changes have been
              made, the offer will be include the capabilities of the current
              local description as well as any additional capabilities that
              could be negotiated in an updated offer. </p>

              <p> Session descriptions generated by createOffer MUST be
              immediately usable by setLocalDescription without causing an
              error as long as setLocalDiscription is called within the
              successCallback function. If a system has limited resources
              (e.g. a finite number of decoders), createOffer needs to return
              an offer that reflects the current state of the system, so that
              setLocalDescription will succeed when it attempts to acquire
              those resources. The session descriptions MUST remain usable by
              setLocalDescription without causing an error until at least end
              of the successCallback function. Calling this method is needed
              to get the ICE user name fragment and password. </p>

              <p> The failureCallback will be called if the system can not
              generate an appropriate offer given the state of the
              PeerConnection. </p>

              <p> A TBD exception is thrown if the constraints parameter is
              malformed. 
                [[ OPEN ISSUE: How are errors reported? ]]
                </p>
                

              <p> To Do: Discuss privacy aspects of this from a finger
              printing point of view - it's probably around as bad as access
              to a canvas :-) </p>
            </dd>

            <dt>void createAnswer (SessionDescription offer,
            SessionDescriptionCallback successCallback, optional PeerConnectionErrorCallback
            failureCallback, optional MediaConstraints constraints, optional
            Boolean createProvisionalAnswer=false)</dt>

            <dd>
              <p>The createAnswer method generates a [[!SDP]] answer with the
              supported configuration for the session that is compatible with
              the parameters supplied in offer. Like createOffer, the returned
              blob contains descriptions of the local MediaStreams attached to
              this PeerConnection, the codec/RTP/RTCP options negotiated for
              this session, and any candidates that have been gathered by the
              ICE Agent. The constraints parameter may be supplied to provide
              additional control over the generated answer. </p>

              <p> As an answer, the generated SDP will contain a specific
              configuration that, along with the offer, specifies how the
              media plane should be established. The generation of the SDP
              must follow the appropriate process for generating an answer or
              provisional answer. </p>

              <p> Session descriptions generated by createAnswer must be
              immediately usable by setLocalDescription without generating an
              error if setLocalDescription is called from the successCallback
              function. Like createOffer, the returned description should
              reflect the current state of the system. The session
              descriptions MUST remain usable by setLocalDescription without
              causing an error until at least the end of the successCallback
              function. Calling this method is is needed to get the ICE user
              name fragment and password. Provisional offers, as described in
              [[RTCWEB-JSEP]], are created if and only if the
              createProvisionalOffer flag is true. </p>

              <p> The failureCallback will be called if the system can not
              generate an appropriate answer given the offer. </p>

              <p> A TBD exception is thrown if the constraints parameter is
              malformed. </p>
            </dd>

            <dt>void setLocalDescription (SdpType action, SessionDescription
            description)</dt>

            <dd>
              <p> The setLocalDescription method instructs the PeerConnection
              to apply the supplied [[!SDP]] description as the local offer or
              answer. The type parameter indicates whether the description
              should be processed as an offer, provisional answer, or final
              answer. 
              [[OPEN ISSUE: The type appears as both the "action" argument
              and in the struct. That is redundant and just sort of crazy. We need
              to pick one.]]              
              </p>

              <p> This API changes the local media state. In order to
              successfully handle scenarios where the application wants to
              offer to change from one media format to a different,
              incompatible format, the PeerConnection must be able to
              simultaneously support use of both the old and new local
              descriptions (e.g. support codecs that exist in both
              descriptions) until a final answer is received, at which point
              the PeerConnection can fully adopt the new local description, or
              roll back to the old description if the remote side denied the
              change. </p>

              <p> Open issues: how to indicate to roll back? </p>

              <p> To Do: specify what parts of the SDP can be changed between
              the createOffer and setLocalDescription </p>

              <p>Changes to the state of media transmission will occur when a
              final answer is successfully applied. </p>

              <p> A TBD exception is thrown if sdp is invalid. A TBD exception
              is thrown if there are insufficient local resources to apply the
              sdp. </p>

              <p> Open Issues: for setLocal and setRemote, discuss how to
              return erro codes and if they need to be asynchronous. </p>
            </dd>

            <dt>readonly attribute SessionDescription localDescription</dt>

            <dd>
              <p> The localDescription method returns a copy of the 
              SessionDescription that was most recently passed to
              setLocalDescription, plus any local candidates that have been
              generated by the ICE Agent since then. </p>

              <p> A null object will be returned if the local description has
              not yet been set. </p>
            </dd>

            <dt>void setRemoteDescription (SdpType action, SessionDescription
            description)</dt>

            <dd>
              <p> The setRemoteDescription method instructs the PeerConnection
              to apply the supplied [[!SDP]] in the description. As in
              setLocalDescription, the action parameter indicates how the blob
              should be processed. This API changes the local media state.
              </p>

              <p> Changes to the state of media transmission will occur when a
              final answer is successfully applied. </p>

              <p> A TBD exception is thrown if the sdp parameter is invalid. A
              TBD exception is thrown if there are insufficient local
              resources to apply the SDP. </p>
            </dd>

            <dt>readonly attribute SessionDescription remoteDescription</dt>

            <dd>
              <p> The remoteDescription method returns a copy of the current
              remote the SessionDescription that was most recently passed to
              setRemoteDescription, plus any remote candidates that have been
              supplied via addIceCandidate since then. </p>

              <p> A null object will be returned if the remote description has
              not yet been set. </p>
            </dd>

            <dt>readonly attribute PeerState readyState</dt>

            <dd>
              <p>The <dfn id="dom-peerconnection-readystate">
                  <code title="">readyState</code>
                </dfn> attribute MUST return the <code>
                  <a>PeerConnection</a>
                </code> object's <a
              href="#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a>. </p>
            </dd>

            <dt>void updateIce (optional IceServers configuration, optional
            MediaConstraints constraints, optional Boolean restart=false)</dt>

            <dd>
              <p> The updateIce method restarts or updates the ICE Agent
              process of gathering local candidates and pinging remote
              candidates. If there is a mandatory constraint called
              "IceTransports" it will control which how the ICE engine can
              act. This can be used to limit the use to TURN candidates by a
              callee to avoid leaking location information prior to the call
              being accepted. </p>

              <p> This call may result in a change to the state of the ICE
              Agent, and may result in a change to media state if it results
              in connectivity being established. </p>

              <p> If the restart parameter is set to true, the ICE state
              machine discards all candidates it has gathered, allocates new
              ports for the host candidates, and restarts ICE as if there had
              been no previos ICE session. Applications can use this to reset
              all ICE negotiation when something has gone terribly wrong. </p>

              <p> A TBD exception will be thrown if constraints parameter is
              malformed. </p>
            </dd>

            <dt>void addIceCandidate (IceCandidate candidate)</dt>

            <dd>
              <p>The addIceCandidate method provides a remote candidate to the
              ICE Agent, which will be added to the remote description.
              Connectivity checks will be sent to the new candidates as long
              as the "IceTransports" constraint is not set to "none". This
              call will result in a change to the state of the ICE Agent, and
              may result in a change to media state if it results in different
              connectivity being established. </p>

              <p> A TBD exception will be thrown if candidate parameter is
              malformed. </p>
            </dd>

            <dt>readonly attribute IceState iceState</dt>

            <dd>
              <p>The <dfn id="dom-peerconnection-icestate">
                  <code>iceState</code>
                </dfn> attribute MUST return the state of the <a
              href="#peerconnection-ice-agent"><code>PeerConnection</code> ICE
              Agent</a> ICE state. </p>
            </dd>

            <dt>readonly attribute MediaStream[] localStreams</dt>

            <dd>
              <p>Returns a live array containing the local streams (those that
              were added with <code title="dom-PeerConnection-addStream">
                  <a href="#dom-peerconnection-addstream">addStream()</a>
                </code>).</p>
            </dd>

            <dt>readonly attribute MediaStream[] remoteStreams</dt>

            <dd>
              <p>Returns a live array containing the streams that the remote
              streams. (those that were added by the remote side). </p>

              <p>This array is updated when <code>
                  <a href="#event-mediastream-addstream">addstream</a>
                </code> and <code title="event-MediaStream-removestream">
                  <a href="#event-mediastream-removestream">removestream</a>
                </code> events are fired.</p>
            </dd>

            <dt>DataChannel createDataChannel([TreatNullAs=EmptyString]
            DOMString? label, optional DataChannelInit? dataChannelDict)</dt>

            <dd>
              <p>Creates a new <code>
                  <a>DataChannel</a>
                </code> object with the given label. The <code>
                  <a>DataChannelInit</a>
                </code> dictionary can be used to configure properties of
              underlying channel such as <!--priority and--> data reliability.
              A corresponding <code>
                  <a>DataChannel</a>
                </code> object is dispatched at the other peer if the channel
              setup was successful.</p>

              <p>When the <dfn id="dom-peerconnection-createdatachannel">
                  <code>createDataChannel()</code>
                </dfn> method is invoked, the user agent MUST run the
              following steps.</p>

              <ol>
                <li>
                  <p>If the <code>
                      <a>PeerConnection</a>
                    </code> object’s <a
                  href="#peerconnection-readiness-state"><code>PeerConnection</code>
                  readiness state</a> is <code>
                      <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                    </code> (3), throw an <code>INVALID_STATE_ERR</code>
                  exception.</p>
                </li>

                <li>
                  <p>Let <var>channel</var> be a newly created <code>
                      <a>DataChannel</a>
                    </code> object.</p>
                </li>

                <li>
                  <p>Initialize <var>channel</var>’s <code>
                      <a href="#dom-datachannel-label">label</a>
                    </code> attribute to the value of the first argument.</p>
                </li>

                <li>
                  <p>Initialize <var>channel</var>’s <code>
                      <a href="#dom-datachannel-reliable">reliable</a>
                    </code> attribute to true.</p>
                </li>

                <li>
                  <p>If the second argument is present and it contains a <code>
                      <a href="#widl-DataChannelInit-reliable">reliable</a>
                    </code> dictionary member, then set <var>channel</var>’s
                  <code>
                      <a href="#dom-datachannel-reliable">reliable</a>
                    </code> attribute to the dictionary member value.</p>
                </li>

                <li>
                  <p>Return <var>channel</var> and continue these steps in the
                  background.</p>
                </li>

                <li>
                  <p>Create <var>channel</var>’s associated <a>underlying data
                  transport</a>.</p>
                </li>
              </ol>
            </dd>

            <dt>attribute Function? ondatachannel</dt>

            <dd>This event handler, of type <code>
                <a href="#event-peerconnection-datachannel">datachannel</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>PeerConnection</a>
              </code> interface.</dd>

            <!--
    <dt>void send (DOMString text)</dt>

    <dd>
      <p>Attempts to send the given text to the remote peer. This uses UDP, which is
      inherently unreliable; there is no guarantee that every message will be
      received.</p>

      <p>When a message sent in this manner from the other peer is received, a
      <code><a href=
      "#event-mediastream-message">message</a></code> event is fired at the
      <code><a>PeerConnection</a></code> object.</p>

      <p>The maximum length of <var>text</var> is 504 bytes after encoding the
      string as UTF-8; attempting to send a payload greater than 504 bytes results in an
      <code>INVALID_ACCESS_ERR</code> exception.</p>

      <p>When the <dfn id='dom-peerconnection-send'><code>send()</code></dfn> method is invoked, the
      user agent MUST run the following steps:</p>

      <ol>

        <li>
          <p>Let <var>message</var> be the method’s first argument.</p>
        </li>

        <li>
          <p>If the <code><a>PeerConnection</a></code> object’s
          <a href="#peerconnection-readiness-state"><code>PeerConnection</code> readiness
          state</a> is <code><a href=
          "#widl-PeerConnection-CLOSED">CLOSED</a></code> (3), throw an
          <code>INVALID_STATE_ERR</code> exception.</p>
        </li>

        <li>
          <p>Let <var>data</var> be <var>message</var> encoded as
          UTF-8. [[!UTF-8]]</p>
        </li>

        <li>
          <p>If <var>data</var> is longer than 504 bytes, throw an
          <code>INVALID_ACCESS_ERR</code> exception and abort these steps.</p>
        </li>
       <li>
          <p>If the <code><a>PeerConnection</a></code>’s <a href=
          "#peerconnection-data-udp-media-stream"><code>PeerConnection</code> data UDP
          media stream</a> is not an <a href="#active-data-udp-media-stream">active data
          UDP media stream</a>, abort these steps. No message is sent.</p>
        </li>

        <li>
          <p>If the user agent is rate-limiting packets sent using this API, and sending
          the data packet at this time would exceed the limit, then abort these steps.
          User agents MAY report this to the user, e.g. in a development console.</p>
        </li>

        <li>
          <p><a href="#transmit-a-data-packet-to-a-peer">Transmit a data packet to a
          peer</a> using the <code><a>PeerConnection</a></code>’s
          <a href="#peerconnection-data-udp-media-stream"><code>PeerConnection</code>
          data UDP media stream</a> with <var>data</var> as the message.</p>
        </li>
      </ol>
    </dd>
   -->

            <dt>void addStream (MediaStream stream, optional MediaConstraints
            constraints)</dt>

            <dd>
              <p>Adds a new stream to the PeerConnection. </p>

              <p>When the <dfn id="dom-peerconnection-addstream">
                  <code title="">addStream()</code>
                </dfn> method is invoked, the user agent MUST run the
              following steps:</p>

              <ol>
                <li>
                  <p>If the <code>
                      <a>PeerConnection</a>
                    </code> object's <a
                  href="#peerconnection-readiness-state"><code>PeerConnection</code>
                  readiness state</a> is <code>
                      <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                    </code> (3), throw an <code>INVALID_STATE_ERR</code>
                  exception.</p>
                </li>

                <li>
                  <p>If <var>stream</var> is already in the <code>
                      <a>PeerConnection</a>
                    </code> object's <code
                      title="dom-PeerConnection-localStreams">
                      <a
                      href="#widl-PeerConnection-localStreams">localStreams</a>
                    </code> object, then abort these steps.</p>
                </li>

                <li>
                  <p>Add <var>stream</var> to the end of the <code>
                      <a>PeerConnection</a>
                    </code> object's <code
                      title="dom-PeerConnection-localStreams">
                      <a
                      href="#widl-PeerConnection-localStreams">localStreams</a>
                    </code> object.</p>
                </li>

                <li>
                  <p>Parse the <var>constraints</var> provided by the
                  application and apply them to the MediaStream, if possible.
                  NOTE - need to deal with throwing an exception here. </p>
                </li>

                <li>
                  <p> Fire a renegotiationneeded event. [[OPEN ISSUE: Should this fire if 
		  the PeerConnection is in "new"?]]</p>
                </li>
              </ol>
            </dd>

            <dt>void removeStream (MediaStream stream)</dt>

            <dd>
              <p>Removes the given stream from the localStream array in the PeerConnection and fires 'renegotiationneeded.</p>

              <p>When the other peer stops sending a stream in this manner, a
              <code title="event-MediaStream-removestream">
                  <a href="#event-mediastream-removestream">removestream</a>
                </code> event is fired at the <code>
                  <a>PeerConnection</a>
                </code> object.</p>

              <p>When the <dfn id="dom-peerconnection-removestream">
                  <code title="">removeStream()</code>
                </dfn> method is invoked, the user agent MUST run the
              following steps:</p>

              <ol>
                <li>
                  <p>If the <code>
                      <a>PeerConnection</a>
                    </code> object's <a
                  href="#peerconnection-readiness-state"><code>PeerConnection</code>
                  readiness state</a> is <code>
                      <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                    </code> (3), throw an <code>INVALID_STATE_ERR</code>
                  exception.</p>
                </li>

                <li>
                  <p>If <var>stream</var> is not in the <code>
                      <a>PeerConnection</a>
                    </code> object's <code
                      title="dom-PeerConnection-localStreams">
                      <a
                      href="#widl-PeerConnection-localStreams">localStreams</a>
                    </code> object, then abort these steps. TODO: Do we need
                  an exception here? </p>
                </li>

                <li>
                  <p>Remove <var>stream</var> from the <code>
                      <a>PeerConnection</a>
                    </code> object's <code
                      title="dom-PeerConnection-localStreams">
                      <a
                      href="#widl-PeerConnection-localStreams">localStreams</a>
                    </code> object.</p>
                </li>

                <li>
                  <p> Fire a renegotiationneeded event.</p>
                </li>
              </ol>
            </dd>

            <dt>void close ()</dt>

            <dd>
              <p>When the <dfn id="dom-peerconnection-close">
                  <code title="">close()</code>
                </dfn> method is invoked, the user agent MUST run the
              following steps:</p>

              <ol>
                <li>
                  <p>If the <code>
                      <a>PeerConnection</a>
                    </code> object's <a
                  href="#peerconnection-readiness-state"><code>PeerConnection</code>
                  readiness state</a> is <code>
                      <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                    </code> (3), throw an <code>INVALID_STATE_ERR</code>
                  exception.</p>
                </li>

                <li>
                  <p>Destroy the <a
                  href="#peerconnection-ice-agent"><code>PeerConnection</code>
                  ICE Agent</a>, abruptly ending any active ICE processing and
                  any active streaming, and releasing any relevant resources
                  (e.g. TURN permissions).</p>
                </li>

                <li>
                  <p>Set the object's <a
                  href="#peerconnection-readiness-state"><code>PeerConnection</code>
                  readiness state</a> to <code>
                      <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                    </code> (3).</p>
                </li>
              </ol>
            </dd>

            <dt>attribute Function? onrenegotationneeded</dt>

            <dd> This event handler, of <span
            title="event handler event type">event handler event type</span>
            <code>
                <a href="#event-renegotiation-needed">renegotiationneeded</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>PeerConnection</a>
              </code> interface.
              Open Issue: Need to sort out which things should be Function and
            which should be a Callback. 
            </dd>

            <dt>attribute Function? onicecandidate </dt>

            <dd>This event handler, of <span
            title="event handler event type">event handler event type</span>
            <code>
                <a href="#event-onicecandidate">onicecandidate</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>PeerConnection</a>
              </code> interface. It is called any time there is a new ICE
            candiate can be added to the a previos offer or answer. </dd>

            <dt>attribute Function? onconnecting</dt>

            <dd>This event handler, of <span
            title="event handler event type">event handler event type</span>
            <code>
                <a href="#event-mediastream-connecting">connecting</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>PeerConnection</a>
              </code> interface.</dd>

            <dt>attribute Function? onopen</dt>

            <dd>This event handler, of <span
            title="event handler event type">event handler event type</span>
            <code>
                <a href="#event-mediastream-open">open</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>PeerConnection</a>
              </code> interface.</dd>

            <dt>attribute Function? onstatechange</dt>

            <dd>This event handler, of <span
            title="event handler event type">event handler event type</span>
            <code>
                <a href="#event-mediastream-open">statechange</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>PeerConnection</a>
              </code> interface. It is called any time the readyState changes.
            </dd>

            <dt>attribute Function? onaddstream</dt>

            <dd>This event handler, of <span
            title="event handler event type">event handler event type</span>
            <code>
                <a href="#event-mediastream-addstream">addstream</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>PeerConnection</a>
              </code> interface. Open Issue: It seems like this even handler
            needs to be fired when the first of two things happens - the
            remote side sends signaling indicating a media will be sent, or
            the side that sent an offer start receiving media in reply to that
            offer. </dd>

            <dt>attribute Function? onremovestream</dt>

            <dd>This event handler, of <span
            title="event handler event type">event handler event type</span>
            <code>
                <a href="#event-mediastream-removestream">removestream</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>PeerConnection</a>
              </code> interface.</dd>

            <dt>attribute Function? onicechange</dt>

            <dd>This event handler, of <span
            title="event handler event type">event handler event type</span>
            <code>
                <a href="#event-mediastream-icechange">icechange</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>PeerConnection</a>
              </code> interface. It is called any time the iceState
            changes.</dd>
          </dl>

          <dl class="idl" title="PeerConnection implements EventTarget" >
            </dl>
            
        </section>
      </section>
    </section>

    <section>
      <h2 id="sec-iana">IANA Registrations</h2>

      <p> IANA is requested to register the constraints defined in <a
      href="#sec-constraints"> Constraints Section </a> as specified in
      [[!RTCWEB-CONSTRAINTS]]. </p>

      <section>
        <h3 id="sec-constraints">Constraints</h3>

        <p> TOOD: Need to change the naming and declaration of these
        constraints to match the constraints draft once that is a bit further
        along. The names here now are likely not quite right but they serve as
        a place holder. 
	  [[OPEN ISSUE: there are multiple ways to add constraints. How are
	  multiple values reconciled?]]
	</p>

        <p> The following new constraints are defined that can be used with a
        PeerConnection object: </p>

        <dl>
          <dt> OfferToReceiveVideo </dt>

          <dd>
            <p> This is a enum type constraint that can take the values "true"
            and "false". The default is a non mandatory "true" for a
            PeerConnection object that has a video stream at the point in time
            when the constraints are being evaluated and is non mandatory
            "false" otherwise. </p>

            <p> In some cases, a PeerConnection may wish to receive video but
            it is not going to send any video. The PeerConnection needs to
            know if it should signal to the remote side if it wishes to
            receive video or not. This constraints allows an application to
            indicate its preferences for receiving video when creating an
            offer. </p>
          </dd>

          <dt>OfferToReceiveAudio </dt>

          <dd>
            <p> This is a enum type constraint that can take the values "true"
            and "false". The default is a non mandatory "true". </p>

            <p> In some cases, a PeerConnection may wish to receive audio but
            it is not going to send any audio. The PeerConnection needs to
            know if it should signal to the remote side if it wishes to
            receive audio. This constraints allows an application to indicate
            its preferences for receiving audio when creating an offer. </p>
          </dd>

          <dt> VoiceActivityDetection </dt>

          <dd>
            <p> This is a enum type constraint that can take the values "true"
            and "false". The default is a non mandatory "true". </p>

            <p> Many codecs and system are capable of detecting "silence" and
            changing there behavior in this case by doing things such as not
            transmitting any media. In many cases, such as when dealing with
            sounds other than spoken voice or emergency calling, it is
            desirable to be able to turn off this behavior. This constraints
            allows the application to provide information about if it wishes
            this type of processing enable or disabled. </p>
          </dd>

          <dt> IceTransports </dt>

          <dd>
            <p> This is a enum type constraint that can take the values
            "none", "relay", and "all". The default is a non mandatory "all".
            </p>

            <p> This constraints indicates which candidates the ICE engine is
            restricted use. The value "none" means the ICE engine MUST not
            send or receive any packets at this point. The value "relay"
            indicates the ICE engine MUST only using media relay candidates
            such as candidates passing through a TURN server. This can be used
            to reduce leakage of IP addresses in certain use cases. The value
            of "all" indicates all values can be used. </p>
          </dd>
        </dl>

        <p> TODO items - need to register with IANA. </p>
      </section>
    </section>

    <!--
      <section>
        <h3>SignalingCallback</h3>

        <dl class="idl"
            title="[Callback, NoInterfaceObject] interface SignalingCallback">
          <dt>void handleEvent (DOMString message, PeerConnection source)</dt>

          <dd>Def TBD</dd>
        </dl>
      </section>
    -->

       <section>
        <h3>Simple Example</h3>

        <div>
          <p>When two peers decide they are going to set up a connection to
          each other, they both go through these steps. The STUN/TURN server
          configuration describes a server they can use to get things like
          their public IP address or to set up NAT traversal. They also have
          to send data for the signaling channel to each other using the same
          out-of-band mechanism they used to establish that they were going to
          communicate in the first place.</p>

          <p> NOTE: TODO - This code does not match the API yet and might have a few
          other problems. </p>

          <pre class="example sh_javascript">
var signalingChannel = createSignalingChannel();
var pc;

// set up the call, get access to local media, and establish connectivity
function start(isCaller) {
    pc = new PeerConnection(null);

    // send any ice candidates to the other peer
    pc.onicecandidate = function (evt) {
        signalingChannel.send(JSON.stringify({ "type": "candidate", "sdp": evt.candidate }));
    };

    // once remote stream arrives, show it in the remote video element
    pc.onaddstream = function (evt) {
        remoteView.src = URL.createObjectURL(evt.stream);
    };

    // get the local stream and show it in the local video element
    navigator.getUserMedia({"audio": true, "video": true}, function (stream) {
        selfView.src = URL.createObjectURL(stream);
        pc.addStream(stream);

        var type;
        if (isCaller) {
            pc.createOffer(gotDescription);
            type = "offer";
        } else {
            pc.createAnswer(pc.remoteDescription, gotDescription);
            type = "answer";
        }

        function gotDescription(desc) {
            pc.setLocalDescription(type, desc);
            signalingChannel.send(JSON.stringify({ "type": type, "sdp": desc }));
        }
    });
}

signalingChannel.onmessage = function (evt) {
    var msg = JSON.parse(evt.data);
    switch (msg.type) {
    case "offer":
        // create the PeerConnection
        start(false);
        // feed the received offer into the PeerConnection
        pc.setRemoteDescription(msg.type, new SessionDescription(msg.sdp));
        break;
    case "answer":
        pc.setRemoteDescription(msg.type, new SessionDescription(msg.sdp));
        break;
    case "candidate":
        pc.addIceCandidate(new IceCandidate(msg.sdp));
        break;
    }
};
          </pre> 
        </div>
      </section>
  
    <section>
      <h3>Advanced Example</h3>

      <div>
        <p>This example shows the more comples functionality.</p>

      <pre class="example sh_javascript"> TODO </pre> 
      </div>
    </section>

    <section>
      <h2>Peer-to-peer Data API</h2>

      <p>The Peer-to-peer Data API lets a web application send and receive
      generic application data peer-to-peer.</p>

      <div class="note" title="hello">
        <p>Open issues (this should not be considered as a complete list of
        open issues)</p>

        <ul>
          <li>Data channel setup signaling (signaling via SDP and application
          specific signaling channel or first channel via SDP and consecutive
          channels via internal signalling).</li>

          <li>What can be shared with the WebSocket API specification
          regarding actual interfaces.</li>
        </ul>
      </div>

      <section>
        <h3>DataChannel</h3>

        <p>The <code>
            <a>DataChannel</a>
          </code> interface represents a bi-directional data channel between
        two peers. A <code>
            <a>DataChannel</a>
          </code> is created via a factory method on a <code>
            <a>PeerConnection</a>
          </code> object. The corresponding <code>
            <a>DataChannel</a>
          </code> object is then dispatched at the other peer if the channel
        setup was successful.</p>

        <p>Each <code>
            <a>DataChannel</a>
          </code> has an associated <dfn>underlying data transport</dfn> that
        is used to transport actual data to the other peer. The transport
        properties of the <a>underlying data transport</a>, such as
        reliability mode, are configured by the peer taking the initiative to
        create the channel. The other peer cannot change any transport
        properties of a offered data channel. The actual wire protocol between
        the peers is out of the scope for this specification.
      Open Issues: this needs to explain how the configuration state
	  is passed between the peers.
       Open Issues: this type of design where one side can pick anything and the
            other side much support everything has proven to make future upgrades
            very difficult. </p>

        <p>A <code>
            <a>DataChannel</a>
          </code> created with <code>
            <a
            href="#dom-peerconnection-createdatachannel">createDataChannel()</a>
          </code> MUST initially be in the <code>
            <a href="#widl-DataChannel-CONNECTING">CONNECTING</a>
          </code> (0) state. If the <code>
            <a>DataChannel</a>
          </code> object’s <a>underlying data transport</a> is successfully
        set up, the user agent MUST <a
        href="#announce-datachannel-open">announce the
        <code>DataChannel</code> as open</a>.</p>

        <p>When the user agent is to <dfn
        id="announce-datachannel-open">announce a <code>DataChannel</code> as
        open</dfn>, the user agent MUST queue a task to run the following
        steps:</p>

        <ol>
          <li>
            <p>If the associated <code>
                <a>PeerConnection</a>
              </code> object’s <a
            href="#peerconnection-readiness-state"><code>PeerConnection</code>
            readiness state</a> is <code>
                <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
              </code> (3), abort these steps.</p>
          </li>

          <li>
            <p>Let <var>channel</var> be the <code>
                <a>DataChannel</a>
              </code> object to be announced.</p>
          </li>

          <li>
            <p>Set <var>channel</var>’s <code>
                <a href="#dom-datachannel-readystate">readyState</a>
              </code> attribute to <code>
                <a href="#widl-DataChannel-OPEN">OPEN</a>
              </code> (1).</p>
          </li>

          <li>
            <p><a>Fire a simple event</a> named <code>
                <a href="#event-datachannel-open">open</a>
              </code> at <var>channel</var>.</p>
          </li>
        </ol>

        <p>When an <a>underlying data transport</a> has been established, the
        user agent, of the peer that did not initiate the creation process
        MUST queue a task to run the following steps:</p>

        <ol>
          <li>
            <p>If the associated <code>
                <a>PeerConnection</a>
              </code> object’s <a
            href="#peerconnection-readiness-state"><code>PeerConnection</code>
            readiness state</a> is <code>
                <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
              </code> (3), abort these steps.</p>
          </li>

          <li>
            <p>Let <var>configuration</var> be an information bundle with
            key-value pairs, received from the other peer as a part of the
            process to establish the <a>underlying data channel</a>.</p>
          </li>

          <li>
            <p>Let <var>channel</var> be a newly created <code>
                <a>DataChannel</a>
              </code> object.</p>
          </li>

          <li>
            <p>Initialize <var>channel</var>’s <code>
                <a href="#dom-datachannel-label">label</a>
              </code> attribute to value that corresponds to the
            "<code>label</code>" key in <var>configuration</var>.</p>
          </li>

          <li>
            <p>Initialize <var>channel</var>’s <code>
                <a href="#dom-datachannel-reliable">reliable</a>
              </code> attribute to true.</p>
          </li>

          <li>
            <p>If <var>configuration</var> contains a key named
            "<code>reliable</code>", set <var>channel</var>’s <code>
                <a href="#dom-datachannel-reliable">reliable</a>
              </code> attribute to the corresponding value.</p>
          </li>

          <!--
          
          <li>
          <p>Have the user agent <a href="#announce-datachannel-open">announce
          <var>connection</var> as open</a>.</p>
          </li>

          -->

          <li>
            <p>Set <var>channel</var>’s <code>
                <a href="#dom-datachannel-readystate">readyState</a>
              </code> attribute to <code>
                <a href="#widl-DataChannel-OPEN">OPEN</a>
              </code> (1).</p>
          </li>

          <li>
            <p><a>Fire a datachannel event</a> named <code>
                <a href="#event-peerconnection-datachannel">datachannel</a>
              </code> with <var>channel</var> at the <code>
                <a>PeerConnection</a>
              </code> object.</p>
          </li>
        </ol>

        <p>When the <dfn id="tear-down-data-transport">process of tearing down
        a <code>
            <a>DataChannel</a>
          </code> object’s <a>underlying data transport</a></dfn> is
        initiated, the user agent MUST run the following steps:</p>

        <ol>
          <li>
            <p>If the associated <code>
                <a>PeerConnection</a>
              </code> object’s <a
            href="#peerconnection-readiness-state"><code>PeerConnection</code>
            readiness state</a> is <code>
                <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
              </code> (3), abort these steps.</p>
          </li>

          <li>
            <p>Let <var>channel</var> be the <code>
                <a>DataChannel</a>
              </code> object which is about to be closed.</p>
          </li>

          <li>
            <p>If <var>channel</var>’s <code>
                <a href="#dom-datachannel-readystate">readyState</a>
              </code> is <code>
                <a href="#widl-DataChannel-CLOSED">CLOSING</a>
              </code> (2) or <code>
                <a href="#widl-DataChannel-CLOSED">CLOSED</a>
              </code> (3), then abort these steps.</p>
          </li>

          <li>
            <p>Set <var>channel</var>’s <code>
                <a href="#dom-datachannel-readystate">readyState</a>
              </code> attribute to <code>
                <a href="#widl-DataChannel-CLOSING">CLOSING</a>
              </code> (2).</p>
          </li>

          <li>
            <p>Queue a task to run the following steps:</p>
          </li>

          <li>
            <ol>
              <li>
                <p>Close <var>channel</var>’s <a>underlying data
                transport</a>.</p>

                <div class="note"> The data transport protocol will specify
                what happens to, e.g. buffered data, when the data transport
                is closed. </div>
              </li>

              <li>
                <p>Set <var>channel</var>’s <code>
                    <a href="#dom-datachannel-readystate">readyState</a>
                  </code> attribute to <code>
                    <a href="#widl-DataChannel-CLOSED">CLOSED</a>
                  </code> (3).</p>
              </li>

              <li>
                <p>Fire a simple event named <code
                    title="event-DataChannel-close">
                    <a href="#event-datachannel-close">close</a>
                  </code> at <var>channel</var>.</p>
              </li>
            </ol>
          </li>
        </ol>

        <dl class="idl" title="interface DataChannel">
          <dt>readonly attribute DOMString label</dt>

          <dd>
            <p>The <dfn id="dom-datachannel-label">
                <code>DataChannel.label</code>
              </dfn> attribute represents a label that can be used to
            distinguish this <code>
                <a>DataChannel</a>
              </code> object from other <code>
                <a>DataChannel</a>
              </code> objects. The attribute MUST return the value to which it
            was set when the <code>
                <a>DataChannel</a>
              </code> object was created.</p>
          </dd>

          <dt>readonly attribute boolean reliable</dt>

          <dd>
            <p>The <dfn id="dom-datachannel-reliable">
                <code>DataChannel.reliable</code>
              </dfn> attribute returns true if the <code>
                <a>DataChannel</a>
              </code> is reliable, and false otherwise. The attribute MUST
            return the value to which it was set when the <code>
                <a>DataChannel</a>
              </code> was created.</p>
          </dd>

          <!--
          
          <dt>readonly attribute long priority</dt>

    <dd>
      <p>The <dfn id='dom-datachannel-priority'><code>DataChannel.priority</code></dfn>
      attribute returns the priority of the <code><a>DataChannel</a></code>; a channel
      with a higher value is prioritized over a channel with a lower value. The attribute
      MUST return the value to which it was set when the the <code><a>DataChannel</a></code>
      was created.</p>

      <p>The value might not be the value given in the <code><a>DataChannelInit</a></code>
      dictionary since it may have been clamped to fit in the range of valid values.</p>
    </dd>

    -->

          <!-- AbstractMessenger -->

          <!-- ready state -->

          <dt>const unsigned short CONNECTING = 0</dt>

          <dd>
            <p>The user agent is attempting to establish the <a>underlying
            data transport</a>. This is the initial state of a <code>
                <a>DataChannel</a>
              </code> object created with <code>
                <a
                href="#dom-peerconnection-createdatachannel">createDataChannel()</a>
              </code>.</p>
          </dd>

          <dt>const unsigned short OPEN = 1</dt>

          <dd>
            <p>
            TODO - theses constants need to be changed to an enum. 
            </p>
            
            <p>The <a>underlying data transport</a> is established and
            communication is possible. This is the initial state of a <code>
                <a>DataChannel</a>
              </code> object dispatched as a part of a <code>
                <a>DataChannelEvent</a>
              </code>.</p>
          </dd>

          <dt>const unsigned short CLOSING = 2</dt>

          <dd>
            <p>The process of closing down the <a>underlying data
            transport</a> has started.</p>
          </dd>

          <dt>const unsigned short CLOSED = 3</dt>

          <dd>
            <p>The <a>underlying data transport</a> has been closed or could
            not be established.</p>
          </dd>

          <dt>readonly attribute unsigned short readyState</dt>

          <dd>
            <p>The <dfn id="dom-datachannel-readystate">
                <code>DataChannel.readyState</code>
              </dfn> attribute represents the state of the
            <code>DataChannel</code> object. It MUST return the value to which
            the user agent last set it (as defined by the processing model
            algorithms). The attribute can have the following values:
            <dfn>CONNECTING</dfn>, <dfn>OPEN</dfn>, <dfn>CLOSING</dfn> or
            <dfn>CLOSED</dfn>.</p>
          </dd>

          <dt>readonly attribute unsigned long bufferedAmount</dt>

          <dd>
            <p class="note">FIXME: align behavior with WebSocket API</p>
          </dd>

          <!-- networking -->

          <dt>[TreatNonCallableAsNull] attribute Function? onopen</dt>

          <dd>This event handler, of type <code>
              <a href="#event-datachannel-open">open</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>DataChannel</a>
            </code> interface.</dd>

          <dt>[TreatNonCallableAsNull] attribute Function? onerror</dt>

          <dd>This event handler, of type <code>
              <a href="#event-datachannel-error">error</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>DataChannel</a>
            </code> interface.</dd>

          <dt>[TreatNonCallableAsNull] attribute Function? onclose</dt>

          <dd>This event handler, of type <code>
              <a href="#event-datachannel-close">close</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>DataChannel</a>
            </code> interface.</dd>

          <!--dt>void close([Clamp] optional unsigned short code, optional DOMString reason)</dt>

    <dd>
      <p>Add text...</p>
    </dd-->

          <dt>void close()</dt>

          <dd>
            <p>Closes the <code>
                <a>DataChannel</a>
              </code>. It may be called regardless if the <code>
                <a>DataChannel</a>
              </code> object was created by this peer or the remote peer.</p>

            <p>When the <dfn>
                <code>close()</code>
              </dfn> method is called, the user agent MUST initiate <a
            href="#tear-down-data-transport">the process of tearing down</a>
            the <code>DataChannel</code> object’s <a>underlying data
            transport</a>.</p>
          </dd>

          <!-- messaging -->

          <dt>[TreatNonCallableAsNull] attribute Function? onmessage</dt>

          <dd>This event handler, of type <code>
              <a href="#event-datachannel-message">message</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>DataChannel</a>
            </code> interface.</dd>

          <dt>attribute DOMString binaryType</dt>

          <dd>
            <p class="note">FIXME: align behavior with WebSocket API</p>
          </dd>

          <dt>void send(DOMString data)</dt>

          <dd>
            <p class="note">FIXME: align behavior with WebSocket API</p>
          </dd>

          <dt>void send(ArrayBuffer data)</dt>

          <dd>
            <p class="note">FIXME: align behavior with WebSocket API</p>
          </dd>

          <dt>void send(Blob data)</dt>

          <dd>
            <p class="note">FIXME: align behavior with WebSocket API</p>
          </dd>
        </dl>

        <dl class="idl" title="dictionary DataChannelInit">
          <dt>boolean reliable</dt>

          <dd>-</dd>

          <!--dt>[Clamp] long priority</dt>

          <dd>-</dd-->
        </dl>
      </section>

      <section>
        <h3>Examples</h3>

        <div>
          <p>This simple example shows how to create a DataChannel, register
          an event listener to handle incoming data, and how to send a
          message.</p>

         <pre class="example sh_javascript">
var chan = peerConn.createDataChannel("mylabel");
chan.onmessage = function (evt) {
    // use evt.data };
    chan.send("hello");
</pre> 
        </div>

        <div>
          <p>This simple example shows how to register an event listener to
          handle the case when a remote peer creates a new DataChannel.</p>

        <pre class="example sh_javascript">

peerConn.ondatachannel = function (evt) {
   var chan = evt.channel;
   chan.onmessage = function (evt) {
       // use evt.data
   };
   chan.onclose = function () {
          // remote side closed the data channel
   };
};
</pre>>
        </div>

        <!--div>
    <p>This simple example shows how configure two DataChannel objects for different purposes.</p>
<pre  class='example sh_javascript'>
// the chat channel is reliable and not as prioritized as game data
var chatChan = peerConn.createDataChannel("chat", { "priority": 1 });

// the game data channel is prioritized and unreliable low latency channel for high performance
var gameDataChan = peerConn.createDataChannel("data", { "reliable": false, "priority": 10 });
    </pre> 
  </div-->
      </section>
    </section>

    <section>
      <h2>Garbage collection</h2>

      <p>A <code>Window</code> object <dfn
      id="concept-peerconnection-owner">has a strong reference</dfn> to any
      <code>
          <a>PeerConnection</a>
        </code> objects created from the constructor whose global object is
      that <code>Window</code> object.</p>

      <!-- we could be less strict here, e.g. dropping the reference when
  there’s no way for an event to be fired because there’s no event handlers
  registered and there’s no way for the remote peer to notice anything because
  no media is streaming; or e.g. dropping the reference when the object reaches
  the CLOSED state. But as dropping the reference in those cases is black-box
  indistinguishable from keeping the reference, I haven't bothered to work out
  the exact rules. If you do change this, see the /unloading document cleanup
  steps/. -->
    </section>

 
   <section>
        <h2>Event definitions</h2>

        <section>
        <h3>PeerConnectionEvent</h3>

        <p>Several of the PeerConnection events use the <code>
            <a>PeerConnectionEvent</a>
          </code> interface.</p>

        <p><dfn title="Fire a track event">Firing a PeerConnectionEvent event named
        <var>e</var></dfn> with a <code>
            <a>PeerConnection</a>
          </code> <var>peer</var> means that an event with the name
        <var>e</var>, which does not bubble (except where otherwise stated)
        and is not cancelable (except where otherwise stated), and which uses
        the <code>
            <a>PeerConnectionEvent</a>
          </code> interface with the <code>peer
          </code> attribute set to the <var>PeerConnectio</var> object, MUST be created and
        dispatched at the given target.</p>

        <dl class="idl" data-merge="PeerConnectionEventInit"
            title="[Constructor(DOMString type, PeerConnectionEventInit eventInitDict)]  interface PeerConnectionEvent : Event">
          <dt>readonly attribute PeerConnection peer</dt>

          <dd>
            <p>The <dfn id="dom-peerconnectionevent-track">
                <code>peer</code>
              </dfn> attribute represents the <code>
                <a>PeerConnection</a>
              </code> object associated with the event.</p>
          </dd>
        </dl>

        <dl class="idl"
            title="dictionary PeerConnectionEventInit : EventInit">
          <dt>PeerConnection peer</dt>

          <dd>
            <p> </p>
          </dd>
        </dl>
   </section>

              <section>
        <h3>PeerConnectionIceEvent</h3>

                <p>The <code>onicecandidate</code> event of the PeerConnection uses the <code>
            <a>PeerConnectionIceEvent</a>
          </code> interface.</p>

        <p><dfn title="Fire a track event">Firing a PeerConnectionIceEvent event named
        <var>e</var></dfn> with a <code>
            <a>PeerConnection</a>
          </code> <var>peer</var> means that an event with the name
        <var>e</var>, which does not bubble (except where otherwise stated)
        and is not cancelable (except where otherwise stated), and which uses
        the <code>PeerConnectionIceEvent</code> interface with the <code>peer
          </code> attribute set to the <var>PeerConnection</var> object, and the
        <code>candidate</code> attribute set to the new ICE candiate 
          MUST be created and
        dispatched at the given target.</p>

        <dl class="idl" data-merge="PeerConnectionIceEventInit"
            title="[Constructor(DOMString type, PeerConnectionIceEventInit eventInitDict)]  interface PeerConnectionIceEvent : Event">
          <dt>readonly attribute PeerConnection peer</dt>

          <dd>
            <p>The 
                <code>peer</code>
               attribute represents the <code>
                <a>PeerConnection</a>
              </code> object associated with the event.</p>
          </dd>

          <dt>readonly attribute IceCandidate candidate</dt>

          <dd>
            <p>The 
                <code>candidate</code>
               attribute is the <code>
                <a>IceCandidate</a>
              </code> object with the new ICE candiate that caused the event.</p>
          </dd>
        </dl>

        <dl class="idl"
            title="dictionary PeerConnectionEventIceInit : EventInit">
          <dt>PeerConnection peer</dt>

          <dd>
            <p> </p>
          </dd>
                    <dt>IceCandidate candidate</dt>

          <dd>
            <p> </p>
          </dd>
        </dl>
   </section>

      <section>
        <h3>MediaStreamTrackEvent</h3>

        <p>The <code>
            <a href="#event-mediastreamtracklist-addtrack">addtrack</a>
          </code> and <code title="event-MediaStreamTracklist-removetrack">
            <a href="#event-mediastreamtracklist-removetrack">removetrack</a>
          </code> events use the <code>
            <a>MediaStreamTrackEvent</a>
          </code> interface.</p>

        <p><dfn title="Fire a track event">Firing a track event named
        <var>e</var></dfn> with a <code>
            <a>MediaStreamTrack</a>
          </code> <var>track</var> means that an event with the name
        <var>e</var>, which does not bubble (except where otherwise stated)
        and is not cancelable (except where otherwise stated), and which uses
        the <code>
            <a>MediaStreamTrackEvent</a>
          </code> interface with the <code>
            <a href="#dom-mediastreamtrackevent-track">track</a>
          </code> attribute set to <var>track</var>, MUST be created and
        dispatched at the given target.</p>

        <dl class="idl" data-merge="MediaStreamTrackEventInit"
            title="[Constructor(DOMString type, MediaStreamTrackEventInit eventInitDict)] interface MediaStreamTrackEvent : Event">
          <dt>readonly attribute MediaStreamTrack track</dt>

          <dd>
            <p>The <dfn id="dom-mediastreamtrackevent-track">
                <code>track</code>
              </dfn> attribute represents the <code>
                <a>MediaStreamTrack</a>
              </code> object associated with the event.</p>
          </dd>
        </dl>

        <dl class="idl"
            title="dictionary MediaStreamTrackEventInit : EventInit">
          <dt>readonly MediaStreamTrack? track</dt>

          <dd>
            <p></p>
          </dd>
        </dl>
      </section>

      <section>
        <h3>MediaStreamEvent</h3>

        <p>The <code>
            <a href="#event-mediastream-addstream">addstream</a>
          </code> and <code title="event-MediaStream-removestream">
            <a href="#event-mediastream-removestream">removestream</a>
          </code> events use the <code>
            <a>MediaStreamEvent</a>
          </code> interface.</p>

        <p><dfn id="fire-a-stream-event" title="fire a stream event">Firing a
        stream event named <var>e</var></dfn> with a <code>
            <a>MediaStream</a>
          </code> <var>stream</var> means that an event with the name
        <var>e</var>, which does not bubble (except where otherwise stated)
        and is not cancelable (except where otherwise stated), and which uses
        the <code>
            <a>MediaStreamEvent</a>
          </code> interface with the <code>
            <a href="#dom-mediastreamevent-stream">stream</a>
          </code> attribute set to <var title="">stream</var>, MUST be created
        and dispatched at the given target.</p>

        <dl class="idl" data-merge="MediaStreamEventInit"
            title="[Constructor(DOMString type, MediaStreamEventInit eventInitDict)] interface MediaStreamEvent : Event">
          <dt>readonly attribute MediaStream? stream</dt>

          <dd>
            <p>The <dfn id="dom-mediastreamevent-stream">
                <code>stream</code>
              </dfn> attribute represents the <code>
                <a>MediaStream</a>
              </code> object associated with the event.</p>
          </dd>
        </dl>

        <dl class="idl" title="dictionary MediaStreamEventInit : EventInit">
          <dt>MediaStream stream</dt>

          <dd>
            <p></p>
          </dd>
        </dl>
      </section>

      <section>
        <h3>DataChannelEvent</h3>

        <p>The <code>
            <a href="#event-peerconnection-datachannel">datachannel</a>
          </code> event use the <code>
            <a>DataChannelEvent</a>
          </code> interface.</p>

        <p><dfn id="fire-a-datachannel-event"
        title="fire a datachannel event">Firing a datachannel event named
        <var>e</var></dfn> with a <code>
            <a>DataChannel</a>
          </code> <var>channel</var> means that an event with the name
        <var>e</var>, which does not bubble (except where otherwise stated)
        and is not cancelable (except where otherwise stated), and which uses
        the <code>
            <a>DataChannelEvent</a>
          </code> interface with the <code>
            <a href="#dom-datachannelevent-channel">channel</a>
          </code> attribute set to <var>channel</var>, MUST be created and
        dispatched at the given target.</p>

        <dl class="idl" data-merge="DataChannelEventInit"
            title="[Constructor(DOMString type, DataChannelEventInit eventInitDict)] interface DataChannelEvent : Event">
          <dt>readonly attribute DataChannel channel</dt>

          <dd>
            <p>The <dfn id="dom-datachannelevent-channel">
                <code>channel</code>
              </dfn> attribute represents the <code>
                <a>DataChannel</a>
              </code> object associated with the event.</p>
          </dd>
        </dl>

        <dl class="idl" title="dictionary DataChannelEventInit : EventInit">
          <dt>DataChannel channel</dt>

          <dd></dd>
        </dl>
      </section>
    </section>

    <section class="informative">
      <h2>Event summary</h2>

      <p>The following event fires on <code>
          <a>MediaStream</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastream-ended">
                <code>ended</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStream</a>
              </code> <a>finished</a> as a result of all tracks in the <code>
                <a>MediaStream</a>
              </code> <a title="ended">ending</a>.</td>
          </tr>
        </tbody>
      </table>

      <p>The following event fires on <code>
          <a>MediaStreamTrack</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastreamtrack-muted">
                <code>muted</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStreamTrack</a>
              </code> object's source is temporarily unable to provide
            data.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastreamtrack-unmuted">
                <code>unmuted</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStreamTrack</a>
              </code> object's source is live again after having been
            temporarily unable to provide data.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastreamtrack-ended">
                <code>ended</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStreamTrack</a>
              </code> object's source will no longer provide any data, either
            because the user revoked the permissions, or because the source
            device has been ejected, or because the remote peer stopped
            sending data, or because the <code>
                <a href="#dom-mediastream-stop">stop()</a>
              </code> method was invoked.</td>
          </tr>
        </tbody>
      </table>

      <p>The following event fires on <code>
          <a>MediaStreamTrackList</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastreamtracklist-addtrack">
                <code>addtrack</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamTrackEvent</a>
              </code>
            </td>

            <td>A new <code>
                <a>MediaStreamTrack</a>
              </code> has been added to this list.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastreamtracklist-removetrack">
                <code>removetrack</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamTrackEvent</a>
              </code>
            </td>

            <td>A <code>
                <a>MediaStreamTrack</a>
              </code> has been removed from this list.</td>
          </tr>
        </tbody>
      </table>

        <p>The following event fires on <code>
          <a>DataChannel</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>

          
          <tr>
            <td>
              <dfn id="event-datachannel-open">
              <code>open</code>
              </dfn>
            </td>
            
            <td>
              <code>
              <a>Event</a>
              </code>
            </td>
            
            <td>  The <code><a>DataChannel</a></code> object’s <a>underlying data
            transport</a> has been established (or re-established).</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-datachannel-message">
              <code>MessageEvent</code>
              </dfn>
            </td>
            
            <td>
              <code>
              <a>Event</a>
              </code>
            </td>
            
            <td>A message was successfully received. TODO: Ref where MessageEvent
          is defined? </td>
          </tr>

          <tr>
            <td>
              <dfn id="event-datachannel-error">
              <code>error</code>
              </dfn>
            </td>
            
            <td>
              <code>
              <a>Event</a>
              </code>
            </td>
            
            <td>TODO.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-datachannel-close">
              <code>close</code>
              </dfn>
            </td>
            
            <td>
              <code>
              <a>Event</a>
              </code>
            </td>
            
            <td> The <code><a>DataChannel</a></code> object’s <a>underlying data
            transport</a> has was closed.</td>
          </tr>


          
        
        </tbody>
      </table>

      
      <p>The following events fire on <code>
          <a>PeerConnection</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastream-connecting">
                <code>connecting</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>TODO</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastream-open">
                <code>open</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>TODO</td>
          </tr>

          <!--
        <tr>
          <td><dfn title="event-MediaStream-error"><code>error</code></dfn></td>
          <td><code>Event</code></td>
          <td></td>
        </tr>
        <tr>
          <td><dfn title="event-MediaStream-close"><code>close</code></dfn></td>
          <td><code>Event</code></td>
          <td>The <code title="dom-PeerConnection-close">close()</code> method was
            called. </td>
          </tr>
          -->

          <!--
          <tr>
            <td>
              <dfn id="event-mediastream-message">
                <code>message</code>
              </dfn>
            </td>

            <td>
              <code>MessageEvent</code>
            </td>

            <td>A <a href="#data-udp-media-stream">data UDP media
            stream</a> message was received.</td>
          </tr>
          -->
          
          <tr>
            <td>
              <dfn id="event-mediastream-addstream">
                <code>addstream</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamEvent</a>
              </code>
            </td>

            <td>A new stream has been added to the <code
                title="dom-PeerConnection-remoteStreams">
                <a href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
              </code> array.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastream-removestream">
                <code>removestream</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamEvent</a>
              </code>
            </td>

            <td>A stream has been removed from the <code
                title="dom-PeerConnection-remoteStreams">
                <a href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
              </code> array.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-renegotiation">
                <code>renegotiationneeded</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>PeerConnectionEvent</a>
              </code>
            </td>

            <td>The browser wishes to inform the application that session
            negotiation needs to be redone at some point in the near future.
            Open Issue: should this be moved to "Negotiation Needed" instead
            of "Re-Negotiation Needed"? </td>
          </tr>


            <tr>
            <td>
              <dfn id="event-statechange">
                <code>statechange</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>PeerConnectionEvent</a>
              </code>
            </td>

            <td> TODO </td>
          </tr>


               <tr>
            <td>
              <dfn id="event-icechange">
                <code>icechange</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>PeerConnectionEvent</a>
              </code>
            </td>

            <td> TODO </td>
          </tr>

          <tr>
            <td>
              <dfn id="event-icecandidate">
              <code>icecandidate</code>
              </dfn>
            </td>

            <td>
              <code>
              <a>PeerConnectionIceEvent</a>
              </code>
            </td>
            
            <td> TODO </td>
          </tr>


        </tbody>
      </table>
    </section>

    <section>
      <h2>Change Log</h2>

      <p> This section will be removed before publication. </p>

      <h3> Changes since May 28, 2012 </h3>

      <ol>
        <li> TODO </li>
      </ol>

      
      <h3> Changes since April 27, 2012 </h3>

      <ol>
        <li> Major rewrite of PeerConnection section to line up with IETF JSEP
        draft.  </li>

        <li>Added simple PeerConnection example. Initial update of
        SessionDescription and IceCandidate to support serialization and
        construction.</li>
      </ol>

      <h3>Changes since 21 April 2012</h3>

      <ol>
        <li>Moved MediaStream and related definitions to getUserMedia.</li>

        <li>Removed some left-overs from the old Data Stream API.</li>

        <li>Initial import of new Data API.</li>

        <li>Renamed "underlying data channel" to "underlying data transport".
        Fixed closing procedures. Fixed some typos.</li>
      </ol>

      <h3> Changes since 12 January 2012</h3>

      <ol>
        <li> Clarified the relation of Stream, Track, and Channel. </li>
      </ol>

      <h3> Changes since 17 October 2011</h3>

      <ol>
        <li>Tweak the introduction text and add a reference to the IETF RTCWEB
        group.</li>

        <li>Changed the first argument to getUserMedia to be an object.</li>

        <li>Added a MediaStreamHints object as a second argument to
        PeerConnection.addStream.</li>

        <li>Added AudioMediaStreamTrack class and DTMF interface.</li>
      </ol>

      <h3> Changes since 23 August 2011</h3>

      <ol>
        <li> Separated the SDP and ICE Agent into separate agents and added
        explicit state attributes for each. </li>

        <li> Removed the send method from PeerConenction and associated
        callback function. </li>

        <li>Modified MediaStream() constructor to take a list of
        MediaStreamTrack objects instead of a MediaStream. Removed text about
        MediaStream parent and child relationship.</li>

        <li>Added abstract.</li>

        <li>Moved a few paragraphs from the MediaStreamTrack.label section to
        the MediaStream.label section (where they belong).</li>

        <li>Split MediaStream.tracks into MediaStream.audioTracks and
        MediaStream.videoTracks.</li>

        <li>Removed a sentence that implied that track access is limited to
        LocalMediaStream.</li>

        <li>Updated a few getUserMedia()-examples to use
        MediaStreamOptions.</li>

        <li>Replaced calls to URL.getObjectURL() with URL.createObjectURL() in
        example code.</li>

        <li>Fixed some broken getUserMedia() links.</li>

        <li>Introduced state handling on MediaStreamTrack (removed state
        handling from MediaStream).</li>

        <li>Reintroduced onended on MediaStream to simplify checking if all
        tracks are ended.</li>

        <li>Aligned the MediaStreamTrack ended event dispatching behavior with
        that of MediaStream.</li>

        <li>Updated the LocalMediaStream.stop() algorithm to implicitly use
        the end track algorithm.</li>

        <li>Replaced an occurrence the term finished track with ended track
        (to align with rest of spec).</li>

        <li>Moved (and extended) the explanation about track references and
        media sources from LocalMediaStream to MediaStreamTrack.</li>

        <li>Removed section "Obtaining local multimedia content".</li>

        <li>Updated getUserMedia() calls in examples (changes in Media Capture
        TF spec).</li>

        <li>Introduced MediaStreamTrackList interface with support for adding
        and removing tracks.</li>

        <li>Updated the algorithm that is run when PeerConnection receives a
        stream (create new stream when negotiated instead of when data
        arrives).</li>

        <li>Updated simple PeerConnection example (PeerConnection constructor
        arguments; use icecandidate event).</li>
      </ol>
    </section>

    <section class="appendix">
      <h2>Acknowledgements</h2>

      <p>The editors wish to thank the Working Group chairs, Harald Alvestrand
      and Stefan Håkansson, for their support.</p>
    </section>
  </body>
</html>
