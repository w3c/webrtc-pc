<!DOCTYPE html>
<html lang="en" typeof="bibo:Document " prefix="bibo: http://purl.org/ontology/bibo/ w3p: http://www.w3.org/2001/02pd/rec54#">
<head><meta property="dc:language" content="en" lang="">
  <title>WebRTC 1.0: Real-time Communication Between Browsers</title>
  <meta charset="utf-8">
  
  
<style>/*****************************************************************
 * ReSpec 3 CSS
 * Robin Berjon - http://berjon.com/
 *****************************************************************/

/* --- INLINES --- */
em.rfc2119 { 
    text-transform:     lowercase;
    font-variant:       small-caps;
    font-style:         normal;
    color:              #900;
}

h1 acronym, h2 acronym, h3 acronym, h4 acronym, h5 acronym, h6 acronym, a acronym,
h1 abbr, h2 abbr, h3 abbr, h4 abbr, h5 abbr, h6 abbr, a abbr {
    border: none;
}

dfn {
    font-weight:    bold;
}

a.internalDFN {
    color:  inherit;
    border-bottom:  1px solid #99c;
    text-decoration:    none;
}

a.externalDFN {
    color:  inherit;
    border-bottom:  1px dotted #ccc;
    text-decoration:    none;
}

a.bibref {
    text-decoration:    none;
}

cite .bibref {
    font-style: normal;
}

code {
    color:  #C83500;
}

/* --- TOC --- */
.toc a, .tof a {
    text-decoration:    none;
}

a .secno, a .figno {
    color:  #000;
}

ul.tof, ol.tof {
    list-style: none outside none;
}

.caption {
    margin-top: 0.5em;
    font-style:   italic;
}

/* --- TABLE --- */
table.simple {
    border-spacing: 0;
    border-collapse:    collapse;
    border-bottom:  3px solid #005a9c;
}

.simple th {
    background: #005a9c;
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
}

.simple th[scope="row"] {
    background: inherit;
    color:  inherit;
    border-top: 1px solid #ddd;
}

.simple td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
}

.simple tr:nth-child(even) {
    background: #f0f6ff;
}

/* --- DL --- */
.section dd > p:first-child {
    margin-top: 0;
}

.section dd > p:last-child {
    margin-bottom: 0;
}

.section dd {
    margin-bottom:  1em;
}

.section dl.attrs dd, .section dl.eldef dd {
    margin-bottom:  0;
}

@media print {
    .removeOnSave {
        display: none;
    }
}
</style><style>/* --- EXAMPLES --- */
div.example-title {
    min-width: 7.5em;
    color: #b9ab2d;
}
div.example-title span {
    text-transform: uppercase;   
}
aside.example, div.example, div.illegal-example {
    padding: 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
div.illegal-example { color: red }
div.illegal-example p { color: black }
aside.example, div.example {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
    border-color: #e0cb52;
    background: #fcfaee;    
}

aside.example div.example {
    border-left-width: .1em;
    border-color: #999;
    background: #fff;
}
aside.example div.example div.example-title {
    color: #999;
}
</style><style>/* --- ISSUES/NOTES --- */
div.issue-title, div.note-title , div.warning-title {
    padding-right:  1em;
    min-width: 7.5em;
    color: #b9ab2d;
}
div.issue-title { color: #e05252; }
div.note-title { color: #2b2; }
div.warning-title { color: #f22; }
div.issue-title span, div.note-title span, div.warning-title span {
    text-transform: uppercase;
}
div.note, div.issue, div.warning {
    margin-top: 1em;
    margin-bottom: 1em;
}
.note > p:first-child, .issue > p:first-child, .warning > p:first-child { margin-top: 0 }
.issue, .note, .warning {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
}
div.issue, div.note , div.warning {
    padding: 1em 1.2em 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
span.note, span.issue, span.warning { padding: .1em .5em .15em; }

.issue {
    border-color: #e05252;
    background: #fbe9e9;
}
.note {
    border-color: #52e052;
    background: #e9fbe9;
}

.warning {
    border-color: #f11;
    border-right-width: .2em;
    border-top-width: .2em;
    border-bottom-width: .2em;
    border-style: solid;
    background: #fbe9e9;
}

.warning-title:before{
    content: "⚠"; /*U+26A0 WARNING SIGN*/
    font-size: 3em;
    float: left;
    height: 100%;
    padding-right: .3em;
    vertical-align: top;
    margin-top: -0.5em;
}
</style><style>/* HIGHLIGHTS */
code.prettyprint {
    color:  inherit;
}

/* this from google-code-prettify */
.pln{color:#000}@media screen{.str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun,.opn,.clo{color:#660}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec,.var{color:#606}.fun{color:red}}@media print,projection{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun,.opn,.clo{color:#440}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style-type:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}
</style><style>/* --- WEB IDL --- */
pre.idl {
    border-top: 1px solid #90b8de;
    border-bottom: 1px solid #90b8de;
    padding:    1em;
    line-height:    120%;
}

pre.idl::before {
    content:    "WebIDL";
    display:    block;
    width:      150px;
    background: #90b8de;
    color:  #fff;
    font-family:    initial;
    padding:    3px;
    font-weight:    bold;
    margin: -1em 0 1em -1em;
}

.idlType {
    color:  #ff4500;
    font-weight:    bold;
    text-decoration:    none;
}

/*.idlModule*/
/*.idlModuleID*/
/*.idlInterface*/
.idlInterfaceID, .idlDictionaryID, .idlCallbackID, .idlEnumID {
    font-weight:    bold;
    color:  #005a9c;
}
a.idlEnumItem {
    color:  #000;
    border-bottom:  1px dotted #ccc;
    text-decoration: none;
}

.idlSuperclass {
    font-style: italic;
    color:  #005a9c;
}

/*.idlAttribute*/
.idlAttrType, .idlFieldType, .idlMemberType {
    color:  #005a9c;
}
.idlAttrName, .idlFieldName, .idlMemberName {
    color:  #ff4500;
}
.idlAttrName a, .idlFieldName a, .idlMemberName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlMethod*/
.idlMethType, .idlCallbackType {
    color:  #005a9c;
}
.idlMethName {
    color:  #ff4500;
}
.idlMethName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlCtor*/
.idlCtorName {
    color:  #ff4500;
}
.idlCtorName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlParam*/
.idlParamType {
    color:  #005a9c;
}
.idlParamName, .idlDefaultValue {
    font-style: italic;
}

.extAttr {
    color:  #666;
}

/*.idlSectionComment*/
.idlSectionComment {
    color: gray;
}

/*.idlConst*/
.idlConstType {
    color:  #005a9c;
}
.idlConstName {
    color:  #ff4500;
}
.idlConstName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlException*/
.idlExceptionID {
    font-weight:    bold;
    color:  #c00;
}

.idlTypedefID, .idlTypedefType {
    color:  #005a9c;
}

.idlRaises, .idlRaises a.idlType, .idlRaises a.idlType code, .excName a, .excName a code {
    color:  #c00;
    font-weight:    normal;
}

.excName a {
    font-family:    monospace;
}

.idlRaises a.idlType, .excName a.idlType {
    border-bottom:  1px dotted #c00;
}

.excGetSetTrue, .excGetSetFalse, .prmNullTrue, .prmNullFalse, .prmOptTrue, .prmOptFalse {
    width:  45px;
    text-align: center;
}
.excGetSetTrue, .prmNullTrue, .prmOptTrue { color:  #0c0; }
.excGetSetFalse, .prmNullFalse, .prmOptFalse { color:  #c00; }

.idlImplements a {
    font-weight:    bold;
}

dl.attributes, dl.methods, dl.constants, dl.constructors, dl.fields, dl.dictionary-members {
    margin-left:    2em;
}

.attributes dt, .methods dt, .constants dt, .constructors dt, .fields dt, .dictionary-members dt {
    font-weight:    normal;
}

.attributes dt code, .methods dt code, .constants dt code, .constructors dt code, .fields dt code, .dictionary-members dt code {
    font-weight:    bold;
    color:  #000;
    font-family:    monospace;
}

.attributes dt code, .fields dt code, .dictionary-members dt code {
    background:  #ffffd2;
}

.attributes dt .idlAttrType code, .fields dt .idlFieldType code, .dictionary-members dt .idlMemberType code {
    color:  #005a9c;
    background:  transparent;
    font-family:    inherit;
    font-weight:    normal;
    font-style: italic;
}

.methods dt code {
    background:  #d9e6f8;
}

.constants dt code {
    background:  #ddffd2;
}

.constructors dt code {
    background:  #cfc;
}

.attributes dd, .methods dd, .constants dd, .constructors dd, .fields dd, .dictionary-members dd {
    margin-bottom:  1em;
}

table.parameters, table.exceptions {
    border-spacing: 0;
    border-collapse:    collapse;
    margin: 0.5em 0;
    width:  100%;
}
table.parameters { border-bottom:  1px solid #90b8de; }
table.exceptions { border-bottom:  1px solid #deb890; }

.parameters th, .exceptions th {
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
    font-family:    initial;
    font-weight:    normal;
    text-shadow:    #666 1px 1px 0;
}
.parameters th { background: #90b8de; }
.exceptions th { background: #deb890; }

.parameters td, .exceptions td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
    vertical-align: top;
}

.parameters tr:first-child td, .exceptions tr:first-child td {
    border-top: none;
}

.parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
    width:  100px;
}

.parameters td.prmType {
    width:  120px;
}

table.exceptions table {
    border-spacing: 0;
    border-collapse:    collapse;
    width:  100%;
}
</style><link href="https://www.w3.org/StyleSheets/TR/W3C-ED" rel="stylesheet"><!--[if lt IE 9]><script src='https://www.w3.org/2008/site/js/html5shiv.js'></script><![endif]--></head>

<body id="respecDocument" role="document" class="h-entry"><div id="respecHeader" role="contentinfo" class="head">
  <p>
      
        
            <a href="http://www.w3.org/"><img src="https://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width="72"></a>
        
      
  </p>
  <h1 class="title p-name" id="title" property="dcterms:title">WebRTC 1.0: Real-time Communication Between Browsers</h1>
  
  <h2 id="w3c-editor-s-draft-02-february-2015"><acronym title="World Wide Web Consortium">W3C</acronym> Editor's Draft <time property="dcterms:issued" class="dt-published" datetime="2015-02-02">02 February 2015</time></h2>
  <dl>
    
      <dt>This version:</dt>
      <dd><a class="u-url" href="http://w3c.github.io/webrtc-pc/archives/20150202/webrtc.html">http://w3c.github.io/webrtc-pc/archives/20150202/webrtc.html</a></dd>
      <dt>Latest published version:</dt>
      <dd><a href="http://www.w3.org/TR/webrtc/">http://www.w3.org/TR/webrtc/</a></dd>
    
    
      <dt>Latest editor's draft:</dt>
      <dd><a href="http://w3c.github.io/webrtc-pc/">http://w3c.github.io/webrtc-pc/</a></dd>
    
    
    
    
    
      
        <dt>Previous editor's draft:</dt>
        <dd><a href="http://w3c.github.io/webrtc-pc/archives/20141205/webrtc.html">http://w3c.github.io/webrtc-pc/archives/20141205/webrtc.html</a></dd>
      
    
    
    
    <dt>Editors:</dt>
    <dd class="p-author h-card vcard" property="bibo:editor" resource="_:editor0"><span property="rdf:first" typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Adam Bergkvist</span>, Ericsson</span>
<span property="rdf:rest" resource="_:editor1"></span>
</dd>
<dd class="p-author h-card vcard" resource="_:editor1"><span property="rdf:first" typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Daniel C. Burnett</span>, Voxeo</span>
<span property="rdf:rest" resource="_:editor2"></span>
</dd>
<dd class="p-author h-card vcard" resource="_:editor2"><span property="rdf:first" typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Cullen Jennings</span>, Cisco</span>
<span property="rdf:rest" resource="_:editor3"></span>
</dd>
<dd class="p-author h-card vcard" resource="_:editor3"><span property="rdf:first" typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Anant Narayanan</span>, Mozilla (until November 2012)</span>
<span property="rdf:rest" resource="rdf:nil"></span>
</dd>

    
    
      
        
          <dt>Participate:</dt>
          
             
                
                  <dd>
                    <a href="http://lists.w3.org/Archives/Public/public-webrtc/">
                      Mailing list
                    </a>
                  </dd>
                
             
                
                  <dd>
                    <a href="https://github.com/w3c/webrtc-pc/issues">
                      Browse open issues
                    </a>
                  </dd>
                
             
                
                  <dd>
                    <a href="https://tools.ietf.org/wg/rtcweb/">
                      IETF RTCWEB Working Group
                    </a>
                  </dd>
                
             
          
        
      
    
  </dl>
  
  
  
  
    
      <p class="copyright">Initial Author of this Specification was Ian Hickson, Google Inc., with the following copyright statement:<br> © Copyright 2004-2011 Apple Computer, Inc., Mozilla Foundation, and Opera Software ASA. You are granted a license to use, reproduce and create derivative works of this document.</p> <p class="copyright">All subsequent changes since 26 July 2011 done by the <acronym title="World Wide Web Consortium">W3C</acronym> WebRTC Working Group are under the following <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>:<br>© 2011-2015 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. <a href="http://www.w3.org/Consortium/Legal/copyright-documents">Document use</a>  rules apply.</p> <p class="copyright">For the entire publication on the <acronym title="World Wide Web Consortium">W3C</acronym> site the <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a> and <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> rules apply.</p>
    
  
  <hr>
</div>
  <section property="dc:abstract" class="introductory" id="abstract"><h2 resource="#h-abstract" id="h-abstract"><span property="xhv:role" resource="xhv:heading">Abstract</span></h2>
    <p>This document defines a set of ECMAScript APIs in WebIDL to allow media
    to be sent to and received from another browser or device implementing the
    appropriate set of real-time protocols. This specification is being
    developed in conjunction with a protocol specification developed by the
    IETF RTCWEB group and an API specification to get access to local media
    devices developed by the Media Capture Task Force.</p>
  </section><section id="sotd" class="introductory"><h2 resource="#h-sotd" id="h-sotd"><span property="xhv:role" resource="xhv:heading">Status of This Document</span></h2>
  
    
      
        <p>
          <em>This section describes the status of this document at the time of its publication.
          Other documents may supersede this document. A list of current <acronym title="World Wide Web Consortium">W3C</acronym> publications and the
          latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/"><acronym title="World Wide Web Consortium">W3C</acronym> technical reports index</a> at
          http://www.w3.org/TR/.</em>
        </p>
        
        
    <p>This document is neither complete nor stable, and as such is not yet
    suitable for commercial implementation. However, early experimentation is
    encouraged. The API is based on preliminary work done in the WHATWG. The
    Web Real-Time Communications Working Group expects this specification to
    evolve significantly based on:</p>

    <ul>
      <li>The outcome of ongoing exchanges in the companion RTCWEB group at
      IETF to define the set of protocols that, together with this document,
      will enable real-time communications in Web browsers.</li>

      <li>Privacy issues that arise when exposing local capabilities and local
      streams.</li>

      <li>Technical discussions within the group.</li>

      <li>Experience gained through early experimentations.</li>

      <li>Feedback received from other groups and individuals.</li>
    </ul>
  
        
        <p>
          This document was published by the <a href="http://www.w3.org/2011/04/webrtc/">Web Real-Time Communications Working Group</a> as an Editor's Draft.
          
          
            If you wish to make comments regarding this document, please send them to 
            <a href="mailto:public-webrtc@w3.org">public-webrtc@w3.org</a> 
            (<a href="mailto:public-webrtc-request@w3.org?subject=subscribe">subscribe</a>,
            <a href="http://lists.w3.org/Archives/Public/public-webrtc/">archives</a>).
          
          
          
          
          
            
            All comments are welcome.
            
          
        </p>
        
        
        
          <p>
            Publication as an Editor's Draft does not imply endorsement by the <acronym title="World Wide Web Consortium">W3C</acronym>
            Membership. This is a draft document and may be updated, replaced or obsoleted by other
            documents at any time. It is inappropriate to cite this document as other than work in
            progress.
          </p>
        
        
        
        <p>
          
            This document was produced by a group operating under the 
            <a id="sotd_patent" property="w3p:patentRules" href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 <acronym title="World Wide Web Consortium">W3C</acronym> Patent
            Policy</a>.
          
          
          
            
              <acronym title="World Wide Web Consortium">W3C</acronym> maintains a <a href="http://www.w3.org/2004/01/pp-impl/47318/status" rel="disclosure">public list of any patent
              disclosures</a> 
            
            made in connection with the deliverables of the group; that page also includes
            instructions for disclosing a patent. An individual who has actual knowledge of a patent
            which the individual believes contains
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
            Claim(s)</a> must disclose the information in accordance with
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
            6 of the <acronym title="World Wide Web Consortium">W3C</acronym> Patent Policy</a>.
          
          
        </p>
        
          <p>This document is governed by the <a id="w3c_process_revision" href="http://www.w3.org/2014/Process-20140801/">1 August 2014 <acronym title="World Wide Web Consortium">W3C</acronym> Process Document</a>.
          </p>
        
        
      
    
  
</section><section id="toc"><h2 resource="#h-toc" id="h-toc" class="introductory"><span property="xhv:role" resource="xhv:heading">Table of Contents</span></h2><ul id="respecContents" role="directory" class="toc"><li class="tocline"><a class="tocxref" href="#intro"><span class="secno">1. </span>Introduction</a></li><li class="tocline"><a class="tocxref" href="#conformance"><span class="secno">2. </span>Conformance</a></li><li class="tocline"><a class="tocxref" href="#terminology"><span class="secno">3. </span>Terminology</a></li><li class="tocline"><a class="tocxref" href="#peer-to-peer-connections"><span class="secno">4. </span>Peer-to-peer connections</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#introduction"><span class="secno">4.1 </span>Introduction</a></li><li class="tocline"><a class="tocxref" href="#configuration"><span class="secno">4.2 </span>Configuration</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#rtcconfiguration-type"><span class="secno">4.2.1 </span>RTCConfiguration Type</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#dictionary-rtcconfiguration-members"><span class="secno">4.2.1.1 </span>Dictionary <span class="formerLink"><code>RTCConfiguration</code></span> Members</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtciceserver-type"><span class="secno">4.2.2 </span>RTCIceServer Type</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#dictionary-rtciceserver-members"><span class="secno">4.2.2.1 </span>Dictionary <span class="formerLink"><code>RTCIceServer</code></span> Members</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcicetransportpolicy-enum"><span class="secno">4.2.3 </span>RTCIceTransportPolicy Enum</a></li><li class="tocline"><a class="tocxref" href="#rtcbundlepolicy-enum"><span class="secno">4.2.4 </span>RTCBundlePolicy Enum</a></li><li class="tocline"><a class="tocxref" href="#offer-answer-options"><span class="secno">4.2.5 </span>Offer/Answer Options</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#dictionary-rtcofferoptions-members"><span class="secno">4.2.5.1 </span>Dictionary <span class="formerLink"><code>RTCOfferOptions</code></span> Members</a></li></ul></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcpeerconnection-interface"><span class="secno">4.3 </span>RTCPeerConnection Interface</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#operation"><span class="secno">4.3.1 </span>Operation</a></li><li class="tocline"><a class="tocxref" href="#interface-definition"><span class="secno">4.3.2 </span>Interface Definition</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#constructors"><span class="secno">4.3.2.1 </span>Constructors</a></li><li class="tocline"><a class="tocxref" href="#attributes"><span class="secno">4.3.2.2 </span>Attributes</a></li><li class="tocline"><a class="tocxref" href="#methods"><span class="secno">4.3.2.3 </span>Methods</a></li></ul></li><li class="tocline"><a class="tocxref" href="#legacy-interface-extensions"><span class="secno">4.3.3 </span>Legacy Interface Extensions</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#methods-1"><span class="secno">4.3.3.1 </span>Methods</a></li></ul></li><li class="tocline"><a class="tocxref" href="#garbage-collection"><span class="secno">4.3.4 </span>Garbage collection</a></li></ul></li><li class="tocline"><a class="tocxref" href="#state-definitions"><span class="secno">4.4 </span>State Definitions</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#rtcpeerstate-enum"><span class="secno">4.4.1 </span>RTCPeerState Enum</a></li><li class="tocline"><a class="tocxref" href="#rtcicegatheringstate-enum"><span class="secno">4.4.2 </span>RTCIceGatheringState Enum</a></li><li class="tocline"><a class="tocxref" href="#rtciceconnectionstate-enum"><span class="secno">4.4.3 </span>RTCIceConnectionState Enum</a></li></ul></li><li class="tocline"><a class="tocxref" href="#callback-definitions"><span class="secno">4.5 </span>Callback Definitions</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#rtcpeerconnectionerrorcallback"><span class="secno">4.5.1 </span>RTCPeerConnectionErrorCallback</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#callback-rtcpeerconnectionerrorcallback-parameters"><span class="secno">4.5.1.1 </span>Callback <span class="formerLink"><code>RTCPeerConnectionErrorCallback</code></span> Parameters</a></li></ul></li></ul></li><li class="tocline"><a class="tocxref" href="#error-handling"><span class="secno">4.6 </span>Error Handling</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#general-principles"><span class="secno">4.6.1 </span>General Principles</a></li><li class="tocline"><a class="tocxref" href="#rtcsdperror"><span class="secno">4.6.2 </span>RTCSdpError</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-1"><span class="secno">4.6.2.1 </span>Attributes</a></li></ul></li></ul></li><li class="tocline"><a class="tocxref" href="#session-description-model"><span class="secno">4.7 </span>Session Description Model</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#rtcsdptype"><span class="secno">4.7.1 </span>RTCSdpType</a></li><li class="tocline"><a class="tocxref" href="#rtcsessiondescription-class"><span class="secno">4.7.2 </span>RTCSessionDescription Class</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#constructors-1"><span class="secno">4.7.2.1 </span>Constructors</a></li><li class="tocline"><a class="tocxref" href="#attributes-2"><span class="secno">4.7.2.2 </span>Attributes</a></li><li class="tocline"><a class="tocxref" href="#serializer"><span class="secno">4.7.2.3 </span>Serializer</a></li><li class="tocline"><a class="tocxref" href="#dictionary-rtcsessiondescriptioninit-members"><span class="secno">4.7.2.4 </span>Dictionary <span class="formerLink"><code>RTCSessionDescriptionInit</code></span> Members</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcsessiondescriptioncallback"><span class="secno">4.7.3 </span>RTCSessionDescriptionCallback</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#callback-rtcsessiondescriptioncallback-parameters"><span class="secno">4.7.3.1 </span>Callback <span class="formerLink"><code>RTCSessionDescriptionCallback</code></span> Parameters</a></li></ul></li></ul></li><li class="tocline"><a class="tocxref" href="#interfaces-for-connectivity-establishment"><span class="secno">4.8 </span>Interfaces for Connectivity Establishment</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#rtcicecandidate-type"><span class="secno">4.8.1 </span>RTCIceCandidate Type</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#constructors-2"><span class="secno">4.8.1.1 </span>Constructors</a></li><li class="tocline"><a class="tocxref" href="#attributes-3"><span class="secno">4.8.1.2 </span>Attributes</a></li><li class="tocline"><a class="tocxref" href="#serializer-1"><span class="secno">4.8.1.3 </span>Serializer</a></li><li class="tocline"><a class="tocxref" href="#dictionary-rtcicecandidateinit-members"><span class="secno">4.8.1.4 </span>Dictionary <span class="formerLink"><code>RTCIceCandidateInit</code></span> Members</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcpeerconnectioniceevent"><span class="secno">4.8.2 </span>RTCPeerConnectionIceEvent</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#constructors-3"><span class="secno">4.8.2.1 </span>Constructors</a></li><li class="tocline"><a class="tocxref" href="#attributes-4"><span class="secno">4.8.2.2 </span>Attributes</a></li><li class="tocline"><a class="tocxref" href="#dictionary-rtcpeerconnectioniceeventinit-members"><span class="secno">4.8.2.3 </span>Dictionary <span class="formerLink"><code>RTCPeerConnectionIceEventInit</code></span> Members</a></li></ul></li></ul></li></ul></li><li class="tocline"><a class="tocxref" href="#peer-to-peer-data-api"><span class="secno">5. </span>Peer-to-peer Data API</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#rtcpeerconnection-interface-extensions"><span class="secno">5.1 </span>RTCPeerConnection Interface Extensions</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-5"><span class="secno">5.1.1 </span>Attributes</a></li><li class="tocline"><a class="tocxref" href="#methods-2"><span class="secno">5.1.2 </span>Methods</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcdatachannel"><span class="secno">5.2 </span>RTCDataChannel</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-6"><span class="secno">5.2.1 </span>Attributes</a></li><li class="tocline"><a class="tocxref" href="#methods-3"><span class="secno">5.2.2 </span>Methods</a></li><li class="tocline"><a class="tocxref" href="#dictionary-rtcdatachannelinit-members"><span class="secno">5.2.3 </span>Dictionary <span class="formerLink"><code>RTCDataChannelInit</code></span> Members</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcdatachannelevent"><span class="secno">5.3 </span>RTCDataChannelEvent</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#constructors-4"><span class="secno">5.3.1 </span>Constructors</a></li><li class="tocline"><a class="tocxref" href="#attributes-7"><span class="secno">5.3.2 </span>Attributes</a></li><li class="tocline"><a class="tocxref" href="#dictionary-rtcdatachanneleventinit-members"><span class="secno">5.3.3 </span>Dictionary <span class="formerLink"><code>RTCDataChannelEventInit</code></span> Members</a></li></ul></li><li class="tocline"><a class="tocxref" href="#garbage-collection-1"><span class="secno">5.4 </span>Garbage Collection</a></li></ul></li><li class="tocline"><a class="tocxref" href="#peer-to-peer-dtmf"><span class="secno">6. </span>Peer-to-peer DTMF</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#rtcpeerconnection-interface-extensions-1"><span class="secno">6.1 </span>RTCPeerConnection Interface Extensions</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#methods-4"><span class="secno">6.1.1 </span>Methods</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcdtmfsender"><span class="secno">6.2 </span>RTCDTMFSender</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-8"><span class="secno">6.2.1 </span>Attributes</a></li><li class="tocline"><a class="tocxref" href="#methods-5"><span class="secno">6.2.2 </span>Methods</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcdtmftonechangeevent"><span class="secno">6.3 </span>RTCDTMFToneChangeEvent</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#constructors-5"><span class="secno">6.3.1 </span>Constructors</a></li><li class="tocline"><a class="tocxref" href="#attributes-9"><span class="secno">6.3.2 </span>Attributes</a></li><li class="tocline"><a class="tocxref" href="#dictionary-rtcdtmftonechangeeventinit-members"><span class="secno">6.3.3 </span>Dictionary <span class="formerLink"><code>RTCDTMFToneChangeEventInit</code></span> Members</a></li></ul></li></ul></li><li class="tocline"><a class="tocxref" href="#statistics-model"><span class="secno">7. </span>Statistics Model</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#introduction-1"><span class="secno">7.1 </span>Introduction</a></li><li class="tocline"><a class="tocxref" href="#rtcpeerconnection-interface-extensions-2"><span class="secno">7.2 </span>RTCPeerConnection Interface Extensions</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#methods-6"><span class="secno">7.2.1 </span>Methods</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcstatscallback"><span class="secno">7.3 </span>RTCStatsCallback</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#callback-rtcstatscallback-parameters"><span class="secno">7.3.1 </span>Callback <span class="formerLink"><code>RTCStatsCallback</code></span> Parameters</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcstatsreport-object"><span class="secno">7.4 </span>RTCStatsReport Object</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#methods-7"><span class="secno">7.4.1 </span>Methods</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcstats-dictionary"><span class="secno">7.5 </span>RTCStats Dictionary</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#dictionary-rtcstats-members"><span class="secno">7.5.1 </span>Dictionary <span class="formerLink"><code>RTCStats</code></span> Members</a></li></ul></li><li class="tocline"><a class="tocxref" href="#derived-stats-dictionaries"><span class="secno">7.6 </span>Derived Stats Dictionaries</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#dictionary-rtcrtpstreamstats-members"><span class="secno">7.6.1 </span>Dictionary <span class="formerLink"><code>RTCRTPStreamStats</code></span> Members</a></li><li class="tocline"><a class="tocxref" href="#dictionary-rtcinboundrtpstreamstats-members"><span class="secno">7.6.2 </span>Dictionary <span class="formerLink"><code>RTCInboundRTPStreamStats</code></span> Members</a></li><li class="tocline"><a class="tocxref" href="#dictionary-rtcoutboundrtpstreamstats-members"><span class="secno">7.6.3 </span>Dictionary <span class="formerLink"><code>RTCOutboundRTPStreamStats</code></span> Members</a></li></ul></li><li class="tocline"><a class="tocxref" href="#example"><span class="secno">7.7 </span>Example</a></li></ul></li><li class="tocline"><a class="tocxref" href="#identity"><span class="secno">8. </span>Identity</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#identity-provider-interaction"><span class="secno">8.1 </span>Identity Provider Interaction</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#identity-provider-selection"><span class="secno">8.1.1 </span>Identity Provider
        Selection</a></li><li class="tocline"><a class="tocxref" href="#instantiating-an-idp-proxy"><span class="secno">8.1.2 </span>Instantiating an IdP Proxy</a></li></ul></li><li class="tocline"><a class="tocxref" href="#requesting-identity-assertions"><span class="secno">8.2 </span>Requesting Identity
      Assertions</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#user-login-procedure"><span class="secno">8.2.1 </span>User Login Procedure</a></li></ul></li><li class="tocline"><a class="tocxref" href="#verifying-identity-assertions"><span class="secno">8.3 </span>Verifying Identity Assertions</a></li><li class="tocline"><a class="tocxref" href="#rtcpeerconnection-interface-extensions-3"><span class="secno">8.4 </span>RTCPeerConnection Interface Extensions</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-10"><span class="secno">8.4.1 </span>Attributes</a></li><li class="tocline"><a class="tocxref" href="#methods-8"><span class="secno">8.4.2 </span>Methods</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcidentityassertion-type"><span class="secno">8.5 </span>RTCIdentityAssertion Type</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#dictionary-rtcidentityassertion-members"><span class="secno">8.5.1 </span>Dictionary <span class="formerLink"><code>RTCIdentityAssertion</code></span> Members</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcidentityevent-type"><span class="secno">8.6 </span>RTCIdentityEvent Type</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-11"><span class="secno">8.6.1 </span>Attributes</a></li></ul></li><li class="tocline"><a class="tocxref" href="#rtcidentityerrorevent-type"><span class="secno">8.7 </span>RTCIdentityErrorEvent Type</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-12"><span class="secno">8.7.1 </span>Attributes</a></li></ul></li><li class="tocline"><a class="tocxref" href="#examples"><span class="secno">8.8 </span>Examples</a></li></ul></li><li class="tocline"><a class="tocxref" href="#media-stream-api-extensions-for-network-use"><span class="secno">9. </span>Media Stream API Extensions for Network Use</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#introduction-2"><span class="secno">9.1 </span>Introduction</a></li><li class="tocline"><a class="tocxref" href="#mediastream"><span class="secno">9.2 </span>MediaStream</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#id"><span class="secno">9.2.1 </span>id</a></li><li class="tocline"><a class="tocxref" href="#events-on-mediastream"><span class="secno">9.2.2 </span>Events on MediaStream</a></li></ul></li><li class="tocline"><a class="tocxref" href="#mediastreamtrack"><span class="secno">9.3 </span>MediaStreamTrack</a></li><li class="tocline"><a class="tocxref" href="#mediastreamevent"><span class="secno">9.4 </span>MediaStreamEvent</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#constructors-6"><span class="secno">9.4.1 </span>Constructors</a></li><li class="tocline"><a class="tocxref" href="#attributes-13"><span class="secno">9.4.2 </span>Attributes</a></li><li class="tocline"><a class="tocxref" href="#dictionary-mediastreameventinit-members"><span class="secno">9.4.3 </span>Dictionary <span class="formerLink"><code>MediaStreamEventInit</code></span> Members</a></li></ul></li><li class="tocline"><a class="tocxref" href="#isolated-media-streams"><span class="secno">9.5 </span>Isolated Media Streams</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#dictionary-mediastreamconstraints-members"><span class="secno">9.5.1 </span>Dictionary <span class="formerLink"><code>MediaStreamConstraints</code></span> Members</a></li><li class="tocline"><a class="tocxref" href="#isolated-track"><span class="secno">9.5.2 </span>Extended MediaStreamTrack Properties</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-14"><span class="secno">9.5.2.1 </span>Attributes</a></li></ul></li><li class="tocline"><a class="tocxref" href="#isolated-pc"><span class="secno">9.5.3 </span>Isolated Streams and RTCPeerConnection</a></li><li class="tocline"><a class="tocxref" href="#isolation-protection"><span class="secno">9.5.4 </span>Protection Afforded by Media Isolation</a></li></ul></li></ul></li><li class="tocline"><a class="tocxref" href="#examples-and-call-flows"><span class="secno">10. </span>Examples and Call Flows</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#simple-peer-to-peer-example"><span class="secno">10.1 </span>Simple Peer-to-peer Example</a></li><li class="tocline"><a class="tocxref" href="#advanced-peer-to-peer-example"><span class="secno">10.2 </span>Advanced Peer-to-peer Example</a></li><li class="tocline"><a class="tocxref" href="#peer-to-peer-data-example"><span class="secno">10.3 </span>Peer-to-peer Data Example</a></li><li class="tocline"><a class="tocxref" href="#call-flow-browser-to-browser"><span class="secno">10.4 </span>Call Flow Browser to Browser</a></li><li class="tocline"><a class="tocxref" href="#dtmf-example"><span class="secno">10.5 </span>DTMF Example</a></li></ul></li><li class="tocline"><a class="tocxref" href="#event-summary"><span class="secno">11. </span>Event summary</a></li><li class="tocline"><a class="tocxref" href="#security-considerations"><span class="secno">12. </span>Security Considerations</a></li><li class="tocline"><a class="tocxref" href="#change-log"><span class="secno">13. </span>Change Log</a></li><li class="tocline"><a class="tocxref" href="#acknowledgements"><span class="secno">A. </span>Acknowledgements</a></li><li class="tocline"><a class="tocxref" href="#references"><span class="secno">B. </span>References</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#normative-references"><span class="secno">B.1 </span>Normative references</a></li><li class="tocline"><a class="tocxref" href="#informative-references"><span class="secno">B.2 </span>Informative references</a></li></ul></li></ul></section>

  

  <section property="bibo:hasPart" resource="#intro" typeof="bibo:Chapter" class="informative" id="intro">
    <!--OddPage--><h2 resource="#h-intro" id="h-intro"><span property="xhv:role" resource="xhv:heading"><span class="secno">1. </span>Introduction</span></h2><p><em>This section is non-normative.</em></p>

    <p>There are a number of facets to video-conferencing in HTML covered by
    this specification:</p>

    <ul>
      <li>Connecting to remote peers using NAT-traversal technologies such as
      ICE, STUN, and TURN.</li>

      <li>Sending the locally-produced streams to remote peers and receiving
      streams from remote peers.</li>

      <li>Sending arbitrary data directly to remote peers.</li>
    </ul>

    <p>This document defines the APIs used for these features. This
    specification is being developed in conjunction with a protocol
    specification developed by the <a href="http://datatracker.ietf.org/wg/rtcweb/">IETF RTCWEB group</a> and an API
    specification to get access to local media devices
    [<cite><a href="#bib-GETUSERMEDIA" class="bibref">GETUSERMEDIA</a></cite>]developed by the <a href="http://www.w3.org/2011/04/webrtc/">Media Capture Task Force</a>. An
    overview of the system can be found in [<cite><a href="#bib-RTCWEB-OVERVIEW" class="bibref">RTCWEB-OVERVIEW</a></cite>] and
    [<cite><a href="#bib-RTCWEB-SECURITY" class="bibref">RTCWEB-SECURITY</a></cite>].</p>
  </section>

  <section property="bibo:hasPart" resource="#conformance" typeof="bibo:Chapter" id="conformance"><!--OddPage--><h2 resource="#h-conformance" id="h-conformance"><span property="xhv:role" resource="xhv:heading"><span class="secno">2. </span>Conformance</span></h2>
<p>
  As well as sections marked as non-normative, all authoring guidelines, diagrams, examples,
  and notes in this specification are non-normative. Everything else in this specification is
  normative.
</p>
<p id="respecRFC2119">The key words <em class="rfc2119" title="MAY">MAY</em>, <em class="rfc2119" title="MUST">MUST</em>, <em class="rfc2119" title="MUST NOT">MUST NOT</em>, <em class="rfc2119" title="RECOMMENDED">RECOMMENDED</em>, <em class="rfc2119" title="SHALL">SHALL</em>, and <em class="rfc2119" title="SHOULD">SHOULD</em> are 
  to be interpreted as described in [<cite><a href="#bib-RFC2119" class="bibref">RFC2119</a></cite>].
</p>

    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn id="dfn-user-agent">user agent</dfn> that implements the interfaces that it
    contains.</p>

    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant.)</p>

    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification must implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [<cite><a href="#bib-WEBIDL" class="bibref">WEBIDL</a></cite>], as
    this specification uses that specification and terminology.</p>
  </section>

  <section property="bibo:hasPart" resource="#terminology" typeof="bibo:Chapter" id="terminology">
    <!--OddPage--><h2 resource="#h-terminology" id="h-terminology"><span property="xhv:role" resource="xhv:heading"><span class="secno">3. </span>Terminology</span></h2>

    <p>The <code><a href="http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
    interface represents a callback used for event handlers as defined in
    [<cite><a href="#bib-HTML5" class="bibref">HTML5</a></cite>].</p>

    <p>The concepts <dfn id="dfn-queue-a-task"><a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a
    task</a></dfn> and <dfn id="dfn-fires-a-simple-event"><a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a
    simple event</a></dfn> are defined in [<cite><a href="#bib-HTML5" class="bibref">HTML5</a></cite>].</p>

    <p>The terms <dfn id="dfn-event">event</dfn>, <dfn id="dfn-event-handlers"><a href="http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
    handlers</a></dfn> and <dfn id="dfn-event-handler-event-types"><a href="http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
    handler event types</a></dfn> are defined in [<cite><a href="#bib-HTML5" class="bibref">HTML5</a></cite>].</p>

    <p>The terms <dfn id="dfn-mediastream">MediaStream</dfn>, <dfn id="dfn-mediastreamtrack">MediaStreamTrack</dfn>,
    <dfn id="dfn-constraints">Constraints</dfn>, and <dfn id="dfn-consumer">Consumer</dfn> are defined in
    [<cite><a href="#bib-GETUSERMEDIA" class="bibref">GETUSERMEDIA</a></cite>].</p>
  </section>

  <section property="bibo:hasPart" resource="#peer-to-peer-connections" typeof="bibo:Chapter" id="peer-to-peer-connections">
    <!--OddPage--><h2 resource="#h-peer-to-peer-connections" id="h-peer-to-peer-connections"><span property="xhv:role" resource="xhv:heading"><span class="secno">4. </span>Peer-to-peer connections</span></h2>

    <section property="bibo:hasPart" resource="#introduction" typeof="bibo:Chapter" id="introduction">
      <h3 resource="#h-introduction" id="h-introduction"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.1 </span>Introduction</span></h3>

      <p>An <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> allows two users to
      communicate directly, browser to browser. Communications are coordinated
      via a signaling channel which is provided by unspecified means, but
      generally by a script in the page via the server, e.g. using
      <code>XMLHttpRequest</code> [<cite><a href="#bib-XMLHttpRequest" class="bibref">XMLHttpRequest</a></cite>].</p>
    </section>

    <section property="bibo:hasPart" resource="#configuration" typeof="bibo:Chapter" id="configuration">
      <h3 resource="#h-configuration" id="h-configuration"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.2 </span>Configuration</span></h3>

      <section property="bibo:hasPart" resource="#rtcconfiguration-type" typeof="bibo:Chapter" id="rtcconfiguration-type">
        <h4 resource="#h-rtcconfiguration-type" id="h-rtcconfiguration-type"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.2.1 </span>RTCConfiguration Type</span></h4>

        <pre class="idl"><span class="idlDictionary" id="idl-def-RTCConfiguration">dictionary <span class="idlDictionaryID">RTCConfiguration</span> {
<span class="idlMember">    <span class="idlMemberType">sequence&lt;<a class="idlType" href="#idl-def-RTCIceServer"><code>RTCIceServer</code></a>&gt;</span> <span class="idlMemberName"><a href="#widl-RTCConfiguration-iceServers">iceServers</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCIceTransportPolicy"><code>RTCIceTransportPolicy</code></a></span>  <span class="idlMemberName"><a href="#widl-RTCConfiguration-iceTransportPolicy">iceTransportPolicy</a></span> = <span class="idlMemberValue">"all"</span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCBundlePolicy"><code>RTCBundlePolicy</code></a></span>        <span class="idlMemberName"><a href="#widl-RTCConfiguration-bundlePolicy">bundlePolicy</a></span> = <span class="idlMemberValue">"balanced"</span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span>              <span class="idlMemberName"><a href="#widl-RTCConfiguration-peerIdentity">peerIdentity</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#dictionary-rtcconfiguration-members" typeof="bibo:Chapter" id="dictionary-rtcconfiguration-members"><h5 resource="#h-dictionary-rtcconfiguration-members" id="h-dictionary-rtcconfiguration-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.2.1.1 </span>Dictionary <a href="#idl-def-RTCConfiguration" class="idlType"><code>RTCConfiguration</code></a> Members</span></h5><dl class="dictionary-members"><dt id="widl-RTCConfiguration-bundlePolicy"><code>bundlePolicy</code> of type <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCBundlePolicy"><code>RTCBundlePolicy</code></a></span>, defaulting to <code>"balanced"</code></dt><dd>
            <p>Indicates which <a href="#target-bundle-policy">BundlePolicy</a> to use. </p>
          </dd><dt id="widl-RTCConfiguration-iceServers"><code>iceServers</code> of type <span class="idlMemberType">sequence&lt;<a class="idlType" href="#idl-def-RTCIceServer"><code>RTCIceServer</code></a>&gt;</span></dt><dd>
            <p>An array containing URIs of servers available to be used by ICE,
            such as STUN and TURN server.</p>
          </dd><dt id="widl-RTCConfiguration-iceTransportPolicy"><code>iceTransportPolicy</code> of type <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCIceTransportPolicy"><code>RTCIceTransportPolicy</code></a></span>, defaulting to <code>"all"</code></dt><dd>
            <p>Indicates which candidates the ICE engine is allowed to use.</p>
          </dd><dt id="widl-RTCConfiguration-peerIdentity"><code>peerIdentity</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
            <p>Sets the <a href="#target-peer-identity">target peer
            identity</a> for the <a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a>. The
            <a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a> will establish a connection to a remote
            peer unless it can be successfully authenticated with the provided
            name.</p>
          </dd></dl></section>
      </section>

      <section property="bibo:hasPart" resource="#rtciceserver-type" typeof="bibo:Chapter" id="rtciceserver-type">
        <h4 resource="#h-rtciceserver-type" id="h-rtciceserver-type"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.2.2 </span>RTCIceServer Type</span></h4>

        <pre class="idl"><span class="idlDictionary" id="idl-def-RTCIceServer">dictionary <span class="idlDictionaryID">RTCIceServer</span> {
<span class="idlMember">    <span class="idlMemberType">(DOMString or sequence&lt;DOMString&gt;)</span> <span class="idlMemberName"><a href="#widl-RTCIceServer-urls">urls</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span>                          <span class="idlMemberName"><a href="#widl-RTCIceServer-username">username</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span>                          <span class="idlMemberName"><a href="#widl-RTCIceServer-credential">credential</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#dictionary-rtciceserver-members" typeof="bibo:Chapter" id="dictionary-rtciceserver-members"><h5 resource="#h-dictionary-rtciceserver-members" id="h-dictionary-rtciceserver-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.2.2.1 </span>Dictionary <a href="#idl-def-RTCIceServer" class="idlType"><code>RTCIceServer</code></a> Members</span></h5><dl class="dictionary-members"><dt id="widl-RTCIceServer-credential"><code>credential</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
            <p>If this <code><a class="idlType" href="#idl-def-RTCIceServer"><code>RTCIceServer</code></a></code> object represents a
            TURN server, then this attribute specifies the credential to use
            with that TURN server.</p>
          </dd><dt id="widl-RTCIceServer-urls"><code>urls</code> of type <span class="idlMemberType">(DOMString or sequence&lt;DOMString&gt;)</span></dt><dd>
            <p>STUN or TURN URI(s) as defined in [<cite><a href="#bib-RFC7064" class="bibref">RFC7064</a></cite>] and [<cite><a href="#bib-RFC7065" class="bibref">RFC7065</a></cite>]
            or other URI types.</p>
          </dd><dt id="widl-RTCIceServer-username"><code>username</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
            <p>If this <code><a class="idlType" href="#idl-def-RTCIceServer"><code>RTCIceServer</code></a></code> object represents a
            TURN server, then this attribute specifies the username to use with
            that TURN server.</p>
          </dd></dl></section>

        <p>In network topologies with multiple layers of NATs, it is desirable
        to have a STUN server between every layer of NATs in addition to the
        TURN servers to minimize the peer to peer network latency.</p>

        <p>An example array of RTCIceServer objects is:</p>

        <p><code>[ { "urls": "stun:stun1.example.net" }, { "urls":
        "turn:turn.example.org", "username": "user", "credential": "myPassword"
        } ]</code></p>
      </section>

      <section property="bibo:hasPart" resource="#rtcicetransportpolicy-enum" typeof="bibo:Chapter" id="rtcicetransportpolicy-enum">
        <h4 resource="#h-rtcicetransportpolicy-enum" id="h-rtcicetransportpolicy-enum"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.2.3 </span>RTCIceTransportPolicy Enum</span></h4>

        <pre class="idl"><span class="idlEnum" id="idl-def-RTCIceTransportPolicy">enum <span class="idlEnumID">RTCIceTransportPolicy</span> {
    "<a href="#idl-def-RTCIceTransportPolicy.none" class="idlEnumItem">none</a>",
    "<a href="#idl-def-RTCIceTransportPolicy.relay" class="idlEnumItem">relay</a>",
    "<a href="#idl-def-RTCIceTransportPolicy.all" class="idlEnumItem">all</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-RTCIceTransportPolicy.none">none</code></td><td>The ICE engine <em title="MUST" class="rfc2119">MUST</em> not send or receive any packets at this
          point.</td></tr><tr><td><code id="idl-def-RTCIceTransportPolicy.relay">relay</code></td><td>The ICE engine <em title="MUST" class="rfc2119">MUST</em> only use media relay candidates such as
          candidates passing through a TURN server. This can be used to reduce
          leakage of IP addresses in certain use cases.</td></tr><tr><td><code id="idl-def-RTCIceTransportPolicy.all">all</code></td><td>The ICE engine may use any type of candidates when this value is
          specified.</td></tr></tbody></table>
      </section>

      <section property="bibo:hasPart" resource="#rtcbundlepolicy-enum" typeof="bibo:Chapter" id="rtcbundlepolicy-enum">
        <h4 resource="#h-rtcbundlepolicy-enum" id="h-rtcbundlepolicy-enum"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.2.4 </span>RTCBundlePolicy Enum</span></h4>

        Defined in [<cite><a href="#bib-RTCWEB-JSEP" class="bibref">RTCWEB-JSEP</a></cite>].  The following is a non-normative
        summary for convenience.

        The BundlePolicy effects which media tracks are negotiated if
        the remote endpoint is not BUNDLE-aware, and what ICE
        candidates are gathered.  If the remote endpoint is
        BUNDLE-aware, all media tracks and data channels are BUNDLEd
        onto the same transport.

        <pre id="target-bundle-policy" class="idl"><span class="idlEnum" id="idl-def-RTCBundlePolicy">enum <span class="idlEnumID">RTCBundlePolicy</span> {
    "<a href="#idl-def-RTCBundlePolicy.balanced" class="idlEnumItem">balanced</a>",
    "<a href="#idl-def-RTCBundlePolicy.max-compat" class="idlEnumItem">max-compat</a>",
    "<a href="#idl-def-RTCBundlePolicy.max-bundle" class="idlEnumItem">max-bundle</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-RTCBundlePolicy.balanced">balanced</code></td><td>Gather ICE candidates for each media type in use (audio,
          video, and data).  If the remote endpoint is not
          BUNDLE-aware, negotiate only one audio and video track on
          separate transports.</td></tr><tr><td><code id="idl-def-RTCBundlePolicy.max-compat">max-compat</code></td><td>Gather ICE candidates for each track. If the remote
          endpoint is not BUNDLE-aware, negotiate all media tracks on
          separate transports.</td></tr><tr><td><code id="idl-def-RTCBundlePolicy.max-bundle">max-bundle</code></td><td>Gather ICE candidates for only one track.  If the remote
          endpoint is not BUNDLE-aware, negotiate only one media
          track.</td></tr></tbody></table>
      </section>

      <section property="bibo:hasPart" resource="#offer-answer-options" typeof="bibo:Chapter" id="offer-answer-options">
        <h4 resource="#h-offer-answer-options" id="h-offer-answer-options"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.2.5 </span>Offer/Answer Options</span></h4>

        <p>These dictionaries describe the options that can be used to control
        the offer/answer creation process.</p>

        <pre class="idl"><span class="idlDictionary" id="idl-def-RTCOfferOptions">dictionary <span class="idlDictionaryID">RTCOfferOptions</span> {
<span class="idlMember">    <span class="idlMemberType">long</span>    <span class="idlMemberName"><a href="#widl-RTCOfferOptions-offerToReceiveVideo">offerToReceiveVideo</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">long</span>    <span class="idlMemberName"><a href="#widl-RTCOfferOptions-offerToReceiveAudio">offerToReceiveAudio</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">boolean</span> <span class="idlMemberName"><a href="#widl-RTCOfferOptions-voiceActivityDetection">voiceActivityDetection</a></span> = <span class="idlMemberValue">true</span>;</span>
<span class="idlMember">    <span class="idlMemberType">boolean</span> <span class="idlMemberName"><a href="#widl-RTCOfferOptions-iceRestart">iceRestart</a></span> = <span class="idlMemberValue">false</span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#dictionary-rtcofferoptions-members" typeof="bibo:Chapter" id="dictionary-rtcofferoptions-members"><h5 resource="#h-dictionary-rtcofferoptions-members" id="h-dictionary-rtcofferoptions-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.2.5.1 </span>Dictionary <a href="#idl-def-RTCOfferOptions" class="idlType"><code>RTCOfferOptions</code></a> Members</span></h5><dl class="dictionary-members"><dt id="widl-RTCOfferOptions-iceRestart"><code>iceRestart</code> of type <span class="idlMemberType">boolean</span>, defaulting to <code>false</code></dt><dd>
            <p>When the value of this dictionary member is true, the generated
            description will have ICE credentials that are different from the
            current credentials (as visible in the
            <code><a class="internalDFN" href="#dom-peerconnection-localdescription">localDescription</a></code> attribute's SDP). Applying the
            generated description will restart ICE.</p>

            <p>When the value of this dictionary member is false, and the
            <code><a class="internalDFN" href="#dom-peerconnection-localdescription">localDescription</a></code> attribute has valid ICE
            credentials, the generated description will have the same ICE
            credentials as the current value from the
            <code><a class="internalDFN" href="#dom-peerconnection-localdescription">localDescription</a></code> attribute.</p>
          </dd><dt id="widl-RTCOfferOptions-offerToReceiveAudio"><code>offerToReceiveAudio</code> of type <span class="idlMemberType">long</span></dt><dd>
            <p>In some cases, an <code>RTCPeerConnection</code> may wish to
            receive audio but not send any audio. The
            <code>RTCPeerConnection</code> needs to know if it should signal to
            the remote side whether it wishes to receive audio. This option
            allows an application to indicate its preferences for the number of
            audio streams to receive when creating an offer.</p>
          </dd><dt id="widl-RTCOfferOptions-offerToReceiveVideo"><code>offerToReceiveVideo</code> of type <span class="idlMemberType">long</span></dt><dd>
            <p>In some cases, an <code>RTCPeerConnection</code> may wish to
            receive video but not send any video. The
            <code>RTCPeerConnection</code> needs to know if it should signal to
            the remote side whether it wishes to receive video or not. This
            option allows an application to indicate its preferences for the
            number of video streams to receive when creating an offer.</p>
          </dd><dt id="widl-RTCOfferOptions-voiceActivityDetection"><code>voiceActivityDetection</code> of type <span class="idlMemberType">boolean</span>, defaulting to <code>true</code></dt><dd>
            <p>Many codecs and system are capable of detecting "silence" and
            changing their behavior in this case by doing things such as not
            transmitting any media. In many cases, such as when dealing with
            emergency calling or sounds other than spoken voice, it is
            desirable to be able to turn off this behavior. This option allows
            the application to provide information about whether it wishes this
            type of processing enabled or disabled.</p>
          </dd></dl></section>

        <pre class="idl"><span class="idlEnum" id="idl-def-RTCIdentityOption">enum <span class="idlEnumID">RTCIdentityOption</span> {
    "<a href="#idl-def-RTCIdentityOption.yes" class="idlEnumItem">yes</a>",
    "<a href="#idl-def-RTCIdentityOption.no" class="idlEnumItem">no</a>",
    "<a href="#idl-def-RTCIdentityOption.ifconfigured" class="idlEnumItem">ifconfigured</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-RTCIdentityOption.yes">yes</code></td><td>An identity <em title="MUST" class="rfc2119">MUST</em> be requested.</td></tr><tr><td><code id="idl-def-RTCIdentityOption.no">no</code></td><td>No identity is to be requested.</td></tr><tr><td><code id="idl-def-RTCIdentityOption.ifconfigured">ifconfigured</code></td><td>The value "ifconfigured" means that an identity will be requested
          if either the user has configured an identity in the browser or if
          the <code>setIdentityProvider()</code> call has been made in
          JavaScript. As this is the default value, an identity will be
          requested if and only if the user has configured an IdP in some
          way.</td></tr></tbody></table>
      </section>
    </section>

    <section property="bibo:hasPart" resource="#rtcpeerconnection-interface" typeof="bibo:Chapter" id="rtcpeerconnection-interface">
      <h3 resource="#h-rtcpeerconnection-interface" id="h-rtcpeerconnection-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.3 </span>RTCPeerConnection Interface</span></h3>

      <p>The general operation of the RTCPeerConnection is described in
      [<cite><a href="#bib-RTCWEB-JSEP" class="bibref">RTCWEB-JSEP</a></cite>].</p>

      <section property="bibo:hasPart" resource="#operation" typeof="bibo:Chapter" id="operation">
        <h4 resource="#h-operation" id="h-operation"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.3.1 </span>Operation</span></h4>

        <p>Calling <code>new <a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a>(<var>configuration</var>
        )</code> creates an <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>

        <p>The <var>configuration</var> has the information to find and access
        the servers used by ICE. There may be multiple servers of each type and
        any TURN server also acts as a STUN server.</p>

        <p>An <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object has an associated
        <dfn id="rtcpeerconnection-ice-agent">ICE agent</dfn> [<cite><a href="#bib-ICE" class="bibref">ICE</a></cite>],
        RTCPeerConnection signaling state, ICE gathering state, and ICE
        connection state. These are initialized when the object is created.</p>

        <p>An <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object has two associated
        stream sets. A <dfn id="local-streams-set">local streams set</dfn>,
        representing streams that are currently sent, and a <dfn id="remote-streams-set">remote streams set</dfn>, representing streams
        that are currently received with this
        <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object. The stream sets are
        initialized to empty sets when the
        <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object is created.</p>

        <p>When the <dfn id="dom-peerconnection"><code>RTCPeerConnection()</code></dfn> constructor
        is invoked, the user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

        <ol>
          <li>
            <p>Validate the <code><a class="idlType" href="#idl-def-RTCConfiguration"><code>RTCConfiguration</code></a></code> argument by
            running the steps defined by the <a href="#dom-peerconnection-updateice">updateIce()</a> method.</p>
          </li>

          <li>
            <p>Let <var>connection</var> be a newly created
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>
          </li>

          <li>
            <p>Create an ICE Agent as defined in [<cite><a href="#bib-ICE" class="bibref">ICE</a></cite>] and let
            <var>connection</var>'s <code>RTCPeerConnection</code> ICE Agent be
            that ICE Agent and provide it the the <a href="#ice-servers-list">ICE servers list</a>. The ICE Agent will
            proceed with gathering as soon as the <a href="#ice-transports-setting">ICE transports setting</a> is not set to
            <code>none</code>. At this point the ICE Agent does not know how
            many ICE components it needs (and hence the number of candidates to
            gather), but it can make a reasonable assumption such as 2. As the
            <code>RTCPeerConnection</code> object gets more information, the
            ICE Agent can adjust the number of components.</p>
          </li>

          <li>
            <p>Set <var>connection</var>'s <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
            signalingState</a> to <code>stable</code>.</p>
          </li>

          <li>
            <p>Set <var>connection</var>'s <a href="#dom-peerconnection-ice-connection-state"><code>RTCPeerConnection</code>
            ice connection state</a> to <code>new</code>.</p>
          </li>

          <li>
            <p>Set <var>connection</var>'s <a href="#dom-peerconnection-ice-gathering-state"><code>RTCPeerConnection</code>
            ice gathering state</a> to <code>new</code>.</p>
          </li>

          <li>
            <p>Initialize an internal variable to represent a queue of
            <code>operations</code> with an empty set.</p>
          </li>

          <li>
            <p>Return <var>connection</var>.</p>
          </li>
        </ol>

        <p>Once the RTCPeerConnection object has been initialized, for every
        call to <code>createOffer</code>, <code>setLocalDescription</code>,
        <code>createAnswer</code> and <code>setRemoteDescription</code>;
        execute the following steps:</p>

        <ol>
          <li>
            <p>Append an object representing the current call being handled
            (i.e. function name and corresponding arguments) to the
            <code>operations</code> array.</p>
          </li>

          <li>
            <p>If the length of the <code>operations</code> array is exactly 1,
            execute the function from the front of the queue
            asynchronously.</p>
          </li>

          <li>
            <p>When the asynchronous operation completes (either successfully
            or with an error), remove the corresponding object from the
            <code>operations</code> array. After removal, if the array is
            non-empty, execute the first object queued asynchronously and
            repeat this step on completion.</p>
          </li>
        </ol>

        <p>The general idea is to have only one among <code>createOffer</code>,
        <code>setLocalDescription</code>, <code>createAnswer</code> and
        <code>setRemoteDescription</code> executing at any given time. If
        subsequent calls are made while one of them is still executing, they
        are added to a queue and processed when the previous operation is fully
        completed. It is valid, and expected, for normal error handling
        procedures to be applied.</p>

        <p>Additionally, during the lifetime of the RTCPeerConnection object,
        the following procedures are followed when an ICE event occurs:</p>

        <ol>
          <li>
            <p>If the <a href="#dom-peerconnection-ice-gathering-state"><code>RTCPeerConnection</code>
            ice gathering state</a> is <code>new</code> and the <a href="#ice-transports-setting">ICE transports setting</a> is not set to
            <code>none</code>, the user agent <em title="MUST" class="rfc2119">MUST</em> queue a task to start
            gathering ICE addresses and set the <a href="#dom-peerconnection-ice-gathering-state">ice gathering state</a>
            to <code>gathering</code>.</p>
          </li>

          <li>
            <p>If the ICE Agent has found one or more candidate pairs for each
            MediaStreamTrack that forms a valid connection, the ICE connection
            state is changed to "connected".</p>
          </li>

          <li>
            <p>When the ICE Agent finishes checking all candidate pairs, if at
            least one connection has been found for each MediaStreamTrack, the
            <a href="#dom-peerconnection-ice-connection-state"><code>RTCPeerConnection</code>
            ice connection state</a> is changed to "completed"; otherwise
            "failed".</p>
          </li>
        </ol>

        <p>When the ICE Agent needs to notify the script about the candidate
        gathering progress, the user agent must queue a task to run the
        following steps:</p>

        <ol>
          <li>
            <p>Let <var>connection</var> be the
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object associated with this
            ICE Agent.</p>
          </li>

          <li>
            <p>If <var>connection</var>'s <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
            signalingState</a> is <code>closed</code>, abort these steps.</p>
          </li>

          <li>
            <p>If the intent of the ICE Agent is to notify the script that:</p>

            <ul>
              <li>
                <p>A new candidate is available.</p>

                <p>Add the candidate to <var>connection</var>'s
                <code><a class="internalDFN" href="#dom-peerconnection-localdescription">localDescription</a></code> and create a
                <code><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></code> object to represent the
                candidate. Let <var>newCandidate</var> be that object.</p>
              </li>

              <li>
                <p>The gathering process is done.</p>

                <p>Set <var>connection</var>'s <a href="#dom-peerconnection-ice-gathering-state">ice gathering
                state</a> to <code>completed</code> and let
                <var>newCandidate</var> be null.</p>
              </li>
            </ul>
          </li>

          <li>
            <p>Fire a icecandidate event named <code><a href="#event-icecandidate">icecandidate</a></code> with
            <var>newCandidate</var> at <var>connection</var>.</p>
          </li>
        </ol>

        <p>User agents negotiate the codec resolution, bitrate, and other media
        parameters. It is <em title="RECOMMENDED" class="rfc2119">RECOMMENDED</em> that user agents initially negotiate for
        the maximum resolution of a video stream. For streams that are then
        rendered (using a <code>video</code> element), it is <em title="RECOMMENDED" class="rfc2119">RECOMMENDED</em> that
        user agents renegotiate for a resolution that matches the rendered
        display size.</p>

        <p>The word "components" in this context refers to an RTP media flow
        and does not have anything to do with how [<cite><a href="#bib-ICE" class="bibref">ICE</a></cite>] uses the term
        "component".</p>

        <p>When a user agent has reached the point where a
        <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> can be created to represent incoming
        components, the user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

        <ol>
          <li>
            <p>Let <var>connection</var> be the
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> expecting this media.</p>
          </li>

          <li>
            <p>Create a <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> object
            <var>stream</var>, to represent the incoming media stream.</p>
          </li>

          <li>
            <p>Run the <a href="#represent-component-with-track">algorithm</a>
            to represent an incoming component with a track for each incoming
            component.</p>

            <div class="note"><div id="h-note1" role="heading" aria-level="5" class="note-title"><span>Note</span></div><p class="">The creation of new incoming
            <code>MediaStream</code>s may be triggered either by SDP
            negotiation or by the receipt of media on a given flow.
            <!--  [[OPEN ISSUE: How many <code>MediaStream</code>s are created
                when you receive multiple conflicting pranswers?]] --></p></div>
          </li>

          <li>
            <p>Queue a task to run the following substeps:</p>

            <ol>
              <li>
                <p>If the <var>connection</var>'s <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
                signalingState</a> is <code>closed</code>, abort these
                steps.</p>
              </li>

              <li>
                <p>Add <var>stream</var> to <var>connection</var>'s <a href="#remote-streams-set">remote streams set</a>.</p>
              </li>

              <li>
                <p><a href="#fire-a-stream-event">Fire a stream event</a> named
                <code title="event-MediaStream-addstream"><a href="#event-mediastream-addstream">addstream</a></code> with
                <var>stream</var> at the <var title="">connection</var>
                object.</p>
              </li>
            </ol>
          </li>
        </ol>

        <p>When a user agent has negotiated media for a component that belongs
        to a media stream that is already represented by an existing
        <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> object, the user agent <em title="MUST" class="rfc2119">MUST</em> associate
        the component with that <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> object.</p>

        <p>When an <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> finds that a stream
        from the remote peer has been removed, the user agent <em title="MUST" class="rfc2119">MUST</em> follow these
        steps:</p>

        <ol>
          <li>
            <p>Let <var>connection</var> be the
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> associated with the stream
            being removed.</p>
          </li>

          <li>
            <p>Let <var>stream</var> be the <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code>
            object that represents the media stream being removed, if any. If
            there isn't one, then abort these steps.</p>
          </li>

          <li>
            <p>By definition, <var>stream</var> is now ended.</p>

            <div class="note"><div id="h-note2" role="heading" aria-level="5" class="note-title"><span>Note</span></div><p class="">A <span title="concept-task">task</span> is thus
            <span title="queue a task">queued</span> to update
            <var>stream</var> and fire an event.</p></div>
          </li>

          <li>
            <p>Queue a task to run the following substeps:</p>

            <ol>
              <li>
                <p>If the <var>connection</var>'s <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
                signalingState</a> is <code>closed</code>, abort these
                steps.</p>
              </li><!-- close() was probably called just before this
         task ran -->

              <li>
                <p>Remove <var>stream</var> from <var>connection</var>'s
                <a href="#remote-streams-set">remote streams set</a>.</p>
              </li>

              <li>
                <p><a href="#fire-a-stream-event">Fire a stream event</a> named
                <code title="event-MediaStream-removestream"><a href="#event-mediastream-removestream">removestream</a></code> with
                <var title="">stream</var> at the <var>connection</var>
                object.</p>
              </li>
            </ol>
          </li>
        </ol>

        <p>The task source for the <span title="concept-task">tasks</span>
        listed in this section is the networking task source.</p>

        <p>If something in the browser changes that causes the
        <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object to need to initiate a new
        session description negotiation, a <code><a href="#event-negotiation">negotiationneeded</a></code> event is fired at the
        <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>

        <p>In particular, if an <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object is
        <a class="internalDFN" href="#dfn-consumer" title="consumer">consuming</a> a <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> on
        which a track is added, by, e.g., the <code><a href="http://w3c.github.io/mediacapture-main/#dom-mediastream-addtrack">addTrack()</a></code>
        method being invoked, the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object
        <em title="MUST" class="rfc2119">MUST</em> fire the "negotiationneeded" event. Removal of media components
        must also trigger "negotiationneeded".</p>

        <div class="warning"><div class="warning-title"><span>Warning</span></div><p class="">To prevent network sniffing from allowing a fourth
        party to establish a connection to a peer using the information sent
        out-of-band to the other peer and thus spoofing the client, the
        configuration information <em title="SHOULD" class="rfc2119">SHOULD</em> always be transmitted using an
        encrypted connection.</p></div>
      </section>

      <section property="bibo:hasPart" resource="#interface-definition" typeof="bibo:Chapter" id="interface-definition">
        <h4 resource="#h-interface-definition" id="h-interface-definition"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.3.2 </span>Interface Definition</span></h4>

        <pre class="idl"><span class="idlInterface" id="idl-def-RTCPeerConnection">[<span class="idlCtor"> <span class="idlCtorKeyword"></span><span class="idlCtorName"><a href="#widl-ctor-RTCPeerConnection--RTCConfiguration-configuration">Constructor</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCConfiguration"><code>RTCConfiguration</code></a></span> <span class="idlParamName">configuration</span></span>)</span>]
interface <span class="idlInterfaceID">RTCPeerConnection</span> : <span class="idlSuperclass">EventTarget </span> {
<span class="idlMethod">    <span class="idlMethType">Promise&lt;<a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a>&gt;</span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-createOffer-Promise-RTCSessionDescription--RTCOfferOptions-options">createOffer</a></span> (<span class="idlParam">optional <span class="idlParamType"><a class="idlType" href="#idl-def-RTCOfferOptions"><code>RTCOfferOptions</code></a></span> <span class="idlParamName">options</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">Promise&lt;<a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a>&gt;</span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-createAnswer-Promise-RTCSessionDescription">createAnswer</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType">Promise&lt;void&gt;</span>                  <span class="idlMethName"><a href="#widl-RTCPeerConnection-setLocalDescription-Promise-void--RTCSessionDescription-description">setLocalDescription</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></span> <span class="idlParamName">description</span></span>);</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a>?</span> <span class="idlAttrName"><a href="#widl-RTCPeerConnection-localDescription">localDescription</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">Promise&lt;void&gt;</span>                  <span class="idlMethName"><a href="#widl-RTCPeerConnection-setRemoteDescription-Promise-void--RTCSessionDescription-description">setRemoteDescription</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></span> <span class="idlParamName">description</span></span>);</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a>?</span> <span class="idlAttrName"><a href="#widl-RTCPeerConnection-remoteDescription">remoteDescription</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCSignalingState"><code>RTCSignalingState</code></a></span>      <span class="idlAttrName"><a href="#widl-RTCPeerConnection-signalingState">signalingState</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">void</span>                           <span class="idlMethName"><a href="#widl-RTCPeerConnection-updateIce-void-RTCConfiguration-configuration">updateIce</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCConfiguration"><code>RTCConfiguration</code></a></span> <span class="idlParamName">configuration</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">Promise&lt;void&gt;</span>                  <span class="idlMethName"><a href="#widl-RTCPeerConnection-addIceCandidate-Promise-void--RTCIceCandidate-candidate">addIceCandidate</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></span> <span class="idlParamName">candidate</span></span>);</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCIceGatheringState"><code>RTCIceGatheringState</code></a></span>   <span class="idlAttrName"><a href="#widl-RTCPeerConnection-iceGatheringState">iceGatheringState</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCIceConnectionState"><code>RTCIceConnectionState</code></a></span>  <span class="idlAttrName"><a href="#widl-RTCPeerConnection-iceConnectionState">iceConnectionState</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">boolean?</span>               <span class="idlAttrName"><a href="#widl-RTCPeerConnection-canTrickleIceCandidates">canTrickleIceCandidates</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-RTCConfiguration"><code>RTCConfiguration</code></a></span>               <span class="idlMethName"><a href="#widl-RTCPeerConnection-getConfiguration-RTCConfiguration">getConfiguration</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType">sequence&lt;<a class="internalDFN" href="#dfn-mediastream">MediaStream</a>&gt;</span>          <span class="idlMethName"><a href="#widl-RTCPeerConnection-getLocalStreams-sequence-MediaStream">getLocalStreams</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType">sequence&lt;<a class="internalDFN" href="#dfn-mediastream">MediaStream</a>&gt;</span>          <span class="idlMethName"><a href="#widl-RTCPeerConnection-getRemoteStreams-sequence-MediaStream">getRemoteStreams</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a class="internalDFN" href="#dfn-mediastream">MediaStream</a>?</span>                   <span class="idlMethName"><a href="#widl-RTCPeerConnection-getStreamById-MediaStream-DOMString-streamId">getStreamById</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">streamId</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>                           <span class="idlMethName"><a href="#widl-RTCPeerConnection-addStream-void-MediaStream-stream">addStream</a></span> (<span class="idlParam"><span class="idlParamType"><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></span> <span class="idlParamName">stream</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>                           <span class="idlMethName"><a href="#widl-RTCPeerConnection-removeStream-void-MediaStream-stream">removeStream</a></span> (<span class="idlParam"><span class="idlParamType"><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></span> <span class="idlParamName">stream</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>                           <span class="idlMethName"><a href="#widl-RTCPeerConnection-close-void">close</a></span> ();</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>           <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onnegotiationneeded">onnegotiationneeded</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>           <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onicecandidate">onicecandidate</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>           <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onsignalingstatechange">onsignalingstatechange</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>           <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onaddstream">onaddstream</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>           <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onremovestream">onremovestream</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>           <span class="idlAttrName"><a href="#widl-RTCPeerConnection-oniceconnectionstatechange">oniceconnectionstatechange</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>           <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onicegatheringstatechange">onicegatheringstatechange</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#constructors" typeof="bibo:Chapter" id="constructors"><h5 resource="#h-constructors" id="h-constructors"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.3.2.1 </span>Constructors</span></h5><dl class="constructors"><dt id="widl-ctor-RTCPeerConnection--RTCConfiguration-configuration"><code>RTCPeerConnection</code></dt><dd>
            See the <a href="#dom-peerconnection">RTCPeerConnection constructor
            algorithm</a>.
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">configuration</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCConfiguration"><code>RTCConfiguration</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table></dd></dl></section><section property="bibo:hasPart" resource="#attributes" typeof="bibo:Chapter" id="attributes"><h5 resource="#h-attributes" id="h-attributes"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.3.2.2 </span>Attributes</span></h5><dl class="attributes"><dt id="widl-RTCPeerConnection-canTrickleIceCandidates"><code>canTrickleIceCandidates</code> of type <span class="idlAttrType">boolean</span>, readonly   , nullable</dt><dd>
            <p>This attribute indicates whether the remote peer is able to
            accept trickled ICE candidates [<cite><a href="#bib-TRICKLE-ICE" class="bibref">TRICKLE-ICE</a></cite>].  The value is
            determined based on whether a remote description indicates support
            for trickle ICE, as defined in Section 4.1.9 of [<cite><a href="#bib-RTCWEB-JSEP" class="bibref">RTCWEB-JSEP</a></cite>].  Prior to
            the completion
            of <a href="#dom-peerconnection-setremotedescription"><code>setRemoteDescription</code></a>,
            this value is <code>null</code>.
          </p></dd><dt id="widl-RTCPeerConnection-iceConnectionState"><code>iceConnectionState</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCIceConnectionState"><code>RTCIceConnectionState</code></a></span>, readonly   </dt><dd>
            <p>The <dfn id="dom-peerconnection-ice-connection-state"><code>iceConnectionState</code></dfn>
            attribute <em title="MUST" class="rfc2119">MUST</em> return the state of the <a href="#rtcpeerconnection-ice-agent"><code>RTCPeerConnection</code> ICE
            Agent</a> ICE state.</p>
          </dd><dt id="widl-RTCPeerConnection-iceGatheringState"><code>iceGatheringState</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCIceGatheringState"><code>RTCIceGatheringState</code></a></span>, readonly   </dt><dd>
            <p>The <dfn id="dom-peerconnection-ice-gathering-state"><code>iceGatheringState</code></dfn>
            attribute <em title="MUST" class="rfc2119">MUST</em> return the gathering state of the <a href="#rtcpeerconnection-ice-agent"><code>RTCPeerConnection</code> ICE
            Agent</a>.</p>
          </dd><dt id="widl-RTCPeerConnection-localDescription"><code>localDescription</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></span>, readonly   , nullable</dt><dd>
            <p>The <dfn id="dom-peerconnection-localdescription"><code>localDescription</code></dfn>
            attribute <em title="MUST" class="rfc2119">MUST</em> return the last <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code>
            that was successfully set using <code><a href="#dom-peerconnection-setlocaldescription">setLocalDescription()</a></code>,
            plus any local candidates that have been generated by the ICE
            Agent since then.</p>

            <p>A null object will be returned if the local description has not
            yet been set.</p>
          </dd><dt id="widl-RTCPeerConnection-onaddstream"><code>onaddstream</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler, of event handler event type <code><a href="#event-mediastream-addstream">addstream</a></code>, <em title="MUST" class="rfc2119">MUST</em> be fired
          by all objects implementing the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>
          interface. It is called any time a <code>MediaStream</code> is added
          by the remote peer. This will be fired only as a result of
          <code>setRemoteDescription</code>. Onnaddstream happens as early as
          possible after the <code>setRemoteDescription</code>. This callback
          does not wait for a given media stream to be accepted or rejected via
          SDP negotiation.</dd><dt id="widl-RTCPeerConnection-onicecandidate"><code>onicecandidate</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler, of event handler event type <code><a href="#event-icecandidate">icecandidate</a></code>, <em title="MUST" class="rfc2119">MUST</em> be supported by
          all objects implementing the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>
          interface.</dd><dt id="widl-RTCPeerConnection-oniceconnectionstatechange"><code>oniceconnectionstatechange</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>
            This event handler, of event handler event type <code><a href="#event-iceconnectionstatechange">iceconnectionstatechange</a></code>,
            <em title="MUST" class="rfc2119">MUST</em> be fired by all objects implementing the
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> interface. It is called any
            time the <a href="#dom-peerconnection-ice-connection-state"><code>RTCPeerConnection</code>
            ice connection state</a> changes.
          </dd><dt id="widl-RTCPeerConnection-onicegatheringstatechange"><code>onicegatheringstatechange</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>
            This event handler, of event handler event type <code><a href="#event-icegatheringstatechange">icegatheringstatechange</a></code>,
            <em title="MUST" class="rfc2119">MUST</em> be fired by all objects implementing the
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> interface. It is called any
            time
            the <a href="#dom-peerconnection-ice-gathering-state"><code>RTCPeerConnection</code>
            ice gathering state</a> changes.
          </dd><dt id="widl-RTCPeerConnection-onnegotiationneeded"><code>onnegotiationneeded</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler, of event handler event type <code><a href="#event-negotiation">negotiationneeded</a></code>, <em title="MUST" class="rfc2119">MUST</em> be supported
          by all objects implementing the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>
          interface.</dd><dt id="widl-RTCPeerConnection-onremovestream"><code>onremovestream</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler, of event handler event type <code><a href="#event-mediastream-removestream">removestream</a></code>, <em title="MUST" class="rfc2119">MUST</em> be
          fired by all objects implementing the
          <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> interface. It is called any
          time a <code>MediaStream</code> is removed by the remote peer. This
          will be fired only as a result of
          <code>setRemoteDescription</code>.</dd><dt id="widl-RTCPeerConnection-onsignalingstatechange"><code>onsignalingstatechange</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler, of event handler event type <code><a href="#event-signalingstatechange">signalingstatechange</a></code>, <em title="MUST" class="rfc2119">MUST</em>
          be supported by all objects implementing the
          <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> interface. It is called any
          time the <code>readyState</code> changes, i.e., from a call to
          <code>setLocalDescription</code>, a call to
          <code>setRemoteDescription</code>, or code. It does not fire for the
          initial state change into <code>new</code>.</dd><dt id="widl-RTCPeerConnection-remoteDescription"><code>remoteDescription</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></span>, readonly   , nullable</dt><dd>
            <p>The <dfn id="dom-peerconnection-remotedescription"><code>remoteDescription</code></dfn>
            attribute <em title="MUST" class="rfc2119">MUST</em> return the last <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code>
            that was successfully set using <code><a href="#dom-peerconnection-setremotedescription">setRemoteDescription()</a></code>,
            plus any remote candidates that have been supplied via
            <code><a href="#dom-peerconnection-addicecandidate">addIceCandidate()</a></code>
            since then.</p>

            <p>A null object will be returned if the remote description has not
            yet been set.</p>
          </dd><dt id="widl-RTCPeerConnection-signalingState"><code>signalingState</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCSignalingState"><code>RTCSignalingState</code></a></span>, readonly   </dt><dd>
            <p>The <dfn id="dom-peerconnection-signaling-state"><code>signalingState</code></dfn>
            attribute <em title="MUST" class="rfc2119">MUST</em> return the <code><a href="#dom-peerconnection-signaling-state">RTCPeerConnection</a></code>
            object's <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
            signaling state</a>.</p>
          </dd></dl></section><section property="bibo:hasPart" resource="#methods" typeof="bibo:Chapter" id="methods"><h5 resource="#h-methods" id="h-methods"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.3.2.3 </span>Methods</span></h5><dl class="methods"><dt id="widl-RTCPeerConnection-addIceCandidate-Promise-void--RTCIceCandidate-candidate"><code>addIceCandidate</code></dt><dd>
            <p>The <dfn id="dom-peerconnection-addicecandidate"><code>addIceCandidate()</code></dfn>
            method provides a remote candidate to the ICE Agent. In addition to
            being added to the remote description, connectivity checks will be
            sent to the new candidates as long as the <a href="#ice-transports-setting">ICE Transports setting</a> is not set to
            <code>none</code>. This call will result in a change to the
            connection state of the ICE Agent, and may result in a change to
            media state if it results in different connectivity being
            established.</p>

            <ol>
              <li>
                <p>Let <var>p</var> be a new promise.</p>
              </li>

              <li>
                <p>If this <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object's
                <a href="#dom-peerconnection-signaling-state">signaling
                state</a> is <code>closed</code>, the user agent <em title="MUST" class="rfc2119">MUST</em> reject
                <var>p</var> with <code>InvalidStateError</code>, and
                jump to the step labeled <em>Return</em>.</p>
              </li>

              <li>
                <p>If the candidate parameter is malformed, reject <var>p</var>
                with <code>SyntaxError</code> and jump to the step labeled
                <em>Return</em>.</p>
              </li>

              <li>
                <p>If the candidate could not be successfully applied, reject
                <var>p</var> with a <code>DOMError</code> object whose
                <code>name</code> attribute has the value TBD (TODO
                InvalidCandidate and InvalidMidIndex) and jump to the step
                labeled <em>Return</em>.</p>
              </li>

              <li>
                <p>If the candidate is successfully applied, resolve
                <var>p</var> with <var>undefined</var>.</p>
              </li>

              <li>
                <p><em>Return:</em> Return <var>p</var>.</p>
              </li>
            </ol>

            <div class="note"><div id="h-note3" role="heading" aria-level="6" class="note-title"><span>Note</span></div><div class="">
              What errors do we need here? Should we reuse the
              *SessionDescriptionError names or invent new ones for candidates?
              Should this method be queued?
            </div></div>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">candidate</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>Promise&lt;void&gt;</code></div></dd><dt id="widl-RTCPeerConnection-addStream-void-MediaStream-stream"><code>addStream</code></dt><dd>
            <p>Adds a new stream to the RTCPeerConnection.</p>

            <p>When the <dfn id="dom-peerconnection-addstream"><code title="">addStream()</code></dfn> method is invoked, the user agent <em title="MUST" class="rfc2119">MUST</em>
            run the following steps:</p>

            <ol>
              <li>
                <p>Let <var>connection</var> be the
                <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object on which the
                <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code>, <var>stream</var>, is to be
                added.</p>
              </li>

              <li>
                <p>If <var>connection</var>'s <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
                signalingState</a> is <code>closed</code>, throw an
                <code>InvalidStateError</code> exception and abort these
                steps.</p>
              </li>

              <li>
                <p>If <var>stream</var> is already in <var>connection</var>'s
                <a href="#local-streams-set">local streams set</a>, then abort
                these steps.</p>
              </li>

              <li>
                <p>Add <var>stream</var> to <var>connection</var>'s <a href="#local-streams-set">local streams set</a>.</p>
              </li><!--li>
                <p>Parse the <var>constraints</var> provided by the application
                and apply them to the MediaStream, if possible. If the
                constraints could not be successfully applied, the user agent
                MUST queue a task to invoke <var>failureCallback</var> with a
                <code>DOMError</code> object whose <code>name</code> attribute
                has the value <code>IncompatibleConstraintsError</code>.</p>
              </li-->

              <li>
                <p>A stream could have contents that are inaccessible to the
                application. This can be due to being marked with a
                <var>peerIdentity</var> option or anything that would make a
                stream <a href="http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#cors-cross-origin">
                CORS cross-origin</a>. These streams can be added to the
                <a href="#local-streams-set">local streams set</a> but content
                <em title="MUST NOT" class="rfc2119">MUST NOT</em> be transmitted, though streams marked with
                <var>peerIdentity</var> can be transmitted if they meet the
                requirements for sending (see <a href="#isolated-pc">).</a></p><a href="#isolated-pc">

                <p>All other streams that are not accessible to the application
                <em title="MUST NOT" class="rfc2119">MUST NOT</em> be sent to the peer, with silence (audio), black
                frames (video) or equivalently absent content being sent in
                place of stream content.</p>

                <p>Note that this property can change over time.</p>
              </a></li><a href="#isolated-pc">

              </a><li><a href="#isolated-pc">
                </a><p><a href="#isolated-pc">If <var>connection</var>'s </a><a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
                signalingState</a> is <code>stable</code>, then fire a <a href="#event-negotiation">negotiationneeded</a> event at
                <var>connection</var>.</p>
              </li>
            </ol>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">stream</td><td class="prmType"><code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCPeerConnection-close-void"><code>close</code></dt><dd>
            <p>When the <dfn id="dom-peerconnection-close"><code title="">RTCPeerConnection close()</code></dfn> method is invoked, the
            user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

            <ol>
              <li>If the <code>RTCPeerConnection</code> object's
              <code>RTCPeerConnection</code> <code>signalingState</code> is
              <code>closed</code>, abort these steps.</li>

              <li>
                <p>Destroy the <a href="#rtcpeerconnection-ice-agent"><code>RTCPeerConnection</code>
                ICE Agent</a>, abruptly ending any active ICE processing and
                any active streaming, and releasing any relevant resources
                (e.g. TURN permissions).</p>
              </li>

              <li>
                <p>Set the object's <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
                signalingState</a> to <code>closed</code>.</p>
              </li>
            </ol>
          <div><em>No parameters.</em></div><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCPeerConnection-createAnswer-Promise-RTCSessionDescription"><code>createAnswer</code></dt><dd>
            <p>The createAnswer method generates an [<cite><a href="#bib-SDP" class="bibref">SDP</a></cite>] answer with the
            supported configuration for the session that is compatible with the
            parameters in the remote configuration. Like createOffer, the
            returned blob contains descriptions of the local MediaStreams
            attached to this RTCPeerConnection, the codec/RTP/RTCP options
            negotiated for this session, and any candidates that have been
            gathered by the ICE Agent. The options parameter may be supplied to
            provide additional control over the generated answer.</p>

            <p>As an answer, the generated SDP will contain a specific
            configuration that, along with the corresponding offer, specifies
            how the media plane should be established. The generation of the
            SDP must follow the appropriate process for generating an
            answer.</p>

            <p>Session descriptions generated by createAnswer must be
            immediately usable by setLocalDescription without causing an
            error as long as setLocalDescription is called reasonably soon.
            Like createOffer, the returned description should reflect
            the current state of the system. The session descriptions <em title="MUST" class="rfc2119">MUST</em>
            remain usable by setLocalDescription without causing an error until
            at least the end of the fulfillment callback of the returned promise. Calling this
            method is needed to get the ICE user name fragment and
            password.</p>

            <p>An answer can be marked as provisional, as described in
            [<cite><a href="#bib-RTCWEB-JSEP" class="bibref">RTCWEB-JSEP</a></cite>], by setting the <code><a href="#widl-RTCSessionDescription-type">type</a></code> to
            <code>"pranswer"</code>.</p>

            <p>If the <code>RTCPeerConnection</code> is configured to generate
            Identity assertions, then the session description <em title="SHALL" class="rfc2119">SHALL</em> contain an
            appropriate assertion.</p>

            <p>If this <code>RTCPeerConnection</code> object is closed before
            the SDP generation process completes, the USER agent <em title="MUST" class="rfc2119">MUST</em> suppress
            the result and not resolve or reject the returned promise.</p>

            <p>If the SDP generation process completed successfully, the user
            agent <em title="MUST" class="rfc2119">MUST</em> resolve the returned promise with a
            newly created <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> object,
            representing the generated answer.</p>

            <p>If the SDP generation process failed for any reason, the user
            agent <em title="MUST" class="rfc2119">MUST</em> reject the returned promise with a <code>DOMError</code>
            object of type TBD.</p>
          <div><em>No parameters.</em></div><div><em>Return type: </em><code>Promise&lt;<a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a>&gt;</code></div></dd><dt id="widl-RTCPeerConnection-createOffer-Promise-RTCSessionDescription--RTCOfferOptions-options"><code>createOffer</code></dt><dd>
            <p>The createOffer method generates a blob of SDP that contains an
            RFC 3264 offer with the supported configurations for the session,
            including descriptions of the local <code>MediaStream</code>s
            attached to this <code>RTCPeerConnection</code>, the codec/RTP/RTCP
            options supported by this implementation, and any candidates that
            have been gathered by the ICE Agent. The options parameter may be
            supplied to provide additional control over the offer
            generated.</p>

            <p>As an offer, the generated SDP will contain the full set of
            capabilities supported by the session (as opposed to an answer,
            which will include only a specific negotiated subset to use); for
            each SDP line, the generation of the SDP must follow the
            appropriate process for generating an offer. In the event
            createOffer is called after the session is established, createOffer
            will generate an offer that is compatible with the current session,
            incorporating any changes that have been made to the session since
            the last complete offer-answer exchange, such as addition or
            removal of streams. If no changes have been made, the offer will
            include the capabilities of the current local description as well
            as any additional capabilities that could be negotiated in an
            updated offer.</p>

            <p>Session descriptions generated by createOffer <em title="MUST" class="rfc2119">MUST</em> be
            immediately usable by setLocalDescription without causing an error
            as long as setLocalDescription is called reasonably soon.
            If a system has limited resources (e.g. a finite number
            of decoders), createOffer needs to return an offer that reflects
            the current state of the system, so that setLocalDescription will
            succeed when it attempts to acquire those resources. The session
            descriptions <em title="MUST" class="rfc2119">MUST</em> remain usable by setLocalDescription without
            causing an error until at least the end of the fulfillment callback of the
            returned promise. Calling this method is needed to get the ICE user name
            fragment and password.</p>

            <p>If the <code>RTCPeerConnection</code> is configured to generate
            Identity assertions, then the session description <em title="SHALL" class="rfc2119">SHALL</em> contain an
            appropriate assertion.</p>

            <p>If this <code>RTCPeerConnection</code> object is closed before
            the SDP generation process completes, the USER agent <em title="MUST" class="rfc2119">MUST</em> suppress
            the result and not resolve or reject the returned promise.</p>

            <p>If the SDP generation process completed successfully, the user
            agent <em title="MUST" class="rfc2119">MUST</em> resolve the returned promise with a
            newly created <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> object,
            representing the generated offer.</p>

            <p>If the SDP generation process failed for any reason, the user
            agent <em title="MUST" class="rfc2119">MUST</em> reject the returned promise with
            an <code>DOMError</code> object of type TBD as its argument.</p>

            <p>To Do: Discuss privacy aspects of this from a fingerprinting
            point of view - it's probably around as bad as access to a canvas
            :-)</p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">options</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCOfferOptions"><code>RTCOfferOptions</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>Promise&lt;<a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a>&gt;</code></div></dd><dt id="widl-RTCPeerConnection-getConfiguration-RTCConfiguration"><code>getConfiguration</code></dt><dd>
            <p>Returns a <code><a class="idlType" href="#idl-def-RTCConfiguration"><code>RTCConfiguration</code></a></code> object
            representing the current configuration of this
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>

            <p>When this method is call, the user agent <em title="MUST" class="rfc2119">MUST</em> construct new
            <code><a class="idlType" href="#idl-def-RTCConfiguration"><code>RTCConfiguration</code></a></code> object to be returned, and
            initialize it using the ICE Agent's <a href="#ice-transports-setting">ICE transports setting</a> and <a href="#ice-servers-list">ICE servers list</a>.</p>
          <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-RTCConfiguration"><code>RTCConfiguration</code></a></code></div></dd><dt id="widl-RTCPeerConnection-getLocalStreams-sequence-MediaStream"><code>getLocalStreams</code></dt><dd>
            <p>Returns a sequence of <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> objects
            representing the streams that are currently sent with this
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>

            <p>The <dfn id="dom-peerconnection-getlocalstreams"><code>getLocalStreams()</code></dfn>
            method <em title="MUST" class="rfc2119">MUST</em> return a new sequence that represents a snapshot of all
            the <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> objects in this
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object's <a href="#local-streams-set">local streams set</a>. The conversion from the
            streams set to the sequence, to be returned, is user agent defined
            and the order does not have to stable between calls.</p>
          <div><em>No parameters.</em></div><div><em>Return type: </em><code>sequence&lt;<a class="internalDFN" href="#dfn-mediastream">MediaStream</a>&gt;</code></div></dd><dt id="widl-RTCPeerConnection-getRemoteStreams-sequence-MediaStream"><code>getRemoteStreams</code></dt><dd>
            <p>Returns a sequence of <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> objects
            representing the streams that are currently received with this
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>

            <p>The <dfn id="dom-peerconnection-getremotestreams"><code>getRemoteStreams()</code></dfn>
            method <em title="MUST" class="rfc2119">MUST</em> return a new sequence that represents a snapshot of all
            the <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> objects in this
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object's <a href="#remote-streams-set">remote streams set</a>. The conversion from
            the streams set to the sequence, to be returned, is user agent
            defined and the order does not have to stable between calls.</p>
          <div><em>No parameters.</em></div><div><em>Return type: </em><code>sequence&lt;<a class="internalDFN" href="#dfn-mediastream">MediaStream</a>&gt;</code></div></dd><dt id="widl-RTCPeerConnection-getStreamById-MediaStream-DOMString-streamId"><code>getStreamById</code></dt><dd>
            <p>If a <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> object, with an
            <code><a href="http://w3c.github.io/mediacapture-main/#dom-mediastream-id">id</a></code>
            equal to <var>streamId</var>, exists in this
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object's stream sets
            (<a href="#local-streams-set">local streams set</a> or <a href="#remote-streams-set">remote streams set</a>), then the <dfn id="dom-peerconnection-getstreambyid"><code>getStreamById()</code></dfn>
            method <em title="MUST" class="rfc2119">MUST</em> return that <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> object. The
            method <em title="MUST" class="rfc2119">MUST</em> return null if no stream matches the
            <var>streamId</var> argument.</p>

            <div class="note"><div id="h-note4" role="heading" aria-level="6" class="note-title"><span>Note</span></div><div class="">
              <p>For this method to make sense, we need to make sure that ids
              are unique within the two stream sets of a RTCPeerConnection.
              This is not the case today when a peer re-adds a stream that is
              received. Two different stream instances will now have the same
              id at both peers; one in the remote stream set and one in the
              local stream set.</p>

              <p>One way to resolve this is to not allow re-adding a stream
              instance that is received (guard on id). If an application really
              needs this functionality it's really easy to make a clone of the
              stream, which will give it a new id, and send the clone.</p>
            </div></div>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">streamId</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code>, nullable</div></dd><dt id="widl-RTCPeerConnection-removeStream-void-MediaStream-stream"><code>removeStream</code></dt><dd>
            <p>Removes the given stream from the
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>.</p>

            <p>When the other peer stops sending a stream in this manner, a
            <code title="event-MediaStream-removestream"><a href="#event-mediastream-removestream">removestream</a></code> event is
            fired at the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>

            <p>When the <dfn id="dom-peerconnection-removestream"><code title="">removeStream()</code></dfn> method is invoked, the user agent
            <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

            <ol>
              <li>
                <p>Let <var>connection</var> be the
                <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object on which the
                <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code>, <var>stream</var>, is to be
                removed.</p>
              </li>

              <li>
                <p>If <var>connection</var>'s <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
                signalingState</a> is <code>closed</code>, throw an
                <code>InvalidStateError</code> exception.</p>
              </li>

              <li>
                <p>If <var>stream</var> is not in <var>connection</var>'s
                <a href="#local-streams-set">local streams set</a>, then abort
                these steps.</p>
              </li>

              <li>
                <p>Remove <var>stream</var> from <var>connection</var>'s
                <a href="#local-streams-set">local streams set</a>.</p>
              </li>

              <li>
                <p>If <var>connection</var>'s <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
                signalingState</a> is <code>stable</code>, then fire a <a href="#event-negotiation">negotiationneeded</a> event at
                <var>connection</var>.</p>
              </li>
            </ol>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">stream</td><td class="prmType"><code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCPeerConnection-setLocalDescription-Promise-void--RTCSessionDescription-description"><code>setLocalDescription</code></dt><dd>
            <p>The <dfn id="dom-peerconnection-setlocaldescription"><code>setLocalDescription()</code></dfn>
            method instructs the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> to apply
            the supplied <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> as the local
            description.</p>

            <p>This API changes the local media state. In order to successfully
            handle scenarios where the application wants to offer to change
            from one media format to a different, incompatible format, the
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> must be able to
            simultaneously support use of both the old and new local
            descriptions (e.g. support codecs that exist in both descriptions)
            until a final answer is received, at which point the
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> can fully adopt the new local
            description, or rollback to the old description if the remote side
            denied the change.</p>

            <div class="issue"><div id="h-issue1" role="heading" aria-level="6" class="issue-title"><span>Issue 1</span></div><p class="">ISSUE: how to indicate to rollback?</p></div>

            <p>To Do: specify what parts of the SDP can be changed between the
            createOffer and setLocalDescription</p>

            <p>The following list describes the <dfn id="set-description-model">processing model</dfn> for setting a new
            <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code>.</p>

            <ul>
              <li>
                <p>When the method is invoked, the user agent <em title="MUST" class="rfc2119">MUST</em> run the
                following steps:</p>

                <ol>
                  <li>
                    <p>Let <var>p</var> be a new promise.</p>
                  </li>

                  <li>
                    <p>If this <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object's
                    <a href="#dom-peerconnection-signaling-state">signaling
                    state</a> is <code>closed</code>, the user agent <em title="MUST" class="rfc2119">MUST</em> reject
                    <var>p</var> with <code>InvalidStateError</code>, and
                    jump to the step labeled <em>Return</em>.</p>
                  </li>

                  <li>
                    <p>If a local description contains a different set of ICE
                    credentials, then the ICE Agent <em title="MUST" class="rfc2119">MUST</em> trigger an ICE restart.
                    When ICE restarts, the gathering state will be changed back to
                    "gathering", if it was not already gathering. If the <a href="#dom-peerconnection-ice-connection-state"><code>RTCPeerConnection</code>
                    ice connection state</a> was "completed", it will be changed
                    back to "connected".</p>
                  </li>

                  <li>
                    <p>The user agent must start the process to apply the
                    <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> argument.</p>
                  </li>

                  <li>
                    <p><em>Return:</em> Return <var>p</var>.</p>
                  </li>
                </ol>
              </li>

              <li>
                <p>If the process to apply the
                <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> argument fails for
                any reason, then user agent must queue a task runs the
                following steps:</p>

                <ol>
                  <li>
                    <p>Let <var>connection</var> be the
                    <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object on with this
                    method was invoked.</p>
                  </li>

                  <li>
                    <p>If <var>connection</var>'s <a href="#dom-peerconnection-signaling-state">signaling state</a>
                    is <code>closed</code>, then abort these steps.</p>
                  </li>

                  <li>
                    <p>If the reason for the failure is:</p>

                    <ul>
                      <li>
                        <p>The content of the
                        <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> argument is
                        invalid or the <code><a href="#widl-RTCSessionDescription-type">type</a></code> is
                        wrong for the current <a href="#dom-peerconnection-signaling-state">signaling
                        state</a> of <var>connection</var>.</p>

                        <p>Let <var>reason</var> be
                        <code>InvalidSessionDescriptionError</code>.</p>
                      </li>

                      <li>
                        <p>The <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> is a
                        valid description but cannot be applied at the media
                        layer.</p>

                        <p>TODO ISSUE - next few points are probably wrong.
                        Make sure to check this in setRemote too.</p>

                        <p>This can happen, e.g., if there are insufficient
                        resources to apply the SDP. The user agent <em title="MUST" class="rfc2119">MUST</em> then
                        rollback as necessary if the new description was
                        partially applied when the failure occurred.</p>

                        <p>If rollback was not necessary or was completed
                        successfully, let <var>reason</var> be
                        <code>IncompatibleSessionDescriptionError</code>. If
                        rollback was not possible, let <var>reason</var> be
                        <code>InternalError</code> and set
                        <var>connection</var>'s <a href="#dom-peerconnection-signaling-state">signaling
                        state</a> to <code>closed</code>.</p>
                      </li>
                    </ul>
                  </li>

                  <li>
                    <p>Reject <var>p</var> with <var>reason</var>.</p>
                  </li>
                </ol>
              </li>

              <li>
                <p>If the <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> argument is
                applied successfully, then user agent must queue a task runs
                the following steps:</p>

                <ol>
                  <li>
                    <p>Let <var>connection</var> be the
                    <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object on with this
                    method was invoked.</p>
                  </li>

                  <li>
                    <p>If <var>connection</var>'s <a href="#dom-peerconnection-signaling-state">signaling state</a>
                    is <code>closed</code>, then abort these steps.</p>
                  </li>

                  <li>
                    <p>Set <var>connection</var>'s description attribute (
                    <code><a class="internalDFN" href="#dom-peerconnection-localdescription">localDescription</a></code> or
                    <code><a class="internalDFN" href="#dom-peerconnection-remotedescription">remoteDescription</a></code> depending on the
                    setting operation) to the
                    <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> argument.</p>
                  </li>

                  <li>
                    <p>If the local description was set,
                    <var>connection</var>'s <a href="#dom-peerconnection-ice-gathering-state">ice gathering
                    state</a> is <code>new</code>, and the local description
                    contains media, then set <var>connection</var>'s <a href="#dom-peerconnection-ice-gathering-state">ice gathering
                    state</a> to <code>gathering</code>.</p>
                  </li>

                  <li>
                    <p>If the local description was set with content that
                    caused an ICE restart, then set <var>connection</var>'s
                    <a href="#dom-peerconnection-ice-gathering-state">ice
                    gathering state</a> to <code>gathering</code>.</p>
                  </li>

                  <li>
                    <p>Set <var>connection</var>'s <a href="#dom-peerconnection-signaling-state">signalingState</a>
                    accordingly.</p>
                  </li>

                  <li>
                    <p>If <var>connection</var>'s <a href="#dom-peerconnection-signaling-state">signalingState</a>
                    changed, fire a simple event named <code><a href="#event-signalingstatechange">signalingstatechange</a></code>
                    at <var>connection</var>.</p>
                  </li>

                  <li>
                    <p>Resolve <var>p</var> with <var>undefined</var>.</p>
                  </li>
                </ol>
              </li>
            </ul>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">description</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>Promise&lt;void&gt;</code></div></dd><dt id="widl-RTCPeerConnection-setRemoteDescription-Promise-void--RTCSessionDescription-description"><code>setRemoteDescription</code></dt><dd>
            <p>The <dfn id="dom-peerconnection-setremotedescription"><code>setRemoteDescription()</code></dfn>
            method instructs the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> to apply
            the supplied <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> as the
            remote offer or answer. This API changes the local media state.</p>

            <p>When the method is invoked, the user agent must follow the
            <a href="#set-description-model">processing model</a> of
            <code><a href="#dom-peerconnection-setlocaldescription">setLocalDescription()</a></code>,
            with the following additional conditions:</p>

            <ul>
              <li>
                <p>If an <code>a=identity</code> attribute is present in the
                session description, the browser <a href="#sec.identity-verify-assertion">validates the identity
                assertion.</a>. Identity validation completes asynchronously
                and does not block the completion of
                <code>setRemoteDescription</code>, unless there is a <a href="#target-peer-identity">target peer identity</a>.</p>

                <p>The <a href="#target-peer-identity">target peer identity</a>
                cannot be changed once set. Once set, if a different value is
                provided, the user agent <em title="MUST" class="rfc2119">MUST</em> reject the returned promise with
                <code>InvalidStateError</code> and abort this
                operation.</p>
              </li>

              <li>
                <p>If the "peerIdentity" configuration is applied to the
                <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>, this establishes a
                <dfn id="target-peer-identity">target peer identity</dfn>.
                Alternatively, if the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> has
                previously authenticated the identity of the peer (that is,
                there is a current value for <code><a href="#widl-RTCPeerConnection-peerIdentity">peerIdentity</a></code>
                ), then this also establishes a <a href="#target-peer-identity">target peer identity</a>.</p>

                <p>If there is a <a href="#target-peer-identity">target peer
                identity</a>, then <code>setRemoteDescription</code> rejects
                the returned promise, unless the description contains an
                identity assertion that matches the
                <a href="#target-peer-identity">target peer identity</a>. The
                <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> <em title="MAY" class="rfc2119">MAY</em> be closed if the
                validated peer identity does not match the <a href="#target-peer-identity">target peer identity</a>.</p>
              </li>
            </ul>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">description</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>Promise&lt;void&gt;</code></div></dd><dt id="widl-RTCPeerConnection-updateIce-void-RTCConfiguration-configuration"><code>updateIce</code></dt><dd>
            <p>The updateIce method updates the ICE Agent process of gathering
            local candidates and pinging remote candidates.</p>

            <p>This call may result in a change to the state of the ICE Agent,
            and may result in a change to media state if it results in
            connectivity being established.</p>

            <p>When the <dfn id="dom-peerconnection-updateice"><code>updateIce()</code></dfn>
            method is invoked, the user <em title="MUST" class="rfc2119">MUST</em> run the following steps to process
            the <code><a class="idlType" href="#idl-def-RTCConfiguration"><code>RTCConfiguration</code></a></code> dictionary:</p>

            <ol>
              <li>
                <p>If the <a href="#widl-RTCConfiguration-iceTransportPolicy">iceTransportPolicy</a> member
                is present, let its value be the ICE Agent's <dfn id="ice-transports-setting">ICE transports setting</dfn>.</p>
              </li>

              <li>
                <p>If the <a href="#widl-RTCConfiguration-iceTransportPolicy">iceTransportPolicy</a> member
                was omitted and the ICE Agent's <a href="#ice-transports-setting">ICE transports setting</a> is unset,
                set the ICE Agent's ICE transports setting to the <a href="#widl-RTCConfiguration-iceTransportPolicy">iceTransportPolicy</a>
                dictionary member default value.</p>
              </li>

              <li>
                <p>If the <a href="#widl-RTCConfiguration-iceServers">iceServers</a> dictionary
                member is present, but its value is an empty list, then throw
                an <code>InvalidAccessError</code> and abort these steps. If
                the list, on the other hand, has elements, each element must be
                validated by running the following sub-steps:</p>

                <ol>
                  <li>
                    <p>Let <var>server</var> be the current list element.</p>
                  </li>

                  <li>
                    <p>If the <var>server.urls</var> dictionary member is
                    omitted or an empty list, then throw an
                    <code>InvalidAccessError</code> and abort these steps.</p>
                  </li>

                  <li>
                    <p>If <var>server.urls</var> is a string, let
                    <var>urls</var> be a list consisting of just that string.
                    Otherwise, let <var>urls</var> refer to the
                    <var>server.urls</var> list.</p>
                  </li>

                  <li>
                    <p>For each url in <var>urls</var>, parse the url and
                    obtain <var>scheme name</var>. If the parsing fails or if
                    <var>scheme name</var> is not implemented by the browser,
                    throw a <code>SyntaxError</code> and abort these steps.</p>
                  </li>

                  <li>
                    <p>If <var>scheme name</var> is "turn" and either of the
                    dictionary members <var>server.username</var> or
                    <var>server.credential</var> are omitted, then throw an
                    <code>InvalidAccessError</code> and abort these steps.</p>
                  </li>
                </ol>

                <p>After passing the validation, let the <a href="#widl-RTCConfiguration-iceServers">iceServers</a> dictionary
                member be the ICE Agent's <dfn id="ice-servers-list">ICE
                servers list</dfn>.</p>

                <p>If a new list of servers replaces the ICE Agent's existing
                ICE servers list, no action will taken until the
                <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> 's <a href="#dom-peerconnection-ice-gathering-state">ice gathering
                state</a> transitions to <code>gathering</code>. If a script
                wants this to happen immediately, it should do an ICE
                restart.</p>
              </li>

              <li>
                <p>If the <a href="#widl-RTCConfiguration-iceServers">iceServers</a> dictionary
                member was omitted, and the ICE Agent's <a href="#ice-servers-list">ICE servers list</a> is unset, throw an
                <code>InvalidAccessError</code> and abort these steps.</p>
              </li>
            </ol>

            <div class="note"><div id="h-note5" role="heading" aria-level="6" class="note-title"><span>Note</span></div><div class="">
              The exception types throw in the above algorithm are provisional
              (until we decide what to do in each case).
            </div></div>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">configuration</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCConfiguration"><code>RTCConfiguration</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
      </section>

      <section property="bibo:hasPart" resource="#legacy-interface-extensions" typeof="bibo:Chapter" id="legacy-interface-extensions">
        <h4 resource="#h-legacy-interface-extensions" id="h-legacy-interface-extensions"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.3.3 </span>Legacy Interface Extensions</span></h4>

        <div class="note"><div id="h-note6" role="heading" aria-level="5" class="note-title"><span>Note</span></div><div class="">These methods are kept on <code>
            <a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a>
          </code> for legacy purposes.</div></div>

        <pre class="idl"><span class="idlInterface" id="idl-def-RTCPeerConnection-1">partial interface <span class="idlInterfaceID">RTCPeerConnection</span> {
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-createOffer-void-RTCSessionDescriptionCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback-RTCOfferOptions-options">createOffer</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCSessionDescriptionCallback"><code>RTCSessionDescriptionCallback</code></a></span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></span> <span class="idlParamName">failureCallback</span></span>, <span class="idlParam">optional <span class="idlParamType"><a class="idlType" href="#idl-def-RTCOfferOptions"><code>RTCOfferOptions</code></a></span> <span class="idlParamName">options</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-setLocalDescription-void-RTCSessionDescription-description-VoidFunction-successCallback-RTCPeerConnectionErrorCallback-failureCallback">setLocalDescription</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></span> <span class="idlParamName">description</span></span>, <span class="idlParam"><span class="idlParamType">VoidFunction</span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></span> <span class="idlParamName">failureCallback</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-createAnswer-void-RTCSessionDescriptionCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback">createAnswer</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCSessionDescriptionCallback"><code>RTCSessionDescriptionCallback</code></a></span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></span> <span class="idlParamName">failureCallback</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-setRemoteDescription-void-RTCSessionDescription-description-VoidFunction-successCallback-RTCPeerConnectionErrorCallback-failureCallback">setRemoteDescription</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></span> <span class="idlParamName">description</span></span>, <span class="idlParam"><span class="idlParamType">VoidFunction</span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></span> <span class="idlParamName">failureCallback</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-addIceCandidate-void-RTCIceCandidate-candidate-VoidFunction-successCallback-RTCPeerConnectionErrorCallback-failureCallback">addIceCandidate</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></span> <span class="idlParamName">candidate</span></span>, <span class="idlParam"><span class="idlParamType">VoidFunction</span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></span> <span class="idlParamName">failureCallback</span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#methods-1" typeof="bibo:Chapter" id="methods-1"><h5 resource="#h-methods-1" id="h-methods-1"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.3.3.1 </span>Methods</span></h5><dl class="methods"><dt id="widl-RTCPeerConnection-addIceCandidate-void-RTCIceCandidate-candidate-VoidFunction-successCallback-RTCPeerConnectionErrorCallback-failureCallback"><code>addIceCandidate</code></dt><dd>
            <p>When the <code>addIceCandidate</code> method is called, the
            user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

            <ol>
              <li>
                <p>Let <var>candidate</var> be the method's first argument.</p>
              </li>
              <li>
                <p>Let <var>successCallback</var> be the callback indicated by
                the method's second argument.</p>
              </li>
              <li>
                <p>Let <var>failureCallback</var> be the callback indicated by
                the method's third argument.</p>
              </li>
              <li>
                <p>Invoke <a href="#dom-peerconnection-addicecandidate">
                  RTCPeerConnection.addIceCandiddate()</a>
                with <var>candidate</var> as the sole argument, and let
                <var>p</var> be the resulting promise.</p>
              </li>
            </ol>

            <p>Upon fulfillment of <var>p</var>,
            invoke <var>successCallback</var> with <code>undefined</code> as the
            argument.</p>

            <p>Upon rejection of <var>p</var> with reason <var>r</var>,
            invoke <var>failureCallback</var> with <var>r</var> as the
            argument.</p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">candidate</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code>VoidFunction</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">failureCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCPeerConnection-createAnswer-void-RTCSessionDescriptionCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback"><code>createAnswer</code></dt><dd>
            <p>When the <code>createAnswer</code> method is called, the user
            agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

            <ol>
              <li>
                <p>Let <var>successCallback</var> be the method's first
                argument.</p>
              </li>
              <li>
                <p>Let <var>failureCallback</var> be the callback indicated by
                the method's second argument.</p>
              </li>
              <li>
                <p>Invoke <a href="#dom-mediadevices-getusermedia">RTCPeerConnection.createAnswer()</a>
                with no arguments, and let <var>p</var> be the resulting promise.</p>
              </li>
            </ol>

            <p>Upon fulfillment of <var>p</var> with value <var>answer</var>,
            invoke <var>successCallback</var> with <var>answer</var> as the
            argument.</p>

            <p>Upon rejection of <var>p</var> with reason <var>r</var>,
            invoke <var>failureCallback</var> with <var>r</var> as the
            argument.</p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCSessionDescriptionCallback"><code>RTCSessionDescriptionCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">failureCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCPeerConnection-createOffer-void-RTCSessionDescriptionCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback-RTCOfferOptions-options"><code>createOffer</code></dt><dd>
            <p>When the <code>createOffer</code> method is called, the user
            agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

            <ol>
              <li>
                <p>Let <var>successCallback</var> be the method's first
                argument.</p>
              </li>
              <li>
                <p>Let <var>failureCallback</var> be the callback indicated by
                the method's second argument.</p>
              </li>
              <li>
                <p>Let <var>options</var> be the callback indicated by
                the method's third argument.</p>
              </li>
              <li>
                <p>Invoke <a href="#dom-mediadevices-getusermedia">RTCPeerConnection.createOffer()</a>
                with <var>options</var> as the sole argument, and let <var>p</var>
                be the resulting promise.</p>
              </li>
            </ol>

            <p>Upon fulfillment of <var>p</var> with value <var>offer</var>,
            invoke <var>successCallback</var> with <var>offer</var> as the
            argument.</p>

            <p>Upon rejection of <var>p</var> with reason <var>r</var>,
            invoke <var>failureCallback</var> with <var>r</var> as the
            argument.</p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCSessionDescriptionCallback"><code>RTCSessionDescriptionCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">failureCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">options</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCOfferOptions"><code>RTCOfferOptions</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCPeerConnection-setLocalDescription-void-RTCSessionDescription-description-VoidFunction-successCallback-RTCPeerConnectionErrorCallback-failureCallback"><code>setLocalDescription</code></dt><dd>
            <p>When the <code>setLocalDescription</code> method is called, the
            user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

            <ol>
              <li>
                <p>Let <var>description</var> be the method's first
                argument.</p>
              </li>
              <li>
                <p>Let <var>successCallback</var> be the callback indicated by
                the method's second argument.</p>
              </li>
              <li>
                <p>Let <var>failureCallback</var> be the callback indicated by
                the method's third argument.</p>
              </li>
              <li>
                <p>Invoke <a href="#dom-peerconnection-setlocaldescription">
                  RTCPeerConnection.setLocalDescription()</a>
                with <var>description</var> as the sole argument, and let
                <var>p</var> be the resulting promise.</p>
              </li>
            </ol>

            <p>Upon fulfillment of <var>p</var>,
            invoke <var>successCallback</var> with <code>undefined</code> as the
            argument.</p>

            <p>Upon rejection of <var>p</var> with reason <var>r</var>,
            invoke <var>failureCallback</var> with <var>r</var> as the
            argument.</p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">description</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code>VoidFunction</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">failureCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCPeerConnection-setRemoteDescription-void-RTCSessionDescription-description-VoidFunction-successCallback-RTCPeerConnectionErrorCallback-failureCallback"><code>setRemoteDescription</code></dt><dd>
            <p>When the <code>setRemoteDescription</code> method is called, the
            user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

            <ol>
              <li>
                <p>Let <var>description</var> be the method's first
                argument.</p>
              </li>
              <li>
                <p>Let <var>successCallback</var> be the callback indicated by
                the method's second argument.</p>
              </li>
              <li>
                <p>Let <var>failureCallback</var> be the callback indicated by
                the method's third argument.</p>
              </li>
              <li>
                <p>Invoke <a href="#dom-peerconnection-setremotedescription">
                  RTCPeerConnection.setLocalDescription()</a>
                with <var>description</var> as the sole argument, and let
                <var>p</var> be the resulting promise.</p>
              </li>
            </ol>

            <p>Upon fulfillment of <var>p</var>,
            invoke <var>successCallback</var> with <code>undefined</code> as the
            argument.</p>

            <p>Upon rejection of <var>p</var> with reason <var>r</var>,
            invoke <var>failureCallback</var> with <var>r</var> as the
            argument.</p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">description</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code>VoidFunction</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">failureCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
      </section>

      <section property="bibo:hasPart" resource="#garbage-collection" typeof="bibo:Chapter" id="garbage-collection">
        <h4 resource="#h-garbage-collection" id="h-garbage-collection"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.3.4 </span>Garbage collection</span></h4>

        <p>An <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object <em title="MUST" class="rfc2119">MUST</em> not be garbage
        collected as long as any event can cause an event handler to be
        triggered on the object. When the object's <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
        signalingState</a> is <code>closed</code>, no such event handler can be
        triggered and it is therefore safe to garbage collect the object.</p>

        <p>All <code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDTMFSender</code></a></code>,
        <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> and
        <code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code> objects that are connected to a
        <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> are considered to have a strong
        reference to the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>
      </section>
    </section>

    <section property="bibo:hasPart" resource="#state-definitions" typeof="bibo:Chapter" id="state-definitions">
      <h3 resource="#h-state-definitions" id="h-state-definitions"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.4 </span>State Definitions</span></h3>

      <section property="bibo:hasPart" resource="#rtcpeerstate-enum" typeof="bibo:Chapter" id="rtcpeerstate-enum">
        <h4 resource="#h-rtcpeerstate-enum" id="h-rtcpeerstate-enum"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.4.1 </span>RTCPeerState Enum</span></h4>

        <pre class="idl"><span class="idlEnum" id="idl-def-RTCSignalingState">enum <span class="idlEnumID">RTCSignalingState</span> {
    "<a href="#idl-def-RTCSignalingState.stable" class="idlEnumItem">stable</a>",
    "<a href="#idl-def-RTCSignalingState.have-local-offer" class="idlEnumItem">have-local-offer</a>",
    "<a href="#idl-def-RTCSignalingState.have-remote-offer" class="idlEnumItem">have-remote-offer</a>",
    "<a href="#idl-def-RTCSignalingState.have-local-pranswer" class="idlEnumItem">have-local-pranswer</a>",
    "<a href="#idl-def-RTCSignalingState.have-remote-pranswer" class="idlEnumItem">have-remote-pranswer</a>",
    "<a href="#idl-def-RTCSignalingState.closed" class="idlEnumItem">closed</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-RTCSignalingState.stable">stable</code></td><td>There is no offer­answer exchange in progress. This is also
          the initial state in which case the local and remote descriptions are
          empty.</td></tr><tr><td><code id="idl-def-RTCSignalingState.have-local-offer">have-local-offer</code></td><td>A local description, of type "offer", has been successfully
          applied.</td></tr><tr><td><code id="idl-def-RTCSignalingState.have-remote-offer">have-remote-offer</code></td><td>A remote description, of type "offer", has been successfully
          applied.</td></tr><tr><td><code id="idl-def-RTCSignalingState.have-local-pranswer">have-local-pranswer</code></td><td>A remote description of type "offer" has been successfully
          applied and a local description of type "pranswer" has been
          successfully applied.</td></tr><tr><td><code id="idl-def-RTCSignalingState.have-remote-pranswer">have-remote-pranswer</code></td><td>A local description of type "offer" has been successfully applied
          and a remote description of type "pranswer" has been successfully
          applied.</td></tr><tr><td><code id="idl-def-RTCSignalingState.closed">closed</code></td><td>The connection is closed.</td></tr></tbody></table>

        <p>The non-normative peer state transitions are: <img alt="The non-normative peer state transition diagram" src="images/peerstates.svg" style="width:100%"></p>

        <p>An example set of transitions might be:</p>

        <p>Caller transition:</p>

        <ul>
          <li>new RTCPeerConnection(): <code>stable</code></li>

          <li>setLocal(offer): <code>have-local-offer</code></li>

          <li>setRemote(pranswer): <code>have-remote-pranswer</code></li>

          <li>setRemote(answer): <code>stable</code></li>

          <li>close(): <code>closed</code></li>
        </ul>

        <p>Callee transition:</p>

        <ul>
          <li>new RTCPeerConnection(): <code>stable</code></li>

          <li>setRemote(offer): <code>have-remote-offer</code></li>

          <li>setLocal(pranswer): <code>have-local-pranswer</code></li>

          <li>setLocal(answer): <code>stable</code></li>

          <li>close(): <code>closed</code></li>
        </ul>
      </section>

      <section property="bibo:hasPart" resource="#rtcicegatheringstate-enum" typeof="bibo:Chapter" id="rtcicegatheringstate-enum">
        <h4 resource="#h-rtcicegatheringstate-enum" id="h-rtcicegatheringstate-enum"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.4.2 </span>RTCIceGatheringState Enum</span></h4>

        <pre class="idl"><span class="idlEnum" id="idl-def-RTCIceGatheringState">enum <span class="idlEnumID">RTCIceGatheringState</span> {
    "<a href="#idl-def-RTCIceGatheringState.new" class="idlEnumItem">new</a>",
    "<a href="#idl-def-RTCIceGatheringState.gathering" class="idlEnumItem">gathering</a>",
    "<a href="#idl-def-RTCIceGatheringState.complete" class="idlEnumItem">complete</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-RTCIceGatheringState.new">new</code></td><td>The object was just created, and no networking has occurred
          yet.</td></tr><tr><td><code id="idl-def-RTCIceGatheringState.gathering">gathering</code></td><td>The ICE engine is in the process of gathering candidates for this
          RTCPeerConnection.</td></tr><tr><td><code id="idl-def-RTCIceGatheringState.complete">complete</code></td><td>The ICE engine has completed gathering. Events such as adding a
          new interface or a new TURN server will cause the state to go back to
          gathering.</td></tr></tbody></table>
      </section>

      <section property="bibo:hasPart" resource="#rtciceconnectionstate-enum" typeof="bibo:Chapter" id="rtciceconnectionstate-enum">
        <h4 resource="#h-rtciceconnectionstate-enum" id="h-rtciceconnectionstate-enum"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.4.3 </span>RTCIceConnectionState Enum</span></h4>

        <pre class="idl"><span class="idlEnum" id="idl-def-RTCIceConnectionState">enum <span class="idlEnumID">RTCIceConnectionState</span> {
    "<a href="#idl-def-RTCIceConnectionState.new" class="idlEnumItem">new</a>",
    "<a href="#idl-def-RTCIceConnectionState.checking" class="idlEnumItem">checking</a>",
    "<a href="#idl-def-RTCIceConnectionState.connected" class="idlEnumItem">connected</a>",
    "<a href="#idl-def-RTCIceConnectionState.completed" class="idlEnumItem">completed</a>",
    "<a href="#idl-def-RTCIceConnectionState.failed" class="idlEnumItem">failed</a>",
    "<a href="#idl-def-RTCIceConnectionState.disconnected" class="idlEnumItem">disconnected</a>",
    "<a href="#idl-def-RTCIceConnectionState.closed" class="idlEnumItem">closed</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-RTCIceConnectionState.new">new</code></td><td>The ICE Agent is gathering addresses and/or waiting for remote
          candidates to be supplied.</td></tr><tr><td><code id="idl-def-RTCIceConnectionState.checking">checking</code></td><td>The ICE Agent has received remote candidates on at least one
          component, and is checking candidate pairs but has not yet found a
          connection. In addition to checking, it may also still be
          gathering.</td></tr><tr><td><code id="idl-def-RTCIceConnectionState.connected">connected</code></td><td>The ICE Agent has found a usable connection for all components
          but is still checking other candidate pairs to see if there is a
          better connection. It may also still be gathering.</td></tr><tr><td><code id="idl-def-RTCIceConnectionState.completed">completed</code></td><td>The ICE Agent has finished gathering and checking and found a
          connection for all components. Open issue: it is not clear how the
          non controlling ICE side knows it is in the state.</td></tr><tr><td><code id="idl-def-RTCIceConnectionState.failed">failed</code></td><td>The ICE Agent is finished checking all candidate pairs and failed
          to find a connection for at least one component. Connections may have
          been found for some components.</td></tr><tr><td><code id="idl-def-RTCIceConnectionState.disconnected">disconnected</code></td><td>Liveness checks have failed for one or more components. This is
          more aggressive than <code>failed</code>, and may trigger
          intermittently (and resolve itself without action) on a flaky
          network.</td></tr><tr><td><code id="idl-def-RTCIceConnectionState.closed">closed</code></td><td>The ICE Agent has shut down and is no longer responding to STUN
          requests.</td></tr></tbody></table>

        <p>States take either the value of any component or all components, as
        outlined below:</p>

        <ul>
          <li><code>checking</code> occurs if ANY component has received a
          candidate and can start checking</li>

          <li><code>connected</code> occurs if ALL components have established
          a working connection</li>

          <li><code>completed</code> occurs if ALL components have finalized
          the running of their ICE processes</li>

          <li><code>failed</code> occurs if ANY component has given up trying
          to connect</li>

          <li><code>disconnected</code> occurs if ANY component has failed
          liveness checks</li>

          <li><code>closed</code> occurs only if
          <code>RTCPeerConnection.close()</code> has been called.</li>
        </ul>

        <p>If a component is discarded as a result of signaling (e.g. RTCP mux
        or BUNDLE), the state may advance directly from <code>checking</code>
        to <code>completed</code>.</p>

        <p>Some example transitions might be:</p>

        <ul>
          <li>new RTCPeerConnection(): <code>new</code></li>

          <li>(<code>new</code>, remote candidates received):
          <code>checking</code></li>

          <li>(<code>checking</code>, found usable connection):
          <code>connected</code></li>

          <li>(<code>checking</code>, gave up): <code>failed</code></li>

          <li>(<code>connected</code>, finished all checks):
          <code>completed</code></li>

          <li>(<code>completed</code>, lost connectivity):
          <code>disconnected</code></li>

          <li>(any state, ICE restart occurs): <code>new</code></li>

          <li>close(): <code>closed</code></li>
        </ul>

        <p>The non-normative ICE state transitions are: <img alt="The non-normative ICE state transition diagram" src="images/icestates.svg" style="width:80%"></p>
      </section>
    </section>

    <section property="bibo:hasPart" resource="#callback-definitions" typeof="bibo:Chapter" id="callback-definitions">
      <h3 resource="#h-callback-definitions" id="h-callback-definitions"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.5 </span>Callback Definitions</span></h3>

      <section property="bibo:hasPart" resource="#rtcpeerconnectionerrorcallback" typeof="bibo:Chapter" id="rtcpeerconnectionerrorcallback">
        <h4 resource="#h-rtcpeerconnectionerrorcallback" id="h-rtcpeerconnectionerrorcallback"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.5.1 </span>RTCPeerConnectionErrorCallback</span></h4>

        <pre class="idl"><span class="idlCallback" id="idl-def-RTCPeerConnectionErrorCallback">callback <span class="idlCallbackID">RTCPeerConnectionErrorCallback</span> = <span class="idlCallbackType">void</span> (<span class="idlParam"><span class="idlParamType">DOMError</span> <span class="idlParamName">error</span></span>);</span></pre><section property="bibo:hasPart" resource="#callback-rtcpeerconnectionerrorcallback-parameters" typeof="bibo:Chapter" id="callback-rtcpeerconnectionerrorcallback-parameters"><h5 resource="#h-callback-rtcpeerconnectionerrorcallback-parameters" id="h-callback-rtcpeerconnectionerrorcallback-parameters"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.5.1.1 </span>Callback <a href="#idl-def-RTCPeerConnectionErrorCallback" class="idlType"><code>RTCPeerConnectionErrorCallback</code></a> Parameters</span></h5><dl class="callback-members"><dt id="widl-RTCPeerConnectionErrorCallback-error"><code>error</code> of type <span class="idlMemberType">DOMError</span></dt><dd>An error object encapsulating information about what went
          wrong.</dd></dl></section>
      </section>
    </section>

    <section property="bibo:hasPart" resource="#error-handling" typeof="bibo:Chapter" id="error-handling">
      <h3 resource="#h-error-handling" id="h-error-handling"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.6 </span>Error Handling</span></h3>

      <section property="bibo:hasPart" resource="#general-principles" typeof="bibo:Chapter" id="general-principles">
        <h4 resource="#h-general-principles" id="h-general-principles"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.6.1 </span>General Principles</span></h4>

        <p>All methods that return promises are governed by the standard error
        handling rules of promises. Methods that do not return promises may throw
        exceptions to indicate errors.</p>

        <p>Legacy-methods may only throw exceptions to indicate invalid state
        and other programming errors. For example, when a legacy-method is
        called when the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> is in an invalid
        state or a state in which that particular method is not allowed to be
        executed, it will throw an exception. In all other cases, legacy methods
        <em title="MUST" class="rfc2119">MUST</em> provide an error object to the error callback.</p>
      </section>

      <section property="bibo:hasPart" resource="#rtcsdperror" typeof="bibo:Chapter" id="rtcsdperror">
        <h4 resource="#h-rtcsdperror" id="h-rtcsdperror"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.6.2 </span>RTCSdpError</span></h4>

        <pre class="idl"><span class="idlInterface" id="idl-def-RTCSdpError">interface <span class="idlInterfaceID">RTCSdpError</span> : <span class="idlSuperclass">DOMError</span> {
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">long</span> <span class="idlAttrName"><a href="#widl-RTCSdpError-sdpLineNumber">sdpLineNumber</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-1" typeof="bibo:Chapter" id="attributes-1"><h5 resource="#h-attributes-1" id="h-attributes-1"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.6.2.1 </span>Attributes</span></h5><dl class="attributes"><dt id="widl-RTCSdpError-sdpLineNumber"><code>sdpLineNumber</code> of type <span class="idlAttrType">long</span>, readonly   </dt><dd>The line number of an <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code>
          at which the error was encountered.</dd></dl></section>

        <div class="note"><div id="h-note7" role="heading" aria-level="5" class="note-title"><span>Note</span></div><div class="">
          <p>Ask the DOM team to extend their list with the following errors.
          The error names and their descriptions are directly copied from the
          old RTCErrorName enum and might need some adjustment before being
          added to the public list of errors.</p>

          <ul>
            <li>InvalidSessionDescriptionError: The provided
            RTCSessionDescription contained invalid SDP, or the type was wrong
            for the current state of the RTCPeerConnection. User agents <em title="SHOULD" class="rfc2119">SHOULD</em>
            provide as much additional information in the error message as
            possible, including the sdpLineNumber, if appropriate.</li>

            <li>IncompatibleSessionDescriptionError: The provided
            RTCSessionDescription contained SDP that could not be correctly
            applied to the RTCPeerConnection due to its current state. User
            agents <em title="SHOULD" class="rfc2119">SHOULD</em> provide as much additional information in the error
            message as possible, including the sdpLineNumber, if
            appropriate.</li>

            <li>IncompatibleConstraintsError: The provided MediaConstraints
            could not be correctly applied to the RTCPeerConnection due to its
            current state. User agents <em title="SHOULD" class="rfc2119">SHOULD</em> provide as much additional
            information in the error message as possible.</li>

            <li>IncompatibleMediaStreamTrackError: The provided
            MediaStreamTrack is not an element of a MediaStream that is
            currently in the RTCPeerConnection's localStreams attribute.</li>

            <li>InternalError: The RTCPeerConnection encountered an error that
            it could not recover from.</li>
          </ul>
        </div></div>
      </section>
    </section>

    <section property="bibo:hasPart" resource="#session-description-model" typeof="bibo:Chapter" id="session-description-model">
      <h3 resource="#h-session-description-model" id="h-session-description-model"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.7 </span>Session Description Model</span></h3>

      <section property="bibo:hasPart" resource="#rtcsdptype" typeof="bibo:Chapter" id="rtcsdptype">
        <h4 resource="#h-rtcsdptype" id="h-rtcsdptype"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.7.1 </span>RTCSdpType</span></h4>

        <p>The RTCSdpType enum describes the type of an
        <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> instance.</p>

        <pre class="idl"><span class="idlEnum" id="idl-def-RTCSdpType">enum <span class="idlEnumID">RTCSdpType</span> {
    "<a href="#idl-def-RTCSdpType.offer" class="idlEnumItem">offer</a>",
    "<a href="#idl-def-RTCSdpType.pranswer" class="idlEnumItem">pranswer</a>",
    "<a href="#idl-def-RTCSdpType.answer" class="idlEnumItem">answer</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-RTCSdpType.offer">offer</code></td><td>
            <p>An RTCSdpType of "offer" indicates that a description should be
            treated as an [<cite><a href="#bib-SDP" class="bibref">SDP</a></cite>] offer.</p>
          </td></tr><tr><td><code id="idl-def-RTCSdpType.pranswer">pranswer</code></td><td>
            <p>An RTCSdpType of "pranswer" indicates that a description should
            be treated as an [<cite><a href="#bib-SDP" class="bibref">SDP</a></cite>] answer, but not a final answer. A
            description used as an SDP "pranswer" may be applied as a response
            to a SDP offer, or an update to a previously sent SDP
            "pranswer".</p>
          </td></tr><tr><td><code id="idl-def-RTCSdpType.answer">answer</code></td><td>
            <p>An RTCSdpType of "answer" indicates that a description should be
            treated as an [<cite><a href="#bib-SDP" class="bibref">SDP</a></cite>] final answer, and the offer-answer exchange
            should be considered complete. A description used as an SDP answer
            may be applied as a response to an SDP offer or as an update to a
            previously sent SDP "pranswer".</p>
          </td></tr></tbody></table>
      </section>

      <section property="bibo:hasPart" resource="#rtcsessiondescription-class" typeof="bibo:Chapter" id="rtcsessiondescription-class">
        <h4 resource="#h-rtcsessiondescription-class" id="h-rtcsessiondescription-class"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.7.2 </span>RTCSessionDescription Class</span></h4>

        <pre class="idl"><span class="idlInterface" id="idl-def-RTCSessionDescription"><span class="idlDictionary" id="idl-def-RTCSessionDescriptionInit">dictionary <span class="idlDictionaryID">RTCSessionDescriptionInit</span> {
<span class="idlMember">    <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCSdpType"><code>RTCSdpType</code></a></span> <span class="idlMemberName"><a href="#widl-RTCSessionDescriptionInit-type">type</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span>  <span class="idlMemberName"><a href="#widl-RTCSessionDescriptionInit-sdp">sdp</a></span>;</span>
};</span><br><br>[<span class="idlCtor"> <span class="idlCtorKeyword"></span><span class="idlCtorName"><a href="#widl-ctor-RTCSessionDescription--RTCSessionDescriptionInit-descriptionInitDict">Constructor</a></span> (<span class="idlParam">optional <span class="idlParamType"><a class="idlType" href="#idl-def-RTCSessionDescriptionInit"><code>RTCSessionDescriptionInit</code></a></span> <span class="idlParamName">descriptionInitDict</span></span>)</span>]
interface <span class="idlInterfaceID">RTCSessionDescription</span> {
<span class="idlAttribute">                attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCSdpType"><code>RTCSdpType</code></a>?</span> <span class="idlAttrName"><a href="#widl-RTCSessionDescription-type">type</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">DOMString?</span>  <span class="idlAttrName"><a href="#widl-RTCSessionDescription-sdp">sdp</a></span>;</span>
<span class="idlSerializer">    serializer = <span class="idlSerializerValues">{attribute}</span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#constructors-1" typeof="bibo:Chapter" id="constructors-1"><h5 resource="#h-constructors-1" id="h-constructors-1"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.7.2.1 </span>Constructors</span></h5><dl class="constructors"><dt id="widl-ctor-RTCSessionDescription--RTCSessionDescriptionInit-descriptionInitDict"><code>RTCSessionDescription</code></dt><dd>The <dfn id="dom-sessiondescription"><code>RTCSessionDescription()</code></dfn>
          constructor takes an optional dictionary argument,
          <var>descriptionInitDict</var>, whose content is used to initialize
          the new <code><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></code> object. If a
          dictionary key is not present in <var>descriptionInitDict</var>, the
          corresponding attribute will be initialized to null. If the
          constructor is run without the dictionary argument, all attributes
          will be initialized to null. This class is a future extensible
          carrier for the data contained in it and does not perform any
          substantive processing.<table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">descriptionInitDict</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCSessionDescriptionInit"><code>RTCSessionDescriptionInit</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table></dd></dl></section><section property="bibo:hasPart" resource="#attributes-2" typeof="bibo:Chapter" id="attributes-2"><h5 resource="#h-attributes-2" id="h-attributes-2"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.7.2.2 </span>Attributes</span></h5><dl class="attributes"><dt id="widl-RTCSessionDescription-sdp"><code>sdp</code> of type <span class="idlAttrType">DOMString</span>,            , nullable</dt><dd>The string representation of the SDP [<cite><a href="#bib-SDP" class="bibref">SDP</a></cite>]</dd><dt id="widl-RTCSessionDescription-type"><code>type</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCSdpType"><code>RTCSdpType</code></a></span>,            , nullable</dt><dd>The type of SDP this RTCSessionDescription represents.</dd></dl></section><section property="bibo:hasPart" resource="#serializer" typeof="bibo:Chapter" id="serializer"><h5 resource="#h-serializer" id="h-serializer"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.7.2.3 </span>Serializer</span></h5><div><p>Instances of this interface are serialized as a map with entries for each of the serializable attributes.</p><p></p></div></section>

        <section property="bibo:hasPart" resource="#dictionary-rtcsessiondescriptioninit-members" typeof="bibo:Chapter" id="dictionary-rtcsessiondescriptioninit-members"><h5 resource="#h-dictionary-rtcsessiondescriptioninit-members" id="h-dictionary-rtcsessiondescriptioninit-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.7.2.4 </span>Dictionary <a href="#idl-def-RTCSessionDescriptionInit" class="idlType"><code>RTCSessionDescriptionInit</code></a> Members</span></h5><dl class="dictionary-members"><dt id="widl-RTCSessionDescriptionInit-sdp"><code>sdp</code> of type <span class="idlMemberType">DOMString</span></dt><dd></dd><dt id="widl-RTCSessionDescriptionInit-type"><code>type</code> of type <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCSdpType"><code>RTCSdpType</code></a></span></dt><dd>DOMString sdp</dd></dl></section>
      </section>

      <section property="bibo:hasPart" resource="#rtcsessiondescriptioncallback" typeof="bibo:Chapter" id="rtcsessiondescriptioncallback">
        <h4 resource="#h-rtcsessiondescriptioncallback" id="h-rtcsessiondescriptioncallback"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.7.3 </span>RTCSessionDescriptionCallback</span></h4>

        <pre class="idl"><span class="idlCallback" id="idl-def-RTCSessionDescriptionCallback">callback <span class="idlCallbackID">RTCSessionDescriptionCallback</span> = <span class="idlCallbackType">void</span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></span> <span class="idlParamName">sdp</span></span>);</span></pre><section property="bibo:hasPart" resource="#callback-rtcsessiondescriptioncallback-parameters" typeof="bibo:Chapter" id="callback-rtcsessiondescriptioncallback-parameters"><h5 resource="#h-callback-rtcsessiondescriptioncallback-parameters" id="h-callback-rtcsessiondescriptioncallback-parameters"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.7.3.1 </span>Callback <a href="#idl-def-RTCSessionDescriptionCallback" class="idlType"><code>RTCSessionDescriptionCallback</code></a> Parameters</span></h5><dl class="callback-members"><dt id="widl-RTCSessionDescriptionCallback-sdp"><code>sdp</code> of type <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCSessionDescription"><code>RTCSessionDescription</code></a></span></dt><dd>The object containing the SDP [<cite><a href="#bib-SDP" class="bibref">SDP</a></cite>].</dd></dl></section>
      </section>
    </section>

    <section property="bibo:hasPart" resource="#interfaces-for-connectivity-establishment" typeof="bibo:Chapter" id="interfaces-for-connectivity-establishment">
      <h3 resource="#h-interfaces-for-connectivity-establishment" id="h-interfaces-for-connectivity-establishment"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.8 </span>Interfaces for Connectivity Establishment</span></h3>

      <section property="bibo:hasPart" resource="#rtcicecandidate-type" typeof="bibo:Chapter" id="rtcicecandidate-type">
        <h4 resource="#h-rtcicecandidate-type" id="h-rtcicecandidate-type"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.8.1 </span>RTCIceCandidate Type</span></h4>

        <p>This class is a future extensible carrier for the data contained in
        it and does not perform any substantive processing.</p>

        <pre class="idl"><span class="idlInterface" id="idl-def-RTCIceCandidate"><span class="idlDictionary" id="idl-def-RTCIceCandidateInit">dictionary <span class="idlDictionaryID">RTCIceCandidateInit</span> {
<span class="idlMember">    <span class="idlMemberType">DOMString</span>      <span class="idlMemberName"><a href="#widl-RTCIceCandidateInit-candidate">candidate</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span>      <span class="idlMemberName"><a href="#widl-RTCIceCandidateInit-sdpMid">sdpMid</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned short</span> <span class="idlMemberName"><a href="#widl-RTCIceCandidateInit-sdpMLineIndex">sdpMLineIndex</a></span>;</span>
};</span><br><br>[<span class="idlCtor"> <span class="idlCtorKeyword"></span><span class="idlCtorName"><a href="#widl-ctor-RTCIceCandidate--RTCIceCandidateInit-candidateInitDict">Constructor</a></span> (<span class="idlParam">optional <span class="idlParamType"><a class="idlType" href="#idl-def-RTCIceCandidateInit"><code>RTCIceCandidateInit</code></a></span> <span class="idlParamName">candidateInitDict</span></span>)</span>]
interface <span class="idlInterfaceID">RTCIceCandidate</span> {
<span class="idlAttribute">                attribute <span class="idlAttrType">DOMString?</span>      <span class="idlAttrName"><a href="#widl-RTCIceCandidate-candidate">candidate</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">DOMString?</span>      <span class="idlAttrName"><a href="#widl-RTCIceCandidate-sdpMid">sdpMid</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">unsigned short?</span> <span class="idlAttrName"><a href="#widl-RTCIceCandidate-sdpMLineIndex">sdpMLineIndex</a></span>;</span>
<span class="idlSerializer">    serializer = <span class="idlSerializerValues">{attribute}</span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#constructors-2" typeof="bibo:Chapter" id="constructors-2"><h5 resource="#h-constructors-2" id="h-constructors-2"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.8.1.1 </span>Constructors</span></h5><dl class="constructors"><dt id="widl-ctor-RTCIceCandidate--RTCIceCandidateInit-candidateInitDict"><code>RTCIceCandidate</code></dt><dd>The <dfn id="dom-icecandidate"><code>RTCIceCandidate()</code></dfn> constructor
          takes an optional dictionary argument, <var>candidateInitDict</var>,
          whose content is used to initialize the new
          <code><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></code> object. If a dictionary key is
          not present in <var>candidateInitDict</var>, the corresponding
          attribute will be initialized to null. If the constructor is run
          without the dictionary argument, all attributes will be initialized
          to null.<table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">candidateInitDict</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCIceCandidateInit"><code>RTCIceCandidateInit</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table></dd></dl></section><section property="bibo:hasPart" resource="#attributes-3" typeof="bibo:Chapter" id="attributes-3"><h5 resource="#h-attributes-3" id="h-attributes-3"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.8.1.2 </span>Attributes</span></h5><dl class="attributes"><dt id="widl-RTCIceCandidate-candidate"><code>candidate</code> of type <span class="idlAttrType">DOMString</span>,            , nullable</dt><dd>This carries the candidate-attribute as defined in section 15.1
          of [<cite><a href="#bib-ICE" class="bibref">ICE</a></cite>].</dd><dt id="widl-RTCIceCandidate-sdpMLineIndex"><code>sdpMLineIndex</code> of type <span class="idlAttrType">unsigned short</span>,            , nullable</dt><dd>This indicates the index (starting at zero) of the m-line in the
          SDP this candidate is associated with.</dd><dt id="widl-RTCIceCandidate-sdpMid"><code>sdpMid</code> of type <span class="idlAttrType">DOMString</span>,            , nullable</dt><dd>If present, this contains the identifier of the "media stream
          identification" as defined in [<cite><a href="#bib-RFC3388" class="bibref">RFC3388</a></cite>] for the m-line this
          candidate is associated with.</dd></dl></section><section property="bibo:hasPart" resource="#serializer-1" typeof="bibo:Chapter" id="serializer-1"><h5 resource="#h-serializer-1" id="h-serializer-1"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.8.1.3 </span>Serializer</span></h5><div><p>Instances of this interface are serialized as a map with entries for each of the serializable attributes.</p><p></p></div></section>

        <section property="bibo:hasPart" resource="#dictionary-rtcicecandidateinit-members" typeof="bibo:Chapter" id="dictionary-rtcicecandidateinit-members"><h5 resource="#h-dictionary-rtcicecandidateinit-members" id="h-dictionary-rtcicecandidateinit-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.8.1.4 </span>Dictionary <a href="#idl-def-RTCIceCandidateInit" class="idlType"><code>RTCIceCandidateInit</code></a> Members</span></h5><dl class="dictionary-members"><dt id="widl-RTCIceCandidateInit-candidate"><code>candidate</code> of type <span class="idlMemberType">DOMString</span></dt><dd>DOMString sdpMid</dd><dt id="widl-RTCIceCandidateInit-sdpMLineIndex"><code>sdpMLineIndex</code> of type <span class="idlMemberType">unsigned short</span></dt><dd></dd><dt id="widl-RTCIceCandidateInit-sdpMid"><code>sdpMid</code> of type <span class="idlMemberType">DOMString</span></dt><dd>unsigned short sdpMLineIndex</dd></dl></section>
      </section>

      <section property="bibo:hasPart" resource="#rtcpeerconnectioniceevent" typeof="bibo:Chapter" id="rtcpeerconnectioniceevent">
        <h4 resource="#h-rtcpeerconnectioniceevent" id="h-rtcpeerconnectioniceevent"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.8.2 </span>RTCPeerConnectionIceEvent</span></h4>

        <p>The <code>icecandidate</code> event of the RTCPeerConnection uses
        the <code><a class="idlType" href="#idl-def-RTCPeerConnectionIceEvent"><code>RTCPeerConnectionIceEvent</code></a></code> interface.</p>

        <p><dfn id="dfn-fire-an-ice-candidate-event" title="Fire an ice candidate event">Firing an
        <code><a class="idlType" href="#idl-def-RTCPeerConnectionIceEvent"><code>RTCPeerConnectionIceEvent</code></a></code> event named
        <var>e</var></dfn> with an <code><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></code>
        <var>candidate</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code>RTCPeerConnectionIceEvent</code> interface with the
        <code>candidate</code> attribute set to the new ICE candidate, <em title="MUST" class="rfc2119">MUST</em> be
        created and dispatched at the given target.</p>

        <pre class="idl"><span class="idlInterface" id="idl-def-RTCPeerConnectionIceEvent"><span class="idlDictionary" id="idl-def-RTCPeerConnectionIceEventInit">dictionary <span class="idlDictionaryID">RTCPeerConnectionIceEventInit</span> : <span class="idlSuperclass">EventInit</span> {
<span class="idlMember">    <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></span> <span class="idlMemberName"><a href="#widl-RTCPeerConnectionIceEventInit-candidate">candidate</a></span>;</span>
};</span><br><br>[<span class="idlCtor"> <span class="idlCtorKeyword"></span><span class="idlCtorName"><a href="#widl-ctor-RTCPeerConnectionIceEvent--DOMString-type-RTCPeerConnectionIceEventInit-eventInitDict">Constructor</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">type</span></span>, <span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCPeerConnectionIceEventInit"><code>RTCPeerConnectionIceEventInit</code></a></span> <span class="idlParamName">eventInitDict</span></span>)</span>]
interface <span class="idlInterfaceID">RTCPeerConnectionIceEvent</span> : <span class="idlSuperclass"><a class="internalDFN" href="#dfn-event">Event</a></span> {
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></span> <span class="idlAttrName"><a href="#widl-RTCPeerConnectionIceEvent-candidate">candidate</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#constructors-3" typeof="bibo:Chapter" id="constructors-3"><h5 resource="#h-constructors-3" id="h-constructors-3"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.8.2.1 </span>Constructors</span></h5><dl class="constructors"><dt id="widl-ctor-RTCPeerConnectionIceEvent--DOMString-type-RTCPeerConnectionIceEventInit-eventInitDict"><code>RTCPeerConnectionIceEvent</code></dt><dd>readonly attribute RTCIceCandidate candidate<table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">type</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">eventInitDict</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCPeerConnectionIceEventInit"><code>RTCPeerConnectionIceEventInit</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table></dd></dl></section><section property="bibo:hasPart" resource="#attributes-4" typeof="bibo:Chapter" id="attributes-4"><h5 resource="#h-attributes-4" id="h-attributes-4"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.8.2.2 </span>Attributes</span></h5><dl class="attributes"><dt id="widl-RTCPeerConnectionIceEvent-candidate"><code>candidate</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></span>, readonly   </dt><dd>
            <p>The <code>candidate</code> attribute is the
            <code><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></code> object with the new ICE
            candidate that caused the event.</p>
          </dd></dl></section>

        <section property="bibo:hasPart" resource="#dictionary-rtcpeerconnectioniceeventinit-members" typeof="bibo:Chapter" id="dictionary-rtcpeerconnectioniceeventinit-members"><h5 resource="#h-dictionary-rtcpeerconnectioniceeventinit-members" id="h-dictionary-rtcpeerconnectioniceeventinit-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.8.2.3 </span>Dictionary <a href="#idl-def-RTCPeerConnectionIceEventInit" class="idlType"><code>RTCPeerConnectionIceEventInit</code></a> Members</span></h5><dl class="dictionary-members"><dt id="widl-RTCPeerConnectionIceEventInit-candidate"><code>candidate</code> of type <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></span></dt><dd>
            <p>TODO</p>
          </dd></dl></section>
      </section>
    </section>
  </section>

  <section property="bibo:hasPart" resource="#peer-to-peer-data-api" typeof="bibo:Chapter" id="peer-to-peer-data-api">
    <!--OddPage--><h2 resource="#h-peer-to-peer-data-api" id="h-peer-to-peer-data-api"><span property="xhv:role" resource="xhv:heading"><span class="secno">5. </span>Peer-to-peer Data API</span></h2>

    <p>The Peer-to-peer Data API lets a web application send and receive
    generic application data peer-to-peer. The API for sending and receiving
    data models the behavior of WebSockets [<cite><a href="#bib-WEBSOCKETS-API" class="bibref">WEBSOCKETS-API</a></cite>].</p>

    <section property="bibo:hasPart" resource="#rtcpeerconnection-interface-extensions" typeof="bibo:Chapter" id="rtcpeerconnection-interface-extensions">
      <h3 resource="#h-rtcpeerconnection-interface-extensions" id="h-rtcpeerconnection-interface-extensions"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.1 </span>RTCPeerConnection Interface Extensions</span></h3>

      <p>The Peer-to-peer data API extends the
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> interface as described below.</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-RTCPeerConnection-2">partial interface <span class="idlInterfaceID">RTCPeerConnection</span> {
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-createDataChannel-RTCDataChannel-DOMString-label-RTCDataChannelInit-dataChannelDict">createDataChannel</a></span> (<span class="idlParam">[<span class="extAttr">TreatNullAs=EmptyString</span>] <span class="idlParamType">DOMString</span> <span class="idlParamName">label</span></span>, <span class="idlParam">optional <span class="idlParamType"><a class="idlType" href="#idl-def-RTCDataChannelInit"><code>RTCDataChannelInit</code></a></span> <span class="idlParamName">dataChannelDict</span></span>);</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-RTCPeerConnection-ondatachannel">ondatachannel</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-5" typeof="bibo:Chapter" id="attributes-5"><h4 resource="#h-attributes-5" id="h-attributes-5"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.1.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-RTCPeerConnection-ondatachannel"><code>ondatachannel</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler, of type <code><a href="#event-datachannel">datachannel</a></code>, <em title="MUST" class="rfc2119">MUST</em> be supported by all
        objects implementing the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>
        interface.</dd></dl></section><section property="bibo:hasPart" resource="#methods-2" typeof="bibo:Chapter" id="methods-2"><h4 resource="#h-methods-2" id="h-methods-2"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.1.2 </span>Methods</span></h4><dl class="methods"><dt id="widl-RTCPeerConnection-createDataChannel-RTCDataChannel-DOMString-label-RTCDataChannelInit-dataChannelDict"><code>createDataChannel</code></dt><dd>
          <p>Creates a new <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object with the
          given label. The <code><a class="idlType" href="#idl-def-RTCDataChannelInit"><code>RTCDataChannelInit</code></a></code> dictionary
          can be used to configure properties of the underlying channel such as
          <!--priority and--> data reliability.</p>

          <p>When the <dfn id="dom-peerconnection-createdatachannel"><code>createDataChannel()</code></dfn>
          method is invoked, the user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps.</p>

          <ol>
            <li>
              <p>If the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object's
              <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
              signalingState</a> is <code>closed</code>, throw an
              <code>InvalidStateError</code> exception and abort these
              steps.</p>
            </li>

            <li>
              <p>Let <var>channel</var> be a newly created
              <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object.</p>
            </li>

            <li>
              <p>Initialize <var>channel</var>'s <code><a href="#dom-datachannel-label">label</a></code> attribute to the value
              of the first argument.</p>
            </li>

            <li>
              <p>If the second (dictionary) argument is present, set
              <var>channel</var>'s <code><a href="#dom-datachannel-ordered">ordered</a></code>, <code><a href="#dom-datachannel-maxpacketlifetime">maxPacketLifeTime</a></code>,
              <code><a href="#dom-datachannel-maxretransmits">maxRetransmits</a></code>,
              <code><a href="#dom-datachannel-protocol">protocol</a></code>,
              <code><a href="#dom-datachannel-negotiated">negotiated</a></code>
              and <code><a href="#dom-datachannel-id">id</a></code> attributes
              to the values of their corresponding dictionary members (if
              present in the dictionary).</p>
            </li>

            <li>
              <p>If both the <code><a href="#dom-datachannel-maxpacketlifetime">maxPacketLifeTime</a></code>
              and <code><a href="#dom-datachannel-maxretransmits">maxRetransmits</a></code>
              attributes are set (not null), then throw a
              <code>SyntaxError</code> exception and abort these steps.</p>
            </li>

            <li>
              <p>If an attribute, either <code><a href="#dom-datachannel-maxpacketlifetime">maxPacketLifeTime</a></code>
              or <code><a href="#dom-datachannel-maxretransmits">maxRetransmits</a></code>, has
              been set to indicate unreliable mode, and that value exceeds the
              maximum value supported by the user agent, the value must be set
              to the user agents maximum value.</p>
            </li>

            <li>
              <p>If <code><a href="#dom-datachannel-id">id</a></code> attribute
              is uninitialized (not set via the dictionary), initialize it to a
              value generated by the user agent, according to the WebRTC
              DataChannel Protocol specification, and skip to the next step.
              Otherwise, if the value of the <code><a href="#dom-datachannel-id">id</a></code> attribute is taken by an
              existing <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>, throw a
              <code>ResourceInUse</code> exception and abort these steps.</p>
            </li>

            <li>
              <p>Return <var>channel</var> and continue the following steps in
              the background.</p>
            </li>

            <li>
              <p>Create <var>channel</var>'s associated <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data
              transport</a> and configure it according to the relevant
              properties of <var>channel</var>.</p>
            </li>
          </ol>
        <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">label</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">dataChannelDict</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCDataChannelInit"><code>RTCDataChannelInit</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code></div></dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#rtcdatachannel" typeof="bibo:Chapter" id="rtcdatachannel">
      <h3 resource="#h-rtcdatachannel" id="h-rtcdatachannel"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.2 </span>RTCDataChannel</span></h3>

      <p>The <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> interface represents a
      bi-directional data channel between two peers. A
      <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> is created via a factory method on an
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object. The messages sent between
      the browsers are described in [<cite><a href="#bib-RTCWEB-DATA" class="bibref">RTCWEB-DATA</a></cite>] and
      [<cite><a href="#bib-RTCWEB-DATA-PROTOCOL" class="bibref">RTCWEB-DATA-PROTOCOL</a></cite>].</p>

      <p>There are two ways to establish a connection with
      <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>. The first way is to simply create a
      <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> at one of the peers with the
      <code><a href="#widl-RTCDataChannelInit-negotiated">negotiated</a></code>
      <code><a class="idlType" href="#idl-def-RTCDataChannelInit"><code>RTCDataChannelInit</code></a></code> dictionary member unset or set to
      its default value false. This will announce the new channel in-band and
      trigger a <code><a class="idlType" href="#idl-def-RTCDataChannelEvent"><code>RTCDataChannelEvent</code></a></code> with the corresponding
      <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object at the other peer. The second
      way is to let the application negotiate the
      <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>. To do this, create a
      <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object with the <code><a href="#widl-RTCDataChannelInit-negotiated">negotiated</a></code>
      <code><a class="idlType" href="#idl-def-RTCDataChannelInit"><code>RTCDataChannelInit</code></a></code> dictionary member set to true, and
      signal out-of-band (e.g. via a web server) to the other side that it
      should create a corresponding <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> with the
      <code><a href="#widl-RTCDataChannelInit-negotiated">negotiated</a></code>
      <code><a class="idlType" href="#idl-def-RTCDataChannelInit"><code>RTCDataChannelInit</code></a></code> dictionary member set to true and
      the same <code><a href="#dom-datachannel-id">id</a></code>. This will
      connect the two separately created <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>
      objects. The second way makes it possible to create channels with
      asymmetric properties and to create channels in a declarative way by
      specifying matching <code><a href="#widl-RTCDataChannelInit-id">ids</a></code>.</p>

      <p>Each <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> has an associated
      <dfn id="dfn-underlying-data-transport">underlying data transport</dfn> that is used to transport actual
      data to the other peer. The transport properties of the <a class="internalDFN" href="#dfn-underlying-data-transport">underlying
      data transport</a>, such as in order delivery settings and reliability
      mode, are configured by the peer as the channel is created. The
      properties of a channel cannot change after the channel has been created.
      The actual wire protocol between the peers is specified by the WebRTC
      DataChannel Protocol specification (TODO: reference needed).</p>

      <p>A <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> can be configured to operate in
      different reliability modes. A reliable channel ensures that the data is
      delivered at the other peer through retransmissions. An unreliable
      channel is configured to either limit the number of retransmissions (
      <code><a href="#widl-RTCDataChannelInit-maxRetransmits">maxRetransmits</a></code> ) or
      set a time during which transmissions (including retransmissions) are
      allowed ( <code><a href="#widl-RTCDataChannelInit-maxPacketLifeTime">maxPacketLifeTime</a></code>
      ). These properties can not be used simultaneously and an attempt to do
      so will result in an error. Not setting any of these properties results
      in a reliable channel.</p>

      <p>A <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>, created with <code><a href="#dom-peerconnection-createdatachannel">createDataChannel()</a></code> or
      dispatched via a <code><a class="idlType" href="#idl-def-RTCDataChannelEvent"><code>RTCDataChannelEvent</code></a></code>, <em title="MUST" class="rfc2119">MUST</em> initially
      be in the <code>connecting</code> state. When the
      <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object's <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data
      transport</a> is ready, the user agent <em title="MUST" class="rfc2119">MUST</em> <a href="#announce-datachannel-open">announce the <code>RTCDataChannel</code> as
      open</a>.</p>

      <p>When the user agent is to <dfn id="announce-datachannel-open">announce
      a <code>RTCDataChannel</code> as open</dfn>, the user agent <em title="MUST" class="rfc2119">MUST</em> queue a
      task to run the following steps:</p>

      <ol>
        <li>
          <p>If the associated <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object's
          <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
          signalingState</a> is <code>closed</code>, abort these steps.</p>
        </li>

        <li>
          <p>Let <var>channel</var> be the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>
          object to be announced.</p>
        </li>

        <li>
          <p>Set <var>channel</var>'s <code><a href="#dom-datachannel-readystate">readyState</a></code> attribute to
          <code>open</code>.</p>
        </li>

        <li>
          <p>Fire a simple event named <code><a href="#event-datachannel-open">open</a></code> at <var>channel</var>.</p>
        </li>
      </ol>

      <p>When an <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data transport</a> is to be announced (the other
      peer created a channel with <code><a href="#widl-RTCDataChannelInit-negotiated">negotiated</a></code> unset or set
      to false), the user agent of the peer that did not initiate the creation
      process <em title="MUST" class="rfc2119">MUST</em> queue a task to run the following steps:</p>

      <ol>
        <li>
          <p>If the associated <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object's
          <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
          signalingState</a> is <code>closed</code>, abort these steps.</p>
        </li>

        <li>
          <p>Let <var>channel</var> be a newly created
          <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object.</p>
        </li>

        <li>
          <p>Let <var>configuration</var> be an information bundle received
          from the other peer as a part of the process to establish the
          <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data transport</a> described by the WebRTC DataChannel
          Protocol specification.</p>
        </li>

        <li>
          <p>Initialize <var>channel</var>'s <code><a href="#dom-datachannel-label">label</a></code>, <code><a href="#dom-datachannel-ordered">ordered</a></code>, <code><a href="#dom-datachannel-maxpacketlifetime">maxPacketLifeTime</a></code>,
          <code><a href="#dom-datachannel-maxretransmits">maxRetransmits</a></code>,
          <code><a href="#dom-datachannel-protocol">protocol</a></code>,
          <code><a href="#dom-datachannel-negotiated">negotiated</a></code> and
          <code><a href="#dom-datachannel-id">id</a></code> attributes to their
          corresponding values in <var>configuration</var>.</p>
        </li>

        <li>
          <p>Set <var>channel</var>'s <code><a href="#dom-datachannel-readystate">readyState</a></code> attribute to
          <code>connecting</code>.</p>
        </li>

        <li>
          <p><a class="internalDFN" href="#fire-a-datachannel-event">Fire a datachannel event</a> named <code><a href="#event-datachannel">datachannel</a></code> with <var>channel</var>
          at the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>
        </li>
      </ol>

      <p>An <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object's <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data
      transport</a> may be torn down in a non-abrupt manner by running the
      <dfn id="data-transport-closing-procedure">closing procedure</dfn>. When
      that happens the user agent <em title="MUST" class="rfc2119">MUST</em>, unless the procedure was initiated by
      the <code><a href="#dom-datachannel-close">close()</a></code> method,
      queue a task that sets the object's <code><a href="#dom-datachannel-readystate">readyState</a></code> attribute to
      <code>closing</code>. This will eventually render the <a href="#dfn-underlying-data-transport">data transport</a> <a href="#data-transport-closed">closed</a>.</p>

      <div class="note"><div id="h-note8" role="heading" aria-level="4" class="note-title"><span>Note</span></div><div class="">
        References to protocol specification are needed.
      </div></div>

      <p>When a <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object's <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data
      transport</a> has been <dfn id="data-transport-closed">closed</dfn>, the
      user agent <em title="MUST" class="rfc2119">MUST</em> queue a task to run the following steps:</p>

      <ol>
        <li>
          <p>Let <var>channel</var> be the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>
          object whose <a href="#dfn-underlying-data-transport">transport</a>
          was closed.</p>

          <div class="note"><div id="h-note9" role="heading" aria-level="4" class="note-title"><span>Note</span></div><div class="">
            The data transport protocol will specify what happens to, e.g.
            buffered data, when the data transport is closed.
          </div></div>
        </li>

        <li>
          <p>Set <var>channel</var>'s <code><a href="#dom-datachannel-readystate">readyState</a></code> attribute to
          <code>closed</code>.</p>
        </li>

        <li>
          <p>If the <a href="#dfn-underlying-data-transport">transport</a> was
          closed <dfn id="data-transport-closed-error">with an error</dfn>,
          fire an NetworkError event at <var>channel</var>.</p>
        </li>

        <li>
          <p>Fire a simple event named <code title="event-RTCDataChannel-close"><a href="#event-datachannel-close">close</a></code> at
          <var>channel</var>.</p>
        </li>
      </ol>

      <pre class="idl"><span class="idlInterface" id="idl-def-RTCDataChannel"><span class="idlDictionary" id="idl-def-RTCDataChannelInit">dictionary <span class="idlDictionaryID">RTCDataChannelInit</span> {
<span class="idlMember">    <span class="idlMemberType">boolean</span>        <span class="idlMemberName"><a href="#widl-RTCDataChannelInit-ordered">ordered</a></span> = <span class="idlMemberValue">true</span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned short</span> <span class="idlMemberName"><a href="#widl-RTCDataChannelInit-maxPacketLifeTime">maxPacketLifeTime</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned short</span> <span class="idlMemberName"><a href="#widl-RTCDataChannelInit-maxRetransmits">maxRetransmits</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span>      <span class="idlMemberName"><a href="#widl-RTCDataChannelInit-protocol">protocol</a></span> = <span class="idlMemberValue">""</span>;</span>
<span class="idlMember">    <span class="idlMemberType">boolean</span>        <span class="idlMemberName"><a href="#widl-RTCDataChannelInit-negotiated">negotiated</a></span> = <span class="idlMemberValue">false</span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned short</span> <span class="idlMemberName"><a href="#widl-RTCDataChannelInit-id">id</a></span>;</span>
};</span><br><br>interface <span class="idlInterfaceID">RTCDataChannel</span> : <span class="idlSuperclass">EventTarget</span> {
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">DOMString</span>           <span class="idlAttrName"><a href="#widl-RTCDataChannel-label">label</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">boolean</span>             <span class="idlAttrName"><a href="#widl-RTCDataChannel-ordered">ordered</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">unsigned short?</span>     <span class="idlAttrName"><a href="#widl-RTCDataChannel-maxPacketLifeTime">maxPacketLifeTime</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">unsigned short?</span>     <span class="idlAttrName"><a href="#widl-RTCDataChannel-maxRetransmits">maxRetransmits</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">DOMString</span>           <span class="idlAttrName"><a href="#widl-RTCDataChannel-protocol">protocol</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">boolean</span>             <span class="idlAttrName"><a href="#widl-RTCDataChannel-negotiated">negotiated</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">unsigned short</span>      <span class="idlAttrName"><a href="#widl-RTCDataChannel-id">id</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCDataChannelState"><code>RTCDataChannelState</code></a></span> <span class="idlAttrName"><a href="#widl-RTCDataChannel-readyState">readyState</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">unsigned long</span>       <span class="idlAttrName"><a href="#widl-RTCDataChannel-bufferedAmount">bufferedAmount</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>        <span class="idlAttrName"><a href="#widl-RTCDataChannel-onopen">onopen</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>        <span class="idlAttrName"><a href="#widl-RTCDataChannel-onerror">onerror</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>        <span class="idlAttrName"><a href="#widl-RTCDataChannel-onclose">onclose</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCDataChannel-close-void">close</a></span> ();</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>        <span class="idlAttrName"><a href="#widl-RTCDataChannel-onmessage">onmessage</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">DOMString</span>           <span class="idlAttrName"><a href="#widl-RTCDataChannel-binaryType">binaryType</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCDataChannel-send-void-DOMString-data">send</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">data</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCDataChannel-send-void-Blob-data">send</a></span> (<span class="idlParam"><span class="idlParamType">Blob</span> <span class="idlParamName">data</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCDataChannel-send-void-ArrayBuffer-data">send</a></span> (<span class="idlParam"><span class="idlParamType">ArrayBuffer</span> <span class="idlParamName">data</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCDataChannel-send-void-ArrayBufferView-data">send</a></span> (<span class="idlParam"><span class="idlParamType">ArrayBufferView</span> <span class="idlParamName">data</span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-6" typeof="bibo:Chapter" id="attributes-6"><h4 resource="#h-attributes-6" id="h-attributes-6"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.2.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-RTCDataChannel-binaryType"><code>binaryType</code> of type <span class="idlAttrType">DOMString</span>,            </dt><dd>
          <p>The <dfn id="dom-datachannel-binarytype"><code>binaryType</code></dfn> attribute
          <em title="MUST" class="rfc2119">MUST</em>, on getting, return the value to which it was last set. On
          setting, the user agent must set the IDL attribute to the new value.
          When a <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object is created, the
          <code><a href="#dom-datachannel-binarytype">binaryType</a></code>
          attribute <em title="MUST" class="rfc2119">MUST</em> be initialized to the string "<code>blob</code>".</p>

          <p>This attribute controls how binary data is exposed to scripts. See
          the [<cite><a href="#bib-WEBSOCKETS-API" class="bibref">WEBSOCKETS-API</a></cite>] for more information.</p>
        </dd><dt id="widl-RTCDataChannel-bufferedAmount"><code>bufferedAmount</code> of type <span class="idlAttrType">unsigned long</span>, readonly   </dt><dd>
          <p>The <dfn id="dom-datachannel-bufferedamount"><code>bufferedAmount</code></dfn>
          attribute <em title="MUST" class="rfc2119">MUST</em> return the number of bytes of application data (UTF-8
          text and binary data) that have been queued using <code><a href="#dom-datachannel-send">send()</a></code> but that, as of the last
          time the event loop started executing a task, had not yet been
          transmitted to the network. (This thus includes any text sent during
          the execution of the current task, regardless of whether the user
          agent is able to transmit text asynchronously with script execution.)
          This does not include framing overhead incurred by the protocol, or
          buffering done by the operating system or network hardware. If the
          channel is closed, this attribute's value will only increase with
          each call to the <code><a href="#dom-datachannel-send">send()</a></code> method (the attribute does
          not reset to zero once the channel closes).</p>
        </dd><dt id="widl-RTCDataChannel-id"><code>id</code> of type <span class="idlAttrType">unsigned short</span>, readonly   </dt><dd>
          <p>The <dfn id="dom-datachannel-id"><code>RTCDataChannel.id</code></dfn> attribute
          returns the id for this <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>. The id
          was either assigned by the user agent at channel creation time or
          selected by the script. The attribute <em title="MUST" class="rfc2119">MUST</em> return the value to which
          it was set when the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> was
          created.</p>
        </dd><dt id="widl-RTCDataChannel-label"><code>label</code> of type <span class="idlAttrType">DOMString</span>, readonly   </dt><dd>
          <p>The <dfn id="dom-datachannel-label"><code>RTCDataChannel.label</code></dfn>
          attribute represents a label that can be used to distinguish this
          <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object from other
          <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> objects. Scripts are allowed to
          create multiple <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> objects with the
          same label. The attribute <em title="MUST" class="rfc2119">MUST</em> return the value to which it was set
          when the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object was created.</p>
        </dd><dt id="widl-RTCDataChannel-maxPacketLifeTime"><code>maxPacketLifeTime</code> of type <span class="idlAttrType">unsigned short</span>, readonly   , nullable</dt><dd>
          <p>The <dfn id="dom-datachannel-maxpacketlifetime"><code>RTCDataChannel.maxPacketLifeTime</code></dfn>
          attribute returns the length of the time window (in milliseconds)
          during which transmissions and retransmissions may occur in
          unreliable mode, or null if unset. The attribute <em title="MUST" class="rfc2119">MUST</em> be initialized
          to null by default and <em title="MUST" class="rfc2119">MUST</em> return the value to which it was set when
          the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> was created.</p>
        </dd><dt id="widl-RTCDataChannel-maxRetransmits"><code>maxRetransmits</code> of type <span class="idlAttrType">unsigned short</span>, readonly   , nullable</dt><dd>
          <p>The <dfn id="dom-datachannel-maxretransmits"><code>RTCDataChannel.maxRetransmits</code></dfn>
          attribute returns the maximum number of retransmissions that are
          attempted in unreliable mode, or null if unset. The attribute <em title="MUST" class="rfc2119">MUST</em> be
          initialized to null by default and <em title="MUST" class="rfc2119">MUST</em> return the value to which it
          was set when the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> was created.</p>
        </dd><dt id="widl-RTCDataChannel-negotiated"><code>negotiated</code> of type <span class="idlAttrType">boolean</span>, readonly   </dt><dd>
          <p>The <dfn id="dom-datachannel-negotiated"><code>RTCDataChannel.negotiated</code></dfn>
          attribute returns true if this <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> was
          negotiated by the application, or false otherwise. The attribute <em title="MUST" class="rfc2119">MUST</em>
          be initialized to false by default and <em title="MUST" class="rfc2119">MUST</em> return the value to which
          it was set when the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> was
          created.</p>
        </dd><dt id="widl-RTCDataChannel-onclose"><code>onclose</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler, of type <code><a href="#event-datachannel-close">close</a></code>, <em title="MUST" class="rfc2119">MUST</em> be supported by all
        objects implementing the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>
        interface.</dd><dt id="widl-RTCDataChannel-onerror"><code>onerror</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler, of type <code><a href="#event-datachannel-error">error</a></code>, <em title="MUST" class="rfc2119">MUST</em> be supported by all
        objects implementing the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>
        interface.</dd><dt id="widl-RTCDataChannel-onmessage"><code>onmessage</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler, of type <code><a href="#event-datachannel-message">message</a></code>, <em title="MUST" class="rfc2119">MUST</em> be supported by
        all objects implementing the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>
        interface.</dd><dt id="widl-RTCDataChannel-onopen"><code>onopen</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler, of type <code><a href="#event-datachannel-open">open</a></code>, <em title="MUST" class="rfc2119">MUST</em> be supported by all
        objects implementing the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>
        interface.</dd><dt id="widl-RTCDataChannel-ordered"><code>ordered</code> of type <span class="idlAttrType">boolean</span>, readonly   </dt><dd>
          <p>The <dfn id="dom-datachannel-ordered"><code>RTCDataChannel.ordered</code></dfn>
          attribute returns true if the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> is
          ordered, and false if other of order delivery is allowed. The
          attribute <em title="MUST" class="rfc2119">MUST</em> be initialized to true by default and <em title="MUST" class="rfc2119">MUST</em> return the
          value to which it was set when the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>
          was created.</p>
        </dd><dt id="widl-RTCDataChannel-protocol"><code>protocol</code> of type <span class="idlAttrType">DOMString</span>, readonly   </dt><dd>
          <p>The <dfn id="dom-datachannel-protocol"><code>RTCDataChannel.protocol</code></dfn>
          attribute returns the name of the sub-protocol used with this
          <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> if any, or the empty string
          otherwise. The attribute <em title="MUST" class="rfc2119">MUST</em> be initialized to the empty string by
          default and <em title="MUST" class="rfc2119">MUST</em> return the value to which it was set when the
          <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> was created.</p>
        </dd><dt id="widl-RTCDataChannel-readyState"><code>readyState</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCDataChannelState"><code>RTCDataChannelState</code></a></span>, readonly   </dt><dd>
          <p>The <dfn id="dom-datachannel-readystate"><code>RTCDataChannel.readyState</code></dfn>
          attribute represents the state of the <code>RTCDataChannel</code>
          object. It <em title="MUST" class="rfc2119">MUST</em> return the value to which the user agent last set it
          (as defined by the processing model algorithms).</p>
        </dd></dl></section><section property="bibo:hasPart" resource="#methods-3" typeof="bibo:Chapter" id="methods-3"><h4 resource="#h-methods-3" id="h-methods-3"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.2.2 </span>Methods</span></h4><dl class="methods"><dt id="widl-RTCDataChannel-close-void"><code>close</code></dt><dd>
          <p>Closes the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>. It may be called
          regardless of whether the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object
          was created by this peer or the remote peer.</p>

          <p>When the <dfn id="dom-datachannel-close"><code>RTCDataChannel
          close()</code></dfn> method is called, the user agent <em title="MUST" class="rfc2119">MUST</em> run the
          following steps:</p>

          <ol>
            <li>
              <p>Let <var>channel</var> be the
              <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object which is about to be
              closed.</p>
            </li>

            <li>
              <p>If <var>channel</var>'s <code><a href="#dom-datachannel-readystate">readyState</a></code> is
              <code>closing</code> or <code>closed</code>, then abort these
              steps.</p>
            </li>

            <li>
              <p>Set <var>channel</var>'s <code><a href="#dom-datachannel-readystate">readyState</a></code> attribute to
              <code>closing</code>.</p>
            </li>

            <li>
              <p>If the <code><a href="#data-transport-closing-procedure">closing procedure</a></code>
              has not started yet, start it.</p>
            </li>
          </ol>
        <div><em>No parameters.</em></div><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCDataChannel-send-void-DOMString-data"><code>send</code></dt><dd>
          <p>Run the steps described by the <code><a href="#dom-datachannel-send">send()</a></code> algorithm with argument
          type <code>string</code> object.</p>
        <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">data</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCDataChannel-send-void-Blob-data"><code>send</code></dt><dd>
          <p>Run the steps described by the <code><a href="#dom-datachannel-send">send()</a></code> algorithm with argument
          type <code>Blob</code> object.</p>
        <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">data</td><td class="prmType"><code>Blob</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCDataChannel-send-void-ArrayBuffer-data"><code>send</code></dt><dd>
          <p>Run the steps described by the <code><a href="#dom-datachannel-send">send()</a></code> algorithm with argument
          type <code>ArrayBuffer</code> object.</p>
        <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">data</td><td class="prmType"><code>ArrayBuffer</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCDataChannel-send-void-ArrayBufferView-data"><code>send</code></dt><dd>
          <p>Run the steps described by the <code><a href="#dom-datachannel-send">send()</a></code> algorithm with argument
          type <code>ArrayBufferView</code> object.</p>
        <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">data</td><td class="prmType"><code>ArrayBufferView</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>

      <section property="bibo:hasPart" resource="#dictionary-rtcdatachannelinit-members" typeof="bibo:Chapter" id="dictionary-rtcdatachannelinit-members"><h4 resource="#h-dictionary-rtcdatachannelinit-members" id="h-dictionary-rtcdatachannelinit-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.2.3 </span>Dictionary <a href="#idl-def-RTCDataChannelInit" class="idlType"><code>RTCDataChannelInit</code></a> Members</span></h4><dl class="dictionary-members"><dt id="widl-RTCDataChannelInit-id"><code>id</code> of type <span class="idlMemberType">unsigned short</span></dt><dd>
          <p>Overrides the default selection of id for this channel.</p>
        </dd><dt id="widl-RTCDataChannelInit-maxPacketLifeTime"><code>maxPacketLifeTime</code> of type <span class="idlMemberType">unsigned short</span></dt><dd>
          <p>Limits the time during which the channel will transmit or
          retransmit data if not acknowledged. This value may be clamped if it
          exceeds the maximum value supported by the user agent.</p>
        </dd><dt id="widl-RTCDataChannelInit-maxRetransmits"><code>maxRetransmits</code> of type <span class="idlMemberType">unsigned short</span></dt><dd>
          <p>Limits the number of times a channel will retransmit data if not
          successfully delivered. This value may be clamped if it exceeds the
          maximum value supported by the user agent..</p>
        </dd><dt id="widl-RTCDataChannelInit-negotiated"><code>negotiated</code> of type <span class="idlMemberType">boolean</span>, defaulting to <code>false</code></dt><dd>
          <p>The default value of false tells the user agent to announce the
          channel in-band and instruct the other peer to dispatch a
          corresponding <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object. If set to
          true, it is up to the application to negotiate the channel and create
          a <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object with the same
          <code><a href="#dom-datachannel-id">id</a></code> at the other
          peer.</p>
        </dd><dt id="widl-RTCDataChannelInit-ordered"><code>ordered</code> of type <span class="idlMemberType">boolean</span>, defaulting to <code>true</code></dt><dd>
          <p>If set to false, data is allowed to be delivered out of order. The
          default value of true, guarantees that data will be delivered in
          order.</p>
        </dd><dt id="widl-RTCDataChannelInit-protocol"><code>protocol</code> of type <span class="idlMemberType">DOMString</span>, defaulting to <code>""</code></dt><dd>
          <p>Subprotocol name used for this channel.</p>
        </dd></dl></section>

      <p>The <dfn id="dom-datachannel-send"><code>send()</code></dfn> method is
      overloaded to handle different data argument types. When any version of
      the method is called, the user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

      <ol>
        <li>
          <p>Let <var>channel</var> be the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>
          object on which data is to be sent.</p>
        </li>

        <li>
          <p>If <var>channel</var>'s <a href="#dom-datachannel-readystate"><code>readyState</code></a> attribute
          is <code>connecting</code>, throw an <code>InvalidStateError</code>
          exception and abort these steps.</p>
        </li>

        <li>
          <p>Execute the sub step that corresponds to the type of the methods
          argument:</p>

          <ul>
            <li>
              <p><code>string</code> object:</p>

              <p>Let <var>data</var> be the result of converting the argument
              object to a sequence of Unicode characters and increase the
              <code><a href="#dom-datachannel-bufferedamount">bufferedAmount</a></code>
              attribute by the number of bytes needed to express
              <var>data</var> as UTF-8.</p>
            </li>

            <li>
              <p><code>Blob</code> object:</p>

              <p>Let <var>data</var> be the raw data represented by the
              <code>Blob</code> object and increase the <code><a href="#dom-datachannel-bufferedamount">bufferedAmount</a></code>
              attribute by the size of data, in bytes.</p>
            </li>

            <li>
              <p><code>ArrayBuffer</code> object:</p>

              <p>Let <var>data</var> be the data stored in the buffer described
              by the <code>ArrayBuffer</code> object and increase the
              <code><a href="#dom-datachannel-bufferedamount">bufferedAmount</a></code>
              attribute by the length of the <code>ArrayBuffer</code> in
              bytes.</p>
            </li>

            <li>
              <p><code>ArrayBufferView</code> object:</p>

              <p>Let <var>data</var> be the data stored in the section of the
              buffer described by the <code>ArrayBuffer</code> object that the
              <code>ArrayBufferView</code> object references and increase the
              <code><a href="#dom-datachannel-bufferedamount">bufferedAmount</a></code>
              attribute by the length of the <code>ArrayBufferView</code> in
              bytes.</p>
            </li>
          </ul>
        </li>

        <li>
          <p>If <var>channel</var>'s <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data transport</a> is
          not established yet, or if the <code><a href="#data-transport-closing-procedure">closing procedure</a></code> has
          started, then abort these steps.</p>
        </li>

        <li>
          <p>Attempt to send <var>data</var> on <var>channel</var>'s
          <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data transport</a>; if the data cannot be sent, e.g.
          because it would need to be buffered but the buffer is full, the user
          agent <em title="MUST" class="rfc2119">MUST</em> abruptly <a href="#data-transport-closed">close</a>
          <var>channel</var>'s <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data transport</a> <a href="#data-transport-closed-error">with an error</a>.</p>
        </li>
      </ol>

      <pre class="idl"><span class="idlEnum" id="idl-def-RTCDataChannelState">enum <span class="idlEnumID">RTCDataChannelState</span> {
    "<a href="#idl-def-RTCDataChannelState.connecting" class="idlEnumItem">connecting</a>",
    "<a href="#idl-def-RTCDataChannelState.open" class="idlEnumItem">open</a>",
    "<a href="#idl-def-RTCDataChannelState.closing" class="idlEnumItem">closing</a>",
    "<a href="#idl-def-RTCDataChannelState.closed" class="idlEnumItem">closed</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-RTCDataChannelState.connecting">connecting</code></td><td>
          <p>The user agent is attempting to establish the <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data
          transport</a>. This is the initial state of a
          <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object created with <code><a href="#dom-peerconnection-createdatachannel">createDataChannel()</a></code>.</p>
        </td></tr><tr><td><code id="idl-def-RTCDataChannelState.open">open</code></td><td>
          <p>The <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data transport</a> is established and
          communication is possible. This is the initial state of a
          <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object dispatched as a part of a
          <code><a class="idlType" href="#idl-def-RTCDataChannelEvent"><code>RTCDataChannelEvent</code></a></code>.</p>
        </td></tr><tr><td><code id="idl-def-RTCDataChannelState.closing">closing</code></td><td>
          <p>The <code><a href="#data-transport-closing-procedure">procedure</a></code> to close
          down the <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data transport</a> has started.</p>
        </td></tr><tr><td><code id="idl-def-RTCDataChannelState.closed">closed</code></td><td>
          <p>The <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data transport</a> has been <code><a href="#data-transport-closed">closed</a></code> or could not be
          established.</p>
        </td></tr></tbody></table>
    </section>

    <section property="bibo:hasPart" resource="#rtcdatachannelevent" typeof="bibo:Chapter" id="rtcdatachannelevent">
      <h3 resource="#h-rtcdatachannelevent" id="h-rtcdatachannelevent"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.3 </span>RTCDataChannelEvent</span></h3>

      <p>The <code><a href="#event-datachannel">datachannel</a></code> event
      uses the <code><a class="idlType" href="#idl-def-RTCDataChannelEvent"><code>RTCDataChannelEvent</code></a></code> interface.</p>

      <p><dfn id="fire-a-datachannel-event" title="fire a datachannel event">Firing a datachannel event named
      <var>e</var></dfn> with a <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>
      <var>channel</var> means that an event with the name <var>e</var>, which
      does not bubble (except where otherwise stated) and is not cancelable
      (except where otherwise stated), and which uses the
      <code><a class="idlType" href="#idl-def-RTCDataChannelEvent"><code>RTCDataChannelEvent</code></a></code> interface with the <code><a href="#dom-datachannelevent-channel">channel</a></code> attribute set to
      <var>channel</var>, <em title="MUST" class="rfc2119">MUST</em> be created and dispatched at the given
      target.</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-RTCDataChannelEvent"><span class="idlDictionary" id="idl-def-RTCDataChannelEventInit">dictionary <span class="idlDictionaryID">RTCDataChannelEventInit</span> : <span class="idlSuperclass">EventInit</span> {
<span class="idlMember">    <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></span> <span class="idlMemberName"><a href="#widl-RTCDataChannelEventInit-channel">channel</a></span>;</span>
};</span><br><br>[<span class="idlCtor"> <span class="idlCtorKeyword"></span><span class="idlCtorName"><a href="#widl-ctor-RTCDataChannelEvent--DOMString-type-RTCDataChannelEventInit-eventInitDict">Constructor</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">type</span></span>, <span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCDataChannelEventInit"><code>RTCDataChannelEventInit</code></a></span> <span class="idlParamName">eventInitDict</span></span>)</span>]
interface <span class="idlInterfaceID">RTCDataChannelEvent</span> : <span class="idlSuperclass"><a class="internalDFN" href="#dfn-event">Event</a></span> {
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></span> <span class="idlAttrName"><a href="#widl-RTCDataChannelEvent-channel">channel</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#constructors-4" typeof="bibo:Chapter" id="constructors-4"><h4 resource="#h-constructors-4" id="h-constructors-4"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.3.1 </span>Constructors</span></h4><dl class="constructors"><dt id="widl-ctor-RTCDataChannelEvent--DOMString-type-RTCDataChannelEventInit-eventInitDict"><code>RTCDataChannelEvent</code></dt><dd>readonly attribute RTCDataChannel channel<table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">type</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">eventInitDict</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCDataChannelEventInit"><code>RTCDataChannelEventInit</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table></dd></dl></section><section property="bibo:hasPart" resource="#attributes-7" typeof="bibo:Chapter" id="attributes-7"><h4 resource="#h-attributes-7" id="h-attributes-7"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.3.2 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-RTCDataChannelEvent-channel"><code>channel</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></span>, readonly   </dt><dd>
          <p>The <dfn id="dom-datachannelevent-channel"><code>channel</code></dfn> attribute
          represents the <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object associated
          with the event.</p>
        </dd></dl></section>

      <section property="bibo:hasPart" resource="#dictionary-rtcdatachanneleventinit-members" typeof="bibo:Chapter" id="dictionary-rtcdatachanneleventinit-members"><h4 resource="#h-dictionary-rtcdatachanneleventinit-members" id="h-dictionary-rtcdatachanneleventinit-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.3.3 </span>Dictionary <a href="#idl-def-RTCDataChannelEventInit" class="idlType"><code>RTCDataChannelEventInit</code></a> Members</span></h4><dl class="dictionary-members"><dt id="widl-RTCDataChannelEventInit-channel"><code>channel</code> of type <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></span></dt><dd>
          <p>TODO</p>
        </dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#garbage-collection-1" typeof="bibo:Chapter" id="garbage-collection-1">
      <h3 resource="#h-garbage-collection-1" id="h-garbage-collection-1"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.4 </span>Garbage Collection</span></h3>

      <p>A <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object <em title="MUST" class="rfc2119">MUST</em> not be garbage
      collected if its</p>

      <ul>
        <li>
          <p><code><a href="#dom-datachannel-readystate">readyState</a></code>
          is <code>connecting</code> and at least one event listener is
          registered for <code>open</code> events, <code>message</code> events,
          <code>error</code> events, or <code>close</code> events.</p>
        </li>

        <li>
          <p><code><a href="#dom-datachannel-readystate">readyState</a></code>
          is <code>open</code> and at least one event listener is registered
          for <code>message</code> events, <code>error</code> events, or
          <code>close</code> events.</p>
        </li>

        <li>
          <p><code><a href="#dom-datachannel-readystate">readyState</a></code>
          is <code>closing</code> and at least one event listener is registered
          for <code>error</code> events, or <code>close</code> events.</p>
        </li>

        <li>
          <p><a class="internalDFN" href="#dfn-underlying-data-transport">underlying data transport</a> is established and data is queued
          to be transmitted.</p>
        </li>
      </ul>
    </section>
  </section>

  <section property="bibo:hasPart" resource="#peer-to-peer-dtmf" typeof="bibo:Chapter" id="peer-to-peer-dtmf">
    <!--OddPage--><h2 resource="#h-peer-to-peer-dtmf" id="h-peer-to-peer-dtmf"><span property="xhv:role" resource="xhv:heading"><span class="secno">6. </span>Peer-to-peer DTMF</span></h2>

    <p>In order to send DTMF (phone keypad) values across an
    <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>, the user agent needs to know which
    <code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code> on which
    <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> will carry the DTMF. This section
    describes an interface on <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> to
    associate DTMF capability with a <code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code> for
    that <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>. Details of how DTMF is sent to
    the other peer are described in [<cite><a href="#bib-RTCWEB-AUDIO" class="bibref">RTCWEB-AUDIO</a></cite>].</p>

    <section property="bibo:hasPart" resource="#rtcpeerconnection-interface-extensions-1" typeof="bibo:Chapter" id="rtcpeerconnection-interface-extensions-1">
      <h3 resource="#h-rtcpeerconnection-interface-extensions-1" id="h-rtcpeerconnection-interface-extensions-1"><span property="xhv:role" resource="xhv:heading"><span class="secno">6.1 </span>RTCPeerConnection Interface Extensions</span></h3>

      <p>The Peer-to-peer DTMF API extends the
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> interface as described below.</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-RTCPeerConnection-3">partial interface <span class="idlInterfaceID">RTCPeerConnection</span> {
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDTMFSender</code></a></span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-createDTMFSender-RTCDTMFSender-MediaStreamTrack-track">createDTMFSender</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></span> <span class="idlParamName">track</span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#methods-4" typeof="bibo:Chapter" id="methods-4"><h4 resource="#h-methods-4" id="h-methods-4"><span property="xhv:role" resource="xhv:heading"><span class="secno">6.1.1 </span>Methods</span></h4><dl class="methods"><dt id="widl-RTCPeerConnection-createDTMFSender-RTCDTMFSender-MediaStreamTrack-track"><code>createDTMFSender</code></dt><dd>
          <p>The <dfn id="dfn-createdtmfsender">createDTMFSender()</dfn> method creates an RTCDTMFSender
          that references the given MediaStreamTrack. The MediaStreamTrack <em title="MUST" class="rfc2119">MUST</em>
          be an element of a MediaStream that's currently in the
          <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object's <a href="#local-streams-set">local streams set</a>; if not, throw an
          <code>InvalidParameter</code> exception and abort these steps.</p>
        <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">track</td><td class="prmType"><code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDTMFSender</code></a></code></div></dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#rtcdtmfsender" typeof="bibo:Chapter" id="rtcdtmfsender">
      <h3 resource="#h-rtcdtmfsender" id="h-rtcdtmfsender"><span property="xhv:role" resource="xhv:heading"><span class="secno">6.2 </span>RTCDTMFSender</span></h3>

      <p>An <code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDTMFSender</code></a></code> is created by calling the
      <code><a class="internalDFN" href="#dfn-createdtmfsender">createDTMFSender()</a></code> method on an
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>. This constructs an object that
      exposes the functions required to send DTMF on the given
      <code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code>.</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-RTCDTMFSender">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">RTCDTMFSender</span> {
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">boolean</span>          <span class="idlAttrName"><a href="#widl-RTCDTMFSender-canInsertDTMF">canInsertDTMF</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCDTMFSender-insertDTMF-void-DOMString-tones-long-duration-long-interToneGap">insertDTMF</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">tones</span></span>, <span class="idlParam">optional <span class="idlParamType">long</span> <span class="idlParamName">duration</span> = <span class="idlDefaultValue">100</span></span>, <span class="idlParam">optional <span class="idlParamType">long</span> <span class="idlParamName">interToneGap</span> = <span class="idlDefaultValue">70</span></span>);</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></span> <span class="idlAttrName"><a href="#widl-RTCDTMFSender-track">track</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>     <span class="idlAttrName"><a href="#widl-RTCDTMFSender-ontonechange">ontonechange</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">DOMString</span>        <span class="idlAttrName"><a href="#widl-RTCDTMFSender-toneBuffer">toneBuffer</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">long</span>             <span class="idlAttrName"><a href="#widl-RTCDTMFSender-duration">duration</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">long</span>             <span class="idlAttrName"><a href="#widl-RTCDTMFSender-interToneGap">interToneGap</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-8" typeof="bibo:Chapter" id="attributes-8"><h4 resource="#h-attributes-8" id="h-attributes-8"><span property="xhv:role" resource="xhv:heading"><span class="secno">6.2.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-RTCDTMFSender-canInsertDTMF"><code>canInsertDTMF</code> of type <span class="idlAttrType">boolean</span>, readonly   </dt><dd>
          <p>The <dfn id="dom-RTCDTMFSender-caninsertdtmf"><code>canInsertDTMF</code></dfn>
          attribute <em title="MUST" class="rfc2119">MUST</em> indicate if the <code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDTMFSender</code></a></code> is
          capable of sending DTMF.</p>
        </dd><dt id="widl-RTCDTMFSender-duration"><code>duration</code> of type <span class="idlAttrType">long</span>, readonly   </dt><dd>
          <p>The <dfn id="dom-RTCDTMFSender-duration"><code>duration</code></dfn> attribute
          <em title="MUST" class="rfc2119">MUST</em> return the current tone duration value. This value will be the
          value last set via the <code><a class="internalDFN" href="#dom-RTCDTMFSender-insertDTMF">insertDTMF()</a></code> method, or
          the default value of 100 ms if <code><a class="internalDFN" href="#dom-RTCDTMFSender-insertDTMF">insertDTMF()</a></code> was
          called without specifying the duration.</p>
        </dd><dt id="widl-RTCDTMFSender-interToneGap"><code>interToneGap</code> of type <span class="idlAttrType">long</span>, readonly   </dt><dd>
          <p>The <dfn id="dom-RTCDTMFSender-intertonegap"><code>interToneGap</code></dfn>
          attribute <em title="MUST" class="rfc2119">MUST</em> return the current value of the between-tone gap. This
          value will be the value last set via the
          <code><a class="internalDFN" href="#dom-RTCDTMFSender-insertDTMF">insertDTMF()</a></code> method, or the default value of 70
          ms if <code><a class="internalDFN" href="#dom-RTCDTMFSender-insertDTMF">insertDTMF()</a></code> was called without specifying
          the interToneGap.</p>
        </dd><dt id="widl-RTCDTMFSender-ontonechange"><code>ontonechange</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>
          <p>This event handler uses the
          <code><a class="idlType" href="#idl-def-RTCDTMFToneChangeEvent"><code>RTCDTMFToneChangeEvent</code></a></code> interface to return the
          character for each tone as it is played out. See
          <code><a class="idlType" href="#idl-def-RTCDTMFToneChangeEvent"><code>RTCDTMFToneChangeEvent</code></a></code> for details.</p>
        </dd><dt id="widl-RTCDTMFSender-toneBuffer"><code>toneBuffer</code> of type <span class="idlAttrType">DOMString</span>, readonly   </dt><dd>
          <p>The <dfn id="dom-RTCDTMFSender-tonebuffer"><code>toneBuffer</code></dfn>
          attribute <em title="MUST" class="rfc2119">MUST</em> return a list of the tones remaining to be played out.
          For the syntax, content, and interpretation of this list, see
          <code>insertDTMF</code>.</p>
        </dd><dt id="widl-RTCDTMFSender-track"><code>track</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></span>, readonly   </dt><dd>
          <p>The <code>track</code> attribute <em title="MUST" class="rfc2119">MUST</em> return the
          <code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code> given as argument to the
          <code><a class="internalDFN" href="#dfn-createdtmfsender">createDTMFSender()</a></code> method.</p>
        </dd></dl></section><section property="bibo:hasPart" resource="#methods-5" typeof="bibo:Chapter" id="methods-5"><h4 resource="#h-methods-5" id="h-methods-5"><span property="xhv:role" resource="xhv:heading"><span class="secno">6.2.2 </span>Methods</span></h4><dl class="methods"><dt id="widl-RTCDTMFSender-insertDTMF-void-DOMString-tones-long-duration-long-interToneGap"><code>insertDTMF</code></dt><dd>
          <p>An <code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDTMFSender</code></a></code> object's <dfn id="dom-RTCDTMFSender-insertDTMF"><code>insertDTMF()</code></dfn> method
          is used to send DTMF tones.</p>

          <p>The tones parameter is treated as a series of characters. The
          characters 0 through 9, A through D, #, and * generate the associated
          DTMF tones. The characters a to d are equivalent to A to D. The
          character ',' indicates a delay of 2 seconds before processing the
          next character in the tones parameter. All other characters <em title="MUST" class="rfc2119">MUST</em> be
          considered <dfn id="dtmf-unrecognized">unrecognized</dfn>.</p>

          <p>The duration parameter indicates the duration in ms to use for
          each character passed in the tones parameters. The duration cannot be
          more than 6000 ms or less than 40 ms. The default duration is 100 ms
          for each tone.</p>

          <p>The interToneGap parameter indicates the gap between tones. It
          <em title="MUST" class="rfc2119">MUST</em> be at least 30 ms. The default value is 70 ms.</p>

          <p>The browser <em title="MAY" class="rfc2119">MAY</em> increase the duration and interToneGap times to
          cause the times that DTMF start and stop to align with the boundaries
          of RTP packets but it <em title="MUST" class="rfc2119">MUST</em> not increase either of them by more than
          the duration of a single RTP audio packet.</p>

          <div class="issue"><div id="h-issue2" role="heading" aria-level="5" class="issue-title"><span>Issue 2</span></div><p class="">ISSUE: How are invalid values handled?</p></div>

          <p>When the <code><a class="internalDFN" href="#dom-RTCDTMFSender-insertDTMF">insertDTMF()</a></code> method is invoked, the
          user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

          <ol>
            <li>If the associated <code>MediaStreamTrack</code> is not
            connected to the associated <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>,
            return.</li>

            <li>If the <code><a href="#dom-RTCDTMFSender-caninsertdtmf">canInsertDTMF</a></code>
            attribute is false, return.</li>

            <li>Set the object's <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> attribute to
            the value of the first argument, the <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> attribute to the
            value of the second argument, and the <code><a href="#dom-RTCDTMFSender-intertonegap">interToneGap</a></code> attribute
            to the value of the third argument.</li>

            <li>If <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> contains any
            <a href="#dtmf-unrecognized">unrecognized</a> characters, throw an
            <code>InvalidCharacterError</code> exception and abort these steps.
            </li>

            <li>If <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> is an empty
            string, return.</li>

            <li>If the value of the <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> attribute is less
            than 40, set it to 40. If, on the other hand, the value is greater
            than 6000, set it to 6000.</li>

            <li>If the value of the <code><a href="#dom-RTCDTMFSender-intertonegap">interToneGap</a></code> attribute
            is less than 30, set it to 30.</li>

            <li>If a <em>Playout task</em> is scheduled to be run; abort these
            steps; otherwise queue a task that runs the following steps
            (<em>Playout task</em>):

              <ol>
                <li>If <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> is an
                empty string, fire an event named <code><a href="#event-RTCDTMFSender-tonechange">tonechange</a></code> with an
                empty string at the <code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDTMFSender</code></a></code> object
                and abort these steps.</li>

                <li>Remove the first character from <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> and let
                that character be <var>tone</var>.</li>

                <li>Start playout of <var>tone</var> for <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> ms on the
                associated RTP media stream, using the appropriate codec.</li>

                <li>Queue a task to be executed in <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> +
                <code><a href="#dom-RTCDTMFSender-intertonegap">interToneGap</a></code> ms
                from now that runs the steps labelled <em>Playout
                task</em>.</li>

                <li>Fire an event named <code><a href="#event-RTCDTMFSender-tonechange">tonechange</a></code> with a
                string consisting of <var>tone</var> at the
                <code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDTMFSender</code></a></code> object.</li>
              </ol>
            </li>
          </ol>

          <p>Calling <code><a href="#dom-RTCDTMFSender-insertDTMF">insertDTMF()</a></code> with an empty
          tones parameter can be used to cancel all tones queued to play after
          the currently playing tone.</p>
        <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">tones</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">duration</td><td class="prmType"><code>long = 100</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">interToneGap</td><td class="prmType"><code>long = 70</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#rtcdtmftonechangeevent" typeof="bibo:Chapter" id="rtcdtmftonechangeevent">
      <h3 resource="#h-rtcdtmftonechangeevent" id="h-rtcdtmftonechangeevent"><span property="xhv:role" resource="xhv:heading"><span class="secno">6.3 </span>RTCDTMFToneChangeEvent</span></h3>

      <p>The <code><a href="#event-RTCDTMFSender-tonechange">tonechange</a></code> event uses the
      <code><a class="idlType" href="#idl-def-RTCDTMFToneChangeEvent"><code>RTCDTMFToneChangeEvent</code></a></code> interface.</p>

      <p><dfn id="fire-a-tonechange-event" title="fire a tonechange event">Firing a tonechange event named
      <var>e</var></dfn> with a <code>DOMString</code> <var>tone</var> means
      that an event with the name <var>e</var>, which does not bubble (except
      where otherwise stated) and is not cancelable (except where otherwise
      stated), and which uses the <code><a class="idlType" href="#idl-def-RTCDTMFToneChangeEvent"><code>RTCDTMFToneChangeEvent</code></a></code>
      interface with the <code><a href="#dom-tonechangeevent-tone">tone</a></code> attribute set to
      <var>tone</var>, <em title="MUST" class="rfc2119">MUST</em> be created and dispatched at the given target.</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-RTCDTMFToneChangeEvent"><span class="idlDictionary" id="idl-def-RTCDTMFToneChangeEventInit">dictionary <span class="idlDictionaryID">RTCDTMFToneChangeEventInit</span> : <span class="idlSuperclass">EventInit</span> {
<span class="idlMember">    <span class="idlMemberType">DOMString</span> <span class="idlMemberName"><a href="#widl-RTCDTMFToneChangeEventInit-tone">tone</a></span>;</span>
};</span><br><br>[<span class="idlCtor"> <span class="idlCtorKeyword"></span><span class="idlCtorName"><a href="#widl-ctor-RTCDTMFToneChangeEvent--DOMString-type-RTCDTMFToneChangeEventInit-eventInitDict">Constructor</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">type</span></span>, <span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCDTMFToneChangeEventInit"><code>RTCDTMFToneChangeEventInit</code></a></span> <span class="idlParamName">eventInitDict</span></span>)</span>]
interface <span class="idlInterfaceID">RTCDTMFToneChangeEvent</span> : <span class="idlSuperclass"><a class="internalDFN" href="#dfn-event">Event</a></span> {
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">DOMString</span> <span class="idlAttrName"><a href="#widl-RTCDTMFToneChangeEvent-tone">tone</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#constructors-5" typeof="bibo:Chapter" id="constructors-5"><h4 resource="#h-constructors-5" id="h-constructors-5"><span property="xhv:role" resource="xhv:heading"><span class="secno">6.3.1 </span>Constructors</span></h4><dl class="constructors"><dt id="widl-ctor-RTCDTMFToneChangeEvent--DOMString-type-RTCDTMFToneChangeEventInit-eventInitDict"><code>RTCDTMFToneChangeEvent</code></dt><dd>readonly attribute DOMString tone<table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">type</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">eventInitDict</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCDTMFToneChangeEventInit"><code>RTCDTMFToneChangeEventInit</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table></dd></dl></section><section property="bibo:hasPart" resource="#attributes-9" typeof="bibo:Chapter" id="attributes-9"><h4 resource="#h-attributes-9" id="h-attributes-9"><span property="xhv:role" resource="xhv:heading"><span class="secno">6.3.2 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-RTCDTMFToneChangeEvent-tone"><code>tone</code> of type <span class="idlAttrType">DOMString</span>, readonly   </dt><dd>
          <p>The <dfn id="dom-tonechangeevent-tone"><code>tone</code></dfn>
          attribute contains the character for the tone that has just begun
          playout (see <code><a class="internalDFN" href="#dom-RTCDTMFSender-insertDTMF">insertDTMF()</a></code> ). If the value is the
          empty string, it indicates that the previous tone has completed
          playback.</p>
        </dd></dl></section>

      <section property="bibo:hasPart" resource="#dictionary-rtcdtmftonechangeeventinit-members" typeof="bibo:Chapter" id="dictionary-rtcdtmftonechangeeventinit-members"><h4 resource="#h-dictionary-rtcdtmftonechangeeventinit-members" id="h-dictionary-rtcdtmftonechangeeventinit-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">6.3.3 </span>Dictionary <a href="#idl-def-RTCDTMFToneChangeEventInit" class="idlType"><code>RTCDTMFToneChangeEventInit</code></a> Members</span></h4><dl class="dictionary-members"><dt id="widl-RTCDTMFToneChangeEventInit-tone"><code>tone</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
          <p>TODO</p>
        </dd></dl></section>
    </section>
  </section>

  <section property="bibo:hasPart" resource="#statistics-model" typeof="bibo:Chapter" id="statistics-model">
    <!--OddPage--><h2 resource="#sec.stats-model" id="sec.stats-model"><span property="xhv:role" resource="xhv:heading"><span class="secno">7. </span>Statistics Model</span></h2>

    <section property="bibo:hasPart" resource="#introduction-1" typeof="bibo:Chapter" id="introduction-1">
      <h3 resource="#h-introduction-1" id="h-introduction-1"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.1 </span>Introduction</span></h3>

      <p>The basic statistics model is that the browser maintains a set of
      statistics referenced by a <dfn id="stats-selector">selector</dfn>. The
      selector may, for example, be a <code>MediaStreamTrack</code>. For a
      track to be a valid selector, it must be a member of a
      <code>MediaStream</code> that is sent or received by the
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object on which the stats request
      was issued. The calling Web application provides the selector to the
      <code><a href="#dom-peerconnection-getstats">getStats()</a></code> method
      and the browser emits (in the JavaScript) a set of statistics that it
      believes is relevant to the selector.</p>

      <div class="note"><div id="h-note10" role="heading" aria-level="4" class="note-title"><span>Note</span></div><div class="">
        Evaluate the need for other selectors than MediaStreamTrack.
      </div></div>

      <p>The statistics returned are designed in such a way that repeated
      queries can be linked by the <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code> <a href="#dom-rtcstats-id">id</a> dictionary member. Thus, a Web application can
      make measurements over a given time period by requesting measurements at
      the beginning and end of that period.</p>
    </section>

    <section property="bibo:hasPart" resource="#rtcpeerconnection-interface-extensions-2" typeof="bibo:Chapter" id="rtcpeerconnection-interface-extensions-2">
      <h3 resource="#h-rtcpeerconnection-interface-extensions-2" id="h-rtcpeerconnection-interface-extensions-2"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.2 </span>RTCPeerConnection Interface Extensions</span></h3>

      <p>The Statistics API extends the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>
      interface as described below.</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-RTCPeerConnection-4">partial interface <span class="idlInterfaceID">RTCPeerConnection</span> {
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-getStats-void-MediaStreamTrack-selector-RTCStatsCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback">getStats</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a>?</span> <span class="idlParamName">selector</span></span>, <span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCStatsCallback"><code>RTCStatsCallback</code></a></span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></span> <span class="idlParamName">failureCallback</span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#methods-6" typeof="bibo:Chapter" id="methods-6"><h4 resource="#h-methods-6" id="h-methods-6"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.2.1 </span>Methods</span></h4><dl class="methods"><dt id="widl-RTCPeerConnection-getStats-void-MediaStreamTrack-selector-RTCStatsCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback"><code>getStats</code></dt><dd>
          <p>Gathers stats for the given <a href="#stats-selector">selector</a>
          and reports the result asynchronously.</p>

          <p>When the <dfn id="dom-peerconnection-getstats"><code>getStats()</code></dfn> method is
          invoked, the user agent <em title="MUST" class="rfc2119">MUST</em> queue a task to run the following
          steps:</p>

          <ol>
            <li>
              <p>If the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object's <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
              signalingState</a> is <code>closed</code>, throw an
              <code>InvalidStateError</code> exception.</p>
            </li>

            <li>
              <p>Return, but continue the following steps in the
              background.</p>
            </li>

            <li>
              <p>Let <var>selectorArg</var> be the methods first argument.</p>
            </li>

            <li>
              <p>If <var>selectorArg</var> is an invalid <a href="#stats-selector">selector</a>, the user agent <em title="MUST" class="rfc2119">MUST</em> queue a task
              to invoke the failure callback (the method's third argument).</p>
            </li>

            <li>
              <p>Start gathering the stats indicated by <var>selectorArg</var>.
              In case <var>selectorArg</var> is null, stats <em title="MUST" class="rfc2119">MUST</em> be gathered
              for the whole <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>
            </li>

            <li>
              <p>When the relevant stats have been gathered, queue a task to
              invoke the success callback (the method's second argument) with a
              new <code><a class="idlType" href="#idl-def-RTCStatsReport"><code>RTCStatsReport</code></a></code> object, representing the
              gathered stats, as its argument.</p>
            </li>
          </ol>
        <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">selector</td><td class="prmType"><code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code></td><td class="prmNullTrue"><span role="img" aria-label="True">✔</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCStatsCallback"><code>RTCStatsCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">failureCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#rtcstatscallback" typeof="bibo:Chapter" id="rtcstatscallback">
      <h3 resource="#h-rtcstatscallback" id="h-rtcstatscallback"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.3 </span>RTCStatsCallback</span></h3>

      <pre class="idl"><span class="idlCallback" id="idl-def-RTCStatsCallback">callback <span class="idlCallbackID">RTCStatsCallback</span> = <span class="idlCallbackType">void</span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-RTCStatsReport"><code>RTCStatsReport</code></a></span> <span class="idlParamName">report</span></span>);</span></pre><section property="bibo:hasPart" resource="#callback-rtcstatscallback-parameters" typeof="bibo:Chapter" id="callback-rtcstatscallback-parameters"><h4 resource="#h-callback-rtcstatscallback-parameters" id="h-callback-rtcstatscallback-parameters"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.3.1 </span>Callback <a href="#idl-def-RTCStatsCallback" class="idlType"><code>RTCStatsCallback</code></a> Parameters</span></h4><dl class="callback-members"><dt id="widl-RTCStatsCallback-report"><code>report</code> of type <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCStatsReport"><code>RTCStatsReport</code></a></span></dt><dd>
          <p>A <code><a class="idlType" href="#idl-def-RTCStatsReport"><code>RTCStatsReport</code></a></code> representing the gathered
          stats.</p>
        </dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#rtcstatsreport-object" typeof="bibo:Chapter" id="rtcstatsreport-object">
      <h3 resource="#h-rtcstatsreport-object" id="h-rtcstatsreport-object"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.4 </span>RTCStatsReport Object</span></h3>

      <p>The <code><a href="#dom-peerconnection-getstats">getStats()</a></code>
      method delivers a successful result in the form of a
      <code><a class="idlType" href="#idl-def-RTCStatsReport"><code>RTCStatsReport</code></a></code> object. A
      <code><a class="idlType" href="#idl-def-RTCStatsReport"><code>RTCStatsReport</code></a></code> object represents a map between
      strings, identifying the inspected objects (<a href="#dom-rtcstats-id">RTCStats.id</a>), and their corresponding
      <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code> objects.</p>

      <p>An <code><a class="idlType" href="#idl-def-RTCStatsReport"><code>RTCStatsReport</code></a></code> may be composed of several
      <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code> objects, each reporting stats for one
      underlying object that the implementation thinks is relevant for the
      <a href="#stats-selector">selector</a>. One achieves the total for the
      <a href="#stats-selector">selector</a> by summing over all the stats of a
      certain type; for instance, if a <code>MediaStreamTrack</code> is carried
      by multiple SSRCs over the network, the
      <code><a class="idlType" href="#idl-def-RTCStatsReport"><code>RTCStatsReport</code></a></code> may contain one <code>RTCStats</code>
      object per SSRC (which can be distinguished by the value of the "ssrc"
      stats attribute).</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-RTCStatsReport">interface <span class="idlInterfaceID">RTCStatsReport</span> {
<span class="idlMethod">    <span class="idlMethType">getter</span> <span class="idlMethName"><a href="#widl-RTCStatsReport-RTCStats-getter-DOMString-id">RTCStats</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">id</span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#methods-7" typeof="bibo:Chapter" id="methods-7"><h4 resource="#h-methods-7" id="h-methods-7"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.4.1 </span>Methods</span></h4><dl class="methods"><dt id="widl-RTCStatsReport-RTCStats-getter-DOMString-id"><code>RTCStats</code></dt><dd>
          <p>Getter to retrieve the <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code> objects that
          this stats report is composed of.</p>

          <p>The set of supported property names [<cite><a href="#bib-WEBIDL" class="bibref">WEBIDL</a></cite>] is defined as the
          ids of all the <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code> objects that has been
          generated for this stats report. The order of the property names is
          left to the user agent.</p>
        <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">id</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>getter</code></div></dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#rtcstats-dictionary" typeof="bibo:Chapter" id="rtcstats-dictionary">
      <h3 resource="#h-rtcstats-dictionary" id="h-rtcstats-dictionary"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.5 </span>RTCStats Dictionary</span></h3>

      <p>An <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code> dictionary represents the stats
      gathered by inspecting a specific object relevant to a <a href="#stats-selector">selector</a>. The <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code>
      dictionary is a base type that specifies as set of default attributes,
      such as <a href="#dom-rtcstats-timestamp">timestamp</a> and <a href="#dom-rtcstats-type">type</a>. Specific stats are added by extending the
      <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code> dictionary.</p>

      <p>Note that while stats names are standardized, any given implementation
      may be using experimental values or values not yet known to the Web
      application. Thus, applications <em title="MUST" class="rfc2119">MUST</em> be prepared to deal with unknown
      stats.</p>

      <div class="note"><div id="h-note11" role="heading" aria-level="4" class="note-title"><span>Note</span></div><div class="">
        OPEN ISSUE: Need to define an IANA registry for this and populate with
        pointers to existing things such as the RTCP statistics.
      </div></div>

      <p>Statistics need to be synchronized with each other in order to yield
      reasonable values in computation; for instance, if "bytesSent" and
      "packetsSent" are both reported, they both need to be reported over the
      same interval, so that "average packet size" can be computed as "bytes /
      packets" - if the intervals are different, this will yield errors. Thus
      implementations <em title="MUST" class="rfc2119">MUST</em> return synchronized values for all stats in a
      <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code> object.</p>

      <pre class="idl"><span class="idlDictionary" id="idl-def-RTCStats">dictionary <span class="idlDictionaryID">RTCStats</span> {
<span class="idlMember">    <span class="idlMemberType">DOMHiResTimeStamp</span> <span class="idlMemberName"><a href="#widl-RTCStats-timestamp">timestamp</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCStatsType"><code>RTCStatsType</code></a></span>      <span class="idlMemberName"><a href="#widl-RTCStats-type">type</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span>         <span class="idlMemberName"><a href="#widl-RTCStats-id">id</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#dictionary-rtcstats-members" typeof="bibo:Chapter" id="dictionary-rtcstats-members"><h4 resource="#h-dictionary-rtcstats-members" id="h-dictionary-rtcstats-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.5.1 </span>Dictionary <a href="#idl-def-RTCStats" class="idlType"><code>RTCStats</code></a> Members</span></h4><dl class="dictionary-members"><dt id="widl-RTCStats-id"><code>id</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
          <p>A unique <dfn id="dom-rtcstats-id"><code>id</code></dfn> that is
          associated with the object that was inspected to produce this
          <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code> object. Two <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code>
          objects, extracted from two different
          <code><a class="idlType" href="#idl-def-RTCStatsReport"><code>RTCStatsReport</code></a></code> objects, <em title="MUST" class="rfc2119">MUST</em> have the same id if
          they were produced by inspecting the same underlying object. User
          agents are free to pick any format for the id as long as it meets the
          requirements above.</p>

          <div class="note"><div id="h-note12" role="heading" aria-level="5" class="note-title"><span>Note</span></div><div class="">
            Consider naming id something that indicates that the id refers to
            the underlying object that was inspected to produce the stats,
            instead of being an id for the JavaScript object. Suggestions:
            statsObjectId, reporterId, srcId.
          </div></div>
        </dd><dt id="widl-RTCStats-timestamp"><code>timestamp</code> of type <span class="idlMemberType">DOMHiResTimeStamp</span></dt><dd>
          <p>The <dfn id="dom-rtcstats-timestamp"><code>timestamp</code></dfn>,
          of type <code>DOMHiResTimeStamp</code> [<cite><a href="#bib-HIGHRES-TIME" class="bibref">HIGHRES-TIME</a></cite>],
          associated with this object. The time is relative to the UNIX epoch
          (Jan 1, 1970, UTC).</p>
        </dd><dt id="widl-RTCStats-type"><code>type</code> of type <span class="idlMemberType"><a class="idlType" href="#idl-def-RTCStatsType"><code>RTCStatsType</code></a></span></dt><dd>
          <p>The type of this object.</p>

          <p>The <dfn id="dom-rtcstats-type"><code>type</code></dfn> attribute
          <em title="MUST" class="rfc2119">MUST</em> be initialized to the name of the most specific type this
          <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code> dictionary represents.</p>
        </dd></dl></section>

      <pre class="idl"><span class="idlEnum" id="idl-def-RTCStatsType">enum <span class="idlEnumID">RTCStatsType</span> {
    "<a href="#idl-def-RTCStatsType.inbound-rtp" class="idlEnumItem">inbound-rtp</a>",
    "<a href="#idl-def-RTCStatsType.outbound-rtp" class="idlEnumItem">outbound-rtp</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-RTCStatsType.inbound-rtp">inbound-rtp</code></td><td>Inbound RTP.</td></tr><tr><td><code id="idl-def-RTCStatsType.outbound-rtp">outbound-rtp</code></td><td>Outbund RTP.</td></tr></tbody></table>
    </section>

    <section property="bibo:hasPart" resource="#derived-stats-dictionaries" typeof="bibo:Chapter" id="derived-stats-dictionaries">
      <h3 resource="#h-derived-stats-dictionaries" id="h-derived-stats-dictionaries"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.6 </span>Derived Stats Dictionaries</span></h3>

      <pre class="idl"><span class="idlDictionary" id="idl-def-RTCRTPStreamStats">dictionary <span class="idlDictionaryID">RTCRTPStreamStats</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></span> {
<span class="idlMember">    <span class="idlMemberType">DOMString</span> <span class="idlMemberName"><a href="#widl-RTCRTPStreamStats-ssrc">ssrc</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span> <span class="idlMemberName"><a href="#widl-RTCRTPStreamStats-remoteId">remoteId</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#dictionary-rtcrtpstreamstats-members" typeof="bibo:Chapter" id="dictionary-rtcrtpstreamstats-members"><h4 resource="#h-dictionary-rtcrtpstreamstats-members" id="h-dictionary-rtcrtpstreamstats-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.6.1 </span>Dictionary <a href="#idl-def-RTCRTPStreamStats" class="idlType"><code>RTCRTPStreamStats</code></a> Members</span></h4><dl class="dictionary-members"><dt id="widl-RTCRTPStreamStats-remoteId"><code>remoteId</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
          <p>The <code>remoteId</code> can be used to look up the corresponding
          <code><a class="idlType" href="#idl-def-RTCStats"><code>RTCStats</code></a></code> object that represents stats reported by
          the other peer.</p>
        </dd><dt id="widl-RTCRTPStreamStats-ssrc"><code>ssrc</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
          <p>...</p>
        </dd></dl></section>

      <pre class="idl"><span class="idlDictionary" id="idl-def-RTCInboundRTPStreamStats">dictionary <span class="idlDictionaryID">RTCInboundRTPStreamStats</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-RTCRTPStreamStats"><code>RTCRTPStreamStats</code></a></span> {
<span class="idlMember">    <span class="idlMemberType">unsigned long</span> <span class="idlMemberName"><a href="#widl-RTCInboundRTPStreamStats-packetsReceived">packetsReceived</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned long</span> <span class="idlMemberName"><a href="#widl-RTCInboundRTPStreamStats-bytesReceived">bytesReceived</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#dictionary-rtcinboundrtpstreamstats-members" typeof="bibo:Chapter" id="dictionary-rtcinboundrtpstreamstats-members"><h4 resource="#h-dictionary-rtcinboundrtpstreamstats-members" id="h-dictionary-rtcinboundrtpstreamstats-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.6.2 </span>Dictionary <a href="#idl-def-RTCInboundRTPStreamStats" class="idlType"><code>RTCInboundRTPStreamStats</code></a> Members</span></h4><dl class="dictionary-members"><dt id="widl-RTCInboundRTPStreamStats-bytesReceived"><code>bytesReceived</code> of type <span class="idlMemberType">unsigned long</span></dt><dd>
          <p>...</p>
        </dd><dt id="widl-RTCInboundRTPStreamStats-packetsReceived"><code>packetsReceived</code> of type <span class="idlMemberType">unsigned long</span></dt><dd>
          <p>...</p>
        </dd></dl></section>

      <pre class="idl"><span class="idlDictionary" id="idl-def-RTCOutboundRTPStreamStats">dictionary <span class="idlDictionaryID">RTCOutboundRTPStreamStats</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-RTCRTPStreamStats"><code>RTCRTPStreamStats</code></a></span> {
<span class="idlMember">    <span class="idlMemberType">unsigned long</span> <span class="idlMemberName"><a href="#widl-RTCOutboundRTPStreamStats-packetsSent">packetsSent</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned long</span> <span class="idlMemberName"><a href="#widl-RTCOutboundRTPStreamStats-bytesSent">bytesSent</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#dictionary-rtcoutboundrtpstreamstats-members" typeof="bibo:Chapter" id="dictionary-rtcoutboundrtpstreamstats-members"><h4 resource="#h-dictionary-rtcoutboundrtpstreamstats-members" id="h-dictionary-rtcoutboundrtpstreamstats-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.6.3 </span>Dictionary <a href="#idl-def-RTCOutboundRTPStreamStats" class="idlType"><code>RTCOutboundRTPStreamStats</code></a> Members</span></h4><dl class="dictionary-members"><dt id="widl-RTCOutboundRTPStreamStats-bytesSent"><code>bytesSent</code> of type <span class="idlMemberType">unsigned long</span></dt><dd>
          <p>...</p>
        </dd><dt id="widl-RTCOutboundRTPStreamStats-packetsSent"><code>packetsSent</code> of type <span class="idlMemberType">unsigned long</span></dt><dd>
          <p>...</p>
        </dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#example" typeof="bibo:Chapter" id="example">
      <h3 resource="#h-example" id="h-example"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.7 </span>Example</span></h3>

      <p>Consider the case where the user is experiencing bad sound and the
      application wants to determine if the cause of it is packet loss. The
      following example code might be used:</p>
      <div class="example"><div class="example-title"><span>Example 1</span></div><pre style="" class="example highlight prettyprint prettyprinted" xml:space="preserve"><span class="kwd">var</span><span class="pln"> baselineReport</span><span class="pun">,</span><span class="pln"> currentReport</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> selector </span><span class="pun">=</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">getRemoteStreams</span><span class="pun">()[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">getAudioTracks</span><span class="pun">()[</span><span class="lit">0</span><span class="pun">];</span><span class="pln">

pc</span><span class="pun">.</span><span class="pln">getStats</span><span class="pun">(</span><span class="pln">selector</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">report</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    baselineReport </span><span class="pun">=</span><span class="pln"> report</span><span class="pun">;</span><span class="pln">
</span><span class="pun">},</span><span class="pln"> logError</span><span class="pun">);</span><span class="pln">

</span><span class="com">// ... wait a bit</span><span class="pln">
setTimeout</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">getStats</span><span class="pun">(</span><span class="pln">selector</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">report</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        currentReport </span><span class="pun">=</span><span class="pln"> report</span><span class="pun">;</span><span class="pln">
        processStats</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">},</span><span class="pln"> logError</span><span class="pun">);</span><span class="pln">
</span><span class="pun">},</span><span class="pln"> aBit</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> processStats</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// compare the elements from the current report with the baseline</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="kwd">in</span><span class="pln"> currentReport</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">var</span><span class="pln"> now </span><span class="pun">=</span><span class="pln"> currentReport</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">now</span><span class="pun">.</span><span class="pln">type </span><span class="pun">!=</span><span class="pln"> </span><span class="str">"outbund-rtp"</span><span class="pun">)</span><span class="pln">
            </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">

        </span><span class="com">// get the corresponding stats from the baseline report</span><span class="pln">
        </span><span class="kwd">base</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> baselineReport</span><span class="pun">[</span><span class="pln">now</span><span class="pun">.</span><span class="pln">id</span><span class="pun">];</span><span class="pln">

        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">base</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            remoteNow </span><span class="pun">=</span><span class="pln"> currentReport</span><span class="pun">[</span><span class="pln">now</span><span class="pun">.</span><span class="pln">remoteId</span><span class="pun">];</span><span class="pln">
            remoteBase </span><span class="pun">=</span><span class="pln"> baselineReport</span><span class="pun">[</span><span class="kwd">base</span><span class="pun">.</span><span class="pln">remoteId</span><span class="pun">];</span><span class="pln">

            </span><span class="kwd">var</span><span class="pln"> packetsSent </span><span class="pun">=</span><span class="pln"> now</span><span class="pun">.</span><span class="pln">packetsSent </span><span class="pun">-</span><span class="pln"> </span><span class="kwd">base</span><span class="pun">.</span><span class="pln">packetsSent</span><span class="pun">;</span><span class="pln">
            </span><span class="kwd">var</span><span class="pln"> packetsReceived </span><span class="pun">=</span><span class="pln"> remoteNow</span><span class="pun">.</span><span class="pln">packetsReceived </span><span class="pun">-</span><span class="pln"> remoteBase</span><span class="pun">.</span><span class="pln">packetsReceived</span><span class="pun">;</span><span class="pln">

            </span><span class="com">// if fractionLost is &gt; 0.3, we have probably found the culprit</span><span class="pln">
            </span><span class="kwd">var</span><span class="pln"> fractionLost </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">packetsSent </span><span class="pun">-</span><span class="pln"> packetsReceived</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> packetsSent</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> logError</span><span class="pun">(</span><span class="pln">error</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    log</span><span class="pun">(</span><span class="pln">error</span><span class="pun">.</span><span class="pln">name </span><span class="pun">+</span><span class="pln"> </span><span class="str">": "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> error</span><span class="pun">.</span><span class="pln">message</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></pre></div>
    </section>
  </section>

  <section property="bibo:hasPart" resource="#identity" typeof="bibo:Chapter" id="identity">
    <!--OddPage--><h2 resource="#sec.identity-proxy" id="sec.identity-proxy"><span property="xhv:role" resource="xhv:heading"><span class="secno">8. </span>Identity</span></h2>

    <section property="bibo:hasPart" resource="#identity-provider-interaction" typeof="bibo:Chapter" id="identity-provider-interaction">
      <h3 resource="#h-identity-provider-interaction" id="h-identity-provider-interaction"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.1 </span>Identity Provider Interaction</span></h3>

      <p>WebRTC offers and answers (and hence the channels established by
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> objects) can be authenticated by
      using a web-based Identity Provider (IdP). The idea is that the entity
      sending the offer/answer acts as the Authenticating Party (AP) and
      obtains an identity assertion from the IdP which it attaches to the
      offer/answer. The consumer of the offer/answer (i.e., the
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> on which
      <code>setRemoteDescription()</code> is called) acts as the Relying Party
      (RP) and verifies the assertion.</p>

      <p>The interaction with the IdP is designed to decouple the browser from
      any particular identity provider; the browser need only know how to load
      the IdP's JavaScript, which is deterministic from the IdP's identity, and
      the generic protocol for requesting and verifying assertions. The IdP
      provides whatever logic is necessary to bridge the generic protocol to
      the IdP's specific requirements. Thus, a single browser can support any
      number of identity protocols, including being forward compatible with
      IdPs which did not exist at the time the browser was written. The generic
      protocol details are described in [<cite><a href="#bib-RTCWEB-SECURITY-ARCH" class="bibref">RTCWEB-SECURITY-ARCH</a></cite>]. This
      document specifies the procedures required to instantiate the IdP proxy,
      request identity assertions, and consume the results.</p>

      <section property="bibo:hasPart" resource="#identity-provider-selection" typeof="bibo:Chapter" id="identity-provider-selection">
        <h4 resource="#sec.identity-proxy-communications" id="sec.identity-proxy-communications"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.1.1 </span>Identity Provider
        Selection</span></h4>

        <p>In order to communicate with the IdP, the browser instantiates an
        isolated interpreted context, effectively an invisible IFRAME. The
        initial contents of the context are loaded from a URI derived from the
        IdP's domain name, as described in [<cite><a href="#bib-RTCWEB-SECURITY-ARCH" class="bibref">RTCWEB-SECURITY-ARCH</a></cite>].</p>

        <p>For purposes of generating assertions, the IdP shall be chosen as
        follows:</p>

        <ol>
          <li>If the <code>setIdentityProvider()</code> method has been called,
          the IdP provided shall be used.</li>

          <li>If the <code>setIdentityProvider()</code> method has not been
          called, then the browser can use an IdP configured into the
          browser.</li>
        </ol>

        <p>In order to verify assertions, the IdP domain name and protocol are
        taken from the <code>domain</code> and <code>protocol</code> fields of
        the identity assertion.</p>
      </section>

      <section property="bibo:hasPart" resource="#instantiating-an-idp-proxy" typeof="bibo:Chapter" id="instantiating-an-idp-proxy">
        <h4 resource="#sec.create-identity-proxy" id="sec.create-identity-proxy"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.1.2 </span>Instantiating an IdP Proxy</span></h4>

        <p>The browser creates an IdP proxy by loading an isolated, invisible
        IFRAME with HTML content from the IdP URI. The URI for the IdP is a
        well-known URI formed from the <q>domain</q> and <q>protocol</q>
        fields, as specified in [<cite><a href="#bib-RTCWEB-SECURITY-ARCH" class="bibref">RTCWEB-SECURITY-ARCH</a></cite>].</p>

        <p>When an IdP proxy is requiured, the browser performs the following
        steps:</p>

        <ol>
          <li>An invisible, sandboxed IFRAME is created within the browser
          context. The IFRAME <code>sandbox</code> attribute is set to
          "allow-forms allow-scripts allow-same-origin" to limit the
          capabilities available to the IdP. The browser <em title="MUST" class="rfc2119">MUST</em> prevent the IdP
          proxy from navigating the browsing context to a different location.
          The browser <em title="MUST" class="rfc2119">MUST</em> prevent the IdP proxy from interacting with the user
          (this includes, in particular, popup windows and user dialogs).</li>

          <li>Once the IdP proxy is created, the browser creates a
          <code>MessageChannel</code> [<cite><a href="#bib-webmessaging" class="bibref">webmessaging</a></cite>] within the context of
          the IdP proxy and assigns one port from the channel to a variable
          named <var>rtcwebIdentityPort</var> on the <var>window</var>. This
          message channel forms the basis of communication between the browser
          and the IdP proxy. Since it is an essential security property of the
          web sandbox that a page is unable to insert objects into content from
          another origin, this ensures that the IdP proxy can trust that
          messages originating from <var>window.rtcwebIdentityPort</var> are
          from <code>RTCPeerConnection</code> and not some other page. This
          protection ensures that pages from other origins are unable to
          instantiate IdP proxies and obtain identity assertions.</li>

          <li>The IdP proxy completes loading and informs the
          <code>RTCPeerConnection</code> that it is ready by sending a "READY"
          message to the message channel port [<cite><a href="#bib-RTCWEB-SECURITY-ARCH" class="bibref">RTCWEB-SECURITY-ARCH</a></cite>]. Once
          this message is received by the <code>RTCPeerConnection</code>, the
          IdP is considered ready to receive requests to generate or verify
          identity assertions.</li>
        </ol>

        <p>[TODO: This is not sufficient unless we expect the IdP to protect
        this information. Otherwise, the a=identity information can be copied
        from a session with "good" properties to any other session with the
        same fingerprint information. Since we want to reuse credentials, that
        would be bad.] The identity mechanism <em title="MUST" class="rfc2119">MUST</em> provide an indication to the
        remote side of whether it requires the stream contents to be protected.
        Implementations <em title="MUST" class="rfc2119">MUST</em> have an user interface that indicates the
        different cases and identity for these.</p>
      </section>
    </section>

    <section property="bibo:hasPart" resource="#requesting-identity-assertions" typeof="bibo:Chapter" id="requesting-identity-assertions">
      <h3 resource="#sec.identity-proxy-assertion-request" id="sec.identity-proxy-assertion-request"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.2 </span>Requesting Identity
      Assertions</span></h3>

      <p>The identity assertion request process involves the following
      steps:</p>

      <ol>
        <li>The <code>RTCPeerConnection</code> instantiates an IdP proxy as
        described in <a href="#sec.identity-proxy-communications">Identity
        Provider Selection section</a> and waits for the IdP to signal that it
        is ready.
        </li>

        <li>The <code>RTCPeerConnection</code> sends a "SIGN" message to the IdP
        proxy. This message includes the material
        the <code>RTCPeerConnection</code> desires to be bound to the user's
        identity.</li>

        <li>If the user has been authenticated by the IdP, and the IdP is
        willing to generate an identity assertion, the IdP generates an
        identity assertion. This step depends entirely on the IdP. The methods
        by which an IdP authenticates users or generates assertions is not
        specified, though this could involve interacting with the IdP server or
        other servers.</li>

        <li>The IdP proxy sends a response containing the identity assertion to
        the <code>RTCPeerConnection</code> over the message channel.</li>

        <li>The <code>RTCPeerConnection</code> <em title="MAY" class="rfc2119">MAY</em> store the identity assertion
        for use with future offers or answers.</li>

        <li>If the identity request was triggered by a
        <code>createOffer()</code> or <code>createAnswer()</code>, then the
        assertion is inserted in the offer/answer SDP.</li>
      </ol>

      <p>The format and contents of the messages that are exchanged are
      described in detail in [<cite><a href="#bib-RTCWEB-SECURITY-ARCH" class="bibref">RTCWEB-SECURITY-ARCH</a></cite>].</p>

      <p>The IdP proxy can return an "ERROR" response. If an error is
      encountered, the browser <em title="MUST" class="rfc2119">MUST</em> generate an <code><a href="#event-idpassertionerror">idpassertionerror</a></code> event. No
      "a=identity" attribute is added to SDP as a result.</p>

      <p>The browser <em title="SHOULD" class="rfc2119">SHOULD</em> limit the time that it will allow for this process.
      This includes both the loading of the <a href="#sec.identity-proxy-communications">IdP proxy</a> and the identity
      assertion generation. Failure to do so potentially causes the
      corresponding operation to take an indefinite amount of time. This timer
      can be cancelled when the IdP produces a response. The timer running to
      completion can be treated as equivalent to an error from the IdP.</p>

      <section property="bibo:hasPart" resource="#user-login-procedure" typeof="bibo:Chapter" id="user-login-procedure">
        <h4 resource="#sec.idp-loginneeded" id="sec.idp-loginneeded"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.2.1 </span>User Login Procedure</span></h4>

        <p>An IdP could respond to a request to generate an identity assertion
        with a "LOGINNEEDED" error. This indicates that the site does not have
        the necessary information available to it (such as cookies) to
        authorize the creation of an identity assertion.</p>

        <p>The "LOGINNEEDED" response includes a URL for a page where the
        authorization process can be completed. This URL is exposed to the
        application through the <code><a class="internalDFN" href="#dfn-loginurl">loginUrl</a></code>
        attribute of the <a href="#event-idpassertionerror">idpassertionerror</a> event. This URL might
        be to a page where a user is able to enter their (IdP) username and
        password, or otherwise provide any information the IdP needs to
        authorize a assertion request.</p>

        <p>An application can load the login URL in an IFRAME or popup; the
        resulting page then provides the user with an opportunity to provide
        information necessary to complete the authorization process.</p>

        <p>Once the authorization process is complete, the page loaded in the
        IFRAME or popup sends a message using <var>postMessage</var>
        [<cite><a href="#bib-webmessaging" class="bibref">webmessaging</a></cite>] to the page that loaded it (through the <var><a href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#dom-opener">
        window.opener</a></var> attribute for popups, or through <var><a href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#dom-parent">
        window.parent</a></var> for pages loaded in an IFRAME). The message
        <em title="MUST" class="rfc2119">MUST</em> be the <var>DOMString</var> "LOGINDONE". This message informs the
        application that another attempt at generating an identity assertion is
        likely to be successful.</p>
      </section>
    </section>

    <section property="bibo:hasPart" resource="#verifying-identity-assertions" typeof="bibo:Chapter" id="verifying-identity-assertions">
      <h3 resource="#sec.identity-verify-assertion" id="sec.identity-verify-assertion"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.3 </span>Verifying Identity Assertions</span></h3>

      <p>Identity assertion validation happens when <code><a href="#dom-peerconnection-setremotedescription">setRemoteDescription</a></code>
      is invoked on <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>. The process runs
      asynchronously, meaning that validation of an identity assertion does not
      block the completion of <code>setRemoteDescription</code>.</p>

      <p>The identity assertion request process involves the following
      steps:</p>

      <ol>
        <li>The <code>RTCPeerConnection</code> instantiates an IdP proxy as
        described in <a href="#sec.identity-proxy-communications">Identity
        Provider Selection section</a> and waits for the IdP to signal that it
        is ready.
        </li>

        <li>The <code>RTCPeerConnection</code> sends a "VERIFY" message to the
        IdP proxy. This message includes the assertion from the offer/answer
        which is to be verified.</li>

        <li>The IdP proxy verifies the identity assertion (depending on the
        authentication protocol this could involve interacting with the IDP
        server).</li>

        <li>Once the assertion is verified, the IdP proxy sends a response
        containing the verified assertion results to the
        <code>RTCPeerConnection</code> over the message channel.</li>

        <li>The <code>RTCPeerConnection</code> validates that the fingerprint
        provided by the IdP in the validation response matches the certificate
        fingerprint that is, or will be, used for communications. This is
        either by:

          <ul>
            <li>Ensuring that there is only a single a=fingerprint value across
            all media sections in the SDP that matches the fingerprint provided
            by the IdP.</li>

            <li>Waiting for all DTLS connections to be establishes and checking
            that the certificate fingerprints on all connections matches the
            one provided by the IdP.</li>
          </ul>
        </li>

        <li>The <code>RTCPeerConnection</code> validates that the domain
        portion of the identity matches the domain of the IdP as described in
        [<cite><a href="#bib-RTCWEB-SECURITY-ARCH" class="bibref">RTCWEB-SECURITY-ARCH</a></cite>].</li>

        <li>The <code>RTCPeerConnection</code> stores the assertion in the
        <code><a href="#widl-RTCPeerConnection-peerIdentity">peerIdentity</a></code>
        attribute and raises a simple event named <a href="#event-peeridentity">peeridentity</a> at itself. The assertion information to be
        displayed <em title="MUST" class="rfc2119">MUST</em> contain the domain name of the IdP as provided in the
        assertion.
        </li>

        <li>The browser <em title="MAY" class="rfc2119">MAY</em> display identity information to a user in browser
        UI. Any user identity information that is displayed in this fashion
        <em title="MUST" class="rfc2119">MUST</em> use a mechanism that cannot be spoofed by content.</li>
      </ol>

      <p>The IdP might fail to validate the identity assertion by providing an
      "ERROR" response to the validation request. Validation can also fail due
      to the additional checks performed by the browser. In both cases, the
      process terminates and no identity information is exposed to the
      application or the user.</p>

      <p>The browser <em title="MUST" class="rfc2119">MUST</em> raise an <code><a href="#event-idpvalidationerror">idpvalidationerror</a></code> event if
      validation of an identity assertion fails for any reason.</p>

      <p>If the "peerIdentity" constraint is applied to the
      <code>RTCPeerConnection</code>, any error <em title="MUST" class="rfc2119">MUST</em> cause <code><a href="#dom-peerconnection-setremotedescription">setRemoteDescription</a></code>
      to fail.</p>

      <p>The browser <em title="SHOULD" class="rfc2119">SHOULD</em> limit the time that it will allow for this process.
      This includes both the loading of the <a href="#sec.identity-proxy-communications">IdP proxy</a> and the identity
      assertion validation. Failure to do so potentially causes the
      corresponding operation to take an indefinite amount of time. This timer
      can be cancelled when the IdP produces a response. The timer running to
      completion can be treated as equivalent to an error from the IdP.</p>

      <p>The format and contents of the messages that are exchanged are
      described in detail in [<cite><a href="#bib-RTCWEB-SECURITY-ARCH" class="bibref">RTCWEB-SECURITY-ARCH</a></cite>].</p>
    </section>

    <section property="bibo:hasPart" resource="#rtcpeerconnection-interface-extensions-3" typeof="bibo:Chapter" id="rtcpeerconnection-interface-extensions-3">
      <h3 resource="#h-rtcpeerconnection-interface-extensions-3" id="h-rtcpeerconnection-interface-extensions-3"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.4 </span>RTCPeerConnection Interface Extensions</span></h3>

      <p>The Identity API extends the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>
      interface as described below.</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-RTCPeerConnection-5">partial interface <span class="idlInterfaceID">RTCPeerConnection</span> {
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-setIdentityProvider-void-DOMString-provider-DOMString-protocol-DOMString-username">setIdentityProvider</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">provider</span></span>, <span class="idlParam">optional <span class="idlParamType">DOMString</span> <span class="idlParamName">protocol</span></span>, <span class="idlParam">optional <span class="idlParamType">DOMString</span> <span class="idlParamName">username</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-getIdentityAssertion-void">getIdentityAssertion</a></span> ();</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCIdentityAssertion"><code>RTCIdentityAssertion</code></a>?</span> <span class="idlAttrName"><a href="#widl-RTCPeerConnection-peerIdentity">peerIdentity</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onidentityresult">onidentityresult</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onpeeridentity">onpeeridentity</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onidpassertionerror">onidpassertionerror</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onidpvalidationerror">onidpvalidationerror</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-10" typeof="bibo:Chapter" id="attributes-10"><h4 resource="#h-attributes-10" id="h-attributes-10"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.4.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-RTCPeerConnection-onidentityresult"><code>onidentityresult</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler, of event handler event type <code><a href="#event-identityresult">identityresult</a></code>, <em title="MUST" class="rfc2119">MUST</em> be fired by
        all objects implementing the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>
        interface. This event is fired when an identity assertion is
        successfully generated. Note: this event is fired when an identity
        assertion is generated during the creation of an offer or answer.</dd><dt id="widl-RTCPeerConnection-onidpassertionerror"><code>onidpassertionerror</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler of type <code><a href="#event-idpassertionerror">idpassertionerror</a></code> <em title="MUST" class="rfc2119">MUST</em> be fired
        when an IdP encounters an error in generating an identity
        assertion.</dd><dt id="widl-RTCPeerConnection-onidpvalidationerror"><code>onidpvalidationerror</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This event handler of type <code><a href="#event-idpvalidationerror">idvalidationperror</a></code> <em title="MUST" class="rfc2119">MUST</em> be fired
        when an IdP encounters an error in validating an identity
        assertion.</dd><dt id="widl-RTCPeerConnection-onpeeridentity"><code>onpeeridentity</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>This simple event handler of type <code><a href="#event-peeridentity">peeridentity</a></code> <em title="MUST" class="rfc2119">MUST</em> be fired when a peer
        identity from a peer is successfully validated.</dd><dt id="widl-RTCPeerConnection-peerIdentity"><code>peerIdentity</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-RTCIdentityAssertion"><code>RTCIdentityAssertion</code></a></span>, readonly   , nullable</dt><dd>
          <p>Contains the peer identity assertion information if an identity
          assertion was provided and verified. Once this value is set to a
          non-<var>null</var> value, it cannot change.</p>
        </dd></dl></section><section property="bibo:hasPart" resource="#methods-8" typeof="bibo:Chapter" id="methods-8"><h4 resource="#h-methods-8" id="h-methods-8"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.4.2 </span>Methods</span></h4><dl class="methods"><dt id="widl-RTCPeerConnection-getIdentityAssertion-void"><code>getIdentityAssertion</code></dt><dd>
          <p>Initiates the process of obtaining an identity assertion.
          Applications need not make this call. It is merely intended to allow
          them to start the process of obtaining identity assertions before a
          call is initiated. If an identity is needed, either because the
          browser has been configured with a default identity provider or
          because the <code>setIdentityProvider()</code> method was called,
          then an identity will be automatically requested when an offer or
          answer is created.</p>

          <p>When <code>getIdentityAssertion</code> is invoked, queue a task to
          run the following steps:</p>

          <ol>
            <li>
              <p>If the <var>connection</var>'s <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
              signalingState</a> is <code>closed</code>, abort these steps.</p>
            </li><!-- close() was probably called just before this
                 task ran -->

            <li>
              <p><a href="#sec.identity-proxy-assertion-request">Request an
              identity assertion</a> from the IdP.</p>
            </li>
          </ol>
        <div><em>No parameters.</em></div><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-RTCPeerConnection-setIdentityProvider-void-DOMString-provider-DOMString-protocol-DOMString-username"><code>setIdentityProvider</code></dt><dd>
          <p>Sets the identity provider to be used for a given
          <code>RTCPeerConnection</code> object. Applications need not make
          this call; if the browser is already configured for an IdP, then that
          configured IdP will be used to get an assertion.</p>

          <p>When the <dfn id="dom-peerconnection-setidentityprovider"><code>setIdentityProvider()</code></dfn>
          method is invoked, the user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:</p>

          <ol>
            <li>
              <p>If the <var>connection</var>'s <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
              signalingState</a> is <code>closed</code>, throw an
              <code>InvalidStateError</code> exception and abort these
              steps.</p>
            </li>

            <li>
              <p>Set the current identity provider values to the triplet
              (<code>provider</code>, <code>protocol</code>,
              <code>username</code>).</p>
            </li>

            <li>
              <p>If any identity provider value has changed, discard any stored
              identity assertion.</p>
            </li>
          </ol>

          <p>Identity provider information is not used until an identity
          assertion is required, either in response to a call to
          <code>getIdentityAssertion</code>, or the need to generate SDP with
          either <code>createOffer</code> or <code>createAnswer</code>.</p>
        <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">provider</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">protocol</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">username</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#rtcidentityassertion-type" typeof="bibo:Chapter" id="rtcidentityassertion-type">
      <h3 resource="#h-rtcidentityassertion-type" id="h-rtcidentityassertion-type"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.5 </span>RTCIdentityAssertion Type</span></h3>

      <pre class="idl"><span class="idlDictionary" id="idl-def-RTCIdentityAssertion">dictionary <span class="idlDictionaryID">RTCIdentityAssertion</span> {
<span class="idlMember">    <span class="idlMemberType">DOMString</span> <span class="idlMemberName"><a href="#widl-RTCIdentityAssertion-idp">idp</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span> <span class="idlMemberName"><a href="#widl-RTCIdentityAssertion-name">name</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#dictionary-rtcidentityassertion-members" typeof="bibo:Chapter" id="dictionary-rtcidentityassertion-members"><h4 resource="#h-dictionary-rtcidentityassertion-members" id="h-dictionary-rtcidentityassertion-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.5.1 </span>Dictionary <a href="#idl-def-RTCIdentityAssertion" class="idlType"><code>RTCIdentityAssertion</code></a> Members</span></h4><dl class="dictionary-members"><dt id="widl-RTCIdentityAssertion-idp"><code>idp</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
          <p>A domain name representing the identity provider.</p>
        </dd><dt id="widl-RTCIdentityAssertion-name"><code>name</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
          <p>An RFC5322-conformant [<cite><a href="#bib-RFC5322" class="bibref">RFC5322</a></cite>] representation of the verified
          peer identity. This identity will have been verified via the
          procedures described in [RTCWEB-SECURITY-ARCH].</p>
        </dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#rtcidentityevent-type" typeof="bibo:Chapter" id="rtcidentityevent-type">
      <h3 resource="#h-rtcidentityevent-type" id="h-rtcidentityevent-type"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.6 </span>RTCIdentityEvent Type</span></h3>

      <p>The <code><dfn id="dfn-rtcidentiytevent">RTCIdentiytEvent</dfn></code> is raised when an IdP
      produces an identity assertion.</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-RTCIdentityEvent">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">RTCIdentityEvent</span> : <span class="idlSuperclass"><a class="internalDFN" href="#dfn-event">Event</a></span> {
<span class="idlAttribute">                attribute <span class="idlAttrType">DOMString</span> <span class="idlAttrName"><a href="#widl-RTCIdentityEvent-assertion">assertion</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-11" typeof="bibo:Chapter" id="attributes-11"><h4 resource="#h-attributes-11" id="h-attributes-11"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.6.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-RTCIdentityEvent-assertion"><code>assertion</code> of type <span class="idlAttrType">DOMString</span>,            </dt><dd>
          <p>A string containing the encoded identity assertion (the
          information that would be added to the "a=identity" line in SDP
          [<cite><a href="#bib-RTCWEB-SECURITY-ARCH" class="bibref">RTCWEB-SECURITY-ARCH</a></cite>]).</p>
        </dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#rtcidentityerrorevent-type" typeof="bibo:Chapter" id="rtcidentityerrorevent-type">
      <h3 resource="#h-rtcidentityerrorevent-type" id="h-rtcidentityerrorevent-type"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.7 </span>RTCIdentityErrorEvent Type</span></h3>

      <p>The <code><dfn id="dfn-rtcidentityerrorevent">RTCIdentityErrorEvent</dfn></code> is raised when an
      IdP fails to successfully produce an identity assertion.</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-RTCIdentityErrorEvent">[<span class="extAttr">NoInterfaceObject</span>]
interface <span class="idlInterfaceID">RTCIdentityErrorEvent</span> : <span class="idlSuperclass"><a class="internalDFN" href="#dfn-event">Event</a></span> {
<span class="idlAttribute">                attribute <span class="idlAttrType">DOMString</span>  <span class="idlAttrName"><a href="#widl-RTCIdentityErrorEvent-idp">idp</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">DOMString</span>  <span class="idlAttrName"><a href="#widl-RTCIdentityErrorEvent-protocol">protocol</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">DOMString?</span> <span class="idlAttrName"><a href="#widl-RTCIdentityErrorEvent-loginUrl">loginUrl</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-12" typeof="bibo:Chapter" id="attributes-12"><h4 resource="#h-attributes-12" id="h-attributes-12"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.7.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-RTCIdentityErrorEvent-idp"><code>idp</code> of type <span class="idlAttrType">DOMString</span>,            </dt><dd>The domain name of the identity provider that is providing the
        error response.</dd><dt id="widl-RTCIdentityErrorEvent-loginUrl"><code>loginUrl</code> of type <span class="idlAttrType">DOMString</span>,            , nullable</dt><dd>An IdP that is unable to generate an identity assertion due to a
        lack of sufficient user authentication information can provide a <dfn id="dfn-loginurl" title="loginUrl">URL</dfn> to
        a page where the user can complete authentication. If the IdP provides
        this URL, this attribute includes the value provided by the IdP.</dd><dt id="widl-RTCIdentityErrorEvent-protocol"><code>protocol</code> of type <span class="idlAttrType">DOMString</span>,            </dt><dd>The IdP protocol that is in use.</dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#examples" typeof="bibo:Chapter" id="examples">
      <h3 resource="#h-examples" id="h-examples"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.8 </span>Examples</span></h3>

      <p>The identity system is designed so that applications need not take any
      special action in order for users to generate and verify identity
      assertions; if a user has configured an IdP into their browser, then the
      browser will automatically request/generate assertions and the other side
      will automatically verify them and display the results. However,
      applications may wish to exercise tighter control over the identity
      system as shown by the following examples.</p>

      <div>
        <p>This example shows how to configure the identity provider and
        protocol.</p>
        <div class="example"><div class="example-title"><span>Example 2</span></div><pre style="" class="example highlight prettyprint prettyprinted" xml:space="preserve"><span class="pln">pc</span><span class="pun">.</span><span class="pln">setIdentityProvider</span><span class="pun">(</span><span class="str">"example.com"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"default"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"alice@example.com"</span><span class="pun">);</span></pre></div>
      </div>

      <div>
        <p>This example shows how to consume identity assertions inside a Web
        application.</p>
        <div class="example"><div class="example-title"><span>Example 3</span></div><pre style="" class="example highlight prettyprint prettyprinted" xml:space="preserve"><span class="pln">pc</span><span class="pun">.</span><span class="pln">onpeeridentity </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"IdP= "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">.</span><span class="pln">peerIdentity</span><span class="pun">.</span><span class="pln">idp </span><span class="pun">+</span><span class="pln">
              </span><span class="str">" identity="</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">.</span><span class="pln">peerIdentity</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span></pre></div>
      </div>
    </section>
  </section>

  <section property="bibo:hasPart" resource="#media-stream-api-extensions-for-network-use" typeof="bibo:Chapter" id="media-stream-api-extensions-for-network-use">
    <!--OddPage--><h2 resource="#h-media-stream-api-extensions-for-network-use" id="h-media-stream-api-extensions-for-network-use"><span property="xhv:role" resource="xhv:heading"><span class="secno">9. </span>Media Stream API Extensions for Network Use</span></h2>

    <section property="bibo:hasPart" resource="#introduction-2" typeof="bibo:Chapter" id="introduction-2">
      <h3 resource="#h-introduction-2" id="h-introduction-2"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.1 </span>Introduction</span></h3>

      <p>The <code>MediaStream</code> interface, as defined in the
      [<cite><a href="#bib-GETUSERMEDIA" class="bibref">GETUSERMEDIA</a></cite>] specification, typically represents a stream of data of
      audio and/or video. A <code>MediaStream</code> may be extended to
      represent a stream that either comes from or is sent to a remote node
      (and not just the local camera, for instance). The extensions required to
      enable this capability on the <code>MediaStream</code> object will be
      described in this section. How the media is transmitted to the peer is
      described in [<cite><a href="#bib-RTCWEB-RTP" class="bibref">RTCWEB-RTP</a></cite>], [<cite><a href="#bib-RTCWEB-AUDIO" class="bibref">RTCWEB-AUDIO</a></cite>], and
      [<cite><a href="#bib-RTCWEB-TRANSPORT" class="bibref">RTCWEB-TRANSPORT</a></cite>].</p>

      <p>A <code>MediaStream</code> as defined in [<cite><a href="#bib-GETUSERMEDIA" class="bibref">GETUSERMEDIA</a></cite>] may contain
      zero or more <code>MediaStreamTrack</code> objects. A
      <code>MediaStreamTrack</code> sent to another peer will appear as one and
      only one <code>MediaStreamTrack</code> to the recipient. A peer is
      defined as a user agent that supports this specification.</p>

      <p>Channels are the smallest unit considered in the
      <code>MediaStream</code> specification. Channels are intended to be
      encoded together for transmission as, for instance, an RTP payload type.
      All of the channels that a codec needs to encode jointly <em title="MUST" class="rfc2119">MUST</em> be in the
      same <code>MediaStreamTrack</code> and the codecs <em title="SHOULD" class="rfc2119">SHOULD</em> be able to
      encode, or discard, all the channels in the track.</p>

      <p>The concepts of an input and output to a given
      <code>MediaStream</code> apply in the case of <code>MediaStream</code>
      objects transmitted over the network as well. A
      <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> created by an
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object (described later in this
      document) will take as input the data received from a remote peer.
      Similarly, a <code>MediaStream</code> from a local source, for instance a
      camera via [<cite><a href="#bib-GETUSERMEDIA" class="bibref">GETUSERMEDIA</a></cite>], will have an output that represents what is
      transmitted to a remote peer if the object is used with an
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>

      <p>The concept of duplicating <code>MediaStream</code> objects as
      described in [<cite><a href="#bib-GETUSERMEDIA" class="bibref">GETUSERMEDIA</a></cite>] is also applicable here. This feature can
      be used, for instance, in a video-conferencing scenario to display the
      local video from the user's camera and microphone in a local
      monitor, while only transmitting the audio to the remote peer (e.g. in
      response to the user using a "video mute" feature). Combining tracks from
      different <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> objects into a new
      <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> is useful in certain situations.</p>

      <div class="note"><div id="h-note13" role="heading" aria-level="4" class="note-title"><span>Note</span></div><p class="">In this document, we only specify aspects of the
      following objects that are relevant when used along with an
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>. Please refer to the original
      definitions of the objects in the [<cite><a href="#bib-GETUSERMEDIA" class="bibref">GETUSERMEDIA</a></cite>] document for general
      information on using <code>MediaStream</code> and
      <code>MediaStreamTrack</code>.</p></div>
    </section>

    <section property="bibo:hasPart" resource="#mediastream" typeof="bibo:Chapter" id="mediastream">
      <h3 resource="#h-mediastream" id="h-mediastream"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.2 </span>MediaStream</span></h3>

      <section property="bibo:hasPart" resource="#id" typeof="bibo:Chapter" id="id">
        <h4 resource="#h-id" id="h-id"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.2.1 </span>id</span></h4>

        <p>The <code><a href="http://w3c.github.io/mediacapture-main/#dom-mediastream-id">id</a></code> attribute
        specified in <code>MediaStream</code> returns an id that is unique to
        this stream, so that streams can be recognized after they are sent
        through the <code><a href="#rtcpeerconnection-interface">RTCPeerConnection</a></code> API.</p>

        <p>When a <code><a href="#mediastream">MediaStream</a></code> is
        created to represent a stream obtained from a remote peer, the
        <code><a href="http://w3c.github.io/mediacapture-main/#dom-mediastream-id">id</a></code>
        attribute is initialized from information provided by the remote
        source.</p>

        <div class="note"><div id="h-note14" role="heading" aria-level="5" class="note-title"><span>Note</span></div><p class="">The id of a <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> object is
        unique to the source of the stream, but that does not mean it is not
        possible to end up with duplicates. For example, a locally generated
        stream could be sent from one user agent to a remote peer using
        <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> and then sent back to the
        original user agent in the same manner, in which case the original user
        agent will have multiple streams with the same id (the
        locally-generated one and the one received from the remote peer).</p></div>
      </section>

      <section property="bibo:hasPart" resource="#events-on-mediastream" typeof="bibo:Chapter" id="events-on-mediastream">
        <h4 resource="#h-events-on-mediastream" id="h-events-on-mediastream"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.2.2 </span>Events on MediaStream</span></h4>

        <p>A new media track may be associated with an existing
        <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code>. For example, if a remote peer adds a
        new <code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code> object to a
        <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> that is being sent over an
        <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>, this is observed on the local
        user agent. If this happens for the reason exemplified, or for any
        other reason than the <code><a href="http://w3c.github.io/mediacapture-main/#dom-mediastream-addtrack">addTrack()</a></code>
        method being invoked locally on a <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> or
        tracks being added as the stream is created (i.e. the stream is
        initialized with tracks), the user agent <em title="MUST" class="rfc2119">MUST</em> run the following
        steps:</p>

        <ol>
          <li>
            <p>Let <var>stream</var> be the target
            <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> object.</p>
          </li>

          <li>
            <p><dfn id="represent-component-with-track">Represent component
            with track</dfn>: Run the following steps to create a track
            representing the incoming component:</p>

            <ol>
              <li>
                <p>Create a <code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code> object
                <var>track</var> to represent the component.</p>
              </li>

              <li>
                <p>Initialize <var>track's</var> <code><a href="http://w3c.github.io/mediacapture-main/#dom-mediastreamtrack-kind">kind</a></code>
                attribute to "<code>audio</code>" or "<code>video</code>"
                depending on the media type of the incoming component.</p>
              </li>

              <li>
                <p>Initialize <var>track's</var> <code><a href="http://w3c.github.io/mediacapture-main/#dom-mediastreamtrack-id">id</a></code>
                attribute to the component track id.</p>
              </li>

              <li>
                <p>Initialize <var>track's</var> <code><a href="http://w3c.github.io/mediacapture-main/#dom-mediastreamtrack-label">label</a></code>
                attribute to "<code>remote audio</code>" or "<code>remote
                video</code>" depending on the media type of the incoming
                component.</p>
              </li>

              <li>
                <p>Initialize <var>track's</var> <code><a href="http://w3c.github.io/mediacapture-main/#dom-mediastreamtrack-readystate">readyState</a></code>
                attribute to <code>live</code> and <code><a href="http://w3c.github.io/mediacapture-main/#dom-mediastreamtrack-muted">muted</a></code> attribute to <code>true</code>.</p>
              </li>

              <li>
                <p>Add <var>track</var> to <var>stream's</var> <a href="http://w3c.github.io/mediacapture-main/#track-set">track set</a>.</p>
              </li>
            </ol>
          </li>

          <li>
            <p>Fire a track event named <code><a href="http://w3c.github.io/mediacapture-main/#event-mediastream-addtrack">addtrack</a></code>
            with the newly created <code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code> object
            at <var>stream</var>.</p>
          </li>
        </ol>

        <p>An existing media track may also be disassociated from a
        <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code>. If this happens for any other reason
        than the <code><a href="http://w3c.github.io/mediacapture-main/#dom-mediastream-removetrack">removeTrack()</a></code>
        method being invoked locally on a <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> or
        the stream being destroyed, the user agent <em title="MUST" class="rfc2119">MUST</em> run the following
        steps:</p>

        <ol>
          <li>
            <p>Let <var>stream</var> be the target
            <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> object.</p>
          </li>

          <li>
            <p>Let <var>track</var> be the <code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code>
            object representing the media component about to be removed.</p>
          </li>

          <li>
            <p>Remove <var>track</var> from <var>stream's</var> <a href="http://w3c.github.io/mediacapture-main/#track-set">track set</a>.</p>
          </li>

          <li>
            <p>Fire a track event named <code><a href="http://w3c.github.io/mediacapture-main/#event-mediastream-removetrack">removetrack</a></code>
            with <var>track</var> at <var>stream</var>.</p>
          </li>
        </ol>

        <p>The event source for the <code>onended</code> event in the networked
        case is the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> object.</p>
      </section>
    </section>

    <section property="bibo:hasPart" resource="#mediastreamtrack" typeof="bibo:Chapter" id="mediastreamtrack">
      <h3 resource="#h-mediastreamtrack" id="h-mediastreamtrack"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.3 </span>MediaStreamTrack</span></h3>

      <p>A <code>MediaStreamTrack</code> object's reference to its
      <code>MediaStream</code> in the non-local media source case (an RTP
      source, as is the case for a <code>MediaStream</code> received over an
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> ) is always strong.</p>

      <p>When a track belongs to a <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> that comes
      from a remote peer and the remote peer has permanently stopped sending
      data the <code>ended</code> event <em title="MUST" class="rfc2119">MUST</em> be fired on the track, as
      specified in [<cite><a href="#bib-GETUSERMEDIA" class="bibref">GETUSERMEDIA</a></cite>].</p>

      <div class="issue"><div id="h-issue3" role="heading" aria-level="4" class="issue-title"><span>Issue 3</span></div><p class="">ISSUE: How do you know when it has stopped? This seems
      like an SDP question, not a media-level question.</p></div>

      <p>A track in a <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code>, received with an
      <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>, <em title="MUST" class="rfc2119">MUST</em> have its
      <code>muted</code> attribute [<cite><a href="#bib-GETUSERMEDIA" class="bibref">GETUSERMEDIA</a></cite>] set to
      <code>true</code> until media data arrives.</p>

      <p>In addition, a <code>MediaStreamTrack</code> has its
      <code>muted</code> attribute set to <code>true</code> on the
      remote peer if the local user agent disables the corresponding
      <code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code> in the
      <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> that is being sent. When the addstream
      event triggers on an <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>, all
      <code><a class="idlType" href="#idl-def-MediaStreamTrack"><code>MediaStreamTrack</code></a></code> objects in the resulting
      <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> are muted until media data can be read
      from the RTP source.</p>

      <div class="issue"><div id="h-issue4" role="heading" aria-level="4" class="issue-title"><span>Issue 4</span></div><p class="">ISSUE: How do you know when it has been disabled? This
      seems like an SDP question, not a media-level question.</p></div>
    </section>

    <section property="bibo:hasPart" resource="#mediastreamevent" typeof="bibo:Chapter" id="mediastreamevent">
      <h3 resource="#h-mediastreamevent" id="h-mediastreamevent"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.4 </span>MediaStreamEvent</span></h3>

      <p>The <code><a href="#event-mediastream-addstream">addstream</a></code>
      and <code title="event-MediaStream-removestream"><a href="#event-mediastream-removestream">removestream</a></code> events use the
      <code><a class="idlType" href="#idl-def-MediaStreamEvent"><code>MediaStreamEvent</code></a></code> interface.</p>

      <p><dfn id="fire-a-stream-event" title="fire a stream event">Firing a
      stream event named <var>e</var></dfn> with a
      <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> <var>stream</var> means that an event
      with the name <var>e</var>, which does not bubble (except where otherwise
      stated) and is not cancelable (except where otherwise stated), and which
      uses the <code><a class="idlType" href="#idl-def-MediaStreamEvent"><code>MediaStreamEvent</code></a></code> interface with the
      <code><a href="#dom-mediastreamevent-stream">stream</a></code> attribute
      set to <var title="">stream</var>, <em title="MUST" class="rfc2119">MUST</em> be created and dispatched at the
      given target.</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-MediaStreamEvent"><span class="idlDictionary" id="idl-def-MediaStreamEventInit">dictionary <span class="idlDictionaryID">MediaStreamEventInit</span> : <span class="idlSuperclass">EventInit</span> {
<span class="idlMember">    <span class="idlMemberType"><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></span> <span class="idlMemberName"><a href="#widl-MediaStreamEventInit-stream">stream</a></span>;</span>
};</span><br><br>[<span class="idlCtor"> <span class="idlCtorKeyword"></span><span class="idlCtorName"><a href="#widl-ctor-MediaStreamEvent--DOMString-type-MediaStreamEventInit-eventInitDict">Constructor</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">type</span></span>, <span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-MediaStreamEventInit"><code>MediaStreamEventInit</code></a></span> <span class="idlParamName">eventInitDict</span></span>)</span>]
interface <span class="idlInterfaceID">MediaStreamEvent</span> : <span class="idlSuperclass"><a class="internalDFN" href="#dfn-event">Event</a></span> {
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType"><a class="internalDFN" href="#dfn-mediastream">MediaStream</a>?</span> <span class="idlAttrName"><a href="#widl-MediaStreamEvent-stream">stream</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#constructors-6" typeof="bibo:Chapter" id="constructors-6"><h4 resource="#h-constructors-6" id="h-constructors-6"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.4.1 </span>Constructors</span></h4><dl class="constructors"><dt id="widl-ctor-MediaStreamEvent--DOMString-type-MediaStreamEventInit-eventInitDict"><code>MediaStreamEvent</code></dt><dd>readonly attribute MediaStream? stream<table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">type</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">eventInitDict</td><td class="prmType"><code><a class="idlType" href="#idl-def-MediaStreamEventInit"><code>MediaStreamEventInit</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table></dd></dl></section><section property="bibo:hasPart" resource="#attributes-13" typeof="bibo:Chapter" id="attributes-13"><h4 resource="#h-attributes-13" id="h-attributes-13"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.4.2 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-MediaStreamEvent-stream"><code>stream</code> of type <span class="idlAttrType"><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></span>, readonly   , nullable</dt><dd>
          <p>The <dfn id="dom-mediastreamevent-stream"><code>stream</code></dfn> attribute
          represents the <code><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></code> object associated with
          the event.</p>
        </dd></dl></section>

      <section property="bibo:hasPart" resource="#dictionary-mediastreameventinit-members" typeof="bibo:Chapter" id="dictionary-mediastreameventinit-members"><h4 resource="#h-dictionary-mediastreameventinit-members" id="h-dictionary-mediastreameventinit-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.4.3 </span>Dictionary <a href="#idl-def-MediaStreamEventInit" class="idlType"><code>MediaStreamEventInit</code></a> Members</span></h4><dl class="dictionary-members"><dt id="widl-MediaStreamEventInit-stream"><code>stream</code> of type <span class="idlMemberType"><a class="internalDFN" href="#dfn-mediastream">MediaStream</a></span></dt><dd>
          <p>TODO</p>
        </dd></dl></section>
    </section>

    <section property="bibo:hasPart" resource="#isolated-media-streams" typeof="bibo:Chapter" id="isolated-media-streams">
      <h3 resource="#h-isolated-media-streams" id="h-isolated-media-streams"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.5 </span>Isolated Media Streams</span></h3>

      <p>A MediaStream acquired using <code>getUserMedia()</code> is, by
      default, accessible to an application. This means that the application is
      able to access the contents of tracks, modify their content, and send
      that media to any peer it chooses.</p>

      <p>WebRTC supports calling scenarios where media is sent to a
      specifically identified peer, without the contents of media streams being
      accessible to applications. This is enabled by use of the
      <code>peerIdentity</code> parameter to
      <code>getUserMedia()</code>.</p>

      <p>An application willingly relinquishes access to media by including a
      <code>peerIdentity</code> parameter in the
      <code>MediaStreamConstraints</code>. This attribute is set to a
      <code>DOMString</code> containing the identity of a specific peer.</p>

      <p>The <code><dfn id="dfn-mediastreamconstraints">MediaStreamConstraints</dfn></code> dictionary is
      expanded to include the <code>peerIdentity</code> parameter.</p>

      <pre class="idl"><span class="idlDictionary" id="idl-def-MediaStreamConstraints">partial dictionary <span class="idlDictionaryID">MediaStreamConstraints</span> {
<span class="idlMember">    <span class="idlMemberType">DOMString</span> <span class="idlMemberName"><a href="#widl-MediaStreamConstraints-peerIdentity">peerIdentity</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#dictionary-mediastreamconstraints-members" typeof="bibo:Chapter" id="dictionary-mediastreamconstraints-members"><h4 resource="#h-dictionary-mediastreamconstraints-members" id="h-dictionary-mediastreamconstraints-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.5.1 </span>Dictionary <a href="#idl-def-MediaStreamConstraints" class="idlType"><code>MediaStreamConstraints</code></a> Members</span></h4><dl class="dictionary-members"><dt id="widl-MediaStreamConstraints-peerIdentity"><code>peerIdentity</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
          <p>If set, <code>peerIdentity</code> isolates media from the
          application. Media can only be sent to the identified peer.</p>
        </dd></dl></section>

      <p>A user that is prompted to provide consent for access to a camera or
      microphone can be shown the value of the <code>peerIdentity</code>
      parameter, so that they can be informed that the consent is more narrowly
      restricted.</p>

      <p>When the <code><dfn id="dfn-peeridentity">peerIdentity</dfn></code> option is supplied to
      <code>getUserMedia()</code>, all of the <code>MediaStreamTrack</code>s in
      the resulting <code>MediaStream</code> are isolated so that content is
      not accessible to any application. Isolated
      <code>MediaStreamTrack</code>s can be used for two purposes:</p>

      <ul>
        <li>
          <p>Displayed in an appropriate media tag (e.g., a video or audio
          element). The browser <em title="MUST" class="rfc2119">MUST</em> ensure that content is inaccessible to the
          application by ensuring that the resulting content is given the same
          protections as content that is <a href="http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#cors-cross-origin">
          CORS cross-origin</a>, as described in the relevant <a href="http://www.w3.org/html/wg/drafts/html/master/embedded-content.html#security-and-privacy-considerations">
          Security and privacy considerations section</a> of [<cite><a href="#bib-HTML5" class="bibref">HTML5</a></cite>].</p>
        </li>

        <li>
          <p>Used as the argument to <a href="#widl-RTCPeerConnection-addStream-void-MediaStream-stream">addStream()</a>
          on an <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> instance, subject to the
          restrictions in <a href="#isolated-pc">.</a></p><a href="#isolated-pc">
        </a></li><a href="#isolated-pc">
      </a></ul><a href="#isolated-pc">

      </a><p><a href="#isolated-pc">A <code>MediaStreamTrack</code> that is added to another
      <code>MediaStream</code> remains isolated. When an isolated
      <code>MediaStreamTrack</code> is added to a <code>MediaStream</code> with
      a different peerIdentity, the <code>MediaStream</code> gets a combination
      of isolation restrictions. A <code>MediaStream</code> containing
      <code>MediaStreamTrack</code> instances with mixed isolation properties
      can be displayed, but cannot be sent using
      <code></code></a><code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>.</p>

      <p>Any <code>peerIdentity</code> property <em title="MUST" class="rfc2119">MUST</em> be retained on cloned
      copies of <code>MediaStreamTrack</code>s.</p>
      <!-- Any stream or track that might be derived from an isolated stream,
           such as
           through <a href="https://www.w3.org/TR/streamproc/#media-element-extensions">captureStreamUntilEnded
           or captureStream</a>, MUST also retain any isolation protections.
        -->

      <section property="bibo:hasPart" resource="#isolated-track" typeof="bibo:Chapter" id="isolated-track">
        <h4 resource="#h-isolated-track" id="h-isolated-track"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.5.2 </span>Extended MediaStreamTrack Properties</span></h4>

        <p><code>MediaStreamTrack</code> is expanded to include an
        <var>isolated</var> attribute and a corresponding event. This allows an
        application to quickly and easily determine whether a track is
        accessible.</p>

        <pre class="idl"><span class="idlInterface" id="idl-def-MediaStreamTrack">partial interface <span class="idlInterfaceID">MediaStreamTrack</span> {
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">boolean</span>      <span class="idlAttrName"><a href="#widl-MediaStreamTrack-isolated">isolated</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-MediaStreamTrack-onisolationchange">onisolationchange</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-14" typeof="bibo:Chapter" id="attributes-14"><h5 resource="#h-attributes-14" id="h-attributes-14"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.5.2.1 </span>Attributes</span></h5><dl class="attributes"><dt id="widl-MediaStreamTrack-isolated"><code>isolated</code> of type <span class="idlAttrType">boolean</span>, readonly   </dt><dd>
            <p>A <code>MediaStreamTrack</code> is isolated (and the
            corresponding <var>isolated</var> attribute set to <var>true</var>)
            when content is inaccessible to the owning document. This occurs as
            a result of setting the <var>peerIdentity</var> option. A track is
            also isolated if it comes from a cross origin source.</p>
          </dd><dt id="widl-MediaStreamTrack-onisolationchange"><code>onisolationchange</code> of type <span class="idlAttrType">EventHandler</span>,            </dt><dd>
            <p>This event handler, of type <a href="#event-isolationchange">isolationchange</a>, is fired when the
            value of the <var>isolated</var> attribute changes.</p>
          </dd></dl></section>
      </section>

      <section property="bibo:hasPart" resource="#isolated-pc" typeof="bibo:Chapter" id="isolated-pc">
        <h4 resource="#h-isolated-pc" id="h-isolated-pc"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.5.3 </span>Isolated Streams and RTCPeerConnection</span></h4>

        <p>A <code>MediaStreamTrack</code> with a <var>peerIdentity</var>
        option set can be added to any <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>.
        However, the content of an isolated track <em title="MUST NOT" class="rfc2119">MUST NOT</em> be transmitted
        unless all of the following constraints are met:</p>

        <ul>
          <li>
            <p>A <code>MediaStreamTrack</code> from a stream acquired using the
            <var>peerIdentity</var> option can be transmitted if the
            <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> has successfully <a href="#sec.identity-verify-assertion">validated the identity</a> of the
            peer AND that identity is the same identity that was used in the
            <var>peerIdentity</var> option associated with the track. That is,
            the <code>name</code> attribute of the <code>peerIdentity</code>
            attribute of the <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> instance
            <em title="MUST" class="rfc2119">MUST</em> match the value of the <code>peerIdentity</code> option passed
            to <code>getUserMedia()</code>.</p>

            <p>Rules for matching identity are described in
            [<cite><a href="#bib-RTCWEB-SECURITY-ARCH" class="bibref">RTCWEB-SECURITY-ARCH</a></cite>].</p>
          </li>

          <li>
            <p>The peer has indicated that it will respect the isolation
            properties of streams. That is, a DTLS connection with a promise to
            respect stream confidentiality, as defined in [<cite><a href="#bib-RTCWEB-ALPN" class="bibref">RTCWEB-ALPN</a></cite>] has
            been established.</p>
          </li>
        </ul>

        <p>Failing to meet these conditions means that no media can be sent for
        the affected <code>MediaStreamTrack</code>. Video <em title="MUST" class="rfc2119">MUST</em> be replaced by
        black frames, audio <em title="MUST" class="rfc2119">MUST</em> be replaced by silence, and equivalently
        information-free content <em title="MUST" class="rfc2119">MUST</em> be provided for other media types.</p>

        <p>Remotely sourced <code>MediaStreamTrack</code>s <em title="MUST" class="rfc2119">MUST</em> be isolated if
        they are received over a DTLS connection that has been negotiated with
        track isolation. This protects isolated media from the application in
        the receiving browser. These tracks <em title="MUST" class="rfc2119">MUST</em> only be displayed to a user
        using the appropriate media element (e.g., &lt;video&gt; or
        &lt;audio&gt;).</p>

        <p>Any <code>MediaStreamTrack</code> that has the
        <var>peerIdentity</var> option set causes all tracks sent using the
        same <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> to be isolated at the
        receiving peer. All DTLS connections created for a
        <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> with isolated local streams <em title="MUST" class="rfc2119">MUST</em>
        be negotiated so that media remains isolated at the remote peer. This
        causes non-isolated media to become isolated at the receiving peer if
        any isolated tracks are added to the same
        <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>.</p>

        <div class="note"><div id="h-note15" role="heading" aria-level="5" class="note-title"><span>Note</span></div><p class="">Tracks that are not bound to a particular
        <var>peerIdentity</var> do not cause other streams to be isolated,
        these tracks simply do not have their content transmitted.</p></div>

        <p>If a stream becomes isolated after initially being accessible, or an
        isolated stream is added to an active session, then media for that
        stream is replaced by information-free content (e.g., black frames or
        silence).</p>
      </section>

      <section property="bibo:hasPart" resource="#isolation-protection" typeof="bibo:Chapter" id="isolation-protection">
        <h4 resource="#h-isolation-protection" id="h-isolation-protection"><span property="xhv:role" resource="xhv:heading"><span class="secno">9.5.4 </span>Protection Afforded by Media Isolation</span></h4>

        <p>Media isolation ensures that the content of a
        <code>MediaStreamTrack</code> is not accessible to web applications.
        However, to ensure that media with a <var>peerIdentity</var> option set
        can be sent to peers, some meta-information about the media will be
        exposed to applications.</p>

        <p>Applications will be able to observe the parameters of the media
        that affect session negotiation and conversion into RTP. This includes
        the codecs that might be supported by the track, the bitrate, the
        number of packets, and the current settings that are set on the
        <code>MediaStreamTrack</code>.</p>

        <p>In particular, the <a href="#statistics-model">statistics</a> that
        <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code> records are not reduced in
        capability. New statistics that might compromise isolation <em title="MUST" class="rfc2119">MUST</em> be
        avoided, or explicitly suppressed for isolated streams.</p>

        <p>Most of these data are exposed to the network when the media is
        transmitted. Only the settings for the <code>MediaStreamTrack</code>
        present a new source of information. This can includes the frame rate
        and resolution of video tracks, the bandwidth of audio tracks, and
        other information about the source, which would not otherwise be
        revealed to a network observer. Since settings don't change at a high
        frequency or in response to changes in media content, settings only
        reveal limited reveal information about the content of a track.
        However, any setting that might change dynamically in response to the
        content of an isolated <code>MediaStreamTrack</code> <em title="MUST" class="rfc2119">MUST</em> have changes
        suppressed.</p>
      </section>
    </section>
  </section>

  <section property="bibo:hasPart" resource="#examples-and-call-flows" typeof="bibo:Chapter" id="examples-and-call-flows" class="informative">
    <!--OddPage--><h2 resource="#h-examples-and-call-flows" id="h-examples-and-call-flows"><span property="xhv:role" resource="xhv:heading"><span class="secno">10. </span>Examples and Call Flows</span></h2><p><em>This section is non-normative.</em></p>

    <section property="bibo:hasPart" resource="#simple-peer-to-peer-example" typeof="bibo:Chapter" id="simple-peer-to-peer-example">
      <h3 resource="#h-simple-peer-to-peer-example" id="h-simple-peer-to-peer-example"><span property="xhv:role" resource="xhv:heading"><span class="secno">10.1 </span>Simple Peer-to-peer Example</span></h3>

      <div>
        <p>When two peers decide they are going to set up a connection to each
        other, they both go through these steps. The STUN/TURN server
        configuration describes a server they can use to get things like their
        public IP address or to set up NAT traversal. They also have to send
        data for the signaling channel to each other using the same out-of-band
        mechanism they used to establish that they were going to communicate in
        the first place.</p>
        <div class="example"><div class="example-title"><span>Example 4</span></div><pre style="" class="example highlight prettyprint prettyprinted" xml:space="preserve"><span class="kwd">var</span><span class="pln"> signalingChannel </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">SignalingChannel</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> configuration </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="str">"iceServers"</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[{</span><span class="pln"> </span><span class="str">"url"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"stun:stun.example.org"</span><span class="pln"> </span><span class="pun">}]</span><span class="pln"> </span><span class="pun">};</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> pc</span><span class="pun">;</span><span class="pln">

</span><span class="com">// call start() to initiate</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> start</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    pc </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCPeerConnection</span><span class="pun">(</span><span class="pln">configuration</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// send any ice candidates to the other peer</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">onicecandidate </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">.</span><span class="pln">candidate</span><span class="pun">)</span><span class="pln">
            signalingChannel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">({</span><span class="pln"> </span><span class="str">"candidate"</span><span class="pun">:</span><span class="pln"> evt</span><span class="pun">.</span><span class="pln">candidate </span><span class="pun">}));</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">

    </span><span class="com">// let the "negotiationneeded" event trigger offer generation</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">onnegotiationneeded </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">createOffer</span><span class="pun">().</span><span class="kwd">then</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">offer</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">setLocalDescription</span><span class="pun">(</span><span class="pln">offer</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">})</span><span class="pln">
        </span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="com">// send the offer to the other peer</span><span class="pln">
            signalingChannel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">({</span><span class="pln"> </span><span class="str">"sdp"</span><span class="pun">:</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">localDescription </span><span class="pun">}));</span><span class="pln">
        </span><span class="pun">})</span><span class="pln">
        </span><span class="pun">.</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">logError</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">

    </span><span class="com">// once remote stream arrives, show it in the remote video element</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">onaddstream </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        remoteView</span><span class="pun">.</span><span class="pln">srcObject </span><span class="pun">=</span><span class="pln"> evt</span><span class="pun">.</span><span class="pln">stream</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">

    </span><span class="com">// get a local stream, show it in a self-view and add it to be sent</span><span class="pln">
    navigator</span><span class="pun">.</span><span class="pln">mediaDevices</span><span class="pun">.</span><span class="pln">getUserMedia</span><span class="pun">({</span><span class="pln"> </span><span class="str">"audio"</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> </span><span class="str">"video"</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">},</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">stream</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        selfView</span><span class="pun">.</span><span class="pln">srcObject </span><span class="pun">=</span><span class="pln"> stream</span><span class="pun">;</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">addStream</span><span class="pun">(</span><span class="pln">stream</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">},</span><span class="pln"> logError</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

signalingChannel</span><span class="pun">.</span><span class="pln">onmessage </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">pc</span><span class="pun">)</span><span class="pln">
        start</span><span class="pun">();</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> message </span><span class="pun">=</span><span class="pln"> JSON</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="pln">evt</span><span class="pun">.</span><span class="pln">data</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">sdp</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">var</span><span class="pln"> desc </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCSessionDescription</span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">sdp</span><span class="pun">);</span><span class="pln">

        </span><span class="com">// if we get an offer, we need to reply with an answer</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">desc</span><span class="pun">.</span><span class="pln">type </span><span class="pun">==</span><span class="pln"> </span><span class="str">"offer"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            pc</span><span class="pun">.</span><span class="pln">setRemoteDescription</span><span class="pun">(</span><span class="pln">desc</span><span class="pun">).</span><span class="kwd">then</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                </span><span class="kwd">return</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">createAnswer</span><span class="pun">();</span><span class="pln">
            </span><span class="pun">})</span><span class="pln">
            </span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">answer</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                </span><span class="kwd">return</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">setLocalDescription</span><span class="pun">(</span><span class="pln">answer</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">})</span><span class="pln">
            </span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                signalingChannel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">({</span><span class="pln"> </span><span class="str">"sdp"</span><span class="pun">:</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">localDescription </span><span class="pun">}));</span><span class="pln">
            </span><span class="pun">})</span><span class="pln">
            </span><span class="pun">.</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">logError</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln">
            pc</span><span class="pun">.</span><span class="pln">setRemoteDescription</span><span class="pun">(</span><span class="pln">desc</span><span class="pun">).</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">logError</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">addIceCandidate</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCIceCandidate</span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">candidate</span><span class="pun">)).</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">logError</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> logError</span><span class="pun">(</span><span class="pln">error</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    log</span><span class="pun">(</span><span class="pln">error</span><span class="pun">.</span><span class="pln">name </span><span class="pun">+</span><span class="pln"> </span><span class="str">": "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> error</span><span class="pun">.</span><span class="pln">message</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></pre></div>
      </div>
    </section>

    <section property="bibo:hasPart" resource="#advanced-peer-to-peer-example" typeof="bibo:Chapter" id="advanced-peer-to-peer-example">
      <h3 resource="#h-advanced-peer-to-peer-example" id="h-advanced-peer-to-peer-example"><span property="xhv:role" resource="xhv:heading"><span class="secno">10.2 </span>Advanced Peer-to-peer Example</span></h3>

      <div>
        <p>This example shows the more complete functionality.</p>
        <div class="example"><div class="example-title"><span>Example 5</span></div><pre style="" class="example highlight prettyprint prettyprinted" xml:space="preserve"><span class="pln">TODO</span></pre></div>
      </div>
    </section>

    <section property="bibo:hasPart" resource="#peer-to-peer-data-example" typeof="bibo:Chapter" id="peer-to-peer-data-example">
      <h3 resource="#h-peer-to-peer-data-example" id="h-peer-to-peer-data-example"><span property="xhv:role" resource="xhv:heading"><span class="secno">10.3 </span>Peer-to-peer Data Example</span></h3>

      <div>
        <p>This example shows how to create a
        <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object and perform the offer/answer
        exchange required to connect the channel to the other peer. The
        <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> is used in the context of a simple
        chat application and listeners are attached to monitor when the channel
        is ready, messages are received and when the channel is closed.</p>

        <div class="note"><div id="h-note16" role="heading" aria-level="4" class="note-title"><span>Note</span></div><p class="">This example uses the <code>negotiationneeded</code>
        event to initiate the offer/answer dialog. The exact behavior
        surrounding the <code>negotiationneeded</code> event is not specified
        in detail at the moment. This example can hopefully help to drive that
        discussion. An assumption made in this example is that the event only
        triggers when a new negotiation should be started. This means that an
        action (such as addStream()) that normally would have fired the
        <code>negotiationneeded</code> event will not do so during an ongoing
        offer/answer dialog.</p></div>
        <div class="example"><div class="example-title"><span>Example 6</span></div><pre style="" class="example highlight prettyprint prettyprinted" xml:space="preserve"><span class="kwd">var</span><span class="pln"> signalingChannel </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">SignalingChannel</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> configuration </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="str">"iceServers"</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[{</span><span class="pln"> </span><span class="str">"url"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"stun:stun.example.org"</span><span class="pln"> </span><span class="pun">}]</span><span class="pln"> </span><span class="pun">};</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> pc</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> channel</span><span class="pun">;</span><span class="pln">

</span><span class="com">// call start(true) to initiate</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> start</span><span class="pun">(</span><span class="pln">isInitiator</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    pc </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCPeerConnection</span><span class="pun">(</span><span class="pln">configuration</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// send any ice candidates to the other peer</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">onicecandidate </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">.</span><span class="pln">candidate</span><span class="pun">)</span><span class="pln">
            signalingChannel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">({</span><span class="pln"> </span><span class="str">"candidate"</span><span class="pun">:</span><span class="pln"> evt</span><span class="pun">.</span><span class="pln">candidate </span><span class="pun">}));</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">

    </span><span class="com">// let the "negotiationneeded" event trigger offer generation</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">onnegotiationneeded </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">createOffer</span><span class="pun">().</span><span class="kwd">then</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">offer</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">setLocalDescription</span><span class="pun">(</span><span class="pln">offer</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">})</span><span class="pln">
        </span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="com">// send the offer to the other peer</span><span class="pln">
            signalingChannel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">({</span><span class="pln"> </span><span class="str">"sdp"</span><span class="pun">:</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">localDescription </span><span class="pun">}));</span><span class="pln">
        </span><span class="pun">})</span><span class="pln">
        </span><span class="pun">.</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">logError</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isInitiator</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// create data channel and setup chat</span><span class="pln">
        channel </span><span class="pun">=</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">createDataChannel</span><span class="pun">(</span><span class="str">"chat"</span><span class="pun">);</span><span class="pln">
        setupChat</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// setup chat on incoming data channel</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">ondatachannel </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            channel </span><span class="pun">=</span><span class="pln"> evt</span><span class="pun">.</span><span class="pln">channel</span><span class="pun">;</span><span class="pln">
            setupChat</span><span class="pun">();</span><span class="pln">
        </span><span class="pun">};</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

signalingChannel</span><span class="pun">.</span><span class="pln">onmessage </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">pc</span><span class="pun">)</span><span class="pln">
        start</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> message </span><span class="pun">=</span><span class="pln"> JSON</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="pln">evt</span><span class="pun">.</span><span class="pln">data</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">sdp</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">var</span><span class="pln"> desc </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCSessionDescription</span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">sdp</span><span class="pun">);</span><span class="pln">

        </span><span class="com">// if we get an offer, we need to reply with an answer</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">desc</span><span class="pun">.</span><span class="pln">type </span><span class="pun">==</span><span class="pln"> </span><span class="str">"offer"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            pc</span><span class="pun">.</span><span class="pln">setRemoteDescription</span><span class="pun">(</span><span class="pln">desc</span><span class="pun">).</span><span class="kwd">then</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                </span><span class="kwd">return</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">createAnswer</span><span class="pun">();</span><span class="pln">
            </span><span class="pun">})</span><span class="pln">
            </span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">answer</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                </span><span class="kwd">return</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">setLocalDescription</span><span class="pun">(</span><span class="pln">answer</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">})</span><span class="pln">
            </span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                signalingChannel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">({</span><span class="pln"> </span><span class="str">"sdp"</span><span class="pun">:</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">localDescription </span><span class="pun">}));</span><span class="pln">
            </span><span class="pun">})</span><span class="pln">
            </span><span class="pun">.</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">logError</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln">
            pc</span><span class="pun">.</span><span class="pln">setRemoteDescription</span><span class="pun">(</span><span class="pln">desc</span><span class="pun">).</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">logError</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">addIceCandidate</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCIceCandidate</span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">candidate</span><span class="pun">)).</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">logError</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> setupChat</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    channel</span><span class="pun">.</span><span class="pln">onopen </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// e.g. enable send button</span><span class="pln">
        enableChat</span><span class="pun">(</span><span class="pln">channel</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">

    channel</span><span class="pun">.</span><span class="pln">onmessage </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        showChatMessage</span><span class="pun">(</span><span class="pln">evt</span><span class="pun">.</span><span class="pln">data</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> sendChatMessage</span><span class="pun">(</span><span class="pln">msg</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    channel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">msg</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> logError</span><span class="pun">(</span><span class="pln">error</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    log</span><span class="pun">(</span><span class="pln">error</span><span class="pun">.</span><span class="pln">name </span><span class="pun">+</span><span class="pln"> </span><span class="str">": "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> error</span><span class="pun">.</span><span class="pln">message</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></pre></div>
      </div><!--div>
    <p>This simple example shows how configure two RTCDataChannel objects for different purposes.</p>
<p><pre  xml:space="preserve"  class='example highlight'>
// the chat channel is reliable and not as prioritized as game data
var chatChan = peerConn.createDataChannel("chat", { "priority": 1 });

// the game data channel is prioritized and unreliable low latency channel for high performance
var gameDataChan = peerConn.createDataChannel("data", { "reliable": false, "priority": 10 });
    </pre></p>
  </div-->
    </section>

    <section property="bibo:hasPart" resource="#call-flow-browser-to-browser" typeof="bibo:Chapter" id="call-flow-browser-to-browser">
      <h3 resource="#h-call-flow-browser-to-browser" id="h-call-flow-browser-to-browser"><span property="xhv:role" resource="xhv:heading"><span class="secno">10.4 </span>Call Flow Browser to Browser</span></h3>

      <div class="note"><div id="h-note17" role="heading" aria-level="4" class="note-title"><span>Note</span></div><p class="">Editors' Note: This example flow needs to be discussed on
      the list and is likely wrong in many ways.</p></div>

      <p>This shows an example of one possible call flow between two browsers.
      This does not show the procedure to get access to local media or every
      callback that gets fired but instead tries to reduce it down to only show
      the key events and messages.</p>

      <p><img alt="A message sequence chart detailing a call flow between two browsers" src="images/ladder-2party-simple.svg" style="width:100%"></p><!--
      <p>The following flow shows a more complete set of the callbacks and
      events that happen.</p>

      <p><img alt=
      "A more complete message sequence chart detailing a call flow between two browsers"
      src="images/ladder-2party-full.svg" style="width:100%"></p>
      -->
    </section>

    <section property="bibo:hasPart" resource="#dtmf-example" typeof="bibo:Chapter" id="dtmf-example">
      <h3 resource="#h-dtmf-example" id="h-dtmf-example"><span property="xhv:role" resource="xhv:heading"><span class="secno">10.5 </span>DTMF Example</span></h3>

      <p>Examples assume that <var>pc</var> is a connected RTCPeerConnection,
      and <var>track</var> is an audio track on that connection.</p>

      <p>Sending the DTMF signal "1234" with 500 ms duration per tone:</p>
      <div class="example"><div class="example-title"><span>Example 7</span></div><pre style="" class="example highlight prettyprint prettyprinted" xml:space="preserve"><span class="kwd">var</span><span class="pln"> sender </span><span class="pun">=</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">createDTMFSender</span><span class="pun">(</span><span class="pln">track</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sender</span><span class="pun">.</span><span class="pln">canInsertDTMF</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> duration </span><span class="pun">=</span><span class="pln"> </span><span class="lit">500</span><span class="pun">;</span><span class="pln">
    sender</span><span class="pun">.</span><span class="pln">insertDTMF</span><span class="pun">(</span><span class="str">"1234"</span><span class="pun">,</span><span class="pln"> duration</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln">
    log</span><span class="pun">(</span><span class="str">"DTMF function not available"</span><span class="pun">);</span></pre></div>

      <p>Send the DTMF signal "1234", and light up the active key using
      <code>lightKey(key)</code> while the tone is playing (assuming that
      <code>lightKey("")</code> will darken all the keys):</p>
      <div class="example"><div class="example-title"><span>Example 8</span></div><pre style="" class="example highlight prettyprint prettyprinted" xml:space="preserve"><span class="kwd">var</span><span class="pln"> sender </span><span class="pun">=</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">createDTMFSender</span><span class="pun">(</span><span class="pln">track</span><span class="pun">);</span><span class="pln">
sender</span><span class="pun">.</span><span class="pln">ontonechange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">e</span><span class="pun">.</span><span class="pln">tone</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// light up the key when playout starts</span><span class="pln">
    lightKey</span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">tone</span><span class="pun">);</span><span class="pln">
    </span><span class="com">// turn off the light after tone duration</span><span class="pln">
    setTimeout</span><span class="pun">(</span><span class="pln">lightKey</span><span class="pun">,</span><span class="pln"> sender</span><span class="pun">.</span><span class="pln">duration</span><span class="pun">,</span><span class="pln"> </span><span class="str">""</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
sender</span><span class="pun">.</span><span class="pln">insertDTMF</span><span class="pun">(</span><span class="str">"1234"</span><span class="pun">);</span></pre></div>

      <p>Send a 1-second "1" tone followed by a 2-second "2" tone:</p>
      <div class="example"><div class="example-title"><span>Example 9</span></div><pre style="" class="example highlight prettyprint prettyprinted" xml:space="preserve"><span class="kwd">var</span><span class="pln"> sender </span><span class="pun">=</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">createDTMFSender</span><span class="pun">(</span><span class="pln">track</span><span class="pun">);</span><span class="pln">
sender</span><span class="pun">.</span><span class="pln">ontonechange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">tone </span><span class="pun">==</span><span class="pln"> </span><span class="str">"1"</span><span class="pun">)</span><span class="pln">
        sender</span><span class="pun">.</span><span class="pln">insertDTMF</span><span class="pun">(</span><span class="str">"2"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2000</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
sender</span><span class="pun">.</span><span class="pln">insertDTMF</span><span class="pun">(</span><span class="str">"1"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1000</span><span class="pun">);</span></pre></div>

      <p>It is always safe to append to the tone buffer. This example appends
      before any tone playout has started as well as during playout.</p>
      <div class="example"><div class="example-title"><span>Example 10</span></div><pre style="" class="example highlight prettyprint prettyprinted" xml:space="preserve"><span class="kwd">var</span><span class="pln"> sender </span><span class="pun">=</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">createDTMFSender</span><span class="pun">(</span><span class="pln">track</span><span class="pun">);</span><span class="pln">
sender</span><span class="pun">.</span><span class="pln">insertDTMF</span><span class="pun">(</span><span class="str">"123"</span><span class="pun">);</span><span class="pln">
</span><span class="com">// append more tones to the tone buffer before playout has begun</span><span class="pln">
sender</span><span class="pun">.</span><span class="pln">insertDTMF</span><span class="pun">(</span><span class="pln">sender</span><span class="pun">.</span><span class="pln">toneBuffer </span><span class="pun">+</span><span class="pln"> </span><span class="str">"456"</span><span class="pun">);</span><span class="pln">

sender</span><span class="pun">.</span><span class="pln">ontonechange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">tone </span><span class="pun">==</span><span class="pln"> </span><span class="str">"1"</span><span class="pun">)</span><span class="pln">
        </span><span class="com">// append more tones when playout has begun</span><span class="pln">
        sender</span><span class="pun">.</span><span class="pln">insertDTMF</span><span class="pun">(</span><span class="pln">sender</span><span class="pun">.</span><span class="pln">toneBuffer </span><span class="pun">+</span><span class="pln"> </span><span class="str">"789"</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span></pre></div>

      <p>Send the DTMF signal "123" and abort after sending "2".</p>
      <div class="example"><div class="example-title"><span>Example 11</span></div><pre style="" class="example highlight prettyprint prettyprinted" xml:space="preserve"><span class="kwd">var</span><span class="pln"> sender </span><span class="pun">=</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">createDTMFSender</span><span class="pun">(</span><span class="pln">track</span><span class="pun">);</span><span class="pln">
sender</span><span class="pun">.</span><span class="pln">ontonechange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">tone </span><span class="pun">==</span><span class="pln"> </span><span class="str">"2"</span><span class="pun">)</span><span class="pln">
        </span><span class="com">// empty the buffer to not play any tone after "2"</span><span class="pln">
        sender</span><span class="pun">.</span><span class="pln">insertDTMF</span><span class="pun">(</span><span class="str">""</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
sender</span><span class="pun">.</span><span class="pln">insertDTMF</span><span class="pun">(</span><span class="str">"123"</span><span class="pun">);</span></pre></div>
    </section><!--
    <section>
      <h3>Call Flow Browser to MCU</h3>

      <p class="note">Editors' Note: This example flow needs to be discussed on
      the list and is likely wrong in many ways.</p>

      <p>This shows an example of one possible call flow between a centralized
      conferencing server and a browser. This does not show every callback that
      gets fired but instead tries to reduce it down to only show the key
      events and messages.</p>

      <p><img alt=
      "A message sequence chart detailing a call flow between a browser and a centralized conferencing server"
      src="images/ladder-mcu-simple.svg" style="width:100%"></p>
    </section>
-->
  </section>

  <section property="bibo:hasPart" resource="#event-summary" typeof="bibo:Chapter" id="event-summary" class="informative">
    <!--OddPage--><h2 resource="#h-event-summary" id="h-event-summary"><span property="xhv:role" resource="xhv:heading"><span class="secno">11. </span>Event summary</span></h2><p><em>This section is non-normative.</em></p>

    <p>The following events fire on <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code>
    objects:</p>

    <table style="border-width:0; width:60%" border="1">
      <tbody><tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      </tbody><tbody>
        <tr>
          <td><dfn id="event-datachannel-open"><code>open</code></dfn></td>

          <td><code><a class="internalDFN" href="#dfn-event">Event</a></code></td>

          <td>
            The <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object's <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data
            transport</a> has been established (or re-established).
          </td>
        </tr>

        <tr>
          <td><dfn id="event-datachannel-message"><code>MessageEvent</code></dfn></td>

          <td><code><a class="internalDFN" href="#dfn-event">Event</a></code></td>

          <td>A message was successfully received. TODO: Ref where MessageEvent
          is defined?</td>
        </tr>

        <tr>
          <td><dfn id="event-datachannel-error"><code>error</code></dfn></td>

          <td><code><a class="internalDFN" href="#dfn-event">Event</a></code></td>

          <td>TODO.</td>
        </tr>

        <tr>
          <td><dfn id="event-datachannel-close"><code>close</code></dfn></td>

          <td><code><a class="internalDFN" href="#dfn-event">Event</a></code></td>

          <td>
            The <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> object's <a class="internalDFN" href="#dfn-underlying-data-transport">underlying data
            transport</a> has bee closed.
          </td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a class="idlType" href="#idl-def-RTCPeerConnection"><code>RTCPeerConnection</code></a></code>
    objects:</p>

    <table style="border-width:0; width:60%" border="1">
      <tbody><tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      </tbody><tbody>
        <tr>
          <td><dfn id="event-mediastream-connecting"><code>connecting</code></dfn></td>

          <td><code>Event</code></td>

          <td>TODO</td>
        </tr><!--
        <tr>
          <td><dfn title="event-MediaStream-error"><code>error</code></dfn></td>
          <td><code>Event</code></td>
          <td></td>
        </tr>
        <tr>
          <td><dfn title="event-MediaStream-close"><code>close</code></dfn></td>
          <td><code>Event</code></td>
          <td>The <code title="dom-RTCPeerConnection-close">close()</code> method was
            called. </td>
        </tr>
        <tr>
          <td>
            <dfn id="event-mediastream-message">
              <code>message</code>
            </dfn>
          </td>

          <td>
            <code>MessageEvent</code>
          </td>

          <td>A <a href="#data-udp-media-stream">data UDP media
          stream</a> message was received.</td>
        </tr>
        -->

        <tr>
          <td><dfn id="event-mediastream-addstream"><code>addstream</code></dfn></td>

          <td><code><a class="idlType" href="#idl-def-MediaStreamEvent"><code>MediaStreamEvent</code></a></code></td>

          <td>
            A new stream has been added to the <a href="#remote-streams-set">remote streams set</a>.
          </td>
        </tr>

        <tr>
          <td><dfn id="event-mediastream-removestream"><code>removestream</code></dfn></td>

          <td><code><a class="idlType" href="#idl-def-MediaStreamEvent"><code>MediaStreamEvent</code></a></code></td>

          <td>
            A stream has been removed from the <a href="#remote-streams-set">remote streams set</a>.
          </td>
        </tr>

        <tr>
          <td><dfn id="event-negotiation"><code>negotiationneeded</code></dfn></td>

          <td><code><a class="internalDFN" href="#dfn-event">Event</a></code></td>

          <td>The browser wishes to inform the application that session
          negotiation needs to be done at some point in the near future.</td>
        </tr>

        <tr>
          <td><dfn id="event-signalingstatechange"><code>signalingstatechange</code></dfn></td>

          <td><code><a class="internalDFN" href="#dfn-event">Event</a></code></td>

          <td>
            The <a href="#dom-peerconnection-signaling-state"><code>RTCPeerConnection</code>
            signalingState</a> has changed. This state change is the result of
            either <code><a href="#dom-peerconnection-setlocaldescription">setLocalDescription()</a></code>
            or <code><a href="#dom-peerconnection-setremotedescription">setRemoteDescription()</a></code>
            being invoked.
          </td>
        </tr>

        <tr>
          <td><dfn id="event-iceconnectionstatechange"><code>iceconnectionstatechange</code></dfn></td>

          <td><code><a class="internalDFN" href="#dfn-event">Event</a></code></td>

          <td>
            The <a href="#dom-peerconnection-ice-connection-state"><code>RTCPeerConnection</code>
            ice connection state</a> has changed.
          </td>
        </tr>

        <tr>
          <td><dfn id="event-icegatheringstatechange"><code>icegatheringstatechange</code></dfn></td>

          <td><code><a class="internalDFN" href="#dfn-event">Event</a></code></td>

          <td>
            The <a href="#dom-peerconnection-ice-gathering-state"><code>RTCPeerConnection</code>
            ice gathering state</a> has changed.
          </td>
        </tr>

        <tr>
          <td><dfn id="event-icecandidate"><code>icecandidate</code></dfn></td>

          <td><code><a class="idlType" href="#idl-def-RTCPeerConnectionIceEvent"><code>RTCPeerConnectionIceEvent</code></a></code></td>

          <td>A new <code><a class="idlType" href="#idl-def-RTCIceCandidate"><code>RTCIceCandidate</code></a></code> is made available to
          the script.</td>
        </tr>

        <tr>
          <td><dfn id="event-datachannel"><code>datachannel</code></dfn></td>

          <td><code><a class="idlType" href="#idl-def-RTCDataChannelEvent"><code>RTCDataChannelEvent</code></a></code></td>

          <td>A new <code><a class="idlType" href="#idl-def-RTCDataChannel"><code>RTCDataChannel</code></a></code> is dispatched to the
          script in response to the other peer creating a channel.</td>
        </tr>

        <tr>
          <td><dfn id="event-isolationchange"><code>isolationchange</code></dfn></td>

          <td><code><a class="internalDFN" href="#dfn-event">Event</a></code></td>

          <td>A new <code><a class="internalDFN" href="#dfn-event">Event</a></code> is dispatched to the script when
          the <var>isolated</var> attribute on a <code>MediaStreamTrack</code>
          changes.</td>
        </tr>

        <tr>
          <td><dfn id="event-identityresult"><code>identityresult</code></dfn></td>

          <td><code><a class="idlType" href="#idl-def-RTCIdentityEvent"><code>RTCIdentityEvent</code></a></code></td>

          <td>A new <code><a class="idlType" href="#idl-def-RTCIdentityEvent"><code>RTCIdentityEvent</code></a></code> is dispatched to the
          script when an identity assertion is successfully generated by an
          IdP.</td>
        </tr>

        <tr>
          <td><code id="event-peeridentity">peeridentity</code></td>

          <td><code><a class="internalDFN" href="#dfn-event">Event</a></code></td>

          <td>A new <code><a class="internalDFN" href="#dfn-event">Event</a></code> is dispatched to the script when
          an identity assertion provided by a peer is successfully
          validated.</td>
        </tr>

        <tr>
          <td><dfn id="event-idpassertionerror"><code>idpassertionerror</code></dfn></td>

          <td><code><a class="idlType" href="#idl-def-RTCIdentityErrorEvent"><code>RTCIdentityErrorEvent</code></a></code></td>

          <td>A new <code><a class="idlType" href="#idl-def-RTCIdentityErrorEvent"><code>RTCIdentityErrorEvent</code></a></code> is dispatched to
          the script when an IdP encounters an error while generating an
          identity assertion.</td>
        </tr>

        <tr>
          <td><dfn id="event-idpvalidationerror"><code>idpvalidationerror</code></dfn></td>

          <td><code><a class="idlType" href="#idl-def-RTCIdentityErrorEvent"><code>RTCIdentityErrorEvent</code></a></code></td>

          <td>A new <code><a class="idlType" href="#idl-def-RTCIdentityErrorEvent"><code>RTCIdentityErrorEvent</code></a></code> is dispatched to
          the script when an IdP encounters an error while validating an
          identity assertion.</td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDTMFSender</code></a></code>
    objects:</p>

    <table style="border-width:0; width:60%" border="1">
      <tbody><tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      </tbody><tbody>
        <tr>
          <td><dfn id="event-RTCDTMFSender-tonechange"><code>tonechange</code></dfn></td>

          <td><code><a class="internalDFN" href="#dfn-event">Event</a></code></td>

          <td>The <code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDTMFSender</code></a></code> object has either just
          begun playout of a tone (returned as the <code><a class="internalDFN" href="#dom-tonechangeevent-tone">tone</a></code>
          attribute) or just ended playout of a tone (returned as an empty
          value in the <code><a class="internalDFN" href="#dom-tonechangeevent-tone">tone</a></code> attribute).</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section property="bibo:hasPart" resource="#security-considerations" typeof="bibo:Chapter" id="security-considerations">
    <!--OddPage--><h2 resource="#h-security-considerations" id="h-security-considerations"><span property="xhv:role" resource="xhv:heading"><span class="secno">12. </span>Security Considerations</span></h2>

    <p>TBD</p>
  </section><!--section>
    <h2 id="sec-iana">IANA Registrations</h2>



    <p>IANA is requested to register the constraints defined in <a href=
    "#sec-constraints">Constraints Section</a> as specified in
    [[!RTCWEB-CONSTRAINTS]].</p>


    <section>
      <h3 id="sec-constraints">Constraints</h3>


      <p>TOOD: Need to change the naming and declaration of these constraints
      to match the constraints draft once that is a bit further along. The
      names here now are likely not quite right but they serve as a place
      holder.</p>


      <p class="issue">ISSUE: there are multiple ways to add constraints. How
      are multiple values reconciled?</p>


      <p>The following new constraints are defined that can be used with an
      <code>RTCPeerConnection</code> object:</p>


      <p>TODO items - need to register with IANA.</p>
    </section>
  </section-->

  <section property="bibo:hasPart" resource="#change-log" typeof="bibo:Chapter" id="change-log">
    <!--OddPage--><h2 resource="#h-change-log" id="h-change-log"><span property="xhv:role" resource="xhv:heading"><span class="secno">13. </span>Change Log</span></h2>

    <p>This section will be removed before publication.</p>
    <!-- Why do the first two headings automatically convert to <h2>? -->
    <!-- Because you haven't added a <section> element around them
         and respec rewrites h? elements based on the section depth -->

    <h2 id="changes-since-december-5-2014">Changes since December 5, 2014</h2>

    <ol>
      <li>Update misleading local/RemoteDescription attribute text.</li>

      <li>Add RTCBundlePolicy.</li>
      
      <li>All callback-based methods have been moved to a legacy section, and
      replaced by same-named overloads using Promises instead.</li>

      <!-- put some random merge tag and put your change log entry after
      that. This reduces the odds of merge conflicts when we merge the pull
      request --> 
      
      <!-- merge tag A -->
      <!-- merge tag B -->
      <!-- merge tag C -->
      <!-- merge tag D -->
      <!-- merge tag E -->
      <!-- merge tag F -->
      <!-- merge tag G -->
      <!-- merge tag H -->
      <!-- merge tag I -->
      <!-- merge tag J -->
      <!-- merge tag H -->
      <!-- merge tag K -->
      <!-- merge tag L -->
      <!-- merge tag M -->
      <!-- merge tag N -->
      <!-- merge tag O -->
      <!-- merge tag P -->
      <!-- merge tag R -->
      <!-- merge tag S -->
      <!-- merge tag T -->
      <!-- merge tag Q -->
      <!-- merge tag U -->
      <!-- merge tag V -->
      <!-- merge tag W -->
    </ol>

    <h2 id="changes-since-june-4-2014">Changes since June 4, 2014</h2>

    <ol>
      <li>Bug 25724: Allow garbage collection of closed PeerConnections</li>

      <li>Bug 27214: Add onicegatheringstatechange event</li>
    </ol>

    <h3 id="changes-since-april-10-2014">Changes since April 10, 2014</h3>

    <ol>
      <li>Bug 25774: Mixed isolation</li>
    </ol>

    <h3 id="changes-since-april-10-2014-1">Changes since April 10, 2014</h3>

    <ol>
      <li>Bug 25855: Clarification about conformance requirements phrased as
      algorithms</li>

      <li>Bug 25892: SignalingStateChange event should be fired only if there
      is a change in signaling state.</li>

      <li>Bug 25152: createObjectURL used in examples is no longer supported by
      Media Capture and Streams.</li>

      <li>Bug 25976: DTMFSender.insertDTMF steps should validate the values of
      duration and interToneGap.</li>

      <li>Bug 25189: Mandatory errorCallback is missing in examples for
      getStats.</li>

      <li>Bug 25840: Creating DataChannel with same label.</li>

      <li>Updated comment above example ice state transitions (discussed in Bug
      25257).</li>

      <li>Updated insertDTMF() algorithm to ignore unrecognized characters (as
      discussed in bug 25977).</li>

      <li>Made formatting of references to ice connection state
      consistent.</li>

      <li>Made insertDTMF() throw on unrecognized characters (used to
      ignore).</li>

      <li>Removed requestIdentity from RTCConfiguration and
      RTCOfferAnswerOptions. Removed RTCOfferAnswerOptions as a result.</li>

      <li>Adding isolated property and associated event to
      MediaStreamTrack.</li>
    </ol>

    <h3 id="changes-since-march-21-2014">Changes since March 21, 2014</h3>

    <ol>
      <li>Changes to identity-related text:

        <ul>
          <li>Removed noaccess constraint</li>

          <li>Add the ability to peerIdentity constrain RTCPeerConnection,
          which limits communication to a single peer</li>

          <li>Change the way that the browser communicates with IdP to a
          message channel
          (http://www.w3.org/TR/webmessaging/#message-channels)</li>

          <li>Improved error feedback from IdP interactions (added new events
          with more detailed context)</li>

          <li>Changed the way that an IdP is able to request user login
          (LOGINNEEDED message)</li>
        </ul>
      </li>

      <li>Bug 25155: maxRetransmitTime is not the name of the SCTP concept it
      points to.</li>
    </ol>

    <h3 id="changes-since-january-27-2014">Changes since January 27, 2014</h3>

    <ol>
      <li>Refined identity assertion generation and validation.</li>

      <li>Default DTMF gap changed from 50 to 70 ms.</li>

      <li>Bug 24875: Examples in the WebRTC spec are not updated As per the
      modified API.</li>
    </ol>

    <h3 id="changes-since-august-30-2013">Changes since August 30, 2013</h3>

    <ol>
      <li>Make RTCPeerConnection close method be idempotent.</li>

      <li>Clarified ICE server configuration could contain URI types other than
      STUN and TURN.</li>

      <li>Changed the DTMF timing values.</li>

      <li>Allow offerToReceiveAudio/video indicate number of streams to
      offer.</li>

      <li>ACTION-98: Added text about clamping of maxRetransmitTime and
      maxRetransmits.</li>

      <li>ACTION-88: Removed nullable types from dictionaries (added attribute
      default values for attributes that would be left uninitialized without
      the init dictionary present.</li>

      <li>InvalidMediaStreamTrackError changed to InvalidParameter.</li>

      <li>Fire NetworkError when the data transport is closed with an
      error.</li>

      <li>Add an exception for data channel with trying to use existing
      code.</li>

      <li>Change maxRetransmits to be an unsigned type.</li>

      <li>Clarify state changes when ICE restarts.</li>

      <li>Added InvalidStateError exception for operations on a
      RTCPeerConnection that is closed.</li>

      <li>Major changes to Identity Proxy section.</li>

      <li>(ACTION: 95) Moved IceTransports (constraint) to RTCConfiguration
      dictionary.</li>

      <li>(ACTION: 95) Introduced RTCOfferAnswerOptions and RTCOfferOptions
      dictionaries.</li>

      <li>(ACTION: 95) Removed constraints argument from addStream() (and
      removed IANA Constraints section).</li>

      <li>Added validation of the RTCConfiguration dictionary argument(s).</li>

      <li>Added getConfiguration() on RTCPeerConnection.</li>
    </ol>

    <h3 id="changes-since-june-3-2013">Changes since June 3, 2013</h3>

    <ol>
      <li>Removed synchronous section left-overs.</li>

      <li>RTCIceServer now accepts multiple URLs.</li>

      <li>Redefined the meaning of negotiated for DataChannel.</li>

      <li>Made iceServers a sequence (instead of an Array).</li>

      <li>Updated error reporting (to use DOMError and camel cased names).</li>

      <li>Added success and failure callbacks to addIceCandidate().</li>

      <li>Made local/remoteDescription attributes nullable.</li>

      <li>Added username member to RTCIceServer dictionary.</li>
    </ol>

    <h3 id="changes-since-march-22-2013">Changes since March 22, 2013</h3>

    <ol>
      <li>Added IceRestart constraint.</li>

      <li>Big updates on DataChannel API to use new channel setup
      procedures.</li>
    </ol>

    <h3 id="changes-since-feb-22-2013">Changes since Feb 22, 2013</h3>

    <ol>
      <li>Example review: Updated DTMF and Stats examples. Added text about
      when to fire "negotiationneeded" event to align with examples.</li>

      <li>Updated RTCPeerConnection state machine. Added a shared processing
      model for setLocalDescription()/setRemoteDescription().</li>

      <li>Updated simple callflow to match the current API.</li>
    </ol>

    <h3 id="changes-since-jan-16-2013">Changes since Jan 16, 2013</h3>

    <ol>
      <li>Initial import of Statistics API to version 2.</li>

      <li>Integration of Statistics API version 2.5 started.</li>

      <li>Updated Statistics API to match Boston/list discussions.</li>

      <li>Extracted API extensions introduced by features, such as the P2P Data
      API, from the RTCPeerConnection API.</li>

      <li>Updated DTMF algorithm to dispatch an event when insertDTMF() is
      called with an empty string to cancel future tones.</li>

      <li>Updated DTMF algorithm to not cancel and reschedule if a playout task
      is running (only update toneBuffer and other values).</li>
    </ol>

    <h3 id="changes-since-dec-12-2012">Changes since Dec 12, 2012</h3>

    <ol>
      <li>Changed AudioMediaStreamTrack to RTCDTMFSender and gave it its own
      section. Updated text to reflect most recent agreements. Also added
      examples section.</li>

      <li>Replaced the localStreams and remoteStreams attributes with functions
      returning sequences of MediaStream objects.</li>

      <li>Added spec text for attributes and methods adopted from the WebSocket
      interface.</li>

      <li>Changed the state ENUMs and transition diagrams.</li>

      <li>Aligned the data channel processing model a bit more with WebSockets
      (mainly closing the underlying transport).</li>
    </ol>

    <h3 id="changes-since-nov-13-2012">Changes since Nov 13, 2012</h3>

    <ol>
      <li>Made some clarifications as to how operation queuing works, and fixed
      a few errors with the error handling description.</li>

      <li>Introduced new representation of tracks in a stream (removed
      MediaStreamTrackList). Added algorithm for creating a track to represent
      an incoming network media component.</li>

      <li>Renamed MediaStream.label to MediaStream.id (the definition needs
      some more work).</li>
    </ol>

    <h3 id="changes-since-nov-03-2012">Changes since Nov 03, 2012</h3>

    <ol>
      <li>Added text describing the queuing mechanism for
      RTCPeerConnection.</li>

      <li>Updated simple P2P example to include all mandatory (error)
      callbacks.</li>

      <li>Updated P2P data example to include all mandatory (error) callbacks.
      Also added some missing RTC prefixes.</li>
    </ol>

    <h3 id="changes-since-oct-19-2012">Changes since Oct 19, 2012</h3>

    <ol>
      <li>Clarified how createOffer() and createAnswer() use their
      callbacks.</li>

      <li>Made all failure callbacks mandatory.</li>

      <li>Added error object types, general error handling principles, and
      rules for when errors should be thrown.</li>
    </ol>

    <h3 id="changes-since-sept-23-2012">Changes since Sept 23, 2012</h3>

    <ol>
      <li>Restructured the document layout and created separate sections for
      features like Peer-to-peer Data API, Statistics and Identity.</li>
    </ol>

    <h3 id="changes-since-aug-16-2012">Changes since Aug 16, 2012</h3>

    <ol>
      <li>Replaced stringifier with serializer on RTCSessionDescription and
      RTCIceCandidate (used when JSON.stringify() is called).</li>

      <li>Removed offer and createProvisionalAnswer arguments from the
      createAnswer() method.</li>

      <li>Removed restart argument from the updateIce() method.</li>

      <li>Made RTCDataChannel an EventTarget</li>

      <li>Updated simple RTCPeerConnection example to match spec changes.</li>

      <li>Added section about RTCDataChannel garbage collection.</li>

      <li>Added stuff for identity proxy.</li>

      <li>Added stuff for stats.</li>

      <li>Added stuff peer and ice state reporting.</li>

      <li>Minor changes to sequence diagrams.</li>

      <li>Added a more complete RTCDataChannel example</li>

      <li>Various fixes from Dan's Idp API review.</li>

      <li>Patched the Stats API.</li>
    </ol>

    <h3 id="changes-since-aug-13-2012">Changes since Aug 13, 2012</h3>

    <ol>
      <li>Made the RTCSessionDescription and RTCIceCandidate constructors take
      dictionaries instead of a strings. Also added detailed stringifier
      algorithm.</li>

      <li>Went through the list of issues (issue numbers are only valid with
      HEAD at fcda53c460). Closed (fixed/wontfix): 1, 8, 10, 13, 14, 16, 18,
      19, 22, 23, 24. Converted to notes: 4, 12. Updated: 9.</li>

      <li>Incorporate <a href="http://lists.w3.org/Archives/Public/www-archive/2012Aug/0015.html">changes
      proposed</a> by Li Li.
      </li>

      <li>Use an enum for DataChannelState and fix IDLs where using an optional
      argument also requires all previous optional arguments to have a default
      value.</li>
    </ol>

    <h3 id="changes-since-jul-20-2012">Changes since Jul 20, 2012</h3>

    <ol>
      <li>Added RTC Prefix to names (including the notes below).</li>

      <li>Moved to new definition of configuration and ice servers object.</li>

      <li>Added correlating lines to candidate structure.</li>

      <li>Converted setLocalDescription and setRemoteDescription to be
      asynchronous.</li>

      <li>Added call flows.</li>
    </ol>

    <h3 id="changes-since-jul-13-2012">Changes since Jul 13, 2012</h3>

    <ol>
      <li>Removed peer attribute from RTCPeerConnectionIceEvent (duplicates
      functionality of Event.target attribute).</li>

      <li>Removed RTCIceCandidateCallback (no longer used).</li>

      <li>Removed RTCPeerConnectionEvent (we use a simple event instead).</li>

      <li>Removed RTCSdpType argument from setLocalDescription() and
      setRemoteDescription(). Updated simple example to match.</li>
    </ol>

    <h3 id="changes-since-may-28-2012">Changes since May 28, 2012</h3>

    <ol>
      <li>Changed names to use RTC Prefix.</li>

      <li>Changed the data structure used to pass in STUN and TURN servers in
      configuration.</li>

      <li>Updated simple RTCPeerConnection example (RTCPeerConnection
      constructor arguments; use icecandidate event).</li>

      <li>Initial import of new Data API.</li>

      <li>Removed some left-overs from the old Data Stream API.</li>

      <li>Renamed "underlying data channel" to "underlying data transport".
      Fixed closing procedures. Fixed some typos.</li>
    </ol>

    <h3 id="changes-since-april-27-2012">Changes since April 27, 2012</h3>

    <ol>
      <li>Major rewrite of RTCPeerConnection section to line up with IETF JSEP
      draft.</li>

      <li>Added simple RTCPeerConnection example. Initial update of
      RTCSessionDescription and RTCIceCandidate to support serialization and
      construction.</li>
    </ol>

    <h3 id="changes-since-21-april-2012">Changes since 21 April 2012</h3>

    <ol>
      <li>Moved MediaStream and related definitions to getUserMedia.</li>

      <li>Removed section "Obtaining local multimedia content".</li>

      <li>Updated getUserMedia() calls in examples (changes in Media Capture TF
      spec).</li>

      <li>Introduced MediaStreamTrackList interface with support for adding and
      removing tracks.</li>

      <li>Updated the algorithm that is run when RTCPeerConnection receives a
      stream (create new stream when negotiated instead of when data
      arrives).</li>
    </ol>

    <h3 id="changes-since-12-january-2012">Changes since 12 January 2012</h3>

    <ol>
      <li>Clarified the relation of Stream, Track, and Channel.</li>
    </ol>

    <h3 id="changes-since-17-october-2011">Changes since 17 October 2011</h3>

    <ol>
      <li>Tweak the introduction text and add a reference to the IETF RTCWEB
      group.</li>

      <li>Changed the first argument to getUserMedia to be an object.</li>

      <li>Added a MediaStreamHints object as a second argument to
      RTCPeerConnection.addStream.</li>

      <li>Added AudioMediaStreamTrack class and DTMF interface.</li>
    </ol>

    <h3 id="changes-since-23-august-2011">Changes since 23 August 2011</h3>

    <ol>
      <li>Separated the SDP and ICE Agent into separate agents and added
      explicit state attributes for each.</li>

      <li>Removed the send method from PeerConenction and associated callback
      function.</li>

      <li>Modified MediaStream() constructor to take a list of MediaStreamTrack
      objects instead of a MediaStream. Removed text about MediaStream parent
      and child relationship.</li>

      <li>Added abstract.</li>

      <li>Moved a few paragraphs from the MediaStreamTrack.label section to the
      MediaStream.label section (where they belong).</li>

      <li>Split MediaStream.tracks into MediaStream.audioTracks and
      MediaStream.videoTracks.</li>

      <li>Removed a sentence that implied that track access is limited to
      LocalMediaStream.</li>

      <li>Updated a few getUserMedia()-examples to use MediaStreamOptions.</li>

      <li>Replaced calls to URL.getObjectURL() with URL.createObjectURL() in
      example code.</li>

      <li>Fixed some broken getUserMedia() links.</li>

      <li>Introduced state handling on MediaStreamTrack (removed state handling
      from MediaStream).</li>

      <li>Reintroduced onended on MediaStream to simplify checking if all
      tracks are ended.</li>

      <li>Aligned the MediaStreamTrack ended event dispatching behavior with
      that of MediaStream.</li>

      <li>Updated the LocalMediaStream.stop() algorithm to implicitly use the
      end track algorithm.</li>

      <li>Replaced an occurrence the term finished track with ended track (to
      align with rest of spec).</li>

      <li>Moved (and extended) the explanation about track references and media
      sources from LocalMediaStream to MediaStreamTrack.</li>
    </ol>
  </section>

  <section property="bibo:hasPart" resource="#acknowledgements" typeof="bibo:Chapter" id="acknowledgements" class="appendix">
    <!--OddPage--><h2 resource="#h-acknowledgements" id="h-acknowledgements"><span property="xhv:role" resource="xhv:heading"><span class="secno">A. </span>Acknowledgements</span></h2>

    <p>The editors wish to thank the Working Group chairs and Team Contact,
    Harald Alvestrand, Stefan Håkansson and Dominique
    Hazaël-Massieux, for their support. Substantial text in this
    specification was provided by many people including Martin Thomson, Harald
    Alvestrand, Justin Uberti, and Eric Rescorla.</p>
  </section>


<section property="bibo:hasPart" resource="#references" typeof="bibo:Chapter" id="references" class="appendix"><!--OddPage--><h2 resource="#h-references" id="h-references"><span property="xhv:role" resource="xhv:heading"><span class="secno">B. </span>References</span></h2><section property="bibo:hasPart" resource="#normative-references" typeof="bibo:Chapter" id="normative-references"><h3 resource="#h-normative-references" id="h-normative-references"><span property="xhv:role" resource="xhv:heading"><span class="secno">B.1 </span>Normative references</span></h3><dl resource="" class="bibliography"><dt id="bib-GETUSERMEDIA">[GETUSERMEDIA]</dt><dd>Daniel Burnett; Adam Bergkvist; Cullen Jennings; Anant Narayanan. <a property="dc:requires" href="http://www.w3.org/TR/mediacapture-streams/"><cite>Media Capture and Streams</cite></a>. 3 September 2013. W3C Working Draft. URL: <a property="dc:requires" href="http://www.w3.org/TR/mediacapture-streams/">http://www.w3.org/TR/mediacapture-streams/</a>
</dd><dt id="bib-HIGHRES-TIME">[HIGHRES-TIME]</dt><dd>Jatinder Mann. <a property="dc:requires" href="http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/HighResolutionTime/Overview.html"><cite>High Resolution Time Specification</cite></a>. 18 October 2012. W3C Editor's Draft. URL: <a property="dc:requires" href="http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/HighResolutionTime/Overview.html">http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/HighResolutionTime/Overview.html</a>
</dd><dt id="bib-HTML5">[HTML5]</dt><dd>Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Edward O'Connor; Silvia Pfeiffer. <a property="dc:requires" href="http://www.w3.org/TR/html5/"><cite>HTML5</cite></a>. 28 October 2014. W3C Recommendation. URL: <a property="dc:requires" href="http://www.w3.org/TR/html5/">http://www.w3.org/TR/html5/</a>
</dd><dt id="bib-ICE">[ICE]</dt><dd>J. Rosenberg. <a property="dc:requires" href="https://tools.ietf.org/html/rfc5245"><cite>Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</cite></a>. April 2010. Proposed Standard. URL: <a property="dc:requires" href="https://tools.ietf.org/html/rfc5245">https://tools.ietf.org/html/rfc5245</a>
</dd><dt id="bib-RFC2119">[RFC2119]</dt><dd>S. Bradner. <a property="dc:requires" href="https://tools.ietf.org/html/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>. March 1997. Best Current Practice. URL: <a property="dc:requires" href="https://tools.ietf.org/html/rfc2119">https://tools.ietf.org/html/rfc2119</a>
</dd><dt id="bib-RFC3388">[RFC3388]</dt><dd>G. Camarillo; G. Eriksson; J. Holler; H. Schulzrinne. <a property="dc:requires" href="https://tools.ietf.org/html/rfc3388"><cite>Grouping of Media Lines in the Session Description Protocol (SDP)</cite></a>. December 2002. Proposed Standard. URL: <a property="dc:requires" href="https://tools.ietf.org/html/rfc3388">https://tools.ietf.org/html/rfc3388</a>
</dd><dt id="bib-RFC7064">[RFC7064]</dt><dd>S. Nandakumar; G. Salgueiro; P. Jones; M. Petit-Huguenin. <a property="dc:requires" href="https://tools.ietf.org/html/rfc7064"><cite>URI Scheme for the Session Traversal Utilities for NAT (STUN) Protocol</cite></a>. November 2013. Proposed Standard. URL: <a property="dc:requires" href="https://tools.ietf.org/html/rfc7064">https://tools.ietf.org/html/rfc7064</a>
</dd><dt id="bib-RFC7065">[RFC7065]</dt><dd>M. Petit-Huguenin; S. Nandakumar; G. Salgueiro; P. Jones. <a property="dc:requires" href="https://tools.ietf.org/html/rfc7065"><cite>Traversal Using Relays around NAT (TURN) Uniform Resource Identifiers</cite></a>. November 2013. Proposed Standard. URL: <a property="dc:requires" href="https://tools.ietf.org/html/rfc7065">https://tools.ietf.org/html/rfc7065</a>
</dd><dt id="bib-RTCWEB-ALPN">[RTCWEB-ALPN]</dt><dd>M. Thomson. <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-alpn/"><cite>Application Layer Protocol Negotiation for Web Real-Time Communications</cite></a>. 23 July 2014. Active Internet-Draft. URL: <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-alpn/">http://datatracker.ietf.org/doc/draft-ietf-rtcweb-alpn/</a>
</dd><dt id="bib-RTCWEB-AUDIO">[RTCWEB-AUDIO]</dt><dd>JM. Valin; C. Bran. <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-audio/"><cite>WebRTC Audio Codec and Processing Requirements</cite></a>. 27 January 2014. Active Internet-Draft. URL: <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-audio/">http://datatracker.ietf.org/doc/draft-ietf-rtcweb-audio/</a>
</dd><dt id="bib-RTCWEB-DATA">[RTCWEB-DATA]</dt><dd>R. Jesup; S. Loreto; M. Tuexen. <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-data-channel/"><cite>RTCWeb Data Channels</cite></a>. 21 October 2013. Active Internet-Draft. URL: <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-data-channel/">http://datatracker.ietf.org/doc/draft-ietf-rtcweb-data-channel/</a>
</dd><dt id="bib-RTCWEB-DATA-PROTOCOL">[RTCWEB-DATA-PROTOCOL]</dt><dd>R. Jesup; S. Loreto; M. Tuexen. <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-data-protocol/"><cite>RTCWeb Data Channel Protocol</cite></a>. 21 October 2013. Active Internet-Draft. URL: <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-data-protocol/">http://datatracker.ietf.org/doc/draft-ietf-rtcweb-data-protocol/</a>
</dd><dt id="bib-RTCWEB-JSEP">[RTCWEB-JSEP]</dt><dd>Justin Uberti; Cullen Jennings. <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-jsep/"><cite>Javascript Session Establishment Protocol</cite></a>. 22 October 2013. Active Internet-Draft. URL: <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-jsep/">http://datatracker.ietf.org/doc/draft-ietf-rtcweb-jsep/</a>
</dd><dt id="bib-RTCWEB-RTP">[RTCWEB-RTP]</dt><dd>C. Perkins; M. Westerlund; J. Ott. <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-rtp-usage/"><cite>Web Real-Time Communication (WebRTC): Media Transport and Use of RTP</cite></a>. 16 December 2013. Active Internet-Draft. URL: <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-rtp-usage/">http://datatracker.ietf.org/doc/draft-ietf-rtcweb-rtp-usage/</a>
</dd><dt id="bib-RTCWEB-SECURITY-ARCH">[RTCWEB-SECURITY-ARCH]</dt><dd>Eric Rescorla. <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-security-arch/"><cite>WebRTC Security Architecture</cite></a>. 22 January 2014. Active Internet-Draft. URL: <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-security-arch/">http://datatracker.ietf.org/doc/draft-ietf-rtcweb-security-arch/</a>
</dd><dt id="bib-RTCWEB-TRANSPORT">[RTCWEB-TRANSPORT]</dt><dd>H. Alvestrand. <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-transports/"><cite>Transports for RTCWEB</cite></a>. 22 January 2014. Active Internet-Draft. URL: <a property="dc:requires" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-transports/">http://datatracker.ietf.org/doc/draft-ietf-rtcweb-transports/</a>
</dd><dt id="bib-SDP">[SDP]</dt><dd>J. Rosenberg; H. Schulzrinne. <a property="dc:requires" href="http://tools.ietf.org/html/rfc3264"><cite>An Offer/Answer Model with the Session Description Protocol (SDP)</cite></a>. June 2002. RFC 3264. URL: <a property="dc:requires" href="http://tools.ietf.org/html/rfc3264">http://tools.ietf.org/html/rfc3264</a>
</dd><dt id="bib-WEBIDL">[WEBIDL]</dt><dd>Cameron McCormack. <a property="dc:requires" href="http://www.w3.org/TR/WebIDL/"><cite>Web IDL</cite></a>. 19 April 2012. W3C Candidate Recommendation. URL: <a property="dc:requires" href="http://www.w3.org/TR/WebIDL/">http://www.w3.org/TR/WebIDL/</a>
</dd><dt id="bib-webmessaging">[webmessaging]</dt><dd>Ian Hickson. <a property="dc:requires" href="http://www.w3.org/TR/webmessaging/"><cite>HTML5 Web Messaging</cite></a>. 1 May 2012. W3C Candidate Recommendation. URL: <a property="dc:requires" href="http://www.w3.org/TR/webmessaging/">http://www.w3.org/TR/webmessaging/</a>
</dd></dl></section><section property="bibo:hasPart" resource="#informative-references" typeof="bibo:Chapter" id="informative-references"><h3 resource="#h-informative-references" id="h-informative-references"><span property="xhv:role" resource="xhv:heading"><span class="secno">B.2 </span>Informative references</span></h3><dl resource="" class="bibliography"><dt id="bib-RFC5322">[RFC5322]</dt><dd>P. Resnick, Ed.. <a property="dc:references" href="https://tools.ietf.org/html/rfc5322"><cite>Internet Message Format</cite></a>. October 2008. Draft Standard. URL: <a property="dc:references" href="https://tools.ietf.org/html/rfc5322">https://tools.ietf.org/html/rfc5322</a>
</dd><dt id="bib-RTCWEB-OVERVIEW">[RTCWEB-OVERVIEW]</dt><dd>H. Alvestrand. <a property="dc:references" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-overview/"><cite>Overview: Real Time Protocols for Brower-based Applications</cite></a>. 14 February 2014. Active Internet-Draft. URL: <a property="dc:references" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-overview/">http://datatracker.ietf.org/doc/draft-ietf-rtcweb-overview/</a>
</dd><dt id="bib-RTCWEB-SECURITY">[RTCWEB-SECURITY]</dt><dd>Eric Rescorla. <a property="dc:references" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-security/"><cite>Security Considerations for WebRTC</cite></a>. 22 January 2014. Active Internet-Draft. URL: <a property="dc:references" href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-security/">http://datatracker.ietf.org/doc/draft-ietf-rtcweb-security/</a>
</dd><dt id="bib-TRICKLE-ICE">[TRICKLE-ICE]</dt><dd>E. Ivov; E. Rescorla; J. Uberti. <a property="dc:references" href="http://datatracker.ietf.org/doc/draft-ietf-mmusic-trickle-ice"><cite>Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol</cite></a>. 7 February 2014. Internet-Draft (work in progress). URL: <a property="dc:references" href="http://datatracker.ietf.org/doc/draft-ietf-mmusic-trickle-ice">http://datatracker.ietf.org/doc/draft-ietf-mmusic-trickle-ice</a>
</dd><dt id="bib-WEBSOCKETS-API">[WEBSOCKETS-API]</dt><dd>Ian Hickson. <a property="dc:references" href="http://www.w3.org/TR/websockets/"><cite>The WebSocket API</cite></a>. 20 September 2012. W3C Candidate Recommendation. URL: <a property="dc:references" href="http://www.w3.org/TR/websockets/">http://www.w3.org/TR/websockets/</a>
</dd><dt id="bib-XMLHttpRequest">[XMLHttpRequest]</dt><dd>Anne van Kesteren; Julian Aubourg; Jungkee Song; Hallvord Steen et al. <a property="dc:references" href="http://www.w3.org/TR/XMLHttpRequest/"><cite>XMLHttpRequest Level 1</cite></a>. 30 January 2014. W3C Working Draft. URL: <a property="dc:references" href="http://www.w3.org/TR/XMLHttpRequest/">http://www.w3.org/TR/XMLHttpRequest/</a>
</dd></dl></section></section></body></html>